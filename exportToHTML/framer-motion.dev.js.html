<html>
<head>
<title>framer-motion.dev.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
.s7 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
framer-motion.dev.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
    <span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? factory(exports, require(</span><span class="s2">'react'</span><span class="s0">)) :</span>
    <span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s0">, </span><span class="s2">'react'</span><span class="s0">], factory) :</span>
    <span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, factory(global.Motion = {}, global.React));</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(exports, React$1) { </span><span class="s2">'use strict'</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">_interopNamespaceDefault(e) {</span>
        <span class="s1">var </span><span class="s0">n = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(e) {</span>
            <span class="s0">Object.keys(e).forEach(</span><span class="s1">function </span><span class="s0">(k) {</span>
                <span class="s1">if </span><span class="s0">(k !== </span><span class="s2">'default'</span><span class="s0">) {</span>
                    <span class="s1">var </span><span class="s0">d = Object.getOwnPropertyDescriptor(e, k);</span>
                    <span class="s0">Object.defineProperty(n, k, d.get ? d : {</span>
                        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
                        <span class="s0">get: </span><span class="s1">function </span><span class="s0">() { </span><span class="s1">return </span><span class="s0">e[k]; }</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">n.default = e;</span>
        <span class="s1">return </span><span class="s0">Object.freeze(n);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">React__namespace = </span><span class="s3">/*#__PURE__*/</span><span class="s0">_interopNamespaceDefault(React$1);</span>

    <span class="s3">// source: react/cjs/react-jsx-runtime.production.min.js</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@license </span><span class="s3">React</span>
     <span class="s3">* react-jsx-runtime.production.min.js</span>
     <span class="s3">*</span>
     <span class="s3">* Copyright (c) Facebook, Inc. and its affiliates.</span>
     <span class="s3">*</span>
     <span class="s3">* This source code is licensed under the MIT license found in the</span>
     <span class="s3">* LICENSE file in the root directory of this source tree.</span>
     <span class="s3">*/</span>
    <span class="s1">var </span><span class="s0">f = React,</span>
        <span class="s0">k = Symbol.for(</span><span class="s2">&quot;react.element&quot;</span><span class="s0">),</span>
        <span class="s0">l = Symbol.for(</span><span class="s2">&quot;react.fragment&quot;</span><span class="s0">),</span>
        <span class="s0">m$1 = Object.prototype.hasOwnProperty,</span>
        <span class="s0">n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,</span>
        <span class="s0">p = { key: !</span><span class="s5">0</span><span class="s0">, ref: !</span><span class="s5">0</span><span class="s0">, __self: !</span><span class="s5">0</span><span class="s0">, __source: !</span><span class="s5">0 </span><span class="s0">};</span>
    <span class="s1">function </span><span class="s0">q(c, a, g) {</span>
        <span class="s1">var </span><span class="s0">b,</span>
            <span class="s0">d = {},</span>
            <span class="s0">e = </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">h = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">void </span><span class="s5">0 </span><span class="s0">!== g &amp;&amp; (e = </span><span class="s2">&quot;&quot; </span><span class="s0">+ g);</span>
        <span class="s1">void </span><span class="s5">0 </span><span class="s0">!== a.key &amp;&amp; (e = </span><span class="s2">&quot;&quot; </span><span class="s0">+ a.key);</span>
        <span class="s1">void </span><span class="s5">0 </span><span class="s0">!== a.ref &amp;&amp; (h = a.ref);</span>
        <span class="s1">for </span><span class="s0">(b </span><span class="s1">in </span><span class="s0">a) m$1.call(a, b) &amp;&amp; !p.hasOwnProperty(b) &amp;&amp; (d[b] = a[b]);</span>
        <span class="s1">if </span><span class="s0">(c &amp;&amp; c.defaultProps)</span>
            <span class="s1">for </span><span class="s0">(b </span><span class="s1">in </span><span class="s0">((a = c.defaultProps), a)) </span><span class="s1">void </span><span class="s5">0 </span><span class="s0">=== d[b] &amp;&amp; (d[b] = a[b]);</span>
        <span class="s1">return </span><span class="s0">{ $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current }</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">Fragment = l;</span>
    <span class="s1">const </span><span class="s0">jsx = q;</span>
    <span class="s1">const </span><span class="s0">jsxs = q;</span>

    <span class="s1">const </span><span class="s0">LayoutGroupContext = React$1.createContext({});</span>

    <span class="s3">/**</span>
     <span class="s3">* Creates a constant value over the lifecycle of a component.</span>
     <span class="s3">*</span>
     <span class="s3">* Even if `useMemo` is provided an empty array as its final argument, it doesn't offer</span>
     <span class="s3">* a guarantee that it won't re-run for performance reasons later on. By using `useConstant`</span>
     <span class="s3">* you can ensure that initialisers don't execute twice or more.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useConstant(init) {</span>
        <span class="s1">const </span><span class="s0">ref = React$1.useRef(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(ref.current === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">ref.current = init();</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">ref.current;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isBrowser = </span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">&quot;undefined&quot;</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">useIsomorphicLayoutEffect = isBrowser ? React$1.useLayoutEffect : React$1.useEffect;</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">PresenceContext = </span>
    <span class="s3">/* @__PURE__ */ </span><span class="s0">React$1.createContext(</span><span class="s1">null</span><span class="s0">);</span>

    <span class="s1">function </span><span class="s0">addUniqueItem(arr, item) {</span>
        <span class="s1">if </span><span class="s0">(arr.indexOf(item) === -</span><span class="s5">1</span><span class="s0">)</span>
            <span class="s0">arr.push(item);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">removeItem(arr, item) {</span>
        <span class="s1">const </span><span class="s0">index = arr.indexOf(item);</span>
        <span class="s1">if </span><span class="s0">(index &gt; -</span><span class="s5">1</span><span class="s0">)</span>
            <span class="s0">arr.splice(index, </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s3">// Adapted from array-move</span>
    <span class="s1">function </span><span class="s0">moveItem([...arr], fromIndex, toIndex) {</span>
        <span class="s1">const </span><span class="s0">startIndex = fromIndex &lt; </span><span class="s5">0 </span><span class="s0">? arr.length + fromIndex : fromIndex;</span>
        <span class="s1">if </span><span class="s0">(startIndex &gt;= </span><span class="s5">0 </span><span class="s0">&amp;&amp; startIndex &lt; arr.length) {</span>
            <span class="s1">const </span><span class="s0">endIndex = toIndex &lt; </span><span class="s5">0 </span><span class="s0">? arr.length + toIndex : toIndex;</span>
            <span class="s1">const </span><span class="s0">[item] = arr.splice(fromIndex, </span><span class="s5">1</span><span class="s0">);</span>
            <span class="s0">arr.splice(endIndex, </span><span class="s5">0</span><span class="s0">, item);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">arr;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">clamp = (min, max, v) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(v &gt; max)</span>
            <span class="s1">return </span><span class="s0">max;</span>
        <span class="s1">if </span><span class="s0">(v &lt; min)</span>
            <span class="s1">return </span><span class="s0">min;</span>
        <span class="s1">return </span><span class="s0">v;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">formatErrorMessage(message, errorCode) {</span>
        <span class="s1">return </span><span class="s0">errorCode</span>
            <span class="s0">? </span><span class="s2">`</span><span class="s0">${message}</span><span class="s2">. For more information and steps for solving, visit https://motion.dev/troubleshooting/</span><span class="s0">${errorCode}</span><span class="s2">`</span>
            <span class="s0">: message;</span>
    <span class="s0">}</span>

    <span class="s0">exports.warning = () =&gt; { };</span>
    <span class="s0">exports.invariant = () =&gt; { };</span>
    <span class="s0">{</span>
        <span class="s0">exports.warning = (check, message, errorCode) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!check &amp;&amp; </span><span class="s1">typeof </span><span class="s0">console !== </span><span class="s2">&quot;undefined&quot;</span><span class="s0">) {</span>
                <span class="s0">console.warn(formatErrorMessage(message, errorCode));</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">exports.invariant = (check, message, errorCode) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!check) {</span>
                <span class="s1">throw new </span><span class="s0">Error(formatErrorMessage(message, errorCode));</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">MotionGlobalConfig = {};</span>

    <span class="s3">/**</span>
     <span class="s3">* Check if value is a numerical string, ie a string that is purely a number eg &quot;100&quot; or &quot;-100.1&quot;</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">isNumericalString = (v) =&gt; </span><span class="s6">/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u</span><span class="s0">.test(v);</span>

    <span class="s1">function </span><span class="s0">isObject(value) {</span>
        <span class="s1">return typeof </span><span class="s0">value === </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp; value !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Check if the value is a zero value string like &quot;0px&quot; or &quot;0%&quot;</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">isZeroValueString = (v) =&gt; </span><span class="s6">/^0[^.\s]+$/u</span><span class="s0">.test(v);</span>

    <span class="s3">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">function </span><span class="s0">memo(callback) {</span>
        <span class="s1">let </span><span class="s0">result;</span>
        <span class="s1">return </span><span class="s0">() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(result === undefined)</span>
                <span class="s0">result = callback();</span>
            <span class="s1">return </span><span class="s0">result;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s3">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">noop = (any) =&gt; any;</span>

    <span class="s3">/**</span>
     <span class="s3">* Pipe</span>
     <span class="s3">* Compose other transformers to run linearily</span>
     <span class="s3">* pipe(min(20), max(40))</span>
     <span class="s3">* </span><span class="s4">@param  </span><span class="s3">{...functions} transformers</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">{function}</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">combineFunctions = (a, b) =&gt; (v) =&gt; b(a(v));</span>
    <span class="s1">const </span><span class="s0">pipe = (...transformers) =&gt; transformers.reduce(combineFunctions);</span>

    <span class="s3">/* 
      Progress within given range 
 
      Given a lower limit and an upper limit, we return the progress 
      (expressed as a number 0-1) represented by the given value, and 
      limit that progress to within 0-1. 
 
      @param [number]: Lower limit 
      @param [number]: Upper limit 
      @param [number]: Value to find progress within given range 
      @return [number]: Progress of value within range as expressed 0-1 
    */</span>
    <span class="s3">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">progress = (from, to, value) =&gt; {</span>
        <span class="s1">const </span><span class="s0">toFromDifference = to - from;</span>
        <span class="s1">return </span><span class="s0">toFromDifference === </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: (value - from) / toFromDifference;</span>
    <span class="s0">};</span>

    <span class="s1">class </span><span class="s0">SubscriptionManager {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.subscriptions = [];</span>
        <span class="s0">}</span>
        <span class="s0">add(handler) {</span>
            <span class="s0">addUniqueItem(</span><span class="s1">this</span><span class="s0">.subscriptions, handler);</span>
            <span class="s1">return </span><span class="s0">() =&gt; removeItem(</span><span class="s1">this</span><span class="s0">.subscriptions, handler);</span>
        <span class="s0">}</span>
        <span class="s0">notify(a, b, c) {</span>
            <span class="s1">const </span><span class="s0">numSubscriptions = </span><span class="s1">this</span><span class="s0">.subscriptions.length;</span>
            <span class="s1">if </span><span class="s0">(!numSubscriptions)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(numSubscriptions === </span><span class="s5">1</span><span class="s0">) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If there's only a single handler we can just call it without invoking a loop.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.subscriptions[</span><span class="s5">0</span><span class="s0">](a, b, c);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numSubscriptions; i++) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Check whether the handler exists before firing as it's possible</span>
                     <span class="s3">* the subscriptions were modified during this loop running.</span>
                     <span class="s3">*/</span>
                    <span class="s1">const </span><span class="s0">handler = </span><span class="s1">this</span><span class="s0">.subscriptions[i];</span>
                    <span class="s0">handler &amp;&amp; handler(a, b, c);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">getSize() {</span>
            <span class="s1">return this</span><span class="s0">.subscriptions.length;</span>
        <span class="s0">}</span>
        <span class="s0">clear() {</span>
            <span class="s1">this</span><span class="s0">.subscriptions.length = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Converts seconds to milliseconds</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">seconds - Time in seconds.</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">milliseconds - Converted time in milliseconds.</span>
     <span class="s3">*/</span>
    <span class="s3">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">secondsToMilliseconds = (seconds) =&gt; seconds * </span><span class="s5">1000</span><span class="s0">;</span>
    <span class="s3">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">millisecondsToSeconds = (milliseconds) =&gt; milliseconds / </span><span class="s5">1000</span><span class="s0">;</span>

    <span class="s3">/* 
      Convert velocity into velocity per second 
 
      @param [number]: Unit per frame 
      @param [number]: Frame duration in ms 
    */</span>
    <span class="s1">function </span><span class="s0">velocityPerSecond(velocity, frameDuration) {</span>
        <span class="s1">return </span><span class="s0">frameDuration ? velocity * (</span><span class="s5">1000 </span><span class="s0">/ frameDuration) : </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">warned = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">function </span><span class="s0">hasWarned$1(message) {</span>
        <span class="s1">return </span><span class="s0">warned.has(message);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">warnOnce(condition, message, errorCode) {</span>
        <span class="s1">if </span><span class="s0">(condition || warned.has(message))</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">console.warn(formatErrorMessage(message, errorCode));</span>
        <span class="s0">warned.add(message);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">wrap = (min, max, v) =&gt; {</span>
        <span class="s1">const </span><span class="s0">rangeSize = max - min;</span>
        <span class="s1">return </span><span class="s0">((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;</span>
    <span class="s0">};</span>

    <span class="s3">/* 
      Bezier function generator 
      This has been modified from GaÃ«tan Renaudeau's BezierEasing 
      https://github.com/gre/bezier-easing/blob/master/src/index.js 
      https://github.com/gre/bezier-easing/blob/master/LICENSE 
       
      I've removed the newtonRaphsonIterate algo because in benchmarking it 
      wasn't noticeably faster than binarySubdivision, indeed removing it 
      usually improved times, depending on the curve. 
      I also removed the lookup table, as for the added bundle size and loop we're 
      only cutting ~4 or so subdivision iterations. I bumped the max iterations up 
      to 12 to compensate and this still tended to be faster for no perceivable 
      loss in accuracy. 
      Usage 
        const easeOut = cubicBezier(.17,.67,.83,.67); 
        const x = easeOut(0.5); // returns 0.627... 
    */</span>
    <span class="s3">// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.</span>
    <span class="s1">const </span><span class="s0">calcBezier = (t, a1, a2) =&gt; (((</span><span class="s5">1.0 </span><span class="s0">- </span><span class="s5">3.0 </span><span class="s0">* a2 + </span><span class="s5">3.0 </span><span class="s0">* a1) * t + (</span><span class="s5">3.0 </span><span class="s0">* a2 - </span><span class="s5">6.0 </span><span class="s0">* a1)) * t + </span><span class="s5">3.0 </span><span class="s0">* a1) *</span>
        <span class="s0">t;</span>
    <span class="s1">const </span><span class="s0">subdivisionPrecision = </span><span class="s5">0.0000001</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">subdivisionMaxIterations = </span><span class="s5">12</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {</span>
        <span class="s1">let </span><span class="s0">currentX;</span>
        <span class="s1">let </span><span class="s0">currentT;</span>
        <span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">currentT = lowerBound + (upperBound - lowerBound) / </span><span class="s5">2.0</span><span class="s0">;</span>
            <span class="s0">currentX = calcBezier(currentT, mX1, mX2) - x;</span>
            <span class="s1">if </span><span class="s0">(currentX &gt; </span><span class="s5">0.0</span><span class="s0">) {</span>
                <span class="s0">upperBound = currentT;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">lowerBound = currentT;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(Math.abs(currentX) &gt; subdivisionPrecision &amp;&amp;</span>
            <span class="s0">++i &lt; subdivisionMaxIterations);</span>
        <span class="s1">return </span><span class="s0">currentT;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">cubicBezier(mX1, mY1, mX2, mY2) {</span>
        <span class="s3">// If this is a linear gradient, return linear easing</span>
        <span class="s1">if </span><span class="s0">(mX1 === mY1 &amp;&amp; mX2 === mY2)</span>
            <span class="s1">return </span><span class="s0">noop;</span>
        <span class="s1">const </span><span class="s0">getTForX = (aX) =&gt; binarySubdivide(aX, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, mX1, mX2);</span>
        <span class="s3">// If animation is at start/end, return t without easing</span>
        <span class="s1">return </span><span class="s0">(t) =&gt; t === </span><span class="s5">0 </span><span class="s0">|| t === </span><span class="s5">1 </span><span class="s0">? t : calcBezier(getTForX(t), mY1, mY2);</span>
    <span class="s0">}</span>

    <span class="s3">// Accepts an easing function and returns a new one that outputs mirrored values for</span>
    <span class="s3">// the second half of the animation. Turns easeIn into easeInOut.</span>
    <span class="s1">const </span><span class="s0">mirrorEasing = (easing) =&gt; (p) =&gt; p &lt;= </span><span class="s5">0.5 </span><span class="s0">? easing(</span><span class="s5">2 </span><span class="s0">* p) / </span><span class="s5">2 </span><span class="s0">: (</span><span class="s5">2 </span><span class="s0">- easing(</span><span class="s5">2 </span><span class="s0">* (</span><span class="s5">1 </span><span class="s0">- p))) / </span><span class="s5">2</span><span class="s0">;</span>

    <span class="s3">// Accepts an easing function and returns a new one that outputs reversed values.</span>
    <span class="s3">// Turns easeIn into easeOut.</span>
    <span class="s1">const </span><span class="s0">reverseEasing = (easing) =&gt; (p) =&gt; </span><span class="s5">1 </span><span class="s0">- easing(</span><span class="s5">1 </span><span class="s0">- p);</span>

    <span class="s1">const </span><span class="s0">backOut = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezier(</span><span class="s5">0.33</span><span class="s0">, </span><span class="s5">1.53</span><span class="s0">, </span><span class="s5">0.69</span><span class="s0">, </span><span class="s5">0.99</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">backIn = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">reverseEasing(backOut);</span>
    <span class="s1">const </span><span class="s0">backInOut = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">mirrorEasing(backIn);</span>

    <span class="s1">const </span><span class="s0">anticipate = (p) =&gt; (p *= </span><span class="s5">2</span><span class="s0">) &lt; </span><span class="s5">1 </span><span class="s0">? </span><span class="s5">0.5 </span><span class="s0">* backIn(p) : </span><span class="s5">0.5 </span><span class="s0">* (</span><span class="s5">2 </span><span class="s0">- Math.pow(</span><span class="s5">2</span><span class="s0">, -</span><span class="s5">10 </span><span class="s0">* (p - </span><span class="s5">1</span><span class="s0">)));</span>

    <span class="s1">const </span><span class="s0">circIn = (p) =&gt; </span><span class="s5">1 </span><span class="s0">- Math.sin(Math.acos(p));</span>
    <span class="s1">const </span><span class="s0">circOut = reverseEasing(circIn);</span>
    <span class="s1">const </span><span class="s0">circInOut = mirrorEasing(circIn);</span>

    <span class="s1">const </span><span class="s0">easeIn = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezier(</span><span class="s5">0.42</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">easeOut = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezier(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0.58</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">easeInOut = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezier(</span><span class="s5">0.42</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0.58</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

    <span class="s1">function </span><span class="s0">steps(numSteps, direction = </span><span class="s2">&quot;end&quot;</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">(progress) =&gt; {</span>
            <span class="s0">progress =</span>
                <span class="s0">direction === </span><span class="s2">&quot;end&quot;</span>
                    <span class="s0">? Math.min(progress, </span><span class="s5">0.999</span><span class="s0">)</span>
                    <span class="s0">: Math.max(progress, </span><span class="s5">0.001</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">expanded = progress * numSteps;</span>
            <span class="s1">const </span><span class="s0">rounded = direction === </span><span class="s2">&quot;end&quot; </span><span class="s0">? Math.floor(expanded) : Math.ceil(expanded);</span>
            <span class="s1">return </span><span class="s0">clamp(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, rounded / numSteps);</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isEasingArray = (ease) =&gt; {</span>
        <span class="s1">return </span><span class="s0">Array.isArray(ease) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">ease[</span><span class="s5">0</span><span class="s0">] !== </span><span class="s2">&quot;number&quot;</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">getEasingForSegment(easing, i) {</span>
        <span class="s1">return </span><span class="s0">isEasingArray(easing) ? easing[wrap(</span><span class="s5">0</span><span class="s0">, easing.length, i)] : easing;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isBezierDefinition = (easing) =&gt; Array.isArray(easing) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">easing[</span><span class="s5">0</span><span class="s0">] === </span><span class="s2">&quot;number&quot;</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">easingLookup = {</span>
        <span class="s0">linear: noop,</span>
        <span class="s0">easeIn,</span>
        <span class="s0">easeInOut,</span>
        <span class="s0">easeOut,</span>
        <span class="s0">circIn,</span>
        <span class="s0">circInOut,</span>
        <span class="s0">circOut,</span>
        <span class="s0">backIn,</span>
        <span class="s0">backInOut,</span>
        <span class="s0">backOut,</span>
        <span class="s0">anticipate,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">isValidEasing = (easing) =&gt; {</span>
        <span class="s1">return typeof </span><span class="s0">easing === </span><span class="s2">&quot;string&quot;</span><span class="s0">;</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">easingDefinitionToFunction = (definition) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(isBezierDefinition(definition)) {</span>
            <span class="s3">// If cubic bezier definition, create bezier curve</span>
            <span class="s0">exports.invariant(definition.length === </span><span class="s5">4</span><span class="s0">, </span><span class="s2">`Cubic bezier arrays must contain four numerical values.`</span><span class="s0">, </span><span class="s2">&quot;cubic-bezier-length&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">[x1, y1, x2, y2] = definition;</span>
            <span class="s1">return </span><span class="s0">cubicBezier(x1, y1, x2, y2);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(isValidEasing(definition)) {</span>
            <span class="s3">// Else lookup from table</span>
            <span class="s0">exports.invariant(easingLookup[definition] !== undefined, </span><span class="s2">`Invalid easing type '</span><span class="s0">${definition}</span><span class="s2">'`</span><span class="s0">, </span><span class="s2">&quot;invalid-easing-type&quot;</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">easingLookup[definition];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">definition;</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">stepsOrder = [</span>
        <span class="s2">&quot;setup&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
        <span class="s2">&quot;read&quot;</span><span class="s0">, </span><span class="s3">// Read</span>
        <span class="s2">&quot;resolveKeyframes&quot;</span><span class="s0">, </span><span class="s3">// Write/Read/Write/Read</span>
        <span class="s2">&quot;preUpdate&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
        <span class="s2">&quot;update&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
        <span class="s2">&quot;preRender&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
        <span class="s2">&quot;render&quot;</span><span class="s0">, </span><span class="s3">// Write</span>
        <span class="s2">&quot;postRender&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
    <span class="s0">];</span>

    <span class="s1">const </span><span class="s0">statsBuffer = {</span>
        <span class="s0">value: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">addProjectionMetrics: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">createRenderStep(runNextFrame, stepName) {</span>
        <span class="s3">/**</span>
         <span class="s3">* We create and reuse two queues, one to queue jobs for the current frame</span>
         <span class="s3">* and one for the next. We reuse to avoid triggering GC after x frames.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">thisFrame = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s1">let </span><span class="s0">nextFrame = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s3">/**</span>
         <span class="s3">* Track whether we're currently processing jobs in this step. This way</span>
         <span class="s3">* we can decide whether to schedule new jobs for this frame or next.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">isProcessing = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">flushNextFrame = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* A set of processes which were marked keepAlive when scheduled.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">toKeepAlive = </span><span class="s1">new </span><span class="s0">WeakSet();</span>
        <span class="s1">let </span><span class="s0">latestFrameData = {</span>
            <span class="s0">delta: </span><span class="s5">0.0</span><span class="s0">,</span>
            <span class="s0">timestamp: </span><span class="s5">0.0</span><span class="s0">,</span>
            <span class="s0">isProcessing: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">};</span>
        <span class="s1">let </span><span class="s0">numCalls = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">function </span><span class="s0">triggerCallback(callback) {</span>
            <span class="s1">if </span><span class="s0">(toKeepAlive.has(callback)) {</span>
                <span class="s0">step.schedule(callback);</span>
                <span class="s0">runNextFrame();</span>
            <span class="s0">}</span>
            <span class="s0">numCalls++;</span>
            <span class="s0">callback(latestFrameData);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">step = {</span>
            <span class="s3">/**</span>
             <span class="s3">* Schedule a process to run on the next frame.</span>
             <span class="s3">*/</span>
            <span class="s0">schedule: (callback, keepAlive = </span><span class="s1">false</span><span class="s0">, immediate = </span><span class="s1">false</span><span class="s0">) =&gt; {</span>
                <span class="s1">const </span><span class="s0">addToCurrentFrame = immediate &amp;&amp; isProcessing;</span>
                <span class="s1">const </span><span class="s0">queue = addToCurrentFrame ? thisFrame : nextFrame;</span>
                <span class="s1">if </span><span class="s0">(keepAlive)</span>
                    <span class="s0">toKeepAlive.add(callback);</span>
                <span class="s1">if </span><span class="s0">(!queue.has(callback))</span>
                    <span class="s0">queue.add(callback);</span>
                <span class="s1">return </span><span class="s0">callback;</span>
            <span class="s0">},</span>
            <span class="s3">/**</span>
             <span class="s3">* Cancel the provided callback from running on the next frame.</span>
             <span class="s3">*/</span>
            <span class="s0">cancel: (callback) =&gt; {</span>
                <span class="s0">nextFrame.delete(callback);</span>
                <span class="s0">toKeepAlive.delete(callback);</span>
            <span class="s0">},</span>
            <span class="s3">/**</span>
             <span class="s3">* Execute all schedule callbacks.</span>
             <span class="s3">*/</span>
            <span class="s0">process: (frameData) =&gt; {</span>
                <span class="s0">latestFrameData = frameData;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're already processing we've probably been triggered by a flushSync</span>
                 <span class="s3">* inside an existing process. Instead of executing, mark flushNextFrame</span>
                 <span class="s3">* as true and ensure we flush the following frame at the end of this one.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(isProcessing) {</span>
                    <span class="s0">flushNextFrame = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">isProcessing = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">[thisFrame, nextFrame] = [nextFrame, thisFrame];</span>
                <span class="s3">// Execute this frame</span>
                <span class="s0">thisFrame.forEach(triggerCallback);</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're recording stats then</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(stepName &amp;&amp; statsBuffer.value) {</span>
                    <span class="s0">statsBuffer.value.frameloop[stepName].push(numCalls);</span>
                <span class="s0">}</span>
                <span class="s0">numCalls = </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s3">// Clear the frame so no callbacks remain. This is to avoid</span>
                <span class="s3">// memory leaks should this render step not run for a while.</span>
                <span class="s0">thisFrame.clear();</span>
                <span class="s0">isProcessing = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(flushNextFrame) {</span>
                    <span class="s0">flushNextFrame = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">step.process(frameData);</span>
                <span class="s0">}</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">step;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">maxElapsed$1 = </span><span class="s5">40</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">createRenderBatcher(scheduleNextBatch, allowKeepAlive) {</span>
        <span class="s1">let </span><span class="s0">runNextFrame = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">useDefaultElapsed = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">state = {</span>
            <span class="s0">delta: </span><span class="s5">0.0</span><span class="s0">,</span>
            <span class="s0">timestamp: </span><span class="s5">0.0</span><span class="s0">,</span>
            <span class="s0">isProcessing: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">flagRunNextFrame = () =&gt; (runNextFrame = </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">steps = stepsOrder.reduce((acc, key) =&gt; {</span>
            <span class="s0">acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);</span>
            <span class="s1">return </span><span class="s0">acc;</span>
        <span class="s0">}, {});</span>
        <span class="s1">const </span><span class="s0">{ setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender, } = steps;</span>
        <span class="s1">const </span><span class="s0">processBatch = () =&gt; {</span>
            <span class="s1">const </span><span class="s0">timestamp = MotionGlobalConfig.useManualTiming</span>
                <span class="s0">? state.timestamp</span>
                <span class="s0">: performance.now();</span>
            <span class="s0">runNextFrame = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!MotionGlobalConfig.useManualTiming) {</span>
                <span class="s0">state.delta = useDefaultElapsed</span>
                    <span class="s0">? </span><span class="s5">1000 </span><span class="s0">/ </span><span class="s5">60</span>
                    <span class="s0">: Math.max(Math.min(timestamp - state.timestamp, maxElapsed$1), </span><span class="s5">1</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">state.timestamp = timestamp;</span>
            <span class="s0">state.isProcessing = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s3">// Unrolled render loop for better per-frame performance</span>
            <span class="s0">setup.process(state);</span>
            <span class="s0">read.process(state);</span>
            <span class="s0">resolveKeyframes.process(state);</span>
            <span class="s0">preUpdate.process(state);</span>
            <span class="s0">update.process(state);</span>
            <span class="s0">preRender.process(state);</span>
            <span class="s0">render.process(state);</span>
            <span class="s0">postRender.process(state);</span>
            <span class="s0">state.isProcessing = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(runNextFrame &amp;&amp; allowKeepAlive) {</span>
                <span class="s0">useDefaultElapsed = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">scheduleNextBatch(processBatch);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">wake = () =&gt; {</span>
            <span class="s0">runNextFrame = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">useDefaultElapsed = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!state.isProcessing) {</span>
                <span class="s0">scheduleNextBatch(processBatch);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">schedule = stepsOrder.reduce((acc, key) =&gt; {</span>
            <span class="s1">const </span><span class="s0">step = steps[key];</span>
            <span class="s0">acc[key] = (process, keepAlive = </span><span class="s1">false</span><span class="s0">, immediate = </span><span class="s1">false</span><span class="s0">) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!runNextFrame)</span>
                    <span class="s0">wake();</span>
                <span class="s1">return </span><span class="s0">step.schedule(process, keepAlive, immediate);</span>
            <span class="s0">};</span>
            <span class="s1">return </span><span class="s0">acc;</span>
        <span class="s0">}, {});</span>
        <span class="s1">const </span><span class="s0">cancel = (process) =&gt; {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; stepsOrder.length; i++) {</span>
                <span class="s0">steps[stepsOrder[i]].cancel(process);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">{ schedule, cancel, state, steps };</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">{ schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = </span><span class="s3">/* @__PURE__ */ </span><span class="s0">createRenderBatcher(</span><span class="s1">typeof </span><span class="s0">requestAnimationFrame !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? requestAnimationFrame : noop, </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s1">let </span><span class="s0">now;</span>
    <span class="s1">function </span><span class="s0">clearTime() {</span>
        <span class="s0">now = undefined;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* An eventloop-synchronous alternative to performance.now().</span>
     <span class="s3">*</span>
     <span class="s3">* Ensures that time measurements remain consistent within a synchronous context.</span>
     <span class="s3">* Usually calling performance.now() twice within the same synchronous context</span>
     <span class="s3">* will return different values which isn't useful for animations when we're usually</span>
     <span class="s3">* trying to sync animations to the same frame.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">time = {</span>
        <span class="s0">now: () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(now === undefined) {</span>
                <span class="s0">time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming</span>
                    <span class="s0">? frameData.timestamp</span>
                    <span class="s0">: performance.now());</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">now;</span>
        <span class="s0">},</span>
        <span class="s0">set: (newTime) =&gt; {</span>
            <span class="s0">now = newTime;</span>
            <span class="s0">queueMicrotask(clearTime);</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">activeAnimations = {</span>
        <span class="s0">layout: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">mainThread: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">waapi: </span><span class="s5">0</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">checkStringStartsWith = (token) =&gt; (key) =&gt; </span><span class="s1">typeof </span><span class="s0">key === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; key.startsWith(token);</span>
    <span class="s1">const </span><span class="s0">isCSSVariableName = </span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">checkStringStartsWith(</span><span class="s2">&quot;--&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">startsAsVariableToken = </span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">checkStringStartsWith(</span><span class="s2">&quot;var(--&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">isCSSVariableToken = (value) =&gt; {</span>
        <span class="s1">const </span><span class="s0">startsWithToken = startsAsVariableToken(value);</span>
        <span class="s1">if </span><span class="s0">(!startsWithToken)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s3">// Ensure any comments are stripped from the value as this can harm performance of the regex.</span>
        <span class="s1">return </span><span class="s0">singleCssVariableRegex.test(value.split(</span><span class="s2">&quot;/*&quot;</span><span class="s0">)[</span><span class="s5">0</span><span class="s0">].trim());</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">singleCssVariableRegex = </span><span class="s6">/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">number = {</span>
        <span class="s0">test: (v) =&gt; </span><span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;number&quot;</span><span class="s0">,</span>
        <span class="s0">parse: parseFloat,</span>
        <span class="s0">transform: (v) =&gt; v,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">alpha = {</span>
        <span class="s0">...number,</span>
        <span class="s0">transform: (v) =&gt; clamp(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, v),</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">scale = {</span>
        <span class="s0">...number,</span>
        <span class="s1">default</span><span class="s0">: </span><span class="s5">1</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s3">// If this number is a decimal, make it just five decimal places</span>
    <span class="s3">// to avoid exponents</span>
    <span class="s1">const </span><span class="s0">sanitize = (v) =&gt; Math.round(v * </span><span class="s5">100000</span><span class="s0">) / </span><span class="s5">100000</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">floatRegex = </span><span class="s6">/-?(?:\d+(?:\.\d+)?|\.\d+)/gu</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">isNullish(v) {</span>
        <span class="s1">return </span><span class="s0">v == </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">singleColorRegex = </span><span class="s6">/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu</span><span class="s0">;</span>

    <span class="s3">/**</span>
     <span class="s3">* Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,</span>
     <span class="s3">* but false if a number or multiple colors</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">isColorString = (type, testProp) =&gt; (v) =&gt; {</span>
        <span class="s1">return </span><span class="s0">Boolean((</span><span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">singleColorRegex.test(v) &amp;&amp;</span>
            <span class="s0">v.startsWith(type)) ||</span>
            <span class="s0">(testProp &amp;&amp;</span>
                <span class="s0">!isNullish(v) &amp;&amp;</span>
                <span class="s0">Object.prototype.hasOwnProperty.call(v, testProp)));</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">splitColor = (aName, bName, cName) =&gt; (v) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">v !== </span><span class="s2">&quot;string&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">v;</span>
        <span class="s1">const </span><span class="s0">[a, b, c, alpha] = v.match(floatRegex);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">[aName]: parseFloat(a),</span>
            <span class="s0">[bName]: parseFloat(b),</span>
            <span class="s0">[cName]: parseFloat(c),</span>
            <span class="s0">alpha: alpha !== undefined ? parseFloat(alpha) : </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s0">};</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">clampRgbUnit = (v) =&gt; clamp(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, v);</span>
    <span class="s1">const </span><span class="s0">rgbUnit = {</span>
        <span class="s0">...number,</span>
        <span class="s0">transform: (v) =&gt; Math.round(clampRgbUnit(v)),</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">rgba = {</span>
        <span class="s0">test: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">isColorString(</span><span class="s2">&quot;rgb&quot;</span><span class="s0">, </span><span class="s2">&quot;red&quot;</span><span class="s0">),</span>
        <span class="s0">parse: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">splitColor(</span><span class="s2">&quot;red&quot;</span><span class="s0">, </span><span class="s2">&quot;green&quot;</span><span class="s0">, </span><span class="s2">&quot;blue&quot;</span><span class="s0">),</span>
        <span class="s0">transform: ({ red, green, blue, alpha: alpha$1 = </span><span class="s5">1 </span><span class="s0">}) =&gt; </span><span class="s2">&quot;rgba(&quot; </span><span class="s0">+</span>
            <span class="s0">rgbUnit.transform(red) +</span>
            <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
            <span class="s0">rgbUnit.transform(green) +</span>
            <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
            <span class="s0">rgbUnit.transform(blue) +</span>
            <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
            <span class="s0">sanitize(alpha.transform(alpha$1)) +</span>
            <span class="s2">&quot;)&quot;</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">parseHex(v) {</span>
        <span class="s1">let </span><span class="s0">r = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">g = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">b = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">a = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s3">// If we have 6 characters, ie #FF0000</span>
        <span class="s1">if </span><span class="s0">(v.length &gt; </span><span class="s5">5</span><span class="s0">) {</span>
            <span class="s0">r = v.substring(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">);</span>
            <span class="s0">g = v.substring(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s0">);</span>
            <span class="s0">b = v.substring(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">7</span><span class="s0">);</span>
            <span class="s0">a = v.substring(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">9</span><span class="s0">);</span>
            <span class="s3">// Or we have 3 characters, ie #F00</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">r = v.substring(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">);</span>
            <span class="s0">g = v.substring(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">);</span>
            <span class="s0">b = v.substring(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">);</span>
            <span class="s0">a = v.substring(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">);</span>
            <span class="s0">r += r;</span>
            <span class="s0">g += g;</span>
            <span class="s0">b += b;</span>
            <span class="s0">a += a;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">red: parseInt(r, </span><span class="s5">16</span><span class="s0">),</span>
            <span class="s0">green: parseInt(g, </span><span class="s5">16</span><span class="s0">),</span>
            <span class="s0">blue: parseInt(b, </span><span class="s5">16</span><span class="s0">),</span>
            <span class="s0">alpha: a ? parseInt(a, </span><span class="s5">16</span><span class="s0">) / </span><span class="s5">255 </span><span class="s0">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">hex = {</span>
        <span class="s0">test: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">isColorString(</span><span class="s2">&quot;#&quot;</span><span class="s0">),</span>
        <span class="s0">parse: parseHex,</span>
        <span class="s0">transform: rgba.transform,</span>
    <span class="s0">};</span>

    <span class="s3">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">createUnitType = (unit) =&gt; ({</span>
        <span class="s0">test: (v) =&gt; </span><span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; v.endsWith(unit) &amp;&amp; v.split(</span><span class="s2">&quot; &quot;</span><span class="s0">).length === </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s0">parse: parseFloat,</span>
        <span class="s0">transform: (v) =&gt; </span><span class="s2">`</span><span class="s0">${v}${unit}</span><span class="s2">`</span><span class="s0">,</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">degrees = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;deg&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">percent = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;%&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">px = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;px&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">vh = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;vh&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">vw = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;vw&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">progressPercentage = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">(() =&gt; ({</span>
        <span class="s0">...percent,</span>
        <span class="s0">parse: (v) =&gt; percent.parse(v) / </span><span class="s5">100</span><span class="s0">,</span>
        <span class="s0">transform: (v) =&gt; percent.transform(v * </span><span class="s5">100</span><span class="s0">),</span>
    <span class="s0">}))();</span>

    <span class="s1">const </span><span class="s0">hsla = {</span>
        <span class="s0">test: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">isColorString(</span><span class="s2">&quot;hsl&quot;</span><span class="s0">, </span><span class="s2">&quot;hue&quot;</span><span class="s0">),</span>
        <span class="s0">parse: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">splitColor(</span><span class="s2">&quot;hue&quot;</span><span class="s0">, </span><span class="s2">&quot;saturation&quot;</span><span class="s0">, </span><span class="s2">&quot;lightness&quot;</span><span class="s0">),</span>
        <span class="s0">transform: ({ hue, saturation, lightness, alpha: alpha$1 = </span><span class="s5">1 </span><span class="s0">}) =&gt; {</span>
            <span class="s1">return </span><span class="s0">(</span><span class="s2">&quot;hsla(&quot; </span><span class="s0">+</span>
                <span class="s0">Math.round(hue) +</span>
                <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
                <span class="s0">percent.transform(sanitize(saturation)) +</span>
                <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
                <span class="s0">percent.transform(sanitize(lightness)) +</span>
                <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
                <span class="s0">sanitize(alpha.transform(alpha$1)) +</span>
                <span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">color = {</span>
        <span class="s0">test: (v) =&gt; rgba.test(v) || hex.test(v) || hsla.test(v),</span>
        <span class="s0">parse: (v) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(rgba.test(v)) {</span>
                <span class="s1">return </span><span class="s0">rgba.parse(v);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(hsla.test(v)) {</span>
                <span class="s1">return </span><span class="s0">hsla.parse(v);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s0">hex.parse(v);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s0">transform: (v) =&gt; {</span>
            <span class="s1">return typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot;</span>
                <span class="s0">? v</span>
                <span class="s0">: v.hasOwnProperty(</span><span class="s2">&quot;red&quot;</span><span class="s0">)</span>
                    <span class="s0">? rgba.transform(v)</span>
                    <span class="s0">: hsla.transform(v);</span>
        <span class="s0">},</span>
        <span class="s0">getAnimatableNone: (v) =&gt; {</span>
            <span class="s1">const </span><span class="s0">parsed = color.parse(v);</span>
            <span class="s0">parsed.alpha = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">color.transform(parsed);</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">colorRegex = </span><span class="s6">/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">test(v) {</span>
        <span class="s1">return </span><span class="s0">(isNaN(v) &amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">(v.match(floatRegex)?.length || </span><span class="s5">0</span><span class="s0">) +</span>
                <span class="s0">(v.match(colorRegex)?.length || </span><span class="s5">0</span><span class="s0">) &gt;</span>
                <span class="s5">0</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">NUMBER_TOKEN = </span><span class="s2">&quot;number&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">COLOR_TOKEN = </span><span class="s2">&quot;color&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">VAR_TOKEN = </span><span class="s2">&quot;var&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">VAR_FUNCTION_TOKEN = </span><span class="s2">&quot;var(&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">SPLIT_TOKEN = </span><span class="s2">&quot;${}&quot;</span><span class="s0">;</span>
    <span class="s3">// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`</span>
    <span class="s1">const </span><span class="s0">complexRegex = </span><span class="s6">/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">analyseComplexValue(value) {</span>
        <span class="s1">const </span><span class="s0">originalValue = value.toString();</span>
        <span class="s1">const </span><span class="s0">values = [];</span>
        <span class="s1">const </span><span class="s0">indexes = {</span>
            <span class="s0">color: [],</span>
            <span class="s0">number: [],</span>
            <span class="s1">var</span><span class="s0">: [],</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">types = [];</span>
        <span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">tokenised = originalValue.replace(complexRegex, (parsedValue) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(color.test(parsedValue)) {</span>
                <span class="s0">indexes.color.push(i);</span>
                <span class="s0">types.push(COLOR_TOKEN);</span>
                <span class="s0">values.push(color.parse(parsedValue));</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {</span>
                <span class="s0">indexes.var.push(i);</span>
                <span class="s0">types.push(VAR_TOKEN);</span>
                <span class="s0">values.push(parsedValue);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">indexes.number.push(i);</span>
                <span class="s0">types.push(NUMBER_TOKEN);</span>
                <span class="s0">values.push(parseFloat(parsedValue));</span>
            <span class="s0">}</span>
            <span class="s0">++i;</span>
            <span class="s1">return </span><span class="s0">SPLIT_TOKEN;</span>
        <span class="s0">});</span>
        <span class="s1">const </span><span class="s0">split = tokenised.split(SPLIT_TOKEN);</span>
        <span class="s1">return </span><span class="s0">{ values, split, indexes, types };</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseComplexValue(v) {</span>
        <span class="s1">return </span><span class="s0">analyseComplexValue(v).values;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createTransformer(source) {</span>
        <span class="s1">const </span><span class="s0">{ split, types } = analyseComplexValue(source);</span>
        <span class="s1">const </span><span class="s0">numSections = split.length;</span>
        <span class="s1">return </span><span class="s0">(v) =&gt; {</span>
            <span class="s1">let </span><span class="s0">output = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numSections; i++) {</span>
                <span class="s0">output += split[i];</span>
                <span class="s1">if </span><span class="s0">(v[i] !== undefined) {</span>
                    <span class="s1">const </span><span class="s0">type = types[i];</span>
                    <span class="s1">if </span><span class="s0">(type === NUMBER_TOKEN) {</span>
                        <span class="s0">output += sanitize(v[i]);</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(type === COLOR_TOKEN) {</span>
                        <span class="s0">output += color.transform(v[i]);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">output += v[i];</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">output;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">convertNumbersToZero = (v) =&gt; </span><span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;number&quot; </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: color.test(v) ? color.getAnimatableNone(v) : v;</span>
    <span class="s1">function </span><span class="s0">getAnimatableNone$1(v) {</span>
        <span class="s1">const </span><span class="s0">parsed = parseComplexValue(v);</span>
        <span class="s1">const </span><span class="s0">transformer = createTransformer(v);</span>
        <span class="s1">return </span><span class="s0">transformer(parsed.map(convertNumbersToZero));</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">complex = {</span>
        <span class="s0">test,</span>
        <span class="s0">parse: parseComplexValue,</span>
        <span class="s0">createTransformer,</span>
        <span class="s0">getAnimatableNone: getAnimatableNone$1,</span>
    <span class="s0">};</span>

    <span class="s3">// Adapted from https://gist.github.com/mjackson/5311256</span>
    <span class="s1">function </span><span class="s0">hueToRgb(p, q, t) {</span>
        <span class="s1">if </span><span class="s0">(t &lt; </span><span class="s5">0</span><span class="s0">)</span>
            <span class="s0">t += </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(t &gt; </span><span class="s5">1</span><span class="s0">)</span>
            <span class="s0">t -= </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(t &lt; </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">6</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">p + (q - p) * </span><span class="s5">6 </span><span class="s0">* t;</span>
        <span class="s1">if </span><span class="s0">(t &lt; </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">2</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">q;</span>
        <span class="s1">if </span><span class="s0">(t &lt; </span><span class="s5">2 </span><span class="s0">/ </span><span class="s5">3</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">p + (q - p) * (</span><span class="s5">2 </span><span class="s0">/ </span><span class="s5">3 </span><span class="s0">- t) * </span><span class="s5">6</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">p;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hslaToRgba({ hue, saturation, lightness, alpha }) {</span>
        <span class="s0">hue /= </span><span class="s5">360</span><span class="s0">;</span>
        <span class="s0">saturation /= </span><span class="s5">100</span><span class="s0">;</span>
        <span class="s0">lightness /= </span><span class="s5">100</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">red = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">green = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">blue = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!saturation) {</span>
            <span class="s0">red = green = blue = lightness;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">q = lightness &lt; </span><span class="s5">0.5</span>
                <span class="s0">? lightness * (</span><span class="s5">1 </span><span class="s0">+ saturation)</span>
                <span class="s0">: lightness + saturation - lightness * saturation;</span>
            <span class="s1">const </span><span class="s0">p = </span><span class="s5">2 </span><span class="s0">* lightness - q;</span>
            <span class="s0">red = hueToRgb(p, q, hue + </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">3</span><span class="s0">);</span>
            <span class="s0">green = hueToRgb(p, q, hue);</span>
            <span class="s0">blue = hueToRgb(p, q, hue - </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">3</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">red: Math.round(red * </span><span class="s5">255</span><span class="s0">),</span>
            <span class="s0">green: Math.round(green * </span><span class="s5">255</span><span class="s0">),</span>
            <span class="s0">blue: Math.round(blue * </span><span class="s5">255</span><span class="s0">),</span>
            <span class="s0">alpha,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">mixImmediate(a, b) {</span>
        <span class="s1">return </span><span class="s0">(p) =&gt; (p &gt; </span><span class="s5">0 </span><span class="s0">? b : a);</span>
    <span class="s0">}</span>

    <span class="s3">/* 
      Value in range from progress 
 
      Given a lower limit and an upper limit, we return the value within 
      that range as expressed by progress (usually a number from 0 to 1) 
 
      So progress = 0.5 would change 
 
      from -------- to 
 
      to 
 
      from ---- to 
 
      E.g. from = 10, to = 20, progress = 0.5 =&gt; 15 
 
      @param [number]: Lower limit of range 
      @param [number]: Upper limit of range 
      @param [number]: The progress between lower and upper limits expressed 0-1 
      @return [number]: Value as calculated from progress within range (not limited within range) 
    */</span>
    <span class="s1">const </span><span class="s0">mixNumber$1 = (from, to, progress) =&gt; {</span>
        <span class="s1">return </span><span class="s0">from + (to - from) * progress;</span>
    <span class="s0">};</span>

    <span class="s3">// Linear color space blending</span>
    <span class="s3">// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw</span>
    <span class="s3">// Demonstrated http://codepen.io/osublake/pen/xGVVaN</span>
    <span class="s1">const </span><span class="s0">mixLinearColor = (from, to, v) =&gt; {</span>
        <span class="s1">const </span><span class="s0">fromExpo = from * from;</span>
        <span class="s1">const </span><span class="s0">expo = v * (to * to - fromExpo) + fromExpo;</span>
        <span class="s1">return </span><span class="s0">expo &lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: Math.sqrt(expo);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">colorTypes = [hex, rgba, hsla];</span>
    <span class="s1">const </span><span class="s0">getColorType = (v) =&gt; colorTypes.find((type) =&gt; type.test(v));</span>
    <span class="s1">function </span><span class="s0">asRGBA(color) {</span>
        <span class="s1">const </span><span class="s0">type = getColorType(color);</span>
        <span class="s0">exports.warning(Boolean(type), </span><span class="s2">`'</span><span class="s0">${color}</span><span class="s2">' is not an animatable color. Use the equivalent color code instead.`</span><span class="s0">, </span><span class="s2">&quot;color-not-animatable&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(!Boolean(type))</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">model = type.parse(color);</span>
        <span class="s1">if </span><span class="s0">(type === hsla) {</span>
            <span class="s3">// TODO Remove this cast - needed since Motion's stricter typing</span>
            <span class="s0">model = hslaToRgba(model);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">model;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">mixColor = (from, to) =&gt; {</span>
        <span class="s1">const </span><span class="s0">fromRGBA = asRGBA(from);</span>
        <span class="s1">const </span><span class="s0">toRGBA = asRGBA(to);</span>
        <span class="s1">if </span><span class="s0">(!fromRGBA || !toRGBA) {</span>
            <span class="s1">return </span><span class="s0">mixImmediate(from, to);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">blended = { ...fromRGBA };</span>
        <span class="s1">return </span><span class="s0">(v) =&gt; {</span>
            <span class="s0">blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);</span>
            <span class="s0">blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);</span>
            <span class="s0">blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);</span>
            <span class="s0">blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);</span>
            <span class="s1">return </span><span class="s0">rgba.transform(blended);</span>
        <span class="s0">};</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">invisibleValues = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;hidden&quot;</span><span class="s0">]);</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns a function that, when provided a progress value between 0 and 1,</span>
     <span class="s3">* will return the &quot;none&quot; or &quot;hidden&quot; string only when the progress is that of</span>
     <span class="s3">* the origin or target.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">mixVisibility(origin, target) {</span>
        <span class="s1">if </span><span class="s0">(invisibleValues.has(origin)) {</span>
            <span class="s1">return </span><span class="s0">(p) =&gt; (p &lt;= </span><span class="s5">0 </span><span class="s0">? origin : target);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">(p) =&gt; (p &gt;= </span><span class="s5">1 </span><span class="s0">? target : origin);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">mixNumber(a, b) {</span>
        <span class="s1">return </span><span class="s0">(p) =&gt; mixNumber$1(a, b, p);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getMixer(a) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">a === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">mixNumber;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">a === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">isCSSVariableToken(a)</span>
                <span class="s0">? mixImmediate</span>
                <span class="s0">: color.test(a)</span>
                    <span class="s0">? mixColor</span>
                    <span class="s0">: mixComplex;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(Array.isArray(a)) {</span>
            <span class="s1">return </span><span class="s0">mixArray;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">a === </span><span class="s2">&quot;object&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">color.test(a) ? mixColor : mixObject;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mixImmediate;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mixArray(a, b) {</span>
        <span class="s1">const </span><span class="s0">output = [...a];</span>
        <span class="s1">const </span><span class="s0">numValues = output.length;</span>
        <span class="s1">const </span><span class="s0">blendValue = a.map((v, i) =&gt; getMixer(v)(v, b[i]));</span>
        <span class="s1">return </span><span class="s0">(p) =&gt; {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numValues; i++) {</span>
                <span class="s0">output[i] = blendValue[i](p);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">output;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mixObject(a, b) {</span>
        <span class="s1">const </span><span class="s0">output = { ...a, ...b };</span>
        <span class="s1">const </span><span class="s0">blendValue = {};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">output) {</span>
            <span class="s1">if </span><span class="s0">(a[key] !== undefined &amp;&amp; b[key] !== undefined) {</span>
                <span class="s0">blendValue[key] = getMixer(a[key])(a[key], b[key]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">(v) =&gt; {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">blendValue) {</span>
                <span class="s0">output[key] = blendValue[key](v);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">output;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">matchOrder(origin, target) {</span>
        <span class="s1">const </span><span class="s0">orderedOrigin = [];</span>
        <span class="s1">const </span><span class="s0">pointers = { color: </span><span class="s5">0</span><span class="s0">, </span><span class="s1">var</span><span class="s0">: </span><span class="s5">0</span><span class="s0">, number: </span><span class="s5">0 </span><span class="s0">};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; target.values.length; i++) {</span>
            <span class="s1">const </span><span class="s0">type = target.types[i];</span>
            <span class="s1">const </span><span class="s0">originIndex = origin.indexes[type][pointers[type]];</span>
            <span class="s1">const </span><span class="s0">originValue = origin.values[originIndex] ?? </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">orderedOrigin[i] = originValue;</span>
            <span class="s0">pointers[type]++;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">orderedOrigin;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">mixComplex = (origin, target) =&gt; {</span>
        <span class="s1">const </span><span class="s0">template = complex.createTransformer(target);</span>
        <span class="s1">const </span><span class="s0">originStats = analyseComplexValue(origin);</span>
        <span class="s1">const </span><span class="s0">targetStats = analyseComplexValue(target);</span>
        <span class="s1">const </span><span class="s0">canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &amp;&amp;</span>
            <span class="s0">originStats.indexes.color.length === targetStats.indexes.color.length &amp;&amp;</span>
            <span class="s0">originStats.indexes.number.length &gt;= targetStats.indexes.number.length;</span>
        <span class="s1">if </span><span class="s0">(canInterpolate) {</span>
            <span class="s1">if </span><span class="s0">((invisibleValues.has(origin) &amp;&amp;</span>
                <span class="s0">!targetStats.values.length) ||</span>
                <span class="s0">(invisibleValues.has(target) &amp;&amp;</span>
                    <span class="s0">!originStats.values.length)) {</span>
                <span class="s1">return </span><span class="s0">mixVisibility(origin, target);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">exports.warning(</span><span class="s1">true</span><span class="s0">, </span><span class="s2">`Complex values '</span><span class="s0">${origin}</span><span class="s2">' and '</span><span class="s0">${target}</span><span class="s2">' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`</span><span class="s0">, </span><span class="s2">&quot;complex-values-different&quot;</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">mixImmediate(origin, target);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">mix(from, to, p) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;number&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">to === </span><span class="s2">&quot;number&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">p === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">mixNumber$1(from, to, p);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">mixer = getMixer(from);</span>
        <span class="s1">return </span><span class="s0">mixer(from, to);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">frameloopDriver = (update) =&gt; {</span>
        <span class="s1">const </span><span class="s0">passTimestamp = ({ timestamp }) =&gt; update(timestamp);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">start: (keepAlive = </span><span class="s1">true</span><span class="s0">) =&gt; frame.update(passTimestamp, keepAlive),</span>
            <span class="s0">stop: () =&gt; cancelFrame(passTimestamp),</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're processing this frame we can use the</span>
             <span class="s3">* framelocked timestamp to keep things in sync.</span>
             <span class="s3">*/</span>
            <span class="s0">now: () =&gt; (frameData.isProcessing ? frameData.timestamp : time.now()),</span>
        <span class="s0">};</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">generateLinearEasing = (easing, duration, </span><span class="s3">// as milliseconds</span>
    <span class="s0">resolution = </span><span class="s5">10 </span><span class="s3">// as milliseconds</span>
    <span class="s0">) =&gt; {</span>
        <span class="s1">let </span><span class="s0">points = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">numPoints = Math.max(Math.round(duration / resolution), </span><span class="s5">2</span><span class="s0">);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numPoints; i++) {</span>
            <span class="s0">points += Math.round(easing(i / (numPoints - </span><span class="s5">1</span><span class="s0">)) * </span><span class="s5">10000</span><span class="s0">) / </span><span class="s5">10000 </span><span class="s0">+ </span><span class="s2">&quot;, &quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s2">`linear(</span><span class="s0">${points.substring(</span><span class="s5">0</span><span class="s0">, points.length - </span><span class="s5">2</span><span class="s0">)}</span><span class="s2">)`</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Implement a practical max duration for keyframe generation</span>
     <span class="s3">* to prevent infinite loops</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">maxGeneratorDuration = </span><span class="s5">20000</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">calcGeneratorDuration(generator) {</span>
        <span class="s1">let </span><span class="s0">duration = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">timeStep = </span><span class="s5">50</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">state = generator.next(duration);</span>
        <span class="s1">while </span><span class="s0">(!state.done &amp;&amp; duration &lt; maxGeneratorDuration) {</span>
            <span class="s0">duration += timeStep;</span>
            <span class="s0">state = generator.next(duration);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">duration &gt;= maxGeneratorDuration ? Infinity : duration;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a progress =&gt; progress easing function from a generator.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">createGeneratorEasing(options, scale = </span><span class="s5">100</span><span class="s0">, createGenerator) {</span>
        <span class="s1">const </span><span class="s0">generator = createGenerator({ ...options, keyframes: [</span><span class="s5">0</span><span class="s0">, scale] });</span>
        <span class="s1">const </span><span class="s0">duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,</span>
            <span class="s0">ease: (progress) =&gt; {</span>
                <span class="s1">return </span><span class="s0">generator.next(duration * progress).value / scale;</span>
            <span class="s0">},</span>
            <span class="s0">duration: millisecondsToSeconds(duration),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">velocitySampleDuration = </span><span class="s5">5</span><span class="s0">; </span><span class="s3">// ms</span>
    <span class="s1">function </span><span class="s0">calcGeneratorVelocity(resolveValue, t, current) {</span>
        <span class="s1">const </span><span class="s0">prevT = Math.max(t - velocitySampleDuration, </span><span class="s5">0</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">velocityPerSecond(current - resolveValue(prevT), t - prevT);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">springDefaults = {</span>
        <span class="s3">// Default spring physics</span>
        <span class="s0">stiffness: </span><span class="s5">100</span><span class="s0">,</span>
        <span class="s0">damping: </span><span class="s5">10</span><span class="s0">,</span>
        <span class="s0">mass: </span><span class="s5">1.0</span><span class="s0">,</span>
        <span class="s0">velocity: </span><span class="s5">0.0</span><span class="s0">,</span>
        <span class="s3">// Default duration/bounce-based options</span>
        <span class="s0">duration: </span><span class="s5">800</span><span class="s0">, </span><span class="s3">// in ms</span>
        <span class="s0">bounce: </span><span class="s5">0.3</span><span class="s0">,</span>
        <span class="s0">visualDuration: </span><span class="s5">0.3</span><span class="s0">, </span><span class="s3">// in seconds</span>
        <span class="s3">// Rest thresholds</span>
        <span class="s0">restSpeed: {</span>
            <span class="s0">granular: </span><span class="s5">0.01</span><span class="s0">,</span>
            <span class="s1">default</span><span class="s0">: </span><span class="s5">2</span><span class="s0">,</span>
        <span class="s0">},</span>
        <span class="s0">restDelta: {</span>
            <span class="s0">granular: </span><span class="s5">0.005</span><span class="s0">,</span>
            <span class="s1">default</span><span class="s0">: </span><span class="s5">0.5</span><span class="s0">,</span>
        <span class="s0">},</span>
        <span class="s3">// Limits</span>
        <span class="s0">minDuration: </span><span class="s5">0.01</span><span class="s0">, </span><span class="s3">// in seconds</span>
        <span class="s0">maxDuration: </span><span class="s5">10.0</span><span class="s0">, </span><span class="s3">// in seconds</span>
        <span class="s0">minDamping: </span><span class="s5">0.05</span><span class="s0">,</span>
        <span class="s0">maxDamping: </span><span class="s5">1</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">safeMin = </span><span class="s5">0.001</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {</span>
        <span class="s1">let </span><span class="s0">envelope;</span>
        <span class="s1">let </span><span class="s0">derivative;</span>
        <span class="s0">exports.warning(duration &lt;= secondsToMilliseconds(springDefaults.maxDuration), </span><span class="s2">&quot;Spring duration must be 10 seconds or less&quot;</span><span class="s0">, </span><span class="s2">&quot;spring-duration-limit&quot;</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">dampingRatio = </span><span class="s5">1 </span><span class="s0">- bounce;</span>
        <span class="s3">/**</span>
         <span class="s3">* Restrict dampingRatio and duration to within acceptable ranges.</span>
         <span class="s3">*/</span>
        <span class="s0">dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);</span>
        <span class="s0">duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));</span>
        <span class="s1">if </span><span class="s0">(dampingRatio &lt; </span><span class="s5">1</span><span class="s0">) {</span>
            <span class="s3">/**</span>
             <span class="s3">* Underdamped spring</span>
             <span class="s3">*/</span>
            <span class="s0">envelope = (undampedFreq) =&gt; {</span>
                <span class="s1">const </span><span class="s0">exponentialDecay = undampedFreq * dampingRatio;</span>
                <span class="s1">const </span><span class="s0">delta = exponentialDecay * duration;</span>
                <span class="s1">const </span><span class="s0">a = exponentialDecay - velocity;</span>
                <span class="s1">const </span><span class="s0">b = calcAngularFreq(undampedFreq, dampingRatio);</span>
                <span class="s1">const </span><span class="s0">c = Math.exp(-delta);</span>
                <span class="s1">return </span><span class="s0">safeMin - (a / b) * c;</span>
            <span class="s0">};</span>
            <span class="s0">derivative = (undampedFreq) =&gt; {</span>
                <span class="s1">const </span><span class="s0">exponentialDecay = undampedFreq * dampingRatio;</span>
                <span class="s1">const </span><span class="s0">delta = exponentialDecay * duration;</span>
                <span class="s1">const </span><span class="s0">d = delta * velocity + velocity;</span>
                <span class="s1">const </span><span class="s0">e = Math.pow(dampingRatio, </span><span class="s5">2</span><span class="s0">) * Math.pow(undampedFreq, </span><span class="s5">2</span><span class="s0">) * duration;</span>
                <span class="s1">const </span><span class="s0">f = Math.exp(-delta);</span>
                <span class="s1">const </span><span class="s0">g = calcAngularFreq(Math.pow(undampedFreq, </span><span class="s5">2</span><span class="s0">), dampingRatio);</span>
                <span class="s1">const </span><span class="s0">factor = -envelope(undampedFreq) + safeMin &gt; </span><span class="s5">0 </span><span class="s0">? -</span><span class="s5">1 </span><span class="s0">: </span><span class="s5">1</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">(factor * ((d - e) * f)) / g;</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s3">/**</span>
             <span class="s3">* Critically-damped spring</span>
             <span class="s3">*/</span>
            <span class="s0">envelope = (undampedFreq) =&gt; {</span>
                <span class="s1">const </span><span class="s0">a = Math.exp(-undampedFreq * duration);</span>
                <span class="s1">const </span><span class="s0">b = (undampedFreq - velocity) * duration + </span><span class="s5">1</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">-safeMin + a * b;</span>
            <span class="s0">};</span>
            <span class="s0">derivative = (undampedFreq) =&gt; {</span>
                <span class="s1">const </span><span class="s0">a = Math.exp(-undampedFreq * duration);</span>
                <span class="s1">const </span><span class="s0">b = (velocity - undampedFreq) * (duration * duration);</span>
                <span class="s1">return </span><span class="s0">a * b;</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">initialGuess = </span><span class="s5">5 </span><span class="s0">/ duration;</span>
        <span class="s1">const </span><span class="s0">undampedFreq = approximateRoot(envelope, derivative, initialGuess);</span>
        <span class="s0">duration = secondsToMilliseconds(duration);</span>
        <span class="s1">if </span><span class="s0">(isNaN(undampedFreq)) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">stiffness: springDefaults.stiffness,</span>
                <span class="s0">damping: springDefaults.damping,</span>
                <span class="s0">duration,</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">stiffness = Math.pow(undampedFreq, </span><span class="s5">2</span><span class="s0">) * mass;</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">stiffness,</span>
                <span class="s0">damping: dampingRatio * </span><span class="s5">2 </span><span class="s0">* Math.sqrt(mass * stiffness),</span>
                <span class="s0">duration,</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">rootIterations = </span><span class="s5">12</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">approximateRoot(envelope, derivative, initialGuess) {</span>
        <span class="s1">let </span><span class="s0">result = initialGuess;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">1</span><span class="s0">; i &lt; rootIterations; i++) {</span>
            <span class="s0">result = result - envelope(result) / derivative(result);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcAngularFreq(undampedFreq, dampingRatio) {</span>
        <span class="s1">return </span><span class="s0">undampedFreq * Math.sqrt(</span><span class="s5">1 </span><span class="s0">- dampingRatio * dampingRatio);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">durationKeys = [</span><span class="s2">&quot;duration&quot;</span><span class="s0">, </span><span class="s2">&quot;bounce&quot;</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">physicsKeys = [</span><span class="s2">&quot;stiffness&quot;</span><span class="s0">, </span><span class="s2">&quot;damping&quot;</span><span class="s0">, </span><span class="s2">&quot;mass&quot;</span><span class="s0">];</span>
    <span class="s1">function </span><span class="s0">isSpringType(options, keys) {</span>
        <span class="s1">return </span><span class="s0">keys.some((key) =&gt; options[key] !== undefined);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getSpringOptions(options) {</span>
        <span class="s1">let </span><span class="s0">springOptions = {</span>
            <span class="s0">velocity: springDefaults.velocity,</span>
            <span class="s0">stiffness: springDefaults.stiffness,</span>
            <span class="s0">damping: springDefaults.damping,</span>
            <span class="s0">mass: springDefaults.mass,</span>
            <span class="s0">isResolvedFromDuration: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">...options,</span>
        <span class="s0">};</span>
        <span class="s3">// stiffness/damping/mass overrides duration/bounce</span>
        <span class="s1">if </span><span class="s0">(!isSpringType(options, physicsKeys) &amp;&amp;</span>
            <span class="s0">isSpringType(options, durationKeys)) {</span>
            <span class="s1">if </span><span class="s0">(options.visualDuration) {</span>
                <span class="s1">const </span><span class="s0">visualDuration = options.visualDuration;</span>
                <span class="s1">const </span><span class="s0">root = (</span><span class="s5">2 </span><span class="s0">* Math.PI) / (visualDuration * </span><span class="s5">1.2</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">stiffness = root * root;</span>
                <span class="s1">const </span><span class="s0">damping = </span><span class="s5">2 </span><span class="s0">*</span>
                    <span class="s0">clamp(</span><span class="s5">0.05</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1 </span><span class="s0">- (options.bounce || </span><span class="s5">0</span><span class="s0">)) *</span>
                    <span class="s0">Math.sqrt(stiffness);</span>
                <span class="s0">springOptions = {</span>
                    <span class="s0">...springOptions,</span>
                    <span class="s0">mass: springDefaults.mass,</span>
                    <span class="s0">stiffness,</span>
                    <span class="s0">damping,</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">const </span><span class="s0">derived = findSpring(options);</span>
                <span class="s0">springOptions = {</span>
                    <span class="s0">...springOptions,</span>
                    <span class="s0">...derived,</span>
                    <span class="s0">mass: springDefaults.mass,</span>
                <span class="s0">};</span>
                <span class="s0">springOptions.isResolvedFromDuration = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">springOptions;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {</span>
        <span class="s1">const </span><span class="s0">options = </span><span class="s1">typeof </span><span class="s0">optionsOrVisualDuration !== </span><span class="s2">&quot;object&quot;</span>
            <span class="s0">? {</span>
                <span class="s0">visualDuration: optionsOrVisualDuration,</span>
                <span class="s0">keyframes: [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">],</span>
                <span class="s0">bounce,</span>
            <span class="s0">}</span>
            <span class="s0">: optionsOrVisualDuration;</span>
        <span class="s1">let </span><span class="s0">{ restSpeed, restDelta } = options;</span>
        <span class="s1">const </span><span class="s0">origin = options.keyframes[</span><span class="s5">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">target = options.keyframes[options.keyframes.length - </span><span class="s5">1</span><span class="s0">];</span>
        <span class="s3">/**</span>
         <span class="s3">* This is the Iterator-spec return value. We ensure it's mutable rather than using a generator</span>
         <span class="s3">* to reduce GC during animation.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">state = { done: </span><span class="s1">false</span><span class="s0">, value: origin };</span>
        <span class="s1">const </span><span class="s0">{ stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({</span>
            <span class="s0">...options,</span>
            <span class="s0">velocity: -millisecondsToSeconds(options.velocity || </span><span class="s5">0</span><span class="s0">),</span>
        <span class="s0">});</span>
        <span class="s1">const </span><span class="s0">initialVelocity = velocity || </span><span class="s5">0.0</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">dampingRatio = damping / (</span><span class="s5">2 </span><span class="s0">* Math.sqrt(stiffness * mass));</span>
        <span class="s1">const </span><span class="s0">initialDelta = target - origin;</span>
        <span class="s1">const </span><span class="s0">undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));</span>
        <span class="s3">/**</span>
         <span class="s3">* If we're working on a granular scale, use smaller defaults for determining</span>
         <span class="s3">* when the spring is finished.</span>
         <span class="s3">*</span>
         <span class="s3">* These defaults have been selected emprically based on what strikes a good</span>
         <span class="s3">* ratio between feeling good and finishing as soon as changes are imperceptible.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">isGranularScale = Math.abs(initialDelta) &lt; </span><span class="s5">5</span><span class="s0">;</span>
        <span class="s0">restSpeed || (restSpeed = isGranularScale</span>
            <span class="s0">? springDefaults.restSpeed.granular</span>
            <span class="s0">: springDefaults.restSpeed.default);</span>
        <span class="s0">restDelta || (restDelta = isGranularScale</span>
            <span class="s0">? springDefaults.restDelta.granular</span>
            <span class="s0">: springDefaults.restDelta.default);</span>
        <span class="s1">let </span><span class="s0">resolveSpring;</span>
        <span class="s1">if </span><span class="s0">(dampingRatio &lt; </span><span class="s5">1</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);</span>
            <span class="s3">// Underdamped spring</span>
            <span class="s0">resolveSpring = (t) =&gt; {</span>
                <span class="s1">const </span><span class="s0">envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);</span>
                <span class="s1">return </span><span class="s0">(target -</span>
                    <span class="s0">envelope *</span>
                        <span class="s0">(((initialVelocity +</span>
                            <span class="s0">dampingRatio * undampedAngularFreq * initialDelta) /</span>
                            <span class="s0">angularFreq) *</span>
                            <span class="s0">Math.sin(angularFreq * t) +</span>
                            <span class="s0">initialDelta * Math.cos(angularFreq * t)));</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(dampingRatio === </span><span class="s5">1</span><span class="s0">) {</span>
            <span class="s3">// Critically damped spring</span>
            <span class="s0">resolveSpring = (t) =&gt; target -</span>
                <span class="s0">Math.exp(-undampedAngularFreq * t) *</span>
                    <span class="s0">(initialDelta +</span>
                        <span class="s0">(initialVelocity + undampedAngularFreq * initialDelta) * t);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// Overdamped spring</span>
            <span class="s1">const </span><span class="s0">dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - </span><span class="s5">1</span><span class="s0">);</span>
            <span class="s0">resolveSpring = (t) =&gt; {</span>
                <span class="s1">const </span><span class="s0">envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);</span>
                <span class="s3">// When performing sinh or cosh values can hit Infinity so we cap them here</span>
                <span class="s1">const </span><span class="s0">freqForT = Math.min(dampedAngularFreq * t, </span><span class="s5">300</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">(target -</span>
                    <span class="s0">(envelope *</span>
                        <span class="s0">((initialVelocity +</span>
                            <span class="s0">dampingRatio * undampedAngularFreq * initialDelta) *</span>
                            <span class="s0">Math.sinh(freqForT) +</span>
                            <span class="s0">dampedAngularFreq *</span>
                                <span class="s0">initialDelta *</span>
                                <span class="s0">Math.cosh(freqForT))) /</span>
                        <span class="s0">dampedAngularFreq);</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">generator = {</span>
            <span class="s0">calculatedDuration: isResolvedFromDuration ? duration || </span><span class="s1">null </span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">next: (t) =&gt; {</span>
                <span class="s1">const </span><span class="s0">current = resolveSpring(t);</span>
                <span class="s1">if </span><span class="s0">(!isResolvedFromDuration) {</span>
                    <span class="s1">let </span><span class="s0">currentVelocity = t === </span><span class="s5">0 </span><span class="s0">? initialVelocity : </span><span class="s5">0.0</span><span class="s0">;</span>
                    <span class="s3">/**</span>
                     <span class="s3">* We only need to calculate velocity for under-damped springs</span>
                     <span class="s3">* as over- and critically-damped springs can't overshoot, so</span>
                     <span class="s3">* checking only for displacement is enough.</span>
                     <span class="s3">*/</span>
                    <span class="s1">if </span><span class="s0">(dampingRatio &lt; </span><span class="s5">1</span><span class="s0">) {</span>
                        <span class="s0">currentVelocity =</span>
                            <span class="s0">t === </span><span class="s5">0</span>
                                <span class="s0">? secondsToMilliseconds(initialVelocity)</span>
                                <span class="s0">: calcGeneratorVelocity(resolveSpring, t, current);</span>
                    <span class="s0">}</span>
                    <span class="s1">const </span><span class="s0">isBelowVelocityThreshold = Math.abs(currentVelocity) &lt;= restSpeed;</span>
                    <span class="s1">const </span><span class="s0">isBelowDisplacementThreshold = Math.abs(target - current) &lt;= restDelta;</span>
                    <span class="s0">state.done =</span>
                        <span class="s0">isBelowVelocityThreshold &amp;&amp; isBelowDisplacementThreshold;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">state.done = t &gt;= duration;</span>
                <span class="s0">}</span>
                <span class="s0">state.value = state.done ? target : current;</span>
                <span class="s1">return </span><span class="s0">state;</span>
            <span class="s0">},</span>
            <span class="s0">toString: () =&gt; {</span>
                <span class="s1">const </span><span class="s0">calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);</span>
                <span class="s1">const </span><span class="s0">easing = generateLinearEasing((progress) =&gt; generator.next(calculatedDuration * progress).value, calculatedDuration, </span><span class="s5">30</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">calculatedDuration + </span><span class="s2">&quot;ms &quot; </span><span class="s0">+ easing;</span>
            <span class="s0">},</span>
            <span class="s0">toTransition: () =&gt; { },</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">generator;</span>
    <span class="s0">}</span>
    <span class="s0">spring.applyToOptions = (options) =&gt; {</span>
        <span class="s1">const </span><span class="s0">generatorOptions = createGeneratorEasing(options, </span><span class="s5">100</span><span class="s0">, spring);</span>
        <span class="s0">options.ease = generatorOptions.ease;</span>
        <span class="s0">options.duration = secondsToMilliseconds(generatorOptions.duration);</span>
        <span class="s0">options.type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">options;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">inertia({ keyframes, velocity = </span><span class="s5">0.0</span><span class="s0">, power = </span><span class="s5">0.8</span><span class="s0">, timeConstant = </span><span class="s5">325</span><span class="s0">, bounceDamping = </span><span class="s5">10</span><span class="s0">, bounceStiffness = </span><span class="s5">500</span><span class="s0">, modifyTarget, min, max, restDelta = </span><span class="s5">0.5</span><span class="s0">, restSpeed, }) {</span>
        <span class="s1">const </span><span class="s0">origin = keyframes[</span><span class="s5">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">state = {</span>
            <span class="s0">done: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">value: origin,</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">isOutOfBounds = (v) =&gt; (min !== undefined &amp;&amp; v &lt; min) || (max !== undefined &amp;&amp; v &gt; max);</span>
        <span class="s1">const </span><span class="s0">nearestBoundary = (v) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(min === undefined)</span>
                <span class="s1">return </span><span class="s0">max;</span>
            <span class="s1">if </span><span class="s0">(max === undefined)</span>
                <span class="s1">return </span><span class="s0">min;</span>
            <span class="s1">return </span><span class="s0">Math.abs(min - v) &lt; Math.abs(max - v) ? min : max;</span>
        <span class="s0">};</span>
        <span class="s1">let </span><span class="s0">amplitude = power * velocity;</span>
        <span class="s1">const </span><span class="s0">ideal = origin + amplitude;</span>
        <span class="s1">const </span><span class="s0">target = modifyTarget === undefined ? ideal : modifyTarget(ideal);</span>
        <span class="s3">/**</span>
         <span class="s3">* If the target has changed we need to re-calculate the amplitude, otherwise</span>
         <span class="s3">* the animation will start from the wrong position.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(target !== ideal)</span>
            <span class="s0">amplitude = target - origin;</span>
        <span class="s1">const </span><span class="s0">calcDelta = (t) =&gt; -amplitude * Math.exp(-t / timeConstant);</span>
        <span class="s1">const </span><span class="s0">calcLatest = (t) =&gt; target + calcDelta(t);</span>
        <span class="s1">const </span><span class="s0">applyFriction = (t) =&gt; {</span>
            <span class="s1">const </span><span class="s0">delta = calcDelta(t);</span>
            <span class="s1">const </span><span class="s0">latest = calcLatest(t);</span>
            <span class="s0">state.done = Math.abs(delta) &lt;= restDelta;</span>
            <span class="s0">state.value = state.done ? target : latest;</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* Ideally this would resolve for t in a stateless way, we could</span>
         <span class="s3">* do that by always precalculating the animation but as we know</span>
         <span class="s3">* this will be done anyway we can assume that spring will</span>
         <span class="s3">* be discovered during that.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">timeReachedBoundary;</span>
        <span class="s1">let </span><span class="s0">spring$1;</span>
        <span class="s1">const </span><span class="s0">checkCatchBoundary = (t) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!isOutOfBounds(state.value))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">timeReachedBoundary = t;</span>
            <span class="s0">spring$1 = spring({</span>
                <span class="s0">keyframes: [state.value, nearestBoundary(state.value)],</span>
                <span class="s0">velocity: calcGeneratorVelocity(calcLatest, t, state.value), </span><span class="s3">// TODO: This should be passing * 1000</span>
                <span class="s0">damping: bounceDamping,</span>
                <span class="s0">stiffness: bounceStiffness,</span>
                <span class="s0">restDelta,</span>
                <span class="s0">restSpeed,</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s0">checkCatchBoundary(</span><span class="s5">0</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">calculatedDuration: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">next: (t) =&gt; {</span>
                <span class="s3">/**</span>
                 <span class="s3">* We need to resolve the friction to figure out if we need a</span>
                 <span class="s3">* spring but we don't want to do this twice per frame. So here</span>
                 <span class="s3">* we flag if we updated for this frame and later if we did</span>
                 <span class="s3">* we can skip doing it again.</span>
                 <span class="s3">*/</span>
                <span class="s1">let </span><span class="s0">hasUpdatedFrame = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(!spring$1 &amp;&amp; timeReachedBoundary === undefined) {</span>
                    <span class="s0">hasUpdatedFrame = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">applyFriction(t);</span>
                    <span class="s0">checkCatchBoundary(t);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we have a spring and the provided t is beyond the moment the friction</span>
                 <span class="s3">* animation crossed the min/max boundary, use the spring.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(timeReachedBoundary !== undefined &amp;&amp; t &gt;= timeReachedBoundary) {</span>
                    <span class="s1">return </span><span class="s0">spring$1.next(t - timeReachedBoundary);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">!hasUpdatedFrame &amp;&amp; applyFriction(t);</span>
                    <span class="s1">return </span><span class="s0">state;</span>
                <span class="s0">}</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createMixers(output, ease, customMixer) {</span>
        <span class="s1">const </span><span class="s0">mixers = [];</span>
        <span class="s1">const </span><span class="s0">mixerFactory = customMixer || MotionGlobalConfig.mix || mix;</span>
        <span class="s1">const </span><span class="s0">numMixers = output.length - </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numMixers; i++) {</span>
            <span class="s1">let </span><span class="s0">mixer = mixerFactory(output[i], output[i + </span><span class="s5">1</span><span class="s0">]);</span>
            <span class="s1">if </span><span class="s0">(ease) {</span>
                <span class="s1">const </span><span class="s0">easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;</span>
                <span class="s0">mixer = pipe(easingFunction, mixer);</span>
            <span class="s0">}</span>
            <span class="s0">mixers.push(mixer);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mixers;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Create a function that maps from a numerical input array to a generic output array.</span>
     <span class="s3">*</span>
     <span class="s3">* Accepts:</span>
     <span class="s3">*   - Numbers</span>
     <span class="s3">*   - Colors (hex, hsl, hsla, rgb, rgba)</span>
     <span class="s3">*   - Complex (combinations of one or more numbers or strings)</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const mixColor = interpolate([0, 1], ['#fff', '#000'])</span>
     <span class="s3">*</span>
     <span class="s3">* mixColor(0.5) // 'rgba(128, 128, 128, 1)'</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* TODO Revisit this approach once we've moved to data models for values,</span>
     <span class="s3">* probably not needed to pregenerate mixer functions.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">interpolate(input, output, { clamp: isClamp = </span><span class="s1">true</span><span class="s0">, ease, mixer } = {}) {</span>
        <span class="s1">const </span><span class="s0">inputLength = input.length;</span>
        <span class="s0">exports.invariant(inputLength === output.length, </span><span class="s2">&quot;Both input and output ranges must be the same length&quot;</span><span class="s0">, </span><span class="s2">&quot;range-length&quot;</span><span class="s0">);</span>
        <span class="s3">/**</span>
         <span class="s3">* If we're only provided a single input, we can just make a function</span>
         <span class="s3">* that returns the output.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(inputLength === </span><span class="s5">1</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">() =&gt; output[</span><span class="s5">0</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(inputLength === </span><span class="s5">2 </span><span class="s0">&amp;&amp; output[</span><span class="s5">0</span><span class="s0">] === output[</span><span class="s5">1</span><span class="s0">])</span>
            <span class="s1">return </span><span class="s0">() =&gt; output[</span><span class="s5">1</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">isZeroDeltaRange = input[</span><span class="s5">0</span><span class="s0">] === input[</span><span class="s5">1</span><span class="s0">];</span>
        <span class="s3">// If input runs highest -&gt; lowest, reverse both arrays</span>
        <span class="s1">if </span><span class="s0">(input[</span><span class="s5">0</span><span class="s0">] &gt; input[inputLength - </span><span class="s5">1</span><span class="s0">]) {</span>
            <span class="s0">input = [...input].reverse();</span>
            <span class="s0">output = [...output].reverse();</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">mixers = createMixers(output, ease, mixer);</span>
        <span class="s1">const </span><span class="s0">numMixers = mixers.length;</span>
        <span class="s1">const </span><span class="s0">interpolator = (v) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(isZeroDeltaRange &amp;&amp; v &lt; input[</span><span class="s5">0</span><span class="s0">])</span>
                <span class="s1">return </span><span class="s0">output[</span><span class="s5">0</span><span class="s0">];</span>
            <span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(numMixers &gt; </span><span class="s5">1</span><span class="s0">) {</span>
                <span class="s1">for </span><span class="s0">(; i &lt; input.length - </span><span class="s5">2</span><span class="s0">; i++) {</span>
                    <span class="s1">if </span><span class="s0">(v &lt; input[i + </span><span class="s5">1</span><span class="s0">])</span>
                        <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">progressInRange = progress(input[i], input[i + </span><span class="s5">1</span><span class="s0">], v);</span>
            <span class="s1">return </span><span class="s0">mixers[i](progressInRange);</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">isClamp</span>
            <span class="s0">? (v) =&gt; interpolator(clamp(input[</span><span class="s5">0</span><span class="s0">], input[inputLength - </span><span class="s5">1</span><span class="s0">], v))</span>
            <span class="s0">: interpolator;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">fillOffset(offset, remaining) {</span>
        <span class="s1">const </span><span class="s0">min = offset[offset.length - </span><span class="s5">1</span><span class="s0">];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">1</span><span class="s0">; i &lt;= remaining; i++) {</span>
            <span class="s1">const </span><span class="s0">offsetProgress = progress(</span><span class="s5">0</span><span class="s0">, remaining, i);</span>
            <span class="s0">offset.push(mixNumber$1(min, </span><span class="s5">1</span><span class="s0">, offsetProgress));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">defaultOffset$1(arr) {</span>
        <span class="s1">const </span><span class="s0">offset = [</span><span class="s5">0</span><span class="s0">];</span>
        <span class="s0">fillOffset(offset, arr.length - </span><span class="s5">1</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">offset;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">convertOffsetToTimes(offset, duration) {</span>
        <span class="s1">return </span><span class="s0">offset.map((o) =&gt; o * duration);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">defaultEasing(values, easing) {</span>
        <span class="s1">return </span><span class="s0">values.map(() =&gt; easing || easeInOut).splice(</span><span class="s5">0</span><span class="s0">, values.length - </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">keyframes({ duration = </span><span class="s5">300</span><span class="s0">, keyframes: keyframeValues, times, ease = </span><span class="s2">&quot;easeInOut&quot;</span><span class="s0">, }) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Easing functions can be externally defined as strings. Here we convert them</span>
         <span class="s3">* into actual functions.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">easingFunctions = isEasingArray(ease)</span>
            <span class="s0">? ease.map(easingDefinitionToFunction)</span>
            <span class="s0">: easingDefinitionToFunction(ease);</span>
        <span class="s3">/**</span>
         <span class="s3">* This is the Iterator-spec return value. We ensure it's mutable rather than using a generator</span>
         <span class="s3">* to reduce GC during animation.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">state = {</span>
            <span class="s0">done: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">value: keyframeValues[</span><span class="s5">0</span><span class="s0">],</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* Create a times array based on the provided 0-1 offsets</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">absoluteTimes = convertOffsetToTimes(</span>
        <span class="s3">// Only use the provided offsets if they're the correct length</span>
        <span class="s3">// TODO Maybe we should warn here if there's a length mismatch</span>
        <span class="s0">times &amp;&amp; times.length === keyframeValues.length</span>
            <span class="s0">? times</span>
            <span class="s0">: defaultOffset$1(keyframeValues), duration);</span>
        <span class="s1">const </span><span class="s0">mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {</span>
            <span class="s0">ease: Array.isArray(easingFunctions)</span>
                <span class="s0">? easingFunctions</span>
                <span class="s0">: defaultEasing(keyframeValues, easingFunctions),</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">calculatedDuration: duration,</span>
            <span class="s0">next: (t) =&gt; {</span>
                <span class="s0">state.value = mapTimeToKeyframe(t);</span>
                <span class="s0">state.done = t &gt;= duration;</span>
                <span class="s1">return </span><span class="s0">state;</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isNotNull$1 = (value) =&gt; value !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">getFinalKeyframe$1(keyframes, { repeat, repeatType = </span><span class="s2">&quot;loop&quot; </span><span class="s0">}, finalKeyframe, speed = </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">resolvedKeyframes = keyframes.filter(isNotNull$1);</span>
        <span class="s1">const </span><span class="s0">useFirstKeyframe = speed &lt; </span><span class="s5">0 </span><span class="s0">|| (repeat &amp;&amp; repeatType !== </span><span class="s2">&quot;loop&quot; </span><span class="s0">&amp;&amp; repeat % </span><span class="s5">2 </span><span class="s0">=== </span><span class="s5">1</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">index = useFirstKeyframe ? </span><span class="s5">0 </span><span class="s0">: resolvedKeyframes.length - </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!index || finalKeyframe === undefined</span>
            <span class="s0">? resolvedKeyframes[index]</span>
            <span class="s0">: finalKeyframe;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">transitionTypeMap = {</span>
        <span class="s0">decay: inertia,</span>
        <span class="s0">inertia,</span>
        <span class="s0">tween: keyframes,</span>
        <span class="s0">keyframes: keyframes,</span>
        <span class="s0">spring,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">replaceTransitionType(transition) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">transition.type === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s0">transition.type = transitionTypeMap[transition.type];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">WithPromise {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.updateFinished();</span>
        <span class="s0">}</span>
        <span class="s0">get finished() {</span>
            <span class="s1">return this</span><span class="s0">._finished;</span>
        <span class="s0">}</span>
        <span class="s0">updateFinished() {</span>
            <span class="s1">this</span><span class="s0">._finished = </span><span class="s1">new </span><span class="s0">Promise((resolve) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.resolve = resolve;</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">notifyFinished() {</span>
            <span class="s1">this</span><span class="s0">.resolve();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Allows the animation to be awaited.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">Use `finished` instead.</span>
         <span class="s3">*/</span>
        <span class="s0">then(onResolve, onReject) {</span>
            <span class="s1">return this</span><span class="s0">.finished.then(onResolve, onReject);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">percentToProgress = (percent) =&gt; percent / </span><span class="s5">100</span><span class="s0">;</span>
    <span class="s1">class </span><span class="s0">JSAnimation </span><span class="s1">extends </span><span class="s0">WithPromise {</span>
        <span class="s0">constructor(options) {</span>
            <span class="s1">super</span><span class="s0">();</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;idle&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.startTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isStopped = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* The current time of the animation.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.currentTime = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* The time at which the animation was paused.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.playbackSpeed = </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* This method is bound to the instance to fix a pattern where</span>
             <span class="s3">* animation.stop is returned as a reference from a useEffect.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.stop = () =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ motionValue } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">if </span><span class="s0">(motionValue &amp;&amp; motionValue.updatedAt !== time.now()) {</span>
                    <span class="s1">this</span><span class="s0">.tick(time.now());</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.isStopped = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;idle&quot;</span><span class="s0">)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.teardown();</span>
                <span class="s1">this</span><span class="s0">.options.onStop?.();</span>
            <span class="s0">};</span>
            <span class="s0">activeAnimations.mainThread++;</span>
            <span class="s1">this</span><span class="s0">.options = options;</span>
            <span class="s1">this</span><span class="s0">.initAnimation();</span>
            <span class="s1">this</span><span class="s0">.play();</span>
            <span class="s1">if </span><span class="s0">(options.autoplay === </span><span class="s1">false</span><span class="s0">)</span>
                <span class="s1">this</span><span class="s0">.pause();</span>
        <span class="s0">}</span>
        <span class="s0">initAnimation() {</span>
            <span class="s1">const </span><span class="s0">{ options } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s0">replaceTransitionType(options);</span>
            <span class="s1">const </span><span class="s0">{ type = keyframes, repeat = </span><span class="s5">0</span><span class="s0">, repeatDelay = </span><span class="s5">0</span><span class="s0">, repeatType, velocity = </span><span class="s5">0</span><span class="s0">, } = options;</span>
            <span class="s1">let </span><span class="s0">{ keyframes: keyframes$1 } = options;</span>
            <span class="s1">const </span><span class="s0">generatorFactory = type || keyframes;</span>
            <span class="s1">if </span><span class="s0">(generatorFactory !== keyframes) {</span>
                <span class="s0">exports.invariant(keyframes$1.length &lt;= </span><span class="s5">2</span><span class="s0">, </span><span class="s2">`Only two keyframes currently supported with spring and inertia animations. Trying to animate </span><span class="s0">${keyframes$1}</span><span class="s2">`</span><span class="s0">, </span><span class="s2">&quot;spring-two-frames&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(generatorFactory !== keyframes &amp;&amp;</span>
                <span class="s1">typeof </span><span class="s0">keyframes$1[</span><span class="s5">0</span><span class="s0">] !== </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[</span><span class="s5">0</span><span class="s0">], keyframes$1[</span><span class="s5">1</span><span class="s0">]));</span>
                <span class="s0">keyframes$1 = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">100</span><span class="s0">];</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">generator = generatorFactory({ ...options, keyframes: keyframes$1 });</span>
            <span class="s3">/**</span>
             <span class="s3">* If we have a mirror repeat type we need to create a second generator that outputs the</span>
             <span class="s3">* mirrored (not reversed) animation and later ping pong between the two generators.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(repeatType === </span><span class="s2">&quot;mirror&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.mirroredGenerator = generatorFactory({</span>
                    <span class="s0">...options,</span>
                    <span class="s0">keyframes: [...keyframes$1].reverse(),</span>
                    <span class="s0">velocity: -velocity,</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If duration is undefined and we have repeat options,</span>
             <span class="s3">* we need to calculate a duration from the generator.</span>
             <span class="s3">*</span>
             <span class="s3">* We set it to the generator itself to cache the duration.</span>
             <span class="s3">* Any timeline resolver will need to have already precalculated</span>
             <span class="s3">* the duration by this step.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(generator.calculatedDuration === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">generator.calculatedDuration = calcGeneratorDuration(generator);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">{ calculatedDuration } = generator;</span>
            <span class="s1">this</span><span class="s0">.calculatedDuration = calculatedDuration;</span>
            <span class="s1">this</span><span class="s0">.resolvedDuration = calculatedDuration + repeatDelay;</span>
            <span class="s1">this</span><span class="s0">.totalDuration = </span><span class="s1">this</span><span class="s0">.resolvedDuration * (repeat + </span><span class="s5">1</span><span class="s0">) - repeatDelay;</span>
            <span class="s1">this</span><span class="s0">.generator = generator;</span>
        <span class="s0">}</span>
        <span class="s0">updateTime(timestamp) {</span>
            <span class="s1">const </span><span class="s0">animationTime = Math.round(timestamp - </span><span class="s1">this</span><span class="s0">.startTime) * </span><span class="s1">this</span><span class="s0">.playbackSpeed;</span>
            <span class="s3">// Update currentTime</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.holdTime !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.currentTime = </span><span class="s1">this</span><span class="s0">.holdTime;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =</span>
                <span class="s3">// 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for</span>
                <span class="s3">// example.</span>
                <span class="s1">this</span><span class="s0">.currentTime = animationTime;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">tick(timestamp, sample = </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">{ generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.startTime === </span><span class="s1">null</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">generator.next(</span><span class="s5">0</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">{ delay = </span><span class="s5">0</span><span class="s0">, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = </span><span class="s1">this</span><span class="s0">.options;</span>
            <span class="s3">/**</span>
             <span class="s3">* requestAnimationFrame timestamps can come through as lower than</span>
             <span class="s3">* the startTime as set by performance.now(). Here we prevent this,</span>
             <span class="s3">* though in the future it could be possible to make setting startTime</span>
             <span class="s3">* a pending operation that gets resolved here.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.speed &gt; </span><span class="s5">0</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.startTime = Math.min(</span><span class="s1">this</span><span class="s0">.startTime, timestamp);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.speed &lt; </span><span class="s5">0</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.startTime = Math.min(timestamp - totalDuration / </span><span class="s1">this</span><span class="s0">.speed, </span><span class="s1">this</span><span class="s0">.startTime);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(sample) {</span>
                <span class="s1">this</span><span class="s0">.currentTime = timestamp;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.updateTime(timestamp);</span>
            <span class="s0">}</span>
            <span class="s3">// Rebase on delay</span>
            <span class="s1">const </span><span class="s0">timeWithoutDelay = </span><span class="s1">this</span><span class="s0">.currentTime - delay * (</span><span class="s1">this</span><span class="s0">.playbackSpeed &gt;= </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">isInDelayPhase = </span><span class="s1">this</span><span class="s0">.playbackSpeed &gt;= </span><span class="s5">0</span>
                <span class="s0">? timeWithoutDelay &lt; </span><span class="s5">0</span>
                <span class="s0">: timeWithoutDelay &gt; totalDuration;</span>
            <span class="s1">this</span><span class="s0">.currentTime = Math.max(timeWithoutDelay, </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s3">// If this animation has finished, set the current time  to the total duration.</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.holdTime === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.currentTime = totalDuration;</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">elapsed = </span><span class="s1">this</span><span class="s0">.currentTime;</span>
            <span class="s1">let </span><span class="s0">frameGenerator = generator;</span>
            <span class="s1">if </span><span class="s0">(repeat) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* Get the current progress (0-1) of the animation. If t is &gt;</span>
                 <span class="s3">* than duration we'll get values like 2.5 (midway through the</span>
                 <span class="s3">* third iteration)</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">progress = Math.min(</span><span class="s1">this</span><span class="s0">.currentTime, totalDuration) / resolvedDuration;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Get the current iteration (0 indexed). For instance the floor of</span>
                 <span class="s3">* 2.5 is 2.</span>
                 <span class="s3">*/</span>
                <span class="s1">let </span><span class="s0">currentIteration = Math.floor(progress);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Get the current progress of the iteration by taking the remainder</span>
                 <span class="s3">* so 2.5 is 0.5 through iteration 2</span>
                 <span class="s3">*/</span>
                <span class="s1">let </span><span class="s0">iterationProgress = progress % </span><span class="s5">1.0</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If iteration progress is 1 we count that as the end</span>
                 <span class="s3">* of the previous iteration.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!iterationProgress &amp;&amp; progress &gt;= </span><span class="s5">1</span><span class="s0">) {</span>
                    <span class="s0">iterationProgress = </span><span class="s5">1</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">iterationProgress === </span><span class="s5">1 </span><span class="s0">&amp;&amp; currentIteration--;</span>
                <span class="s0">currentIteration = Math.min(currentIteration, repeat + </span><span class="s5">1</span><span class="s0">);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Reverse progress if we're not running in &quot;normal&quot; direction</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">isOddIteration = Boolean(currentIteration % </span><span class="s5">2</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(isOddIteration) {</span>
                    <span class="s1">if </span><span class="s0">(repeatType === </span><span class="s2">&quot;reverse&quot;</span><span class="s0">) {</span>
                        <span class="s0">iterationProgress = </span><span class="s5">1 </span><span class="s0">- iterationProgress;</span>
                        <span class="s1">if </span><span class="s0">(repeatDelay) {</span>
                            <span class="s0">iterationProgress -= repeatDelay / resolvedDuration;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(repeatType === </span><span class="s2">&quot;mirror&quot;</span><span class="s0">) {</span>
                        <span class="s0">frameGenerator = mirroredGenerator;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s0">elapsed = clamp(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, iterationProgress) * resolvedDuration;</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're in negative time, set state as the initial keyframe.</span>
             <span class="s3">* This prevents delay: x, duration: 0 animations from finishing</span>
             <span class="s3">* instantly.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">state = isInDelayPhase</span>
                <span class="s0">? { done: </span><span class="s1">false</span><span class="s0">, value: keyframes[</span><span class="s5">0</span><span class="s0">] }</span>
                <span class="s0">: frameGenerator.next(elapsed);</span>
            <span class="s1">if </span><span class="s0">(mixKeyframes) {</span>
                <span class="s0">state.value = mixKeyframes(state.value);</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">{ done } = state;</span>
            <span class="s1">if </span><span class="s0">(!isInDelayPhase &amp;&amp; calculatedDuration !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">done =</span>
                    <span class="s1">this</span><span class="s0">.playbackSpeed &gt;= </span><span class="s5">0</span>
                        <span class="s0">? </span><span class="s1">this</span><span class="s0">.currentTime &gt;= totalDuration</span>
                        <span class="s0">: </span><span class="s1">this</span><span class="s0">.currentTime &lt;= </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">isAnimationFinished = </span><span class="s1">this</span><span class="s0">.holdTime === </span><span class="s1">null </span><span class="s0">&amp;&amp;</span>
                <span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s0">|| (</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;running&quot; </span><span class="s0">&amp;&amp; done));</span>
            <span class="s3">// TODO: The exception for inertia could be cleaner here</span>
            <span class="s1">if </span><span class="s0">(isAnimationFinished &amp;&amp; type !== inertia) {</span>
                <span class="s0">state.value = getFinalKeyframe$1(keyframes, </span><span class="s1">this</span><span class="s0">.options, finalKeyframe, </span><span class="s1">this</span><span class="s0">.speed);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(onUpdate) {</span>
                <span class="s0">onUpdate(state.value);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(isAnimationFinished) {</span>
                <span class="s1">this</span><span class="s0">.finish();</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">state;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Allows the returned animation to be awaited or promise-chained. Currently</span>
         <span class="s3">* resolves when the animation finishes at all but in a future update could/should</span>
         <span class="s3">* reject if its cancels.</span>
         <span class="s3">*/</span>
        <span class="s0">then(resolve, reject) {</span>
            <span class="s1">return this</span><span class="s0">.finished.then(resolve, reject);</span>
        <span class="s0">}</span>
        <span class="s0">get duration() {</span>
            <span class="s1">return </span><span class="s0">millisecondsToSeconds(</span><span class="s1">this</span><span class="s0">.calculatedDuration);</span>
        <span class="s0">}</span>
        <span class="s0">get iterationDuration() {</span>
            <span class="s1">const </span><span class="s0">{ delay = </span><span class="s5">0 </span><span class="s0">} = </span><span class="s1">this</span><span class="s0">.options || {};</span>
            <span class="s1">return this</span><span class="s0">.duration + millisecondsToSeconds(delay);</span>
        <span class="s0">}</span>
        <span class="s0">get time() {</span>
            <span class="s1">return </span><span class="s0">millisecondsToSeconds(</span><span class="s1">this</span><span class="s0">.currentTime);</span>
        <span class="s0">}</span>
        <span class="s0">set time(newTime) {</span>
            <span class="s0">newTime = secondsToMilliseconds(newTime);</span>
            <span class="s1">this</span><span class="s0">.currentTime = newTime;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.startTime === </span><span class="s1">null </span><span class="s0">||</span>
                <span class="s1">this</span><span class="s0">.holdTime !== </span><span class="s1">null </span><span class="s0">||</span>
                <span class="s1">this</span><span class="s0">.playbackSpeed === </span><span class="s5">0</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.holdTime = newTime;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.driver) {</span>
                <span class="s1">this</span><span class="s0">.startTime = </span><span class="s1">this</span><span class="s0">.driver.now() - newTime / </span><span class="s1">this</span><span class="s0">.playbackSpeed;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.driver?.start(</span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get speed() {</span>
            <span class="s1">return this</span><span class="s0">.playbackSpeed;</span>
        <span class="s0">}</span>
        <span class="s0">set speed(newSpeed) {</span>
            <span class="s1">this</span><span class="s0">.updateTime(time.now());</span>
            <span class="s1">const </span><span class="s0">hasChanged = </span><span class="s1">this</span><span class="s0">.playbackSpeed !== newSpeed;</span>
            <span class="s1">this</span><span class="s0">.playbackSpeed = newSpeed;</span>
            <span class="s1">if </span><span class="s0">(hasChanged) {</span>
                <span class="s1">this</span><span class="s0">.time = millisecondsToSeconds(</span><span class="s1">this</span><span class="s0">.currentTime);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">play() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStopped)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ driver = frameloopDriver, startTime } = </span><span class="s1">this</span><span class="s0">.options;</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.driver) {</span>
                <span class="s1">this</span><span class="s0">.driver = driver((timestamp) =&gt; </span><span class="s1">this</span><span class="s0">.tick(timestamp));</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.options.onPlay?.();</span>
            <span class="s1">const </span><span class="s0">now = </span><span class="s1">this</span><span class="s0">.driver.now();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.updateFinished();</span>
                <span class="s1">this</span><span class="s0">.startTime = now;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.holdTime !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.startTime = now - </span><span class="s1">this</span><span class="s0">.holdTime;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.startTime) {</span>
                <span class="s1">this</span><span class="s0">.startTime = startTime ?? now;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.speed &lt; </span><span class="s5">0</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.startTime += </span><span class="s1">this</span><span class="s0">.calculatedDuration;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Set playState to running only after we've used it in</span>
             <span class="s3">* the previous logic.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;running&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.driver.start();</span>
        <span class="s0">}</span>
        <span class="s0">pause() {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;paused&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.updateTime(time.now());</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">this</span><span class="s0">.currentTime;</span>
        <span class="s0">}</span>
        <span class="s0">complete() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state !== </span><span class="s2">&quot;running&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.play();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;finished&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">finish() {</span>
            <span class="s1">this</span><span class="s0">.notifyFinished();</span>
            <span class="s1">this</span><span class="s0">.teardown();</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;finished&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.options.onComplete?.();</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.startTime = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.tick(</span><span class="s5">0</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.teardown();</span>
            <span class="s1">this</span><span class="s0">.options.onCancel?.();</span>
        <span class="s0">}</span>
        <span class="s0">teardown() {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;idle&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.stopDriver();</span>
            <span class="s1">this</span><span class="s0">.startTime = </span><span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">activeAnimations.mainThread--;</span>
        <span class="s0">}</span>
        <span class="s0">stopDriver() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.driver)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.driver.stop();</span>
            <span class="s1">this</span><span class="s0">.driver = undefined;</span>
        <span class="s0">}</span>
        <span class="s0">sample(sampleTime) {</span>
            <span class="s1">this</span><span class="s0">.startTime = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">return this</span><span class="s0">.tick(sampleTime, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">attachTimeline(timeline) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.allowFlatten) {</span>
                <span class="s1">this</span><span class="s0">.options.type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.options.ease = </span><span class="s2">&quot;linear&quot;</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.initAnimation();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.driver?.stop();</span>
            <span class="s1">return </span><span class="s0">timeline.observe(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// Legacy function support</span>
    <span class="s1">function </span><span class="s0">animateValue(options) {</span>
        <span class="s1">return new </span><span class="s0">JSAnimation(options);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">fillWildcards(keyframes) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">1</span><span class="s0">; i &lt; keyframes.length; i++) {</span>
            <span class="s0">keyframes[i] ?? (keyframes[i] = keyframes[i - </span><span class="s5">1</span><span class="s0">]);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">radToDeg = (rad) =&gt; (rad * </span><span class="s5">180</span><span class="s0">) / Math.PI;</span>
    <span class="s1">const </span><span class="s0">rotate = (v) =&gt; {</span>
        <span class="s1">const </span><span class="s0">angle = radToDeg(Math.atan2(v[</span><span class="s5">1</span><span class="s0">], v[</span><span class="s5">0</span><span class="s0">]));</span>
        <span class="s1">return </span><span class="s0">rebaseAngle(angle);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">matrix2dParsers = {</span>
        <span class="s0">x: </span><span class="s5">4</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s5">5</span><span class="s0">,</span>
        <span class="s0">translateX: </span><span class="s5">4</span><span class="s0">,</span>
        <span class="s0">translateY: </span><span class="s5">5</span><span class="s0">,</span>
        <span class="s0">scaleX: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">scaleY: </span><span class="s5">3</span><span class="s0">,</span>
        <span class="s0">scale: (v) =&gt; (Math.abs(v[</span><span class="s5">0</span><span class="s0">]) + Math.abs(v[</span><span class="s5">3</span><span class="s0">])) / </span><span class="s5">2</span><span class="s0">,</span>
        <span class="s0">rotate,</span>
        <span class="s0">rotateZ: rotate,</span>
        <span class="s0">skewX: (v) =&gt; radToDeg(Math.atan(v[</span><span class="s5">1</span><span class="s0">])),</span>
        <span class="s0">skewY: (v) =&gt; radToDeg(Math.atan(v[</span><span class="s5">2</span><span class="s0">])),</span>
        <span class="s0">skew: (v) =&gt; (Math.abs(v[</span><span class="s5">1</span><span class="s0">]) + Math.abs(v[</span><span class="s5">2</span><span class="s0">])) / </span><span class="s5">2</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">rebaseAngle = (angle) =&gt; {</span>
        <span class="s0">angle = angle % </span><span class="s5">360</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(angle &lt; </span><span class="s5">0</span><span class="s0">)</span>
            <span class="s0">angle += </span><span class="s5">360</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">angle;</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">rotateZ = rotate;</span>
    <span class="s1">const </span><span class="s0">scaleX = (v) =&gt; Math.sqrt(v[</span><span class="s5">0</span><span class="s0">] * v[</span><span class="s5">0</span><span class="s0">] + v[</span><span class="s5">1</span><span class="s0">] * v[</span><span class="s5">1</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">scaleY = (v) =&gt; Math.sqrt(v[</span><span class="s5">4</span><span class="s0">] * v[</span><span class="s5">4</span><span class="s0">] + v[</span><span class="s5">5</span><span class="s0">] * v[</span><span class="s5">5</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">matrix3dParsers = {</span>
        <span class="s0">x: </span><span class="s5">12</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s5">13</span><span class="s0">,</span>
        <span class="s0">z: </span><span class="s5">14</span><span class="s0">,</span>
        <span class="s0">translateX: </span><span class="s5">12</span><span class="s0">,</span>
        <span class="s0">translateY: </span><span class="s5">13</span><span class="s0">,</span>
        <span class="s0">translateZ: </span><span class="s5">14</span><span class="s0">,</span>
        <span class="s0">scaleX,</span>
        <span class="s0">scaleY,</span>
        <span class="s0">scale: (v) =&gt; (scaleX(v) + scaleY(v)) / </span><span class="s5">2</span><span class="s0">,</span>
        <span class="s0">rotateX: (v) =&gt; rebaseAngle(radToDeg(Math.atan2(v[</span><span class="s5">6</span><span class="s0">], v[</span><span class="s5">5</span><span class="s0">]))),</span>
        <span class="s0">rotateY: (v) =&gt; rebaseAngle(radToDeg(Math.atan2(-v[</span><span class="s5">2</span><span class="s0">], v[</span><span class="s5">0</span><span class="s0">]))),</span>
        <span class="s0">rotateZ,</span>
        <span class="s0">rotate: rotateZ,</span>
        <span class="s0">skewX: (v) =&gt; radToDeg(Math.atan(v[</span><span class="s5">4</span><span class="s0">])),</span>
        <span class="s0">skewY: (v) =&gt; radToDeg(Math.atan(v[</span><span class="s5">1</span><span class="s0">])),</span>
        <span class="s0">skew: (v) =&gt; (Math.abs(v[</span><span class="s5">1</span><span class="s0">]) + Math.abs(v[</span><span class="s5">4</span><span class="s0">])) / </span><span class="s5">2</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">defaultTransformValue(name) {</span>
        <span class="s1">return </span><span class="s0">name.includes(</span><span class="s2">&quot;scale&quot;</span><span class="s0">) ? </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseValueFromTransform(transform, name) {</span>
        <span class="s1">if </span><span class="s0">(!transform || transform === </span><span class="s2">&quot;none&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">defaultTransformValue(name);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">matrix3dMatch = transform.match(</span><span class="s6">/^matrix3d\(([-\d.e\s,]+)\)$/u</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">parsers;</span>
        <span class="s1">let </span><span class="s0">match;</span>
        <span class="s1">if </span><span class="s0">(matrix3dMatch) {</span>
            <span class="s0">parsers = matrix3dParsers;</span>
            <span class="s0">match = matrix3dMatch;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">matrix2dMatch = transform.match(</span><span class="s6">/^matrix\(([-\d.e\s,]+)\)$/u</span><span class="s0">);</span>
            <span class="s0">parsers = matrix2dParsers;</span>
            <span class="s0">match = matrix2dMatch;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!match) {</span>
            <span class="s1">return </span><span class="s0">defaultTransformValue(name);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">valueParser = parsers[name];</span>
        <span class="s1">const </span><span class="s0">values = match[</span><span class="s5">1</span><span class="s0">].split(</span><span class="s2">&quot;,&quot;</span><span class="s0">).map(convertTransformToNumber);</span>
        <span class="s1">return typeof </span><span class="s0">valueParser === </span><span class="s2">&quot;function&quot;</span>
            <span class="s0">? valueParser(values)</span>
            <span class="s0">: values[valueParser];</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">readTransformValue = (instance, name) =&gt; {</span>
        <span class="s1">const </span><span class="s0">{ transform = </span><span class="s2">&quot;none&quot; </span><span class="s0">} = getComputedStyle(instance);</span>
        <span class="s1">return </span><span class="s0">parseValueFromTransform(transform, name);</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">convertTransformToNumber(value) {</span>
        <span class="s1">return </span><span class="s0">parseFloat(value.trim());</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Generate a list of every possible transform key.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">transformPropOrder = [</span>
        <span class="s2">&quot;transformPerspective&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;y&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;z&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;translateX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;translateY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;translateZ&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;scale&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;scaleX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;scaleY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rotate&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rotateX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rotateY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rotateZ&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skew&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skewX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skewY&quot;</span><span class="s0">,</span>
    <span class="s0">];</span>
    <span class="s3">/**</span>
     <span class="s3">* A quick lookup for transform props.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">transformProps = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">(() =&gt; </span><span class="s1">new </span><span class="s0">Set(transformPropOrder))();</span>

    <span class="s1">const </span><span class="s0">isNumOrPxType = (v) =&gt; v === number || v === px;</span>
    <span class="s1">const </span><span class="s0">transformKeys = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">nonTranslationalTransformKeys = transformPropOrder.filter((key) =&gt; !transformKeys.has(key));</span>
    <span class="s1">function </span><span class="s0">removeNonTranslationalTransform(visualElement) {</span>
        <span class="s1">const </span><span class="s0">removedTransforms = [];</span>
        <span class="s0">nonTranslationalTransformKeys.forEach((key) =&gt; {</span>
            <span class="s1">const </span><span class="s0">value = visualElement.getValue(key);</span>
            <span class="s1">if </span><span class="s0">(value !== undefined) {</span>
                <span class="s0">removedTransforms.push([key, value.get()]);</span>
                <span class="s0">value.set(key.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">) ? </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">removedTransforms;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">positionalValues = {</span>
        <span class="s3">// Dimensions</span>
        <span class="s0">width: ({ x }, { paddingLeft = </span><span class="s2">&quot;0&quot;</span><span class="s0">, paddingRight = </span><span class="s2">&quot;0&quot; </span><span class="s0">}) =&gt; x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),</span>
        <span class="s0">height: ({ y }, { paddingTop = </span><span class="s2">&quot;0&quot;</span><span class="s0">, paddingBottom = </span><span class="s2">&quot;0&quot; </span><span class="s0">}) =&gt; y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),</span>
        <span class="s0">top: (_bbox, { top }) =&gt; parseFloat(top),</span>
        <span class="s0">left: (_bbox, { left }) =&gt; parseFloat(left),</span>
        <span class="s0">bottom: ({ y }, { top }) =&gt; parseFloat(top) + (y.max - y.min),</span>
        <span class="s0">right: ({ x }, { left }) =&gt; parseFloat(left) + (x.max - x.min),</span>
        <span class="s3">// Transform</span>
        <span class="s0">x: (_bbox, { transform }) =&gt; parseValueFromTransform(transform, </span><span class="s2">&quot;x&quot;</span><span class="s0">),</span>
        <span class="s0">y: (_bbox, { transform }) =&gt; parseValueFromTransform(transform, </span><span class="s2">&quot;y&quot;</span><span class="s0">),</span>
    <span class="s0">};</span>
    <span class="s3">// Alias translate longform names</span>
    <span class="s0">positionalValues.translateX = positionalValues.x;</span>
    <span class="s0">positionalValues.translateY = positionalValues.y;</span>

    <span class="s1">const </span><span class="s0">toResolve = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">let </span><span class="s0">isScheduled = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">anyNeedsMeasurement = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">isForced = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">measureAllKeyframes() {</span>
        <span class="s1">if </span><span class="s0">(anyNeedsMeasurement) {</span>
            <span class="s1">const </span><span class="s0">resolversToMeasure = Array.from(toResolve).filter((resolver) =&gt; resolver.needsMeasurement);</span>
            <span class="s1">const </span><span class="s0">elementsToMeasure = </span><span class="s1">new </span><span class="s0">Set(resolversToMeasure.map((resolver) =&gt; resolver.element));</span>
            <span class="s1">const </span><span class="s0">transformsToRestore = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s3">/**</span>
             <span class="s3">* Write pass</span>
             <span class="s3">* If we're measuring elements we want to remove bounding box-changing transforms.</span>
             <span class="s3">*/</span>
            <span class="s0">elementsToMeasure.forEach((element) =&gt; {</span>
                <span class="s1">const </span><span class="s0">removedTransforms = removeNonTranslationalTransform(element);</span>
                <span class="s1">if </span><span class="s0">(!removedTransforms.length)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">transformsToRestore.set(element, removedTransforms);</span>
                <span class="s0">element.render();</span>
            <span class="s0">});</span>
            <span class="s3">// Read</span>
            <span class="s0">resolversToMeasure.forEach((resolver) =&gt; resolver.measureInitialState());</span>
            <span class="s3">// Write</span>
            <span class="s0">elementsToMeasure.forEach((element) =&gt; {</span>
                <span class="s0">element.render();</span>
                <span class="s1">const </span><span class="s0">restore = transformsToRestore.get(element);</span>
                <span class="s1">if </span><span class="s0">(restore) {</span>
                    <span class="s0">restore.forEach(([key, value]) =&gt; {</span>
                        <span class="s0">element.getValue(key)?.set(value);</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s3">// Read</span>
            <span class="s0">resolversToMeasure.forEach((resolver) =&gt; resolver.measureEndState());</span>
            <span class="s3">// Write</span>
            <span class="s0">resolversToMeasure.forEach((resolver) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(resolver.suspendedScrollY !== undefined) {</span>
                    <span class="s0">window.scrollTo(</span><span class="s5">0</span><span class="s0">, resolver.suspendedScrollY);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">anyNeedsMeasurement = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">isScheduled = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">toResolve.forEach((resolver) =&gt; resolver.complete(isForced));</span>
        <span class="s0">toResolve.clear();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">readAllKeyframes() {</span>
        <span class="s0">toResolve.forEach((resolver) =&gt; {</span>
            <span class="s0">resolver.readKeyframes();</span>
            <span class="s1">if </span><span class="s0">(resolver.needsMeasurement) {</span>
                <span class="s0">anyNeedsMeasurement = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">flushKeyframeResolvers() {</span>
        <span class="s0">isForced = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">readAllKeyframes();</span>
        <span class="s0">measureAllKeyframes();</span>
        <span class="s0">isForced = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">KeyframeResolver {</span>
        <span class="s0">constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;pending&quot;</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Track whether this resolver is async. If it is, it'll be added to the</span>
             <span class="s3">* resolver queue and flushed in the next frame. Resolvers that aren't going</span>
             <span class="s3">* to trigger read/write thrashing don't need to be async.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.isAsync = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Track whether this resolver needs to perform a measurement</span>
             <span class="s3">* to resolve its keyframes.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.needsMeasurement = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.unresolvedKeyframes = [...unresolvedKeyframes];</span>
            <span class="s1">this</span><span class="s0">.onComplete = onComplete;</span>
            <span class="s1">this</span><span class="s0">.name = name;</span>
            <span class="s1">this</span><span class="s0">.motionValue = motionValue;</span>
            <span class="s1">this</span><span class="s0">.element = element;</span>
            <span class="s1">this</span><span class="s0">.isAsync = isAsync;</span>
        <span class="s0">}</span>
        <span class="s0">scheduleResolve() {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;scheduled&quot;</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAsync) {</span>
                <span class="s0">toResolve.add(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(!isScheduled) {</span>
                    <span class="s0">isScheduled = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">frame.read(readAllKeyframes);</span>
                    <span class="s0">frame.resolveKeyframes(measureAllKeyframes);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.readKeyframes();</span>
                <span class="s1">this</span><span class="s0">.complete();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">readKeyframes() {</span>
            <span class="s1">const </span><span class="s0">{ unresolvedKeyframes, name, element, motionValue } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s3">// If initial keyframe is null we need to read it from the DOM</span>
            <span class="s1">if </span><span class="s0">(unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">] === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">currentValue = motionValue?.get();</span>
                <span class="s3">// TODO: This doesn't work if the final keyframe is a wildcard</span>
                <span class="s1">const </span><span class="s0">finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - </span><span class="s5">1</span><span class="s0">];</span>
                <span class="s1">if </span><span class="s0">(currentValue !== undefined) {</span>
                    <span class="s0">unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">] = currentValue;</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(element &amp;&amp; name) {</span>
                    <span class="s1">const </span><span class="s0">valueAsRead = element.readValue(name, finalKeyframe);</span>
                    <span class="s1">if </span><span class="s0">(valueAsRead !== undefined &amp;&amp; valueAsRead !== </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s0">unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">] = valueAsRead;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">] === undefined) {</span>
                    <span class="s0">unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">] = finalKeyframe;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(motionValue &amp;&amp; currentValue === undefined) {</span>
                    <span class="s0">motionValue.set(unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">]);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">fillWildcards(unresolvedKeyframes);</span>
        <span class="s0">}</span>
        <span class="s0">setFinalKeyframe() { }</span>
        <span class="s0">measureInitialState() { }</span>
        <span class="s0">renderEndStyles() { }</span>
        <span class="s0">measureEndState() { }</span>
        <span class="s0">complete(isForcedComplete = </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;complete&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.onComplete(</span><span class="s1">this</span><span class="s0">.unresolvedKeyframes, </span><span class="s1">this</span><span class="s0">.finalKeyframe, isForcedComplete);</span>
            <span class="s0">toResolve.delete(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;scheduled&quot;</span><span class="s0">) {</span>
                <span class="s0">toResolve.delete(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;pending&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">resume() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;pending&quot;</span><span class="s0">)</span>
                <span class="s1">this</span><span class="s0">.scheduleResolve();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isCSSVar = (name) =&gt; name.startsWith(</span><span class="s2">&quot;--&quot;</span><span class="s0">);</span>

    <span class="s1">function </span><span class="s0">setStyle(element, name, value) {</span>
        <span class="s0">isCSSVar(name)</span>
            <span class="s0">? element.style.setProperty(name, value)</span>
            <span class="s0">: (element.style[name] = value);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">supportsScrollTimeline = </span><span class="s3">/* @__PURE__ */ </span><span class="s0">memo(() =&gt; window.ScrollTimeline !== undefined);</span>

    <span class="s3">/**</span>
     <span class="s3">* Add the ability for test suites to manually set support flags</span>
     <span class="s3">* to better test more environments.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">supportsFlags = {};</span>

    <span class="s1">function </span><span class="s0">memoSupports(callback, supportsFlag) {</span>
        <span class="s1">const </span><span class="s0">memoized = memo(callback);</span>
        <span class="s1">return </span><span class="s0">() =&gt; supportsFlags[supportsFlag] ?? memoized();</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">supportsLinearEasing = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">memoSupports(() =&gt; {</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">document</span>
                <span class="s0">.createElement(</span><span class="s2">&quot;div&quot;</span><span class="s0">)</span>
                <span class="s0">.animate({ opacity: </span><span class="s5">0 </span><span class="s0">}, { easing: </span><span class="s2">&quot;linear(0, 1)&quot; </span><span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">catch </span><span class="s0">(e) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}, </span><span class="s2">&quot;linearEasing&quot;</span><span class="s0">);</span>

    <span class="s1">const </span><span class="s0">cubicBezierAsString = ([a, b, c, d]) =&gt; </span><span class="s2">`cubic-bezier(</span><span class="s0">${a}</span><span class="s2">, </span><span class="s0">${b}</span><span class="s2">, </span><span class="s0">${c}</span><span class="s2">, </span><span class="s0">${d}</span><span class="s2">)`</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">supportedWaapiEasing = {</span>
        <span class="s0">linear: </span><span class="s2">&quot;linear&quot;</span><span class="s0">,</span>
        <span class="s0">ease: </span><span class="s2">&quot;ease&quot;</span><span class="s0">,</span>
        <span class="s0">easeIn: </span><span class="s2">&quot;ease-in&quot;</span><span class="s0">,</span>
        <span class="s0">easeOut: </span><span class="s2">&quot;ease-out&quot;</span><span class="s0">,</span>
        <span class="s0">easeInOut: </span><span class="s2">&quot;ease-in-out&quot;</span><span class="s0">,</span>
        <span class="s0">circIn: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezierAsString([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0.65</span><span class="s0">, </span><span class="s5">0.55</span><span class="s0">, </span><span class="s5">1</span><span class="s0">]),</span>
        <span class="s0">circOut: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezierAsString([</span><span class="s5">0.55</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0.45</span><span class="s0">]),</span>
        <span class="s0">backIn: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezierAsString([</span><span class="s5">0.31</span><span class="s0">, </span><span class="s5">0.01</span><span class="s0">, </span><span class="s5">0.66</span><span class="s0">, -</span><span class="s5">0.59</span><span class="s0">]),</span>
        <span class="s0">backOut: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezierAsString([</span><span class="s5">0.33</span><span class="s0">, </span><span class="s5">1.53</span><span class="s0">, </span><span class="s5">0.69</span><span class="s0">, </span><span class="s5">0.99</span><span class="s0">]),</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">mapEasingToNativeEasing(easing, duration) {</span>
        <span class="s1">if </span><span class="s0">(!easing) {</span>
            <span class="s1">return </span><span class="s0">undefined;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">easing === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">supportsLinearEasing()</span>
                <span class="s0">? generateLinearEasing(easing, duration)</span>
                <span class="s0">: </span><span class="s2">&quot;ease-out&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(isBezierDefinition(easing)) {</span>
            <span class="s1">return </span><span class="s0">cubicBezierAsString(easing);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(Array.isArray(easing)) {</span>
            <span class="s1">return </span><span class="s0">easing.map((segmentEasing) =&gt; mapEasingToNativeEasing(segmentEasing, duration) ||</span>
                <span class="s0">supportedWaapiEasing.easeOut);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">supportedWaapiEasing[easing];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">startWaapiAnimation(element, valueName, keyframes, { delay = </span><span class="s5">0</span><span class="s0">, duration = </span><span class="s5">300</span><span class="s0">, repeat = </span><span class="s5">0</span><span class="s0">, repeatType = </span><span class="s2">&quot;loop&quot;</span><span class="s0">, ease = </span><span class="s2">&quot;easeOut&quot;</span><span class="s0">, times, } = {}, pseudoElement = undefined) {</span>
        <span class="s1">const </span><span class="s0">keyframeOptions = {</span>
            <span class="s0">[valueName]: keyframes,</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(times)</span>
            <span class="s0">keyframeOptions.offset = times;</span>
        <span class="s1">const </span><span class="s0">easing = mapEasingToNativeEasing(ease, duration);</span>
        <span class="s3">/**</span>
         <span class="s3">* If this is an easing array, apply to keyframes, not animation as a whole</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(easing))</span>
            <span class="s0">keyframeOptions.easing = easing;</span>
        <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
            <span class="s0">activeAnimations.waapi++;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">options = {</span>
            <span class="s0">delay,</span>
            <span class="s0">duration,</span>
            <span class="s0">easing: !Array.isArray(easing) ? easing : </span><span class="s2">&quot;linear&quot;</span><span class="s0">,</span>
            <span class="s0">fill: </span><span class="s2">&quot;both&quot;</span><span class="s0">,</span>
            <span class="s0">iterations: repeat + </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s0">direction: repeatType === </span><span class="s2">&quot;reverse&quot; </span><span class="s0">? </span><span class="s2">&quot;alternate&quot; </span><span class="s0">: </span><span class="s2">&quot;normal&quot;</span><span class="s0">,</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(pseudoElement)</span>
            <span class="s0">options.pseudoElement = pseudoElement;</span>
        <span class="s1">const </span><span class="s0">animation = element.animate(keyframeOptions, options);</span>
        <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
            <span class="s0">animation.finished.finally(() =&gt; {</span>
                <span class="s0">activeAnimations.waapi--;</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">animation;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isGenerator(type) {</span>
        <span class="s1">return typeof </span><span class="s0">type === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">&quot;applyToOptions&quot; </span><span class="s1">in </span><span class="s0">type;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">applyGeneratorOptions({ type, ...options }) {</span>
        <span class="s1">if </span><span class="s0">(isGenerator(type) &amp;&amp; supportsLinearEasing()) {</span>
            <span class="s1">return </span><span class="s0">type.applyToOptions(options);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">options.duration ?? (options.duration = </span><span class="s5">300</span><span class="s0">);</span>
            <span class="s0">options.ease ?? (options.ease = </span><span class="s2">&quot;easeOut&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">options;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.</span>
     <span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">NativeAnimation </span><span class="s1">extends </span><span class="s0">WithPromise {</span>
        <span class="s0">constructor(options) {</span>
            <span class="s1">super</span><span class="s0">();</span>
            <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isStopped = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!options)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ element, name, keyframes, pseudoElement, allowFlatten = </span><span class="s1">false</span><span class="s0">, finalKeyframe, onComplete, } = options;</span>
            <span class="s1">this</span><span class="s0">.isPseudoElement = Boolean(pseudoElement);</span>
            <span class="s1">this</span><span class="s0">.allowFlatten = allowFlatten;</span>
            <span class="s1">this</span><span class="s0">.options = options;</span>
            <span class="s0">exports.invariant(</span><span class="s1">typeof </span><span class="s0">options.type !== </span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">`Mini animate() doesn't support &quot;type&quot; as a string.`</span><span class="s0">, </span><span class="s2">&quot;mini-spring&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">transition = applyGeneratorOptions(options);</span>
            <span class="s1">this</span><span class="s0">.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);</span>
            <span class="s1">if </span><span class="s0">(transition.autoplay === </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.animation.pause();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.animation.onfinish = () =&gt; {</span>
                <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">this</span><span class="s0">.time;</span>
                <span class="s1">if </span><span class="s0">(!pseudoElement) {</span>
                    <span class="s1">const </span><span class="s0">keyframe = getFinalKeyframe$1(keyframes, </span><span class="s1">this</span><span class="s0">.options, finalKeyframe, </span><span class="s1">this</span><span class="s0">.speed);</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.updateMotionValue) {</span>
                        <span class="s1">this</span><span class="s0">.updateMotionValue(keyframe);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If we can, we want to commit the final style as set by the user,</span>
                         <span class="s3">* rather than the computed keyframe value supplied by the animation.</span>
                         <span class="s3">*/</span>
                        <span class="s0">setStyle(element, name, keyframe);</span>
                    <span class="s0">}</span>
                    <span class="s1">this</span><span class="s0">.animation.cancel();</span>
                <span class="s0">}</span>
                <span class="s0">onComplete?.();</span>
                <span class="s1">this</span><span class="s0">.notifyFinished();</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s0">play() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStopped)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.animation.play();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.updateFinished();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">pause() {</span>
            <span class="s1">this</span><span class="s0">.animation.pause();</span>
        <span class="s0">}</span>
        <span class="s0">complete() {</span>
            <span class="s1">this</span><span class="s0">.animation.finish?.();</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.animation.cancel();</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(e) { }</span>
        <span class="s0">}</span>
        <span class="s0">stop() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStopped)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isStopped = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ state } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(state === </span><span class="s2">&quot;idle&quot; </span><span class="s0">|| state === </span><span class="s2">&quot;finished&quot;</span><span class="s0">) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.updateMotionValue) {</span>
                <span class="s1">this</span><span class="s0">.updateMotionValue();</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.commitStyles();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isPseudoElement)</span>
                <span class="s1">this</span><span class="s0">.cancel();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* WAAPI doesn't natively have any interruption capabilities.</span>
         <span class="s3">*</span>
         <span class="s3">* In this method, we commit styles back to the DOM before cancelling</span>
         <span class="s3">* the animation.</span>
         <span class="s3">*</span>
         <span class="s3">* This is designed to be overridden by NativeAnimationExtended, which</span>
         <span class="s3">* will create a renderless JS animation and sample it twice to calculate</span>
         <span class="s3">* its current value, &quot;previous&quot; value, and therefore allow</span>
         <span class="s3">* Motion to also correctly calculate velocity for any subsequent animation</span>
         <span class="s3">* while deferring the commit until the next animation frame.</span>
         <span class="s3">*/</span>
        <span class="s0">commitStyles() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isPseudoElement) {</span>
                <span class="s1">this</span><span class="s0">.animation.commitStyles?.();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">get duration() {</span>
            <span class="s1">const </span><span class="s0">duration = </span><span class="s1">this</span><span class="s0">.animation.effect?.getComputedTiming?.().duration || </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">millisecondsToSeconds(Number(duration));</span>
        <span class="s0">}</span>
        <span class="s0">get iterationDuration() {</span>
            <span class="s1">const </span><span class="s0">{ delay = </span><span class="s5">0 </span><span class="s0">} = </span><span class="s1">this</span><span class="s0">.options || {};</span>
            <span class="s1">return this</span><span class="s0">.duration + millisecondsToSeconds(delay);</span>
        <span class="s0">}</span>
        <span class="s0">get time() {</span>
            <span class="s1">return </span><span class="s0">millisecondsToSeconds(Number(</span><span class="s1">this</span><span class="s0">.animation.currentTime) || </span><span class="s5">0</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">set time(newTime) {</span>
            <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.animation.currentTime = secondsToMilliseconds(newTime);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* The playback speed of the animation.</span>
         <span class="s3">* 1 = normal speed, 2 = double speed, 0.5 = half speed.</span>
         <span class="s3">*/</span>
        <span class="s0">get speed() {</span>
            <span class="s1">return this</span><span class="s0">.animation.playbackRate;</span>
        <span class="s0">}</span>
        <span class="s0">set speed(newSpeed) {</span>
            <span class="s3">// Allow backwards playback after finishing</span>
            <span class="s1">if </span><span class="s0">(newSpeed &lt; </span><span class="s5">0</span><span class="s0">)</span>
                <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.animation.playbackRate = newSpeed;</span>
        <span class="s0">}</span>
        <span class="s0">get state() {</span>
            <span class="s1">return this</span><span class="s0">.finishedTime !== </span><span class="s1">null</span>
                <span class="s0">? </span><span class="s2">&quot;finished&quot;</span>
                <span class="s0">: </span><span class="s1">this</span><span class="s0">.animation.playState;</span>
        <span class="s0">}</span>
        <span class="s0">get startTime() {</span>
            <span class="s1">return </span><span class="s0">Number(</span><span class="s1">this</span><span class="s0">.animation.startTime);</span>
        <span class="s0">}</span>
        <span class="s0">set startTime(newStartTime) {</span>
            <span class="s1">this</span><span class="s0">.animation.startTime = newStartTime;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Attaches a timeline to the animation, for instance the `ScrollTimeline`.</span>
         <span class="s3">*/</span>
        <span class="s0">attachTimeline({ timeline, observe }) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.allowFlatten) {</span>
                <span class="s1">this</span><span class="s0">.animation.effect?.updateTiming({ easing: </span><span class="s2">&quot;linear&quot; </span><span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.animation.onfinish = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(timeline &amp;&amp; supportsScrollTimeline()) {</span>
                <span class="s1">this</span><span class="s0">.animation.timeline = timeline;</span>
                <span class="s1">return </span><span class="s0">noop;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s0">observe(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">unsupportedEasingFunctions = {</span>
        <span class="s0">anticipate,</span>
        <span class="s0">backInOut,</span>
        <span class="s0">circInOut,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">isUnsupportedEase(key) {</span>
        <span class="s1">return </span><span class="s0">key </span><span class="s1">in </span><span class="s0">unsupportedEasingFunctions;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">replaceStringEasing(transition) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">transition.ease === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">isUnsupportedEase(transition.ease)) {</span>
            <span class="s0">transition.ease = unsupportedEasingFunctions[transition.ease];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* 10ms is chosen here as it strikes a balance between smooth</span>
     <span class="s3">* results (more than one keyframe per frame at 60fps) and</span>
     <span class="s3">* keyframe quantity.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">sampleDelta = </span><span class="s5">10</span><span class="s0">; </span><span class="s3">//ms</span>
    <span class="s1">class </span><span class="s0">NativeAnimationExtended </span><span class="s1">extends </span><span class="s0">NativeAnimation {</span>
        <span class="s0">constructor(options) {</span>
            <span class="s3">/**</span>
             <span class="s3">* The base NativeAnimation function only supports a subset</span>
             <span class="s3">* of Motion easings, and WAAPI also only supports some</span>
             <span class="s3">* easing functions via string/cubic-bezier definitions.</span>
             <span class="s3">*</span>
             <span class="s3">* This function replaces those unsupported easing functions</span>
             <span class="s3">* with a JS easing function. This will later get compiled</span>
             <span class="s3">* to a linear() easing function.</span>
             <span class="s3">*/</span>
            <span class="s0">replaceStringEasing(options);</span>
            <span class="s3">/**</span>
             <span class="s3">* Ensure we replace the transition type with a generator function</span>
             <span class="s3">* before passing to WAAPI.</span>
             <span class="s3">*</span>
             <span class="s3">* TODO: Does this have a better home? It could be shared with</span>
             <span class="s3">* JSAnimation.</span>
             <span class="s3">*/</span>
            <span class="s0">replaceTransitionType(options);</span>
            <span class="s1">super</span><span class="s0">(options);</span>
            <span class="s1">if </span><span class="s0">(options.startTime) {</span>
                <span class="s1">this</span><span class="s0">.startTime = options.startTime;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.options = options;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* WAAPI doesn't natively have any interruption capabilities.</span>
         <span class="s3">*</span>
         <span class="s3">* Rather than read commited styles back out of the DOM, we can</span>
         <span class="s3">* create a renderless JS animation and sample it twice to calculate</span>
         <span class="s3">* its current value, &quot;previous&quot; value, and therefore allow</span>
         <span class="s3">* Motion to calculate velocity for any subsequent animation.</span>
         <span class="s3">*/</span>
        <span class="s0">updateMotionValue(value) {</span>
            <span class="s1">const </span><span class="s0">{ motionValue, onUpdate, onComplete, element, ...options } = </span><span class="s1">this</span><span class="s0">.options;</span>
            <span class="s1">if </span><span class="s0">(!motionValue)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(value !== undefined) {</span>
                <span class="s0">motionValue.set(value);</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">sampleAnimation = </span><span class="s1">new </span><span class="s0">JSAnimation({</span>
                <span class="s0">...options,</span>
                <span class="s0">autoplay: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">});</span>
            <span class="s1">const </span><span class="s0">sampleTime = secondsToMilliseconds(</span><span class="s1">this</span><span class="s0">.finishedTime ?? </span><span class="s1">this</span><span class="s0">.time);</span>
            <span class="s0">motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);</span>
            <span class="s0">sampleAnimation.stop();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Check if a value is animatable. Examples:</span>
     <span class="s3">*</span>
     <span class="s3">* â: 100, &quot;100px&quot;, &quot;#fff&quot;</span>
     <span class="s3">* â: &quot;block&quot;, &quot;url(2.jpg)&quot;</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">value</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@internal</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">isAnimatable = (value, name) =&gt; {</span>
        <span class="s3">// If the list of keys that might be non-animatable grows, replace with Set</span>
        <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;zIndex&quot;</span><span class="s0">)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s3">// If it's a number or a keyframes array, we can animate it. We might at some point</span>
        <span class="s3">// need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,</span>
        <span class="s3">// but for now lets leave it like this for performance reasons</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot; </span><span class="s0">|| Array.isArray(value))</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; </span><span class="s3">// It's animatable if we have a string</span>
            <span class="s0">(complex.test(value) || value === </span><span class="s2">&quot;0&quot;</span><span class="s0">) &amp;&amp; </span><span class="s3">// And it contains numbers and/or colors</span>
            <span class="s0">!value.startsWith(</span><span class="s2">&quot;url(&quot;</span><span class="s0">) </span><span class="s3">// Unless it starts with &quot;url(&quot;</span>
        <span class="s0">) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">hasKeyframesChanged(keyframes) {</span>
        <span class="s1">const </span><span class="s0">current = keyframes[</span><span class="s5">0</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(keyframes.length === </span><span class="s5">1</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; keyframes.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(keyframes[i] !== current)</span>
                <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">canAnimate(keyframes, name, type, velocity) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Check if we're able to animate between the start and end keyframes,</span>
         <span class="s3">* and throw a warning if we're attempting to animate between one that's</span>
         <span class="s3">* animatable and another that isn't.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">originKeyframe = keyframes[</span><span class="s5">0</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(originKeyframe === </span><span class="s1">null</span><span class="s0">)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* These aren't traditionally animatable but we do support them.</span>
         <span class="s3">* In future we could look into making this more generic or replacing</span>
         <span class="s3">* this function with mix() === mixImmediate</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;display&quot; </span><span class="s0">|| name === </span><span class="s2">&quot;visibility&quot;</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">targetKeyframe = keyframes[keyframes.length - </span><span class="s5">1</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">isOriginAnimatable = isAnimatable(originKeyframe, name);</span>
        <span class="s1">const </span><span class="s0">isTargetAnimatable = isAnimatable(targetKeyframe, name);</span>
        <span class="s0">exports.warning(isOriginAnimatable === isTargetAnimatable, </span><span class="s2">`You are trying to animate </span><span class="s0">${name} </span><span class="s2">from &quot;</span><span class="s0">${originKeyframe}</span><span class="s2">&quot; to &quot;</span><span class="s0">${targetKeyframe}</span><span class="s2">&quot;. &quot;</span><span class="s0">${isOriginAnimatable ? targetKeyframe : originKeyframe}</span><span class="s2">&quot; is not an animatable value.`</span><span class="s0">, </span><span class="s2">&quot;value-not-animatable&quot;</span><span class="s0">);</span>
        <span class="s3">// Always skip if any of these are true</span>
        <span class="s1">if </span><span class="s0">(!isOriginAnimatable || !isTargetAnimatable) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">(hasKeyframesChanged(keyframes) ||</span>
            <span class="s0">((type === </span><span class="s2">&quot;spring&quot; </span><span class="s0">|| isGenerator(type)) &amp;&amp; velocity));</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">makeAnimationInstant(options) {</span>
        <span class="s0">options.duration = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">options.type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of values that can be hardware-accelerated.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">acceleratedValues$1 = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;opacity&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;clipPath&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;filter&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;transform&quot;</span><span class="s0">,</span>
        <span class="s3">// TODO: Could be re-enabled now we have support for linear() easing</span>
        <span class="s3">// &quot;background-color&quot;</span>
    <span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">supportsWaapi = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">memo(() =&gt; Object.hasOwnProperty.call(Element.prototype, </span><span class="s2">&quot;animate&quot;</span><span class="s0">));</span>
    <span class="s1">function </span><span class="s0">supportsBrowserAnimation(options) {</span>
        <span class="s1">const </span><span class="s0">{ motionValue, name, repeatDelay, repeatType, damping, type } = options;</span>
        <span class="s1">const </span><span class="s0">subject = motionValue?.owner?.current;</span>
        <span class="s3">/**</span>
         <span class="s3">* We use this check instead of isHTMLElement() because we explicitly</span>
         <span class="s3">* **don't** want elements in different timing contexts (i.e. popups)</span>
         <span class="s3">* to be accelerated, as it's not possible to sync these animations</span>
         <span class="s3">* properly with those driven from the main window frameloop.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!(subject </span><span class="s1">instanceof </span><span class="s0">HTMLElement)) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">{ onUpdate, transformTemplate } = motionValue.owner.getProps();</span>
        <span class="s1">return </span><span class="s0">(supportsWaapi() &amp;&amp;</span>
            <span class="s0">name &amp;&amp;</span>
            <span class="s0">acceleratedValues$1.has(name) &amp;&amp;</span>
            <span class="s0">(name !== </span><span class="s2">&quot;transform&quot; </span><span class="s0">|| !transformTemplate) &amp;&amp;</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're outputting values to onUpdate then we can't use WAAPI as there's</span>
             <span class="s3">* no way to read the value from WAAPI every frame.</span>
             <span class="s3">*/</span>
            <span class="s0">!onUpdate &amp;&amp;</span>
            <span class="s0">!repeatDelay &amp;&amp;</span>
            <span class="s0">repeatType !== </span><span class="s2">&quot;mirror&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">damping !== </span><span class="s5">0 </span><span class="s0">&amp;&amp;</span>
            <span class="s0">type !== </span><span class="s2">&quot;inertia&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Maximum time allowed between an animation being created and it being</span>
     <span class="s3">* resolved for us to use the latter as the start time.</span>
     <span class="s3">*</span>
     <span class="s3">* This is to ensure that while we prefer to &quot;start&quot; an animation as soon</span>
     <span class="s3">* as it's triggered, we also want to avoid a visual jump if there's a big delay</span>
     <span class="s3">* between these two moments.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">MAX_RESOLVE_DELAY = </span><span class="s5">40</span><span class="s0">;</span>
    <span class="s1">class </span><span class="s0">AsyncMotionValueAnimation </span><span class="s1">extends </span><span class="s0">WithPromise {</span>
        <span class="s0">constructor({ autoplay = </span><span class="s1">true</span><span class="s0">, delay = </span><span class="s5">0</span><span class="s0">, type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">, repeat = </span><span class="s5">0</span><span class="s0">, repeatDelay = </span><span class="s5">0</span><span class="s0">, repeatType = </span><span class="s2">&quot;loop&quot;</span><span class="s0">, keyframes, name, motionValue, element, ...options }) {</span>
            <span class="s1">super</span><span class="s0">();</span>
            <span class="s3">/**</span>
             <span class="s3">* Bound to support return animation.stop pattern</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.stop = () =&gt; {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._animation) {</span>
                    <span class="s1">this</span><span class="s0">._animation.stop();</span>
                    <span class="s1">this</span><span class="s0">.stopTimeline?.();</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.keyframeResolver?.cancel();</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.createdAt = time.now();</span>
            <span class="s1">const </span><span class="s0">optionsWithDefaults = {</span>
                <span class="s0">autoplay,</span>
                <span class="s0">delay,</span>
                <span class="s0">type,</span>
                <span class="s0">repeat,</span>
                <span class="s0">repeatDelay,</span>
                <span class="s0">repeatType,</span>
                <span class="s0">name,</span>
                <span class="s0">motionValue,</span>
                <span class="s0">element,</span>
                <span class="s0">...options,</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;</span>
            <span class="s1">this</span><span class="s0">.keyframeResolver = </span><span class="s1">new </span><span class="s0">KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) =&gt; </span><span class="s1">this</span><span class="s0">.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);</span>
            <span class="s1">this</span><span class="s0">.keyframeResolver?.scheduleResolve();</span>
        <span class="s0">}</span>
        <span class="s0">onKeyframesResolved(keyframes, finalKeyframe, options, sync) {</span>
            <span class="s1">this</span><span class="s0">.keyframeResolver = undefined;</span>
            <span class="s1">const </span><span class="s0">{ name, type, velocity, delay, isHandoff, onUpdate } = options;</span>
            <span class="s1">this</span><span class="s0">.resolvedAt = time.now();</span>
            <span class="s3">/**</span>
             <span class="s3">* If we can't animate this value with the resolved keyframes</span>
             <span class="s3">* then we should complete it immediately.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(!canAnimate(keyframes, name, type, velocity)) {</span>
                <span class="s1">if </span><span class="s0">(MotionGlobalConfig.instantAnimations || !delay) {</span>
                    <span class="s0">onUpdate?.(getFinalKeyframe$1(keyframes, options, finalKeyframe));</span>
                <span class="s0">}</span>
                <span class="s0">keyframes[</span><span class="s5">0</span><span class="s0">] = keyframes[keyframes.length - </span><span class="s5">1</span><span class="s0">];</span>
                <span class="s0">makeAnimationInstant(options);</span>
                <span class="s0">options.repeat = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Resolve startTime for the animation.</span>
             <span class="s3">*</span>
             <span class="s3">* This method uses the createdAt and resolvedAt to calculate the</span>
             <span class="s3">* animation startTime. *Ideally*, we would use the createdAt time as t=0</span>
             <span class="s3">* as the following frame would then be the first frame of the animation in</span>
             <span class="s3">* progress, which would feel snappier.</span>
             <span class="s3">*</span>
             <span class="s3">* However, if there's a delay (main thread work) between the creation of</span>
             <span class="s3">* the animation and the first commited frame, we prefer to use resolvedAt</span>
             <span class="s3">* to avoid a sudden jump into the animation.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">startTime = sync</span>
                <span class="s0">? !</span><span class="s1">this</span><span class="s0">.resolvedAt</span>
                    <span class="s0">? </span><span class="s1">this</span><span class="s0">.createdAt</span>
                    <span class="s0">: </span><span class="s1">this</span><span class="s0">.resolvedAt - </span><span class="s1">this</span><span class="s0">.createdAt &gt; MAX_RESOLVE_DELAY</span>
                        <span class="s0">? </span><span class="s1">this</span><span class="s0">.resolvedAt</span>
                        <span class="s0">: </span><span class="s1">this</span><span class="s0">.createdAt</span>
                <span class="s0">: undefined;</span>
            <span class="s1">const </span><span class="s0">resolvedOptions = {</span>
                <span class="s0">startTime,</span>
                <span class="s0">finalKeyframe,</span>
                <span class="s0">...options,</span>
                <span class="s0">keyframes,</span>
            <span class="s0">};</span>
            <span class="s3">/**</span>
             <span class="s3">* Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via</span>
             <span class="s3">* WAAPI. Therefore, this animation must be JS to ensure it runs &quot;under&quot; the</span>
             <span class="s3">* optimised animation.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">animation = !isHandoff &amp;&amp; supportsBrowserAnimation(resolvedOptions)</span>
                <span class="s0">? </span><span class="s1">new </span><span class="s0">NativeAnimationExtended({</span>
                    <span class="s0">...resolvedOptions,</span>
                    <span class="s0">element: resolvedOptions.motionValue.owner.current,</span>
                <span class="s0">})</span>
                <span class="s0">: </span><span class="s1">new </span><span class="s0">JSAnimation(resolvedOptions);</span>
            <span class="s0">animation.finished.then(() =&gt; </span><span class="s1">this</span><span class="s0">.notifyFinished()).catch(noop);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.pendingTimeline) {</span>
                <span class="s1">this</span><span class="s0">.stopTimeline = animation.attachTimeline(</span><span class="s1">this</span><span class="s0">.pendingTimeline);</span>
                <span class="s1">this</span><span class="s0">.pendingTimeline = undefined;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">._animation = animation;</span>
        <span class="s0">}</span>
        <span class="s0">get finished() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._animation) {</span>
                <span class="s1">return this</span><span class="s0">._finished;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return this</span><span class="s0">.animation.finished;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">then(onResolve, _onReject) {</span>
            <span class="s1">return this</span><span class="s0">.finished.finally(onResolve).then(() =&gt; { });</span>
        <span class="s0">}</span>
        <span class="s0">get animation() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._animation) {</span>
                <span class="s1">this</span><span class="s0">.keyframeResolver?.resume();</span>
                <span class="s0">flushKeyframeResolvers();</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">._animation;</span>
        <span class="s0">}</span>
        <span class="s0">get duration() {</span>
            <span class="s1">return this</span><span class="s0">.animation.duration;</span>
        <span class="s0">}</span>
        <span class="s0">get iterationDuration() {</span>
            <span class="s1">return this</span><span class="s0">.animation.iterationDuration;</span>
        <span class="s0">}</span>
        <span class="s0">get time() {</span>
            <span class="s1">return this</span><span class="s0">.animation.time;</span>
        <span class="s0">}</span>
        <span class="s0">set time(newTime) {</span>
            <span class="s1">this</span><span class="s0">.animation.time = newTime;</span>
        <span class="s0">}</span>
        <span class="s0">get speed() {</span>
            <span class="s1">return this</span><span class="s0">.animation.speed;</span>
        <span class="s0">}</span>
        <span class="s0">get state() {</span>
            <span class="s1">return this</span><span class="s0">.animation.state;</span>
        <span class="s0">}</span>
        <span class="s0">set speed(newSpeed) {</span>
            <span class="s1">this</span><span class="s0">.animation.speed = newSpeed;</span>
        <span class="s0">}</span>
        <span class="s0">get startTime() {</span>
            <span class="s1">return this</span><span class="s0">.animation.startTime;</span>
        <span class="s0">}</span>
        <span class="s0">attachTimeline(timeline) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._animation) {</span>
                <span class="s1">this</span><span class="s0">.stopTimeline = </span><span class="s1">this</span><span class="s0">.animation.attachTimeline(timeline);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.pendingTimeline = timeline;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">() =&gt; </span><span class="s1">this</span><span class="s0">.stop();</span>
        <span class="s0">}</span>
        <span class="s0">play() {</span>
            <span class="s1">this</span><span class="s0">.animation.play();</span>
        <span class="s0">}</span>
        <span class="s0">pause() {</span>
            <span class="s1">this</span><span class="s0">.animation.pause();</span>
        <span class="s0">}</span>
        <span class="s0">complete() {</span>
            <span class="s1">this</span><span class="s0">.animation.complete();</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._animation) {</span>
                <span class="s1">this</span><span class="s0">.animation.cancel();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.keyframeResolver?.cancel();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">GroupAnimation {</span>
        <span class="s0">constructor(animations) {</span>
            <span class="s3">// Bound to accomadate common `return animation.stop` pattern</span>
            <span class="s1">this</span><span class="s0">.stop = () =&gt; </span><span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;stop&quot;</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.animations = animations.filter(Boolean);</span>
        <span class="s0">}</span>
        <span class="s0">get finished() {</span>
            <span class="s1">return </span><span class="s0">Promise.all(</span><span class="s1">this</span><span class="s0">.animations.map((animation) =&gt; animation.finished));</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* TODO: Filter out cancelled or stopped animations before returning</span>
         <span class="s3">*/</span>
        <span class="s0">getAll(propName) {</span>
            <span class="s1">return this</span><span class="s0">.animations[</span><span class="s5">0</span><span class="s0">][propName];</span>
        <span class="s0">}</span>
        <span class="s0">setAll(propName, newValue) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.animations.length; i++) {</span>
                <span class="s1">this</span><span class="s0">.animations[i][propName] = newValue;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">attachTimeline(timeline) {</span>
            <span class="s1">const </span><span class="s0">subscriptions = </span><span class="s1">this</span><span class="s0">.animations.map((animation) =&gt; animation.attachTimeline(timeline));</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">subscriptions.forEach((cancel, i) =&gt; {</span>
                    <span class="s0">cancel &amp;&amp; cancel();</span>
                    <span class="s1">this</span><span class="s0">.animations[i].stop();</span>
                <span class="s0">});</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s0">get time() {</span>
            <span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;time&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">set time(time) {</span>
            <span class="s1">this</span><span class="s0">.setAll(</span><span class="s2">&quot;time&quot;</span><span class="s0">, time);</span>
        <span class="s0">}</span>
        <span class="s0">get speed() {</span>
            <span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;speed&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">set speed(speed) {</span>
            <span class="s1">this</span><span class="s0">.setAll(</span><span class="s2">&quot;speed&quot;</span><span class="s0">, speed);</span>
        <span class="s0">}</span>
        <span class="s0">get state() {</span>
            <span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;state&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get startTime() {</span>
            <span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;startTime&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get duration() {</span>
            <span class="s1">return </span><span class="s0">getMax(</span><span class="s1">this</span><span class="s0">.animations, </span><span class="s2">&quot;duration&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get iterationDuration() {</span>
            <span class="s1">return </span><span class="s0">getMax(</span><span class="s1">this</span><span class="s0">.animations, </span><span class="s2">&quot;iterationDuration&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">runAll(methodName) {</span>
            <span class="s1">this</span><span class="s0">.animations.forEach((controls) =&gt; controls[methodName]());</span>
        <span class="s0">}</span>
        <span class="s0">play() {</span>
            <span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;play&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">pause() {</span>
            <span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;pause&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;cancel&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">complete() {</span>
            <span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;complete&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getMax(animations, propName) {</span>
        <span class="s1">let </span><span class="s0">max = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; animations.length; i++) {</span>
            <span class="s1">const </span><span class="s0">value = animations[i][propName];</span>
            <span class="s1">if </span><span class="s0">(value !== </span><span class="s1">null </span><span class="s0">&amp;&amp; value &gt; max) {</span>
                <span class="s0">max = value;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">max;</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">GroupAnimationWithThen </span><span class="s1">extends </span><span class="s0">GroupAnimation {</span>
        <span class="s0">then(onResolve, _onReject) {</span>
            <span class="s1">return this</span><span class="s0">.finished.finally(onResolve).then(() =&gt; { });</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">NativeAnimationWrapper </span><span class="s1">extends </span><span class="s0">NativeAnimation {</span>
        <span class="s0">constructor(animation) {</span>
            <span class="s1">super</span><span class="s0">();</span>
            <span class="s1">this</span><span class="s0">.animation = animation;</span>
            <span class="s0">animation.onfinish = () =&gt; {</span>
                <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">this</span><span class="s0">.time;</span>
                <span class="s1">this</span><span class="s0">.notifyFinished();</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">animationMaps = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">const </span><span class="s0">animationMapKey = (name, pseudoElement = </span><span class="s2">&quot;&quot;</span><span class="s0">) =&gt; </span><span class="s2">`</span><span class="s0">${name}</span><span class="s2">:</span><span class="s0">${pseudoElement}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">getAnimationMap(element) {</span>
        <span class="s1">const </span><span class="s0">map = animationMaps.get(element) || </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">animationMaps.set(element, map);</span>
        <span class="s1">return </span><span class="s0">map;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Parse Framer's special CSS variable format into a CSS token and a fallback.</span>
     <span class="s3">*</span>
     <span class="s3">* ```</span>
     <span class="s3">* `var(--foo, #fff)` =&gt; [`--foo`, '#fff']</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">current</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">splitCSSVariableRegex = </span>
    <span class="s3">// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words</span>
    <span class="s6">/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">parseCSSVariable(current) {</span>
        <span class="s1">const </span><span class="s0">match = splitCSSVariableRegex.exec(current);</span>
        <span class="s1">if </span><span class="s0">(!match)</span>
            <span class="s1">return </span><span class="s0">[,];</span>
        <span class="s1">const </span><span class="s0">[, token1, token2, fallback] = match;</span>
        <span class="s1">return </span><span class="s0">[</span><span class="s2">`--</span><span class="s0">${token1 ?? token2}</span><span class="s2">`</span><span class="s0">, fallback];</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">maxDepth = </span><span class="s5">4</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">getVariableValue(current, element, depth = </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s0">exports.invariant(depth &lt;= maxDepth, </span><span class="s2">`Max CSS variable fallback depth detected in property &quot;</span><span class="s0">${current}</span><span class="s2">&quot;. This may indicate a circular fallback dependency.`</span><span class="s0">, </span><span class="s2">&quot;max-css-var-depth&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">[token, fallback] = parseCSSVariable(current);</span>
        <span class="s3">// No CSS variable detected</span>
        <span class="s1">if </span><span class="s0">(!token)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s3">// Attempt to read this CSS variable off the element</span>
        <span class="s1">const </span><span class="s0">resolved = window.getComputedStyle(element).getPropertyValue(token);</span>
        <span class="s1">if </span><span class="s0">(resolved) {</span>
            <span class="s1">const </span><span class="s0">trimmed = resolved.trim();</span>
            <span class="s1">return </span><span class="s0">isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">isCSSVariableToken(fallback)</span>
            <span class="s0">? getVariableValue(fallback, element, depth + </span><span class="s5">1</span><span class="s0">)</span>
            <span class="s0">: fallback;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getValueTransition$1(transition, key) {</span>
        <span class="s1">return </span><span class="s0">(transition?.[key] ??</span>
            <span class="s0">transition?.[</span><span class="s2">&quot;default&quot;</span><span class="s0">] ??</span>
            <span class="s0">transition);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">positionalKeys = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;width&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;height&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;top&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;left&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;right&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;bottom&quot;</span><span class="s0">,</span>
        <span class="s0">...transformPropOrder,</span>
    <span class="s0">]);</span>

    <span class="s3">/**</span>
     <span class="s3">* ValueType for &quot;auto&quot;</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">auto = {</span>
        <span class="s0">test: (v) =&gt; v === </span><span class="s2">&quot;auto&quot;</span><span class="s0">,</span>
        <span class="s0">parse: (v) =&gt; v,</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Tests a provided value against a ValueType</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">testValueType = (v) =&gt; (type) =&gt; type.test(v);</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of value types commonly used for dimensions</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];</span>
    <span class="s3">/**</span>
     <span class="s3">* Tests a dimensional value against the list of dimension ValueTypes</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">findDimensionValueType = (v) =&gt; dimensionValueTypes.find(testValueType(v));</span>

    <span class="s1">function </span><span class="s0">isNone(value) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">value === </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(value !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">value === </span><span class="s2">&quot;none&quot; </span><span class="s0">|| value === </span><span class="s2">&quot;0&quot; </span><span class="s0">|| isZeroValueString(value);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Properties that should default to 1 or 100%</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">maxDefaults = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;brightness&quot;</span><span class="s0">, </span><span class="s2">&quot;contrast&quot;</span><span class="s0">, </span><span class="s2">&quot;saturate&quot;</span><span class="s0">, </span><span class="s2">&quot;opacity&quot;</span><span class="s0">]);</span>
    <span class="s1">function </span><span class="s0">applyDefaultFilter(v) {</span>
        <span class="s1">const </span><span class="s0">[name, value] = v.slice(</span><span class="s5">0</span><span class="s0">, -</span><span class="s5">1</span><span class="s0">).split(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;drop-shadow&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">v;</span>
        <span class="s1">const </span><span class="s0">[number] = value.match(floatRegex) || [];</span>
        <span class="s1">if </span><span class="s0">(!number)</span>
            <span class="s1">return </span><span class="s0">v;</span>
        <span class="s1">const </span><span class="s0">unit = value.replace(number, </span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">defaultValue = maxDefaults.has(name) ? </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(number !== value)</span>
            <span class="s0">defaultValue *= </span><span class="s5">100</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">name + </span><span class="s2">&quot;(&quot; </span><span class="s0">+ defaultValue + unit + </span><span class="s2">&quot;)&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">functionRegex = </span><span class="s6">/\b([a-z-]*)\(.*?\)/gu</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">filter = {</span>
        <span class="s0">...complex,</span>
        <span class="s0">getAnimatableNone: (v) =&gt; {</span>
            <span class="s1">const </span><span class="s0">functions = v.match(functionRegex);</span>
            <span class="s1">return </span><span class="s0">functions ? functions.map(applyDefaultFilter).join(</span><span class="s2">&quot; &quot;</span><span class="s0">) : v;</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">int = {</span>
        <span class="s0">...number,</span>
        <span class="s0">transform: Math.round,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">transformValueTypes = {</span>
        <span class="s0">rotate: degrees,</span>
        <span class="s0">rotateX: degrees,</span>
        <span class="s0">rotateY: degrees,</span>
        <span class="s0">rotateZ: degrees,</span>
        <span class="s0">scale,</span>
        <span class="s0">scaleX: scale,</span>
        <span class="s0">scaleY: scale,</span>
        <span class="s0">scaleZ: scale,</span>
        <span class="s0">skew: degrees,</span>
        <span class="s0">skewX: degrees,</span>
        <span class="s0">skewY: degrees,</span>
        <span class="s0">distance: px,</span>
        <span class="s0">translateX: px,</span>
        <span class="s0">translateY: px,</span>
        <span class="s0">translateZ: px,</span>
        <span class="s0">x: px,</span>
        <span class="s0">y: px,</span>
        <span class="s0">z: px,</span>
        <span class="s0">perspective: px,</span>
        <span class="s0">transformPerspective: px,</span>
        <span class="s0">opacity: alpha,</span>
        <span class="s0">originX: progressPercentage,</span>
        <span class="s0">originY: progressPercentage,</span>
        <span class="s0">originZ: px,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">numberValueTypes = {</span>
        <span class="s3">// Border props</span>
        <span class="s0">borderWidth: px,</span>
        <span class="s0">borderTopWidth: px,</span>
        <span class="s0">borderRightWidth: px,</span>
        <span class="s0">borderBottomWidth: px,</span>
        <span class="s0">borderLeftWidth: px,</span>
        <span class="s0">borderRadius: px,</span>
        <span class="s0">radius: px,</span>
        <span class="s0">borderTopLeftRadius: px,</span>
        <span class="s0">borderTopRightRadius: px,</span>
        <span class="s0">borderBottomRightRadius: px,</span>
        <span class="s0">borderBottomLeftRadius: px,</span>
        <span class="s3">// Positioning props</span>
        <span class="s0">width: px,</span>
        <span class="s0">maxWidth: px,</span>
        <span class="s0">height: px,</span>
        <span class="s0">maxHeight: px,</span>
        <span class="s0">top: px,</span>
        <span class="s0">right: px,</span>
        <span class="s0">bottom: px,</span>
        <span class="s0">left: px,</span>
        <span class="s3">// Spacing props</span>
        <span class="s0">padding: px,</span>
        <span class="s0">paddingTop: px,</span>
        <span class="s0">paddingRight: px,</span>
        <span class="s0">paddingBottom: px,</span>
        <span class="s0">paddingLeft: px,</span>
        <span class="s0">margin: px,</span>
        <span class="s0">marginTop: px,</span>
        <span class="s0">marginRight: px,</span>
        <span class="s0">marginBottom: px,</span>
        <span class="s0">marginLeft: px,</span>
        <span class="s3">// Misc</span>
        <span class="s0">backgroundPositionX: px,</span>
        <span class="s0">backgroundPositionY: px,</span>
        <span class="s0">...transformValueTypes,</span>
        <span class="s0">zIndex: int,</span>
        <span class="s3">// SVG</span>
        <span class="s0">fillOpacity: alpha,</span>
        <span class="s0">strokeOpacity: alpha,</span>
        <span class="s0">numOctaves: int,</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* A map of default value types for common values</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">defaultValueTypes = {</span>
        <span class="s0">...numberValueTypes,</span>
        <span class="s3">// Color props</span>
        <span class="s0">color,</span>
        <span class="s0">backgroundColor: color,</span>
        <span class="s0">outlineColor: color,</span>
        <span class="s0">fill: color,</span>
        <span class="s0">stroke: color,</span>
        <span class="s3">// Border props</span>
        <span class="s0">borderColor: color,</span>
        <span class="s0">borderTopColor: color,</span>
        <span class="s0">borderRightColor: color,</span>
        <span class="s0">borderBottomColor: color,</span>
        <span class="s0">borderLeftColor: color,</span>
        <span class="s0">filter,</span>
        <span class="s0">WebkitFilter: filter,</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the default ValueType for the provided value key</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">getDefaultValueType = (key) =&gt; defaultValueTypes[key];</span>

    <span class="s1">function </span><span class="s0">getAnimatableNone(key, value) {</span>
        <span class="s1">let </span><span class="s0">defaultValueType = getDefaultValueType(key);</span>
        <span class="s1">if </span><span class="s0">(defaultValueType !== filter)</span>
            <span class="s0">defaultValueType = complex;</span>
        <span class="s3">// If value is not recognised as animatable, ie &quot;none&quot;, create an animatable version origin based on the target</span>
        <span class="s1">return </span><span class="s0">defaultValueType.getAnimatableNone</span>
            <span class="s0">? defaultValueType.getAnimatableNone(value)</span>
            <span class="s0">: undefined;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* If we encounter keyframes like &quot;none&quot; or &quot;0&quot; and we also have keyframes like</span>
     <span class="s3">* &quot;#fff&quot; or &quot;200px 200px&quot; we want to find a keyframe to serve as a template for</span>
     <span class="s3">* the &quot;none&quot; keyframes. In this case &quot;#fff&quot; or &quot;200px 200px&quot; - then these get turned into</span>
     <span class="s3">* zero equivalents, i.e. &quot;#fff0&quot; or &quot;0px 0px&quot;.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">invalidTemplates = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;0&quot;</span><span class="s0">]);</span>
    <span class="s1">function </span><span class="s0">makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {</span>
        <span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">animatableTemplate = undefined;</span>
        <span class="s1">while </span><span class="s0">(i &lt; unresolvedKeyframes.length &amp;&amp; !animatableTemplate) {</span>
            <span class="s1">const </span><span class="s0">keyframe = unresolvedKeyframes[i];</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">keyframe === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">!invalidTemplates.has(keyframe) &amp;&amp;</span>
                <span class="s0">analyseComplexValue(keyframe).values.length) {</span>
                <span class="s0">animatableTemplate = unresolvedKeyframes[i];</span>
            <span class="s0">}</span>
            <span class="s0">i++;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(animatableTemplate &amp;&amp; name) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">noneIndex of noneKeyframeIndexes) {</span>
                <span class="s0">unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">DOMKeyframesResolver </span><span class="s1">extends </span><span class="s0">KeyframeResolver {</span>
        <span class="s0">constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {</span>
            <span class="s1">super</span><span class="s0">(unresolvedKeyframes, onComplete, name, motionValue, element, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">readKeyframes() {</span>
            <span class="s1">const </span><span class="s0">{ unresolvedKeyframes, element, name } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!element || !element.current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">super</span><span class="s0">.readKeyframes();</span>
            <span class="s3">/**</span>
             <span class="s3">* If any keyframe is a CSS variable, we need to find its value by sampling the element</span>
             <span class="s3">*/</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; unresolvedKeyframes.length; i++) {</span>
                <span class="s1">let </span><span class="s0">keyframe = unresolvedKeyframes[i];</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">keyframe === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                    <span class="s0">keyframe = keyframe.trim();</span>
                    <span class="s1">if </span><span class="s0">(isCSSVariableToken(keyframe)) {</span>
                        <span class="s1">const </span><span class="s0">resolved = getVariableValue(keyframe, element.current);</span>
                        <span class="s1">if </span><span class="s0">(resolved !== undefined) {</span>
                            <span class="s0">unresolvedKeyframes[i] = resolved;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(i === unresolvedKeyframes.length - </span><span class="s5">1</span><span class="s0">) {</span>
                            <span class="s1">this</span><span class="s0">.finalKeyframe = keyframe;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Resolve &quot;none&quot; values. We do this potentially twice - once before and once after measuring keyframes.</span>
             <span class="s3">* This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which</span>
             <span class="s3">* have a far bigger performance impact.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.resolveNoneKeyframes();</span>
            <span class="s3">/**</span>
             <span class="s3">* Check to see if unit type has changed. If so schedule jobs that will</span>
             <span class="s3">* temporarily set styles to the destination keyframes.</span>
             <span class="s3">* Skip if we have more than two keyframes or this isn't a positional value.</span>
             <span class="s3">* TODO: We can throw if there are multiple keyframes and the value type changes.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(!positionalKeys.has(name) || unresolvedKeyframes.length !== </span><span class="s5">2</span><span class="s0">) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">[origin, target] = unresolvedKeyframes;</span>
            <span class="s1">const </span><span class="s0">originType = findDimensionValueType(origin);</span>
            <span class="s1">const </span><span class="s0">targetType = findDimensionValueType(target);</span>
            <span class="s3">/**</span>
             <span class="s3">* Either we don't recognise these value types or we can animate between them.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(originType === targetType)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* If both values are numbers or pixels, we can animate between them by</span>
             <span class="s3">* converting them to numbers.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(isNumOrPxType(originType) &amp;&amp; isNumOrPxType(targetType)) {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; unresolvedKeyframes.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">value = unresolvedKeyframes[i];</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                        <span class="s0">unresolvedKeyframes[i] = parseFloat(value);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(positionalValues[name]) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* Else, the only way to resolve this is by measuring the element.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.needsMeasurement = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">resolveNoneKeyframes() {</span>
            <span class="s1">const </span><span class="s0">{ unresolvedKeyframes, name } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">noneKeyframeIndexes = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; unresolvedKeyframes.length; i++) {</span>
                <span class="s1">if </span><span class="s0">(unresolvedKeyframes[i] === </span><span class="s1">null </span><span class="s0">||</span>
                    <span class="s0">isNone(unresolvedKeyframes[i])) {</span>
                    <span class="s0">noneKeyframeIndexes.push(i);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(noneKeyframeIndexes.length) {</span>
                <span class="s0">makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">measureInitialState() {</span>
            <span class="s1">const </span><span class="s0">{ element, unresolvedKeyframes, name } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!element || !element.current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;height&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.suspendedScrollY = window.pageYOffset;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));</span>
            <span class="s0">unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">] = </span><span class="s1">this</span><span class="s0">.measuredOrigin;</span>
            <span class="s3">// Set final key frame to measure after next render</span>
            <span class="s1">const </span><span class="s0">measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - </span><span class="s5">1</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(measureKeyframe !== undefined) {</span>
                <span class="s0">element.getValue(name, measureKeyframe).jump(measureKeyframe, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">measureEndState() {</span>
            <span class="s1">const </span><span class="s0">{ element, name, unresolvedKeyframes } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!element || !element.current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">value = element.getValue(name);</span>
            <span class="s0">value &amp;&amp; value.jump(</span><span class="s1">this</span><span class="s0">.measuredOrigin, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">finalKeyframeIndex = unresolvedKeyframes.length - </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];</span>
            <span class="s0">unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));</span>
            <span class="s1">if </span><span class="s0">(finalKeyframe !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.finalKeyframe === undefined) {</span>
                <span class="s1">this</span><span class="s0">.finalKeyframe = finalKeyframe;</span>
            <span class="s0">}</span>
            <span class="s3">// If we removed transform values, reapply them before the next render</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.removedTransforms?.length) {</span>
                <span class="s1">this</span><span class="s0">.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) =&gt; {</span>
                    <span class="s0">element</span>
                        <span class="s0">.getValue(unsetTransformName)</span>
                        <span class="s0">.set(unsetTransformValue);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.resolveNoneKeyframes();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">pxValues = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s3">// Border props</span>
        <span class="s2">&quot;borderWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderTopWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderRightWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderBottomWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderLeftWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderRadius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;radius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderTopLeftRadius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderTopRightRadius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderBottomRightRadius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderBottomLeftRadius&quot;</span><span class="s0">,</span>
        <span class="s3">// Positioning props</span>
        <span class="s2">&quot;width&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;maxWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;height&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;maxHeight&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;top&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;right&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;bottom&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;left&quot;</span><span class="s0">,</span>
        <span class="s3">// Spacing props</span>
        <span class="s2">&quot;padding&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;paddingTop&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;paddingRight&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;paddingBottom&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;paddingLeft&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;margin&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marginTop&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marginRight&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marginBottom&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marginLeft&quot;</span><span class="s0">,</span>
        <span class="s3">// Misc</span>
        <span class="s2">&quot;backgroundPositionX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;backgroundPositionY&quot;</span><span class="s0">,</span>
    <span class="s0">]);</span>

    <span class="s1">function </span><span class="s0">applyPxDefaults(keyframes, name) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; keyframes.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">keyframes[i] === </span><span class="s2">&quot;number&quot; </span><span class="s0">&amp;&amp; pxValues.has(name)) {</span>
                <span class="s0">keyframes[i] = keyframes[i] + </span><span class="s2">&quot;px&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isWaapiSupportedEasing(easing) {</span>
        <span class="s1">return </span><span class="s0">Boolean((</span><span class="s1">typeof </span><span class="s0">easing === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; supportsLinearEasing()) ||</span>
            <span class="s0">!easing ||</span>
            <span class="s0">(</span><span class="s1">typeof </span><span class="s0">easing === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">(easing </span><span class="s1">in </span><span class="s0">supportedWaapiEasing || supportsLinearEasing())) ||</span>
            <span class="s0">isBezierDefinition(easing) ||</span>
            <span class="s0">(Array.isArray(easing) &amp;&amp; easing.every(isWaapiSupportedEasing)));</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">supportsPartialKeyframes = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">memo(() =&gt; {</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">document.createElement(</span><span class="s2">&quot;div&quot;</span><span class="s0">).animate({ opacity: [</span><span class="s5">1</span><span class="s0">] });</span>
        <span class="s0">}</span>
        <span class="s1">catch </span><span class="s0">(e) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of values that can be hardware-accelerated.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">acceleratedValues = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;opacity&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;clipPath&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;filter&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;transform&quot;</span><span class="s0">,</span>
        <span class="s3">// TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved</span>
        <span class="s3">// or until we implement support for linear() easing.</span>
        <span class="s3">// &quot;background-color&quot;</span>
    <span class="s0">]);</span>

    <span class="s1">function </span><span class="s0">camelToDash$1(str) {</span>
        <span class="s1">return </span><span class="s0">str.replace(</span><span class="s6">/([A-Z])/g</span><span class="s0">, (match) =&gt; </span><span class="s2">`-</span><span class="s0">${match.toLowerCase()}</span><span class="s2">`</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">resolveElements(elementOrSelector, scope, selectorCache) {</span>
        <span class="s1">if </span><span class="s0">(elementOrSelector </span><span class="s1">instanceof </span><span class="s0">EventTarget) {</span>
            <span class="s1">return </span><span class="s0">[elementOrSelector];</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">elementOrSelector === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">let </span><span class="s0">root = document;</span>
            <span class="s1">if </span><span class="s0">(scope) {</span>
                <span class="s0">root = scope.current;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">elements = selectorCache?.[elementOrSelector] ??</span>
                <span class="s0">root.querySelectorAll(elementOrSelector);</span>
            <span class="s1">return </span><span class="s0">elements ? Array.from(elements) : [];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">Array.from(elementOrSelector);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createSelectorEffect(subjectEffect) {</span>
        <span class="s1">return </span><span class="s0">(subject, values) =&gt; {</span>
            <span class="s1">const </span><span class="s0">elements = resolveElements(subject);</span>
            <span class="s1">const </span><span class="s0">subscriptions = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">element of elements) {</span>
                <span class="s1">const </span><span class="s0">remove = subjectEffect(element, values);</span>
                <span class="s0">subscriptions.push(remove);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">remove of subscriptions)</span>
                    <span class="s0">remove();</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Provided a value and a ValueType, returns the value as that value type.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">getValueAsType = (value, type) =&gt; {</span>
        <span class="s1">return </span><span class="s0">type &amp;&amp; </span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot;</span>
            <span class="s0">? type.transform(value)</span>
            <span class="s0">: value;</span>
    <span class="s0">};</span>

    <span class="s1">class </span><span class="s0">MotionValueState {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.latest = {};</span>
            <span class="s1">this</span><span class="s0">.values = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">}</span>
        <span class="s0">set(name, value, render, computed, useDefaultValueType = </span><span class="s1">true</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">existingValue = </span><span class="s1">this</span><span class="s0">.values.get(name);</span>
            <span class="s1">if </span><span class="s0">(existingValue) {</span>
                <span class="s0">existingValue.onRemove();</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">onChange = () =&gt; {</span>
                <span class="s1">const </span><span class="s0">v = value.get();</span>
                <span class="s1">if </span><span class="s0">(useDefaultValueType) {</span>
                    <span class="s1">this</span><span class="s0">.latest[name] = getValueAsType(v, numberValueTypes[name]);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">this</span><span class="s0">.latest[name] = v;</span>
                <span class="s0">}</span>
                <span class="s0">render &amp;&amp; frame.render(render);</span>
            <span class="s0">};</span>
            <span class="s0">onChange();</span>
            <span class="s1">const </span><span class="s0">cancelOnChange = value.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, onChange);</span>
            <span class="s0">computed &amp;&amp; value.addDependent(computed);</span>
            <span class="s1">const </span><span class="s0">remove = () =&gt; {</span>
                <span class="s0">cancelOnChange();</span>
                <span class="s0">render &amp;&amp; cancelFrame(render);</span>
                <span class="s1">this</span><span class="s0">.values.delete(name);</span>
                <span class="s0">computed &amp;&amp; value.removeDependent(computed);</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.values.set(name, { value, onRemove: remove });</span>
            <span class="s1">return </span><span class="s0">remove;</span>
        <span class="s0">}</span>
        <span class="s0">get(name) {</span>
            <span class="s1">return this</span><span class="s0">.values.get(name)?.value;</span>
        <span class="s0">}</span>
        <span class="s0">destroy() {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">value of </span><span class="s1">this</span><span class="s0">.values.values()) {</span>
                <span class="s0">value.onRemove();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createEffect(addValue) {</span>
        <span class="s1">const </span><span class="s0">stateCache = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
        <span class="s1">const </span><span class="s0">subscriptions = [];</span>
        <span class="s1">return </span><span class="s0">(subject, values) =&gt; {</span>
            <span class="s1">const </span><span class="s0">state = stateCache.get(subject) ?? </span><span class="s1">new </span><span class="s0">MotionValueState();</span>
            <span class="s0">stateCache.set(subject, state);</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">values) {</span>
                <span class="s1">const </span><span class="s0">value = values[key];</span>
                <span class="s1">const </span><span class="s0">remove = addValue(subject, state, key, value);</span>
                <span class="s0">subscriptions.push(remove);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">cancel of subscriptions)</span>
                    <span class="s0">cancel();</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">canSetAsProperty(element, name) {</span>
        <span class="s1">if </span><span class="s0">(!(name </span><span class="s1">in </span><span class="s0">element))</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(element), name) ||</span>
            <span class="s0">Object.getOwnPropertyDescriptor(element, name);</span>
        <span class="s3">// Check if it has a setter</span>
        <span class="s1">return </span><span class="s0">descriptor &amp;&amp; </span><span class="s1">typeof </span><span class="s0">descriptor.set === </span><span class="s2">&quot;function&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">addAttrValue = (element, state, key, value) =&gt; {</span>
        <span class="s1">const </span><span class="s0">isProp = canSetAsProperty(element, key);</span>
        <span class="s1">const </span><span class="s0">name = isProp</span>
            <span class="s0">? key</span>
            <span class="s0">: key.startsWith(</span><span class="s2">&quot;data&quot;</span><span class="s0">) || key.startsWith(</span><span class="s2">&quot;aria&quot;</span><span class="s0">)</span>
                <span class="s0">? camelToDash$1(key)</span>
                <span class="s0">: key;</span>
        <span class="s3">/**</span>
         <span class="s3">* Set attribute directly via property if available</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">render = isProp</span>
            <span class="s0">? () =&gt; {</span>
                <span class="s0">element[name] = state.latest[key];</span>
            <span class="s0">}</span>
            <span class="s0">: () =&gt; {</span>
                <span class="s1">const </span><span class="s0">v = state.latest[key];</span>
                <span class="s1">if </span><span class="s0">(v === </span><span class="s1">null </span><span class="s0">|| v === undefined) {</span>
                    <span class="s0">element.removeAttribute(name);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">element.setAttribute(name, String(v));</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">state.set(key, value, render);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">attrEffect = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createSelectorEffect(</span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">createEffect(addAttrValue));</span>

    <span class="s1">const </span><span class="s0">propEffect = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createEffect((subject, state, key, value) =&gt; {</span>
        <span class="s1">return </span><span class="s0">state.set(key, value, () =&gt; {</span>
            <span class="s0">subject[key] = state.latest[key];</span>
        <span class="s0">}, undefined, </span><span class="s1">false</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s3">/**</span>
     <span class="s3">* Checks if an element is an HTML element in a way</span>
     <span class="s3">* that works across iframes</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isHTMLElement(element) {</span>
        <span class="s1">return </span><span class="s0">isObject(element) &amp;&amp; </span><span class="s2">&quot;offsetHeight&quot; </span><span class="s1">in </span><span class="s0">element;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Maximum time between the value of two frames, beyond which we</span>
     <span class="s3">* assume the velocity has since been 0.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">MAX_VELOCITY_DELTA = </span><span class="s5">30</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">isFloat = (value) =&gt; {</span>
        <span class="s1">return </span><span class="s0">!isNaN(parseFloat(value));</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">collectMotionValues = {</span>
        <span class="s0">current: undefined,</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* `MotionValue` is used to track the state and velocity of motion values.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">MotionValue {</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">init - The initiating value</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">config - Optional configuration options</span>
         <span class="s3">*</span>
         <span class="s3">* -  `transformer`: A function to transform incoming values with.</span>
         <span class="s3">*/</span>
        <span class="s0">constructor(init, options = {}) {</span>
            <span class="s3">/**</span>
             <span class="s3">* Tracks whether this value can output a velocity. Currently this is only true</span>
             <span class="s3">* if the value is numerical, but we might be able to widen the scope here and support</span>
             <span class="s3">* other value types.</span>
             <span class="s3">*</span>
             <span class="s3">* </span><span class="s4">@internal</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.canTrackVelocity = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* An object containing a SubscriptionManager for each active event.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.events = {};</span>
            <span class="s1">this</span><span class="s0">.updateAndNotify = (v) =&gt; {</span>
                <span class="s1">const </span><span class="s0">currentTime = time.now();</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're updating the value during another frame or eventloop</span>
                 <span class="s3">* than the previous frame, then the we set the previous frame value</span>
                 <span class="s3">* to current.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.updatedAt !== currentTime) {</span>
                    <span class="s1">this</span><span class="s0">.setPrevFrameValue();</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.prev = </span><span class="s1">this</span><span class="s0">.current;</span>
                <span class="s1">this</span><span class="s0">.setCurrent(v);</span>
                <span class="s3">// Update update subscribers</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.current !== </span><span class="s1">this</span><span class="s0">.prev) {</span>
                    <span class="s1">this</span><span class="s0">.events.change?.notify(</span><span class="s1">this</span><span class="s0">.current);</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.dependents) {</span>
                        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">dependent of </span><span class="s1">this</span><span class="s0">.dependents) {</span>
                            <span class="s0">dependent.dirty();</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.hasAnimated = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.setCurrent(init);</span>
            <span class="s1">this</span><span class="s0">.owner = options.owner;</span>
        <span class="s0">}</span>
        <span class="s0">setCurrent(current) {</span>
            <span class="s1">this</span><span class="s0">.current = current;</span>
            <span class="s1">this</span><span class="s0">.updatedAt = time.now();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.canTrackVelocity === </span><span class="s1">null </span><span class="s0">&amp;&amp; current !== undefined) {</span>
                <span class="s1">this</span><span class="s0">.canTrackVelocity = isFloat(</span><span class="s1">this</span><span class="s0">.current);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">setPrevFrameValue(prevFrameValue = </span><span class="s1">this</span><span class="s0">.current) {</span>
            <span class="s1">this</span><span class="s0">.prevFrameValue = prevFrameValue;</span>
            <span class="s1">this</span><span class="s0">.prevUpdatedAt = </span><span class="s1">this</span><span class="s0">.updatedAt;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Adds a function that will be notified when the `MotionValue` is updated.</span>
         <span class="s3">*</span>
         <span class="s3">* It returns a function that, when called, will cancel the subscription.</span>
         <span class="s3">*</span>
         <span class="s3">* When calling `onChange` inside a React component, it should be wrapped with the</span>
         <span class="s3">* `useEffect` hook. As it returns an unsubscribe function, this should be returned</span>
         <span class="s3">* from the `useEffect` function to ensure you don't add duplicate subscribers..</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* export const MyComponent = () =&gt; {</span>
         <span class="s3">*   const x = useMotionValue(0)</span>
         <span class="s3">*   const y = useMotionValue(0)</span>
         <span class="s3">*   const opacity = useMotionValue(1)</span>
         <span class="s3">*</span>
         <span class="s3">*   useEffect(() =&gt; {</span>
         <span class="s3">*     function updateOpacity() {</span>
         <span class="s3">*       const maxXY = Math.max(x.get(), y.get())</span>
         <span class="s3">*       const newOpacity = transform(maxXY, [0, 100], [1, 0])</span>
         <span class="s3">*       opacity.set(newOpacity)</span>
         <span class="s3">*     }</span>
         <span class="s3">*</span>
         <span class="s3">*     const unsubscribeX = x.on(&quot;change&quot;, updateOpacity)</span>
         <span class="s3">*     const unsubscribeY = y.on(&quot;change&quot;, updateOpacity)</span>
         <span class="s3">*</span>
         <span class="s3">*     return () =&gt; {</span>
         <span class="s3">*       unsubscribeX()</span>
         <span class="s3">*       unsubscribeY()</span>
         <span class="s3">*     }</span>
         <span class="s3">*   }, [])</span>
         <span class="s3">*</span>
         <span class="s3">*   return &lt;motion.div style={{ x }} /&gt;</span>
         <span class="s3">* }</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">subscriber - A function that receives the latest value.</span>
         <span class="s3">* </span><span class="s4">@returns </span><span class="s3">A function that, when called, will cancel this subscription.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@deprecated</span>
         <span class="s3">*/</span>
        <span class="s0">onChange(subscription) {</span>
            <span class="s0">{</span>
                <span class="s0">warnOnce(</span><span class="s1">false</span><span class="s0">, </span><span class="s2">`value.onChange(callback) is deprecated. Switch to value.on(&quot;change&quot;, callback).`</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, subscription);</span>
        <span class="s0">}</span>
        <span class="s0">on(eventName, callback) {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.events[eventName]) {</span>
                <span class="s1">this</span><span class="s0">.events[eventName] = </span><span class="s1">new </span><span class="s0">SubscriptionManager();</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">unsubscribe = </span><span class="s1">this</span><span class="s0">.events[eventName].add(callback);</span>
            <span class="s1">if </span><span class="s0">(eventName === </span><span class="s2">&quot;change&quot;</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">() =&gt; {</span>
                    <span class="s0">unsubscribe();</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If we have no more change listeners by the start</span>
                     <span class="s3">* of the next frame, stop active animations.</span>
                     <span class="s3">*/</span>
                    <span class="s0">frame.read(() =&gt; {</span>
                        <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.events.change.getSize()) {</span>
                            <span class="s1">this</span><span class="s0">.stop();</span>
                        <span class="s0">}</span>
                    <span class="s0">});</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">unsubscribe;</span>
        <span class="s0">}</span>
        <span class="s0">clearListeners() {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">eventManagers </span><span class="s1">in this</span><span class="s0">.events) {</span>
                <span class="s1">this</span><span class="s0">.events[eventManagers].clear();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Attaches a passive effect to the `MotionValue`.</span>
         <span class="s3">*/</span>
        <span class="s0">attach(passiveEffect, stopPassiveEffect) {</span>
            <span class="s1">this</span><span class="s0">.passiveEffect = passiveEffect;</span>
            <span class="s1">this</span><span class="s0">.stopPassiveEffect = stopPassiveEffect;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Sets the state of the `MotionValue`.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@remarks</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* const x = useMotionValue(0)</span>
         <span class="s3">* x.set(10)</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">latest - Latest value to set.</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">render - Whether to notify render subscribers. Defaults to `true`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">set(v) {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.passiveEffect) {</span>
                <span class="s1">this</span><span class="s0">.updateAndNotify(v);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.passiveEffect(v, </span><span class="s1">this</span><span class="s0">.updateAndNotify);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">setWithVelocity(prev, current, delta) {</span>
            <span class="s1">this</span><span class="s0">.set(current);</span>
            <span class="s1">this</span><span class="s0">.prev = undefined;</span>
            <span class="s1">this</span><span class="s0">.prevFrameValue = prev;</span>
            <span class="s1">this</span><span class="s0">.prevUpdatedAt = </span><span class="s1">this</span><span class="s0">.updatedAt - delta;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Set the state of the `MotionValue`, stopping any active animations,</span>
         <span class="s3">* effects, and resets velocity to `0`.</span>
         <span class="s3">*/</span>
        <span class="s0">jump(v, endAnimation = </span><span class="s1">true</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.updateAndNotify(v);</span>
            <span class="s1">this</span><span class="s0">.prev = v;</span>
            <span class="s1">this</span><span class="s0">.prevUpdatedAt = </span><span class="s1">this</span><span class="s0">.prevFrameValue = undefined;</span>
            <span class="s0">endAnimation &amp;&amp; </span><span class="s1">this</span><span class="s0">.stop();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.stopPassiveEffect)</span>
                <span class="s1">this</span><span class="s0">.stopPassiveEffect();</span>
        <span class="s0">}</span>
        <span class="s0">dirty() {</span>
            <span class="s1">this</span><span class="s0">.events.change?.notify(</span><span class="s1">this</span><span class="s0">.current);</span>
        <span class="s0">}</span>
        <span class="s0">addDependent(dependent) {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.dependents) {</span>
                <span class="s1">this</span><span class="s0">.dependents = </span><span class="s1">new </span><span class="s0">Set();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.dependents.add(dependent);</span>
        <span class="s0">}</span>
        <span class="s0">removeDependent(dependent) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.dependents) {</span>
                <span class="s1">this</span><span class="s0">.dependents.delete(dependent);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Returns the latest state of `MotionValue`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@returns </span><span class="s3">- The latest state of `MotionValue`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">get() {</span>
            <span class="s1">if </span><span class="s0">(collectMotionValues.current) {</span>
                <span class="s0">collectMotionValues.current.push(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">.current;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">getPrevious() {</span>
            <span class="s1">return this</span><span class="s0">.prev;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Returns the latest velocity of `MotionValue`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@returns </span><span class="s3">- The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">getVelocity() {</span>
            <span class="s1">const </span><span class="s0">currentTime = time.now();</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.canTrackVelocity ||</span>
                <span class="s1">this</span><span class="s0">.prevFrameValue === undefined ||</span>
                <span class="s0">currentTime - </span><span class="s1">this</span><span class="s0">.updatedAt &gt; MAX_VELOCITY_DELTA) {</span>
                <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">delta = Math.min(</span><span class="s1">this</span><span class="s0">.updatedAt - </span><span class="s1">this</span><span class="s0">.prevUpdatedAt, MAX_VELOCITY_DELTA);</span>
            <span class="s3">// Casts because of parseFloat's poor typing</span>
            <span class="s1">return </span><span class="s0">velocityPerSecond(parseFloat(</span><span class="s1">this</span><span class="s0">.current) -</span>
                <span class="s0">parseFloat(</span><span class="s1">this</span><span class="s0">.prevFrameValue), delta);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Registers a new animation to control this `MotionValue`. Only one</span>
         <span class="s3">* animation can drive a `MotionValue` at one time.</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* value.start()</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">animation - A function that starts the provided animation</span>
         <span class="s3">*/</span>
        <span class="s0">start(startAnimation) {</span>
            <span class="s1">this</span><span class="s0">.stop();</span>
            <span class="s1">return new </span><span class="s0">Promise((resolve) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.hasAnimated = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.animation = startAnimation(resolve);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.events.animationStart) {</span>
                    <span class="s1">this</span><span class="s0">.events.animationStart.notify();</span>
                <span class="s0">}</span>
            <span class="s0">}).then(() =&gt; {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.events.animationComplete) {</span>
                    <span class="s1">this</span><span class="s0">.events.animationComplete.notify();</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.clearAnimation();</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Stop the currently active animation.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">stop() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.animation) {</span>
                <span class="s1">this</span><span class="s0">.animation.stop();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.events.animationCancel) {</span>
                    <span class="s1">this</span><span class="s0">.events.animationCancel.notify();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.clearAnimation();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Returns `true` if this value is currently animating.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">isAnimating() {</span>
            <span class="s1">return </span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.animation;</span>
        <span class="s0">}</span>
        <span class="s0">clearAnimation() {</span>
            <span class="s1">delete this</span><span class="s0">.animation;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Destroy and clean up subscribers to this `MotionValue`.</span>
         <span class="s3">*</span>
         <span class="s3">* The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically</span>
         <span class="s3">* handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually</span>
         <span class="s3">* created a `MotionValue` via the `motionValue` function.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">destroy() {</span>
            <span class="s1">this</span><span class="s0">.dependents?.clear();</span>
            <span class="s1">this</span><span class="s0">.events.destroy?.notify();</span>
            <span class="s1">this</span><span class="s0">.clearListeners();</span>
            <span class="s1">this</span><span class="s0">.stop();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.stopPassiveEffect) {</span>
                <span class="s1">this</span><span class="s0">.stopPassiveEffect();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">motionValue(init, options) {</span>
        <span class="s1">return new </span><span class="s0">MotionValue(init, options);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">translateAlias$1 = {</span>
        <span class="s0">x: </span><span class="s2">&quot;translateX&quot;</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s2">&quot;translateY&quot;</span><span class="s0">,</span>
        <span class="s0">z: </span><span class="s2">&quot;translateZ&quot;</span><span class="s0">,</span>
        <span class="s0">transformPerspective: </span><span class="s2">&quot;perspective&quot;</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">buildTransform$1(state) {</span>
        <span class="s1">let </span><span class="s0">transform = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">transformIsDefault = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Loop over all possible transforms in order, adding the ones that</span>
         <span class="s3">* are present to the transform string.</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; transformPropOrder.length; i++) {</span>
            <span class="s1">const </span><span class="s0">key = transformPropOrder[i];</span>
            <span class="s1">const </span><span class="s0">value = state.latest[key];</span>
            <span class="s1">if </span><span class="s0">(value === undefined)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">let </span><span class="s0">valueIsDefault = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
                <span class="s0">valueIsDefault = value === (key.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">) ? </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">valueIsDefault = parseFloat(value) === </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!valueIsDefault) {</span>
                <span class="s0">transformIsDefault = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">transformName = translateAlias$1[key] || key;</span>
                <span class="s1">const </span><span class="s0">valueToRender = state.latest[key];</span>
                <span class="s0">transform += </span><span class="s2">`</span><span class="s0">${transformName}</span><span class="s2">(</span><span class="s0">${valueToRender}</span><span class="s2">) `</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">transformIsDefault ? </span><span class="s2">&quot;none&quot; </span><span class="s0">: transform.trim();</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">originProps = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;originX&quot;</span><span class="s0">, </span><span class="s2">&quot;originY&quot;</span><span class="s0">, </span><span class="s2">&quot;originZ&quot;</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">addStyleValue = (element, state, key, value) =&gt; {</span>
        <span class="s1">let </span><span class="s0">render = undefined;</span>
        <span class="s1">let </span><span class="s0">computed = undefined;</span>
        <span class="s1">if </span><span class="s0">(transformProps.has(key)) {</span>
            <span class="s1">if </span><span class="s0">(!state.get(</span><span class="s2">&quot;transform&quot;</span><span class="s0">)) {</span>
                <span class="s3">// If this is an HTML element, we need to set the transform-box to fill-box</span>
                <span class="s3">// to normalise the transform relative to the element's bounding box</span>
                <span class="s1">if </span><span class="s0">(!isHTMLElement(element) &amp;&amp; !state.get(</span><span class="s2">&quot;transformBox&quot;</span><span class="s0">)) {</span>
                    <span class="s0">addStyleValue(element, state, </span><span class="s2">&quot;transformBox&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">MotionValue(</span><span class="s2">&quot;fill-box&quot;</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s0">state.set(</span><span class="s2">&quot;transform&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">MotionValue(</span><span class="s2">&quot;none&quot;</span><span class="s0">), () =&gt; {</span>
                    <span class="s0">element.style.transform = buildTransform$1(state);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">computed = state.get(</span><span class="s2">&quot;transform&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(originProps.has(key)) {</span>
            <span class="s1">if </span><span class="s0">(!state.get(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">)) {</span>
                <span class="s0">state.set(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">MotionValue(</span><span class="s2">&quot;&quot;</span><span class="s0">), () =&gt; {</span>
                    <span class="s1">const </span><span class="s0">originX = state.latest.originX ?? </span><span class="s2">&quot;50%&quot;</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">originY = state.latest.originY ?? </span><span class="s2">&quot;50%&quot;</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">originZ = state.latest.originZ ?? </span><span class="s5">0</span><span class="s0">;</span>
                    <span class="s0">element.style.transformOrigin = </span><span class="s2">`</span><span class="s0">${originX} ${originY} ${originZ}</span><span class="s2">`</span><span class="s0">;</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">computed = state.get(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(isCSSVar(key)) {</span>
            <span class="s0">render = () =&gt; {</span>
                <span class="s0">element.style.setProperty(key, state.latest[key]);</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">render = () =&gt; {</span>
                <span class="s0">element.style[key] = state.latest[key];</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">state.set(key, value, render, computed);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">styleEffect = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createSelectorEffect(</span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">createEffect(addStyleValue));</span>

    <span class="s1">const </span><span class="s0">toPx = px.transform;</span>
    <span class="s1">function </span><span class="s0">addSVGPathValue(element, state, key, value) {</span>
        <span class="s0">frame.render(() =&gt; element.setAttribute(</span><span class="s2">&quot;pathLength&quot;</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s0">));</span>
        <span class="s1">if </span><span class="s0">(key === </span><span class="s2">&quot;pathOffset&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">state.set(key, value, () =&gt; element.setAttribute(</span><span class="s2">&quot;stroke-dashoffset&quot;</span><span class="s0">, toPx(-state.latest[key])));</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(!state.get(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">)) {</span>
                <span class="s0">state.set(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">MotionValue(</span><span class="s2">&quot;1 1&quot;</span><span class="s0">), () =&gt; {</span>
                    <span class="s1">const </span><span class="s0">{ pathLength = </span><span class="s5">1</span><span class="s0">, pathSpacing } = state.latest;</span>
                    <span class="s0">element.setAttribute(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">, </span><span class="s2">`</span><span class="s0">${toPx(pathLength)} ${toPx(pathSpacing ?? </span><span class="s5">1 </span><span class="s0">- Number(pathLength))}</span><span class="s2">`</span><span class="s0">);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">state.set(key, value, undefined, state.get(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">addSVGValue = (element, state, key, value) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(key.startsWith(</span><span class="s2">&quot;path&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">addSVGPathValue(element, state, key, value);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(key.startsWith(</span><span class="s2">&quot;attr&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">addAttrValue(element, state, convertAttrKey(key), value);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">handler = key </span><span class="s1">in </span><span class="s0">element.style ? addStyleValue : addAttrValue;</span>
        <span class="s1">return </span><span class="s0">handler(element, state, key, value);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">svgEffect = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createSelectorEffect(</span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">createEffect(addSVGValue));</span>
    <span class="s1">function </span><span class="s0">convertAttrKey(key) {</span>
        <span class="s1">return </span><span class="s0">key.replace(</span><span class="s6">/^attr([A-Z])/</span><span class="s0">, (_, firstChar) =&gt; firstChar.toLowerCase());</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">{ schedule: microtask, cancel: cancelMicrotask } = </span>
    <span class="s3">/* @__PURE__ */ </span><span class="s0">createRenderBatcher(queueMicrotask, </span><span class="s1">false</span><span class="s0">);</span>

    <span class="s1">const </span><span class="s0">isDragging = {</span>
        <span class="s0">x: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">isDragActive() {</span>
        <span class="s1">return </span><span class="s0">isDragging.x || isDragging.y;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">setDragLock(axis) {</span>
        <span class="s1">if </span><span class="s0">(axis === </span><span class="s2">&quot;x&quot; </span><span class="s0">|| axis === </span><span class="s2">&quot;y&quot;</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(isDragging[axis]) {</span>
                <span class="s1">return null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">isDragging[axis] = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">() =&gt; {</span>
                    <span class="s0">isDragging[axis] = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(isDragging.x || isDragging.y) {</span>
                <span class="s1">return null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">isDragging.x = isDragging.y = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">() =&gt; {</span>
                    <span class="s0">isDragging.x = isDragging.y = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">setupGesture(elementOrSelector, options) {</span>
        <span class="s1">const </span><span class="s0">elements = resolveElements(elementOrSelector);</span>
        <span class="s1">const </span><span class="s0">gestureAbortController = </span><span class="s1">new </span><span class="s0">AbortController();</span>
        <span class="s1">const </span><span class="s0">eventOptions = {</span>
            <span class="s0">passive: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">...options,</span>
            <span class="s0">signal: gestureAbortController.signal,</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">cancel = () =&gt; gestureAbortController.abort();</span>
        <span class="s1">return </span><span class="s0">[elements, eventOptions, cancel];</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isValidHover(event) {</span>
        <span class="s1">return </span><span class="s0">!(event.pointerType === </span><span class="s2">&quot;touch&quot; </span><span class="s0">|| isDragActive());</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Create a hover gesture. hover() is different to .addEventListener(&quot;pointerenter&quot;)</span>
     <span class="s3">* in that it has an easier syntax, filters out polyfilled touch events, interoperates</span>
     <span class="s3">* with drag gestures, and automatically removes the &quot;pointerennd&quot; event listener when the hover ends.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">hover(elementOrSelector, onHoverStart, options = {}) {</span>
        <span class="s1">const </span><span class="s0">[elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);</span>
        <span class="s1">const </span><span class="s0">onPointerEnter = (enterEvent) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!isValidHover(enterEvent))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ target } = enterEvent;</span>
            <span class="s1">const </span><span class="s0">onHoverEnd = onHoverStart(target, enterEvent);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">onHoverEnd !== </span><span class="s2">&quot;function&quot; </span><span class="s0">|| !target)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">onPointerLeave = (leaveEvent) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!isValidHover(leaveEvent))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">onHoverEnd(leaveEvent);</span>
                <span class="s0">target.removeEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s0">, onPointerLeave);</span>
            <span class="s0">};</span>
            <span class="s0">target.addEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s0">, onPointerLeave, eventOptions);</span>
        <span class="s0">};</span>
        <span class="s0">elements.forEach((element) =&gt; {</span>
            <span class="s0">element.addEventListener(</span><span class="s2">&quot;pointerenter&quot;</span><span class="s0">, onPointerEnter, eventOptions);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">cancel;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Recursively traverse up the tree to check whether the provided child node</span>
     <span class="s3">* is the parent or a descendant of it.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">parent - Element to find</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">child - Element to test against parent</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">isNodeOrChild = (parent, child) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(!child) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(parent === child) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">isNodeOrChild(parent, child.parentElement);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">isPrimaryPointer = (event) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(event.pointerType === </span><span class="s2">&quot;mouse&quot;</span><span class="s0">) {</span>
            <span class="s1">return typeof </span><span class="s0">event.button !== </span><span class="s2">&quot;number&quot; </span><span class="s0">|| event.button &lt;= </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s3">/**</span>
             <span class="s3">* isPrimary is true for all mice buttons, whereas every touch point</span>
             <span class="s3">* is regarded as its own input. So subsequent concurrent touch points</span>
             <span class="s3">* will be false.</span>
             <span class="s3">*</span>
             <span class="s3">* Specifically match against false here as incomplete versions of</span>
             <span class="s3">* PointerEvents in very old browser might have it set as undefined.</span>
             <span class="s3">*/</span>
            <span class="s1">return </span><span class="s0">event.isPrimary !== </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">focusableElements = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;BUTTON&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;INPUT&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;SELECT&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;TEXTAREA&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;A&quot;</span><span class="s0">,</span>
    <span class="s0">]);</span>
    <span class="s1">function </span><span class="s0">isElementKeyboardAccessible(element) {</span>
        <span class="s1">return </span><span class="s0">(focusableElements.has(element.tagName) ||</span>
            <span class="s0">element.tabIndex !== -</span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isPressing = </span><span class="s1">new </span><span class="s0">WeakSet();</span>

    <span class="s3">/**</span>
     <span class="s3">* Filter out events that are not &quot;Enter&quot; keys.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">filterEvents(callback) {</span>
        <span class="s1">return </span><span class="s0">(event) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(event.key !== </span><span class="s2">&quot;Enter&quot;</span><span class="s0">)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">callback(event);</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">firePointerEvent(target, type) {</span>
        <span class="s0">target.dispatchEvent(</span><span class="s1">new </span><span class="s0">PointerEvent(</span><span class="s2">&quot;pointer&quot; </span><span class="s0">+ type, { isPrimary: </span><span class="s1">true</span><span class="s0">, bubbles: </span><span class="s1">true </span><span class="s0">}));</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">enableKeyboardPress = (focusEvent, eventOptions) =&gt; {</span>
        <span class="s1">const </span><span class="s0">element = focusEvent.currentTarget;</span>
        <span class="s1">if </span><span class="s0">(!element)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">handleKeydown = filterEvents(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(isPressing.has(element))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">firePointerEvent(element, </span><span class="s2">&quot;down&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">handleKeyup = filterEvents(() =&gt; {</span>
                <span class="s0">firePointerEvent(element, </span><span class="s2">&quot;up&quot;</span><span class="s0">);</span>
            <span class="s0">});</span>
            <span class="s1">const </span><span class="s0">handleBlur = () =&gt; firePointerEvent(element, </span><span class="s2">&quot;cancel&quot;</span><span class="s0">);</span>
            <span class="s0">element.addEventListener(</span><span class="s2">&quot;keyup&quot;</span><span class="s0">, handleKeyup, eventOptions);</span>
            <span class="s0">element.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s0">, handleBlur, eventOptions);</span>
        <span class="s0">});</span>
        <span class="s0">element.addEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s0">, handleKeydown, eventOptions);</span>
        <span class="s3">/**</span>
         <span class="s3">* Add an event listener that fires on blur to remove the keydown events.</span>
         <span class="s3">*/</span>
        <span class="s0">element.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s0">, () =&gt; element.removeEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s0">, handleKeydown), eventOptions);</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Filter out events that are not primary pointer events, or are triggering</span>
     <span class="s3">* while a Motion gesture is active.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isValidPressEvent(event) {</span>
        <span class="s1">return </span><span class="s0">isPrimaryPointer(event) &amp;&amp; !isDragActive();</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Create a press gesture.</span>
     <span class="s3">*</span>
     <span class="s3">* Press is different to `&quot;pointerdown&quot;`, `&quot;pointerup&quot;` in that it</span>
     <span class="s3">* automatically filters out secondary pointer events like right</span>
     <span class="s3">* click and multitouch.</span>
     <span class="s3">*</span>
     <span class="s3">* It also adds accessibility support for keyboards, where</span>
     <span class="s3">* an element with a press gesture will receive focus and</span>
     <span class="s3">*  trigger on Enter `&quot;keydown&quot;` and `&quot;keyup&quot;` events.</span>
     <span class="s3">*</span>
     <span class="s3">* This is different to a browser's `&quot;click&quot;` event, which does</span>
     <span class="s3">* respond to keyboards but only for the `&quot;click&quot;` itself, rather</span>
     <span class="s3">* than the press start and end/cancel. The element also needs</span>
     <span class="s3">* to be focusable for this to work, whereas a press gesture will</span>
     <span class="s3">* make an element focusable by default.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">press(targetOrSelector, onPressStart, options = {}) {</span>
        <span class="s1">const </span><span class="s0">[targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);</span>
        <span class="s1">const </span><span class="s0">startPress = (startEvent) =&gt; {</span>
            <span class="s1">const </span><span class="s0">target = startEvent.currentTarget;</span>
            <span class="s1">if </span><span class="s0">(!isValidPressEvent(startEvent))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">isPressing.add(target);</span>
            <span class="s1">const </span><span class="s0">onPressEnd = onPressStart(target, startEvent);</span>
            <span class="s1">const </span><span class="s0">onPointerEnd = (endEvent, success) =&gt; {</span>
                <span class="s0">window.removeEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s0">, onPointerUp);</span>
                <span class="s0">window.removeEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">, onPointerCancel);</span>
                <span class="s1">if </span><span class="s0">(isPressing.has(target)) {</span>
                    <span class="s0">isPressing.delete(target);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(!isValidPressEvent(endEvent)) {</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">onPressEnd === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                    <span class="s0">onPressEnd(endEvent, { success });</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">onPointerUp = (upEvent) =&gt; {</span>
                <span class="s0">onPointerEnd(upEvent, target === window ||</span>
                    <span class="s0">target === document ||</span>
                    <span class="s0">options.useGlobalTarget ||</span>
                    <span class="s0">isNodeOrChild(target, upEvent.target));</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">onPointerCancel = (cancelEvent) =&gt; {</span>
                <span class="s0">onPointerEnd(cancelEvent, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">};</span>
            <span class="s0">window.addEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s0">, onPointerUp, eventOptions);</span>
            <span class="s0">window.addEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">, onPointerCancel, eventOptions);</span>
        <span class="s0">};</span>
        <span class="s0">targets.forEach((target) =&gt; {</span>
            <span class="s1">const </span><span class="s0">pointerDownTarget = options.useGlobalTarget ? window : target;</span>
            <span class="s0">pointerDownTarget.addEventListener(</span><span class="s2">&quot;pointerdown&quot;</span><span class="s0">, startPress, eventOptions);</span>
            <span class="s1">if </span><span class="s0">(isHTMLElement(target)) {</span>
                <span class="s0">target.addEventListener(</span><span class="s2">&quot;focus&quot;</span><span class="s0">, (event) =&gt; enableKeyboardPress(event, eventOptions));</span>
                <span class="s1">if </span><span class="s0">(!isElementKeyboardAccessible(target) &amp;&amp;</span>
                    <span class="s0">!target.hasAttribute(</span><span class="s2">&quot;tabindex&quot;</span><span class="s0">)) {</span>
                    <span class="s0">target.tabIndex = </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">cancelEvents;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getComputedStyle$2(element, name) {</span>
        <span class="s1">const </span><span class="s0">computedStyle = window.getComputedStyle(element);</span>
        <span class="s1">return </span><span class="s0">isCSSVar(name)</span>
            <span class="s0">? computedStyle.getPropertyValue(name)</span>
            <span class="s0">: computedStyle[name];</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Checks if an element is an SVG element in a way</span>
     <span class="s3">* that works across iframes</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isSVGElement(element) {</span>
        <span class="s1">return </span><span class="s0">isObject(element) &amp;&amp; </span><span class="s2">&quot;ownerSVGElement&quot; </span><span class="s1">in </span><span class="s0">element;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">resizeHandlers = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">let </span><span class="s0">observer;</span>
    <span class="s1">const </span><span class="s0">getSize = (borderBoxAxis, svgAxis, htmlAxis) =&gt; (target, borderBoxSize) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(borderBoxSize &amp;&amp; borderBoxSize[</span><span class="s5">0</span><span class="s0">]) {</span>
            <span class="s1">return </span><span class="s0">borderBoxSize[</span><span class="s5">0</span><span class="s0">][(borderBoxAxis + </span><span class="s2">&quot;Size&quot;</span><span class="s0">)];</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(isSVGElement(target) &amp;&amp; </span><span class="s2">&quot;getBBox&quot; </span><span class="s1">in </span><span class="s0">target) {</span>
            <span class="s1">return </span><span class="s0">target.getBBox()[svgAxis];</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">target[htmlAxis];</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">getWidth = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">getSize(</span><span class="s2">&quot;inline&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s0">, </span><span class="s2">&quot;offsetWidth&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">getHeight = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">getSize(</span><span class="s2">&quot;block&quot;</span><span class="s0">, </span><span class="s2">&quot;height&quot;</span><span class="s0">, </span><span class="s2">&quot;offsetHeight&quot;</span><span class="s0">);</span>
    <span class="s1">function </span><span class="s0">notifyTarget({ target, borderBoxSize }) {</span>
        <span class="s0">resizeHandlers.get(target)?.forEach((handler) =&gt; {</span>
            <span class="s0">handler(target, {</span>
                <span class="s0">get width() {</span>
                    <span class="s1">return </span><span class="s0">getWidth(target, borderBoxSize);</span>
                <span class="s0">},</span>
                <span class="s0">get height() {</span>
                    <span class="s1">return </span><span class="s0">getHeight(target, borderBoxSize);</span>
                <span class="s0">},</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">notifyAll(entries) {</span>
        <span class="s0">entries.forEach(notifyTarget);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createResizeObserver() {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">ResizeObserver === </span><span class="s2">&quot;undefined&quot;</span><span class="s0">)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">observer = </span><span class="s1">new </span><span class="s0">ResizeObserver(notifyAll);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resizeElement(target, handler) {</span>
        <span class="s1">if </span><span class="s0">(!observer)</span>
            <span class="s0">createResizeObserver();</span>
        <span class="s1">const </span><span class="s0">elements = resolveElements(target);</span>
        <span class="s0">elements.forEach((element) =&gt; {</span>
            <span class="s1">let </span><span class="s0">elementHandlers = resizeHandlers.get(element);</span>
            <span class="s1">if </span><span class="s0">(!elementHandlers) {</span>
                <span class="s0">elementHandlers = </span><span class="s1">new </span><span class="s0">Set();</span>
                <span class="s0">resizeHandlers.set(element, elementHandlers);</span>
            <span class="s0">}</span>
            <span class="s0">elementHandlers.add(handler);</span>
            <span class="s0">observer?.observe(element);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">() =&gt; {</span>
            <span class="s0">elements.forEach((element) =&gt; {</span>
                <span class="s1">const </span><span class="s0">elementHandlers = resizeHandlers.get(element);</span>
                <span class="s0">elementHandlers?.delete(handler);</span>
                <span class="s1">if </span><span class="s0">(!elementHandlers?.size) {</span>
                    <span class="s0">observer?.unobserve(element);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">windowCallbacks = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">let </span><span class="s0">windowResizeHandler;</span>
    <span class="s1">function </span><span class="s0">createWindowResizeHandler() {</span>
        <span class="s0">windowResizeHandler = () =&gt; {</span>
            <span class="s1">const </span><span class="s0">info = {</span>
                <span class="s0">get width() {</span>
                    <span class="s1">return </span><span class="s0">window.innerWidth;</span>
                <span class="s0">},</span>
                <span class="s0">get height() {</span>
                    <span class="s1">return </span><span class="s0">window.innerHeight;</span>
                <span class="s0">},</span>
            <span class="s0">};</span>
            <span class="s0">windowCallbacks.forEach((callback) =&gt; callback(info));</span>
        <span class="s0">};</span>
        <span class="s0">window.addEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">, windowResizeHandler);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resizeWindow(callback) {</span>
        <span class="s0">windowCallbacks.add(callback);</span>
        <span class="s1">if </span><span class="s0">(!windowResizeHandler)</span>
            <span class="s0">createWindowResizeHandler();</span>
        <span class="s1">return </span><span class="s0">() =&gt; {</span>
            <span class="s0">windowCallbacks.delete(callback);</span>
            <span class="s1">if </span><span class="s0">(!windowCallbacks.size &amp;&amp;</span>
                <span class="s1">typeof </span><span class="s0">windowResizeHandler === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                <span class="s0">window.removeEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">, windowResizeHandler);</span>
                <span class="s0">windowResizeHandler = undefined;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">resize(a, b) {</span>
        <span class="s1">return typeof </span><span class="s0">a === </span><span class="s2">&quot;function&quot; </span><span class="s0">? resizeWindow(a) : resizeElement(a, b);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">observeTimeline(update, timeline) {</span>
        <span class="s1">let </span><span class="s0">prevProgress;</span>
        <span class="s1">const </span><span class="s0">onFrame = () =&gt; {</span>
            <span class="s1">const </span><span class="s0">{ currentTime } = timeline;</span>
            <span class="s1">const </span><span class="s0">percentage = currentTime === </span><span class="s1">null </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: currentTime.value;</span>
            <span class="s1">const </span><span class="s0">progress = percentage / </span><span class="s5">100</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(prevProgress !== progress) {</span>
                <span class="s0">update(progress);</span>
            <span class="s0">}</span>
            <span class="s0">prevProgress = progress;</span>
        <span class="s0">};</span>
        <span class="s0">frame.preUpdate(onFrame, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">() =&gt; cancelFrame(onFrame);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">record() {</span>
        <span class="s1">const </span><span class="s0">{ value } = statsBuffer;</span>
        <span class="s1">if </span><span class="s0">(value === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">cancelFrame(record);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">value.frameloop.rate.push(frameData.delta);</span>
        <span class="s0">value.animations.mainThread.push(activeAnimations.mainThread);</span>
        <span class="s0">value.animations.waapi.push(activeAnimations.waapi);</span>
        <span class="s0">value.animations.layout.push(activeAnimations.layout);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mean(values) {</span>
        <span class="s1">return </span><span class="s0">values.reduce((acc, value) =&gt; acc + value, </span><span class="s5">0</span><span class="s0">) / values.length;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">summarise(values, calcAverage = mean) {</span>
        <span class="s1">if </span><span class="s0">(values.length === </span><span class="s5">0</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">min: </span><span class="s5">0</span><span class="s0">,</span>
                <span class="s0">max: </span><span class="s5">0</span><span class="s0">,</span>
                <span class="s0">avg: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">min: Math.min(...values),</span>
            <span class="s0">max: Math.max(...values),</span>
            <span class="s0">avg: calcAverage(values),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">msToFps = (ms) =&gt; Math.round(</span><span class="s5">1000 </span><span class="s0">/ ms);</span>
    <span class="s1">function </span><span class="s0">clearStatsBuffer() {</span>
        <span class="s0">statsBuffer.value = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">statsBuffer.addProjectionMetrics = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">reportStats() {</span>
        <span class="s1">const </span><span class="s0">{ value } = statsBuffer;</span>
        <span class="s1">if </span><span class="s0">(!value) {</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Stats are not being measured&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">clearStatsBuffer();</span>
        <span class="s0">cancelFrame(record);</span>
        <span class="s1">const </span><span class="s0">summary = {</span>
            <span class="s0">frameloop: {</span>
                <span class="s0">setup: summarise(value.frameloop.setup),</span>
                <span class="s0">rate: summarise(value.frameloop.rate),</span>
                <span class="s0">read: summarise(value.frameloop.read),</span>
                <span class="s0">resolveKeyframes: summarise(value.frameloop.resolveKeyframes),</span>
                <span class="s0">preUpdate: summarise(value.frameloop.preUpdate),</span>
                <span class="s0">update: summarise(value.frameloop.update),</span>
                <span class="s0">preRender: summarise(value.frameloop.preRender),</span>
                <span class="s0">render: summarise(value.frameloop.render),</span>
                <span class="s0">postRender: summarise(value.frameloop.postRender),</span>
            <span class="s0">},</span>
            <span class="s0">animations: {</span>
                <span class="s0">mainThread: summarise(value.animations.mainThread),</span>
                <span class="s0">waapi: summarise(value.animations.waapi),</span>
                <span class="s0">layout: summarise(value.animations.layout),</span>
            <span class="s0">},</span>
            <span class="s0">layoutProjection: {</span>
                <span class="s0">nodes: summarise(value.layoutProjection.nodes),</span>
                <span class="s0">calculatedTargetDeltas: summarise(value.layoutProjection.calculatedTargetDeltas),</span>
                <span class="s0">calculatedProjections: summarise(value.layoutProjection.calculatedProjections),</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* Convert the rate to FPS</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">{ rate } = summary.frameloop;</span>
        <span class="s0">rate.min = msToFps(rate.min);</span>
        <span class="s0">rate.max = msToFps(rate.max);</span>
        <span class="s0">rate.avg = msToFps(rate.avg);</span>
        <span class="s0">[rate.min, rate.max] = [rate.max, rate.min];</span>
        <span class="s1">return </span><span class="s0">summary;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">recordStats() {</span>
        <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
            <span class="s0">clearStatsBuffer();</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Stats are already being measured&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">newStatsBuffer = statsBuffer;</span>
        <span class="s0">newStatsBuffer.value = {</span>
            <span class="s0">frameloop: {</span>
                <span class="s0">setup: [],</span>
                <span class="s0">rate: [],</span>
                <span class="s0">read: [],</span>
                <span class="s0">resolveKeyframes: [],</span>
                <span class="s0">preUpdate: [],</span>
                <span class="s0">update: [],</span>
                <span class="s0">preRender: [],</span>
                <span class="s0">render: [],</span>
                <span class="s0">postRender: [],</span>
            <span class="s0">},</span>
            <span class="s0">animations: {</span>
                <span class="s0">mainThread: [],</span>
                <span class="s0">waapi: [],</span>
                <span class="s0">layout: [],</span>
            <span class="s0">},</span>
            <span class="s0">layoutProjection: {</span>
                <span class="s0">nodes: [],</span>
                <span class="s0">calculatedTargetDeltas: [],</span>
                <span class="s0">calculatedProjections: [],</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s0">newStatsBuffer.addProjectionMetrics = (metrics) =&gt; {</span>
            <span class="s1">const </span><span class="s0">{ layoutProjection } = newStatsBuffer.value;</span>
            <span class="s0">layoutProjection.nodes.push(metrics.nodes);</span>
            <span class="s0">layoutProjection.calculatedTargetDeltas.push(metrics.calculatedTargetDeltas);</span>
            <span class="s0">layoutProjection.calculatedProjections.push(metrics.calculatedProjections);</span>
        <span class="s0">};</span>
        <span class="s0">frame.postRender(record, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">reportStats;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Checks if an element is specifically an SVGSVGElement (the root SVG element)</span>
     <span class="s3">* in a way that works across iframes</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isSVGSVGElement(element) {</span>
        <span class="s1">return </span><span class="s0">isSVGElement(element) &amp;&amp; element.tagName === </span><span class="s2">&quot;svg&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getOriginIndex(from, total) {</span>
        <span class="s1">if </span><span class="s0">(from === </span><span class="s2">&quot;first&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">lastIndex = total - </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">from === </span><span class="s2">&quot;last&quot; </span><span class="s0">? lastIndex : lastIndex / </span><span class="s5">2</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">stagger(duration = </span><span class="s5">0.1</span><span class="s0">, { startDelay = </span><span class="s5">0</span><span class="s0">, from = </span><span class="s5">0</span><span class="s0">, ease } = {}) {</span>
        <span class="s1">return </span><span class="s0">(i, total) =&gt; {</span>
            <span class="s1">const </span><span class="s0">fromIndex = </span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;number&quot; </span><span class="s0">? from : getOriginIndex(from, total);</span>
            <span class="s1">const </span><span class="s0">distance = Math.abs(fromIndex - i);</span>
            <span class="s1">let </span><span class="s0">delay = duration * distance;</span>
            <span class="s1">if </span><span class="s0">(ease) {</span>
                <span class="s1">const </span><span class="s0">maxDelay = total * duration;</span>
                <span class="s1">const </span><span class="s0">easingFunction = easingDefinitionToFunction(ease);</span>
                <span class="s0">delay = easingFunction(delay / maxDelay) * maxDelay;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">startDelay + delay;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">transform(...args) {</span>
        <span class="s1">const </span><span class="s0">useImmediate = !Array.isArray(args[</span><span class="s5">0</span><span class="s0">]);</span>
        <span class="s1">const </span><span class="s0">argOffset = useImmediate ? </span><span class="s5">0 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">inputValue = args[</span><span class="s5">0 </span><span class="s0">+ argOffset];</span>
        <span class="s1">const </span><span class="s0">inputRange = args[</span><span class="s5">1 </span><span class="s0">+ argOffset];</span>
        <span class="s1">const </span><span class="s0">outputRange = args[</span><span class="s5">2 </span><span class="s0">+ argOffset];</span>
        <span class="s1">const </span><span class="s0">options = args[</span><span class="s5">3 </span><span class="s0">+ argOffset];</span>
        <span class="s1">const </span><span class="s0">interpolator = interpolate(inputRange, outputRange, options);</span>
        <span class="s1">return </span><span class="s0">useImmediate ? interpolator(inputValue) : interpolator;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">subscribeValue(inputValues, outputValue, getLatest) {</span>
        <span class="s1">const </span><span class="s0">update = () =&gt; outputValue.set(getLatest());</span>
        <span class="s1">const </span><span class="s0">scheduleUpdate = () =&gt; frame.preRender(update, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">subscriptions = inputValues.map((v) =&gt; v.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, scheduleUpdate));</span>
        <span class="s0">outputValue.on(</span><span class="s2">&quot;destroy&quot;</span><span class="s0">, () =&gt; {</span>
            <span class="s0">subscriptions.forEach((unsubscribe) =&gt; unsubscribe());</span>
            <span class="s0">cancelFrame(update);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a `MotionValue` that transforms the output of other `MotionValue`s by</span>
     <span class="s3">* passing their latest values through a transform function.</span>
     <span class="s3">*</span>
     <span class="s3">* Whenever a `MotionValue` referred to in the provided function is updated,</span>
     <span class="s3">* it will be re-evaluated.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const x = motionValue(0)</span>
     <span class="s3">* const y = transformValue(() =&gt; x.get() * 2) // double x</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">transformer - A transform function. This function must be pure with no side-effects or conditional statements.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">`MotionValue`</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">transformValue(transform) {</span>
        <span class="s1">const </span><span class="s0">collectedValues = [];</span>
        <span class="s3">/**</span>
         <span class="s3">* Open session of collectMotionValues. Any MotionValue that calls get()</span>
         <span class="s3">* inside transform will be saved into this array.</span>
         <span class="s3">*/</span>
        <span class="s0">collectMotionValues.current = collectedValues;</span>
        <span class="s1">const </span><span class="s0">initialValue = transform();</span>
        <span class="s0">collectMotionValues.current = undefined;</span>
        <span class="s1">const </span><span class="s0">value = motionValue(initialValue);</span>
        <span class="s0">subscribeValue(collectedValues, value, transform);</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a `MotionValue` that maps the output of another `MotionValue` by</span>
     <span class="s3">* mapping it from one range of values into another.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@remarks</span>
     <span class="s3">*</span>
     <span class="s3">* Given an input range of `[-200, -100, 100, 200]` and an output range of</span>
     <span class="s3">* `[0, 1, 1, 0]`, the returned `MotionValue` will:</span>
     <span class="s3">*</span>
     <span class="s3">* - When provided a value between `-200` and `-100`, will return a value between `0` and  `1`.</span>
     <span class="s3">* - When provided a value between `-100` and `100`, will return `1`.</span>
     <span class="s3">* - When provided a value between `100` and `200`, will return a value between `1` and  `0`</span>
     <span class="s3">*</span>
     <span class="s3">* The input range must be a linear series of numbers. The output range</span>
     <span class="s3">* can be any value type supported by Motion: numbers, colors, shadows, etc.</span>
     <span class="s3">*</span>
     <span class="s3">* Every value in the output range must be of the same type and in the same format.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const x = motionValue(0)</span>
     <span class="s3">* const xRange = [-200, -100, 100, 200]</span>
     <span class="s3">* const opacityRange = [0, 1, 1, 0]</span>
     <span class="s3">* const opacity = mapValue(x, xRange, opacityRange)</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">inputValue - `MotionValue`</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">inputRange - A linear series of numbers (either all increasing or decreasing)</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">outputRange - A series of numbers, colors or strings. Must be the same length as `inputRange`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options -</span>
     <span class="s3">*</span>
     <span class="s3">*  - clamp: boolean. Clamp values to within the given range. Defaults to `true`</span>
     <span class="s3">*  - ease: EasingFunction[]. Easing functions to use on the interpolations between each value in the input and output ranges. If provided as an array, the array must be one item shorter than the input and output ranges, as the easings apply to the transition between each.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">`MotionValue`</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">mapValue(inputValue, inputRange, outputRange, options) {</span>
        <span class="s1">const </span><span class="s0">map = transform(inputRange, outputRange, options);</span>
        <span class="s1">return </span><span class="s0">transformValue(() =&gt; map(inputValue.get()));</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isMotionValue = (value) =&gt; Boolean(value &amp;&amp; value.getVelocity);</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a `MotionValue` that animates to its latest value using a spring.</span>
     <span class="s3">* Can either be a value or track another `MotionValue`.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const x = motionValue(0)</span>
     <span class="s3">* const y = transformValue(() =&gt; x.get() * 2) // double x</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">transformer - A transform function. This function must be pure with no side-effects or conditional statements.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">`MotionValue`</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">springValue(source, options) {</span>
        <span class="s1">const </span><span class="s0">initialValue = isMotionValue(source) ? source.get() : source;</span>
        <span class="s1">const </span><span class="s0">value = motionValue(initialValue);</span>
        <span class="s0">attachSpring(value, source, options);</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">attachSpring(value, source, options) {</span>
        <span class="s1">const </span><span class="s0">initialValue = value.get();</span>
        <span class="s1">let </span><span class="s0">activeAnimation = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">latestValue = initialValue;</span>
        <span class="s1">let </span><span class="s0">latestSetter;</span>
        <span class="s1">const </span><span class="s0">unit = </span><span class="s1">typeof </span><span class="s0">initialValue === </span><span class="s2">&quot;string&quot;</span>
            <span class="s0">? initialValue.replace(</span><span class="s6">/[\d.-]/g</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">)</span>
            <span class="s0">: undefined;</span>
        <span class="s1">const </span><span class="s0">stopAnimation = () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(activeAnimation) {</span>
                <span class="s0">activeAnimation.stop();</span>
                <span class="s0">activeAnimation = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">startAnimation = () =&gt; {</span>
            <span class="s0">stopAnimation();</span>
            <span class="s0">activeAnimation = </span><span class="s1">new </span><span class="s0">JSAnimation({</span>
                <span class="s0">keyframes: [asNumber$1(value.get()), asNumber$1(latestValue)],</span>
                <span class="s0">velocity: value.getVelocity(),</span>
                <span class="s0">type: </span><span class="s2">&quot;spring&quot;</span><span class="s0">,</span>
                <span class="s0">restDelta: </span><span class="s5">0.001</span><span class="s0">,</span>
                <span class="s0">restSpeed: </span><span class="s5">0.01</span><span class="s0">,</span>
                <span class="s0">...options,</span>
                <span class="s0">onUpdate: latestSetter,</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s0">value.attach((v, set) =&gt; {</span>
            <span class="s0">latestValue = v;</span>
            <span class="s0">latestSetter = (latest) =&gt; set(parseValue(latest, unit));</span>
            <span class="s0">frame.postRender(startAnimation);</span>
            <span class="s1">return </span><span class="s0">value.get();</span>
        <span class="s0">}, stopAnimation);</span>
        <span class="s1">if </span><span class="s0">(isMotionValue(source)) {</span>
            <span class="s1">const </span><span class="s0">removeSourceOnChange = source.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, (v) =&gt; value.set(parseValue(v, unit)));</span>
            <span class="s1">const </span><span class="s0">removeValueOnDestroy = value.on(</span><span class="s2">&quot;destroy&quot;</span><span class="s0">, removeSourceOnChange);</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">removeSourceOnChange();</span>
                <span class="s0">removeValueOnDestroy();</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">stopAnimation;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseValue(v, unit) {</span>
        <span class="s1">return </span><span class="s0">unit ? v + unit : v;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">asNumber$1(v) {</span>
        <span class="s1">return typeof </span><span class="s0">v === </span><span class="s2">&quot;number&quot; </span><span class="s0">? v : parseFloat(v);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of all ValueTypes</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">valueTypes = [...dimensionValueTypes, color, complex];</span>
    <span class="s3">/**</span>
     <span class="s3">* Tests a value against the list of ValueTypes</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">findValueType = (v) =&gt; valueTypes.find(testValueType(v));</span>

    <span class="s1">function </span><span class="s0">chooseLayerType(valueName) {</span>
        <span class="s1">if </span><span class="s0">(valueName === </span><span class="s2">&quot;layout&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s2">&quot;group&quot;</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(valueName === </span><span class="s2">&quot;enter&quot; </span><span class="s0">|| valueName === </span><span class="s2">&quot;new&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s2">&quot;new&quot;</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(valueName === </span><span class="s2">&quot;exit&quot; </span><span class="s0">|| valueName === </span><span class="s2">&quot;old&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s2">&quot;old&quot;</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s2">&quot;group&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">let </span><span class="s0">pendingRules = {};</span>
    <span class="s1">let </span><span class="s0">style = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">css = {</span>
        <span class="s0">set: (selector, values) =&gt; {</span>
            <span class="s0">pendingRules[selector] = values;</span>
        <span class="s0">},</span>
        <span class="s0">commit: () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!style) {</span>
                <span class="s0">style = document.createElement(</span><span class="s2">&quot;style&quot;</span><span class="s0">);</span>
                <span class="s0">style.id = </span><span class="s2">&quot;motion-view&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">cssText = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">selector </span><span class="s1">in </span><span class="s0">pendingRules) {</span>
                <span class="s1">const </span><span class="s0">rule = pendingRules[selector];</span>
                <span class="s0">cssText += </span><span class="s2">`</span><span class="s0">${selector} </span><span class="s2">{</span><span class="s7">\n</span><span class="s2">`</span><span class="s0">;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[property, value] of Object.entries(rule)) {</span>
                    <span class="s0">cssText += </span><span class="s2">`  </span><span class="s0">${property}</span><span class="s2">: </span><span class="s0">${value}</span><span class="s2">;</span><span class="s7">\n</span><span class="s2">`</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">cssText += </span><span class="s2">&quot;}</span><span class="s7">\n</span><span class="s2">&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">style.textContent = cssText;</span>
            <span class="s0">document.head.appendChild(style);</span>
            <span class="s0">pendingRules = {};</span>
        <span class="s0">},</span>
        <span class="s0">remove: () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(style &amp;&amp; style.parentElement) {</span>
                <span class="s0">style.parentElement.removeChild(style);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">getViewAnimationLayerInfo(pseudoElement) {</span>
        <span class="s1">const </span><span class="s0">match = pseudoElement.match(</span><span class="s6">/::view-transition-(old|new|group|image-pair)\((.*?)\)/</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(!match)</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">{ layer: match[</span><span class="s5">2</span><span class="s0">], type: match[</span><span class="s5">1</span><span class="s0">] };</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">filterViewAnimations(animation) {</span>
        <span class="s1">const </span><span class="s0">{ effect } = animation;</span>
        <span class="s1">if </span><span class="s0">(!effect)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">(effect.target === document.documentElement &amp;&amp;</span>
            <span class="s0">effect.pseudoElement?.startsWith(</span><span class="s2">&quot;::view-transition&quot;</span><span class="s0">));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getViewAnimations() {</span>
        <span class="s1">return </span><span class="s0">document.getAnimations().filter(filterViewAnimations);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">hasTarget(target, targets) {</span>
        <span class="s1">return </span><span class="s0">targets.has(target) &amp;&amp; Object.keys(targets.get(target)).length &gt; </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">definitionNames = [</span><span class="s2">&quot;layout&quot;</span><span class="s0">, </span><span class="s2">&quot;enter&quot;</span><span class="s0">, </span><span class="s2">&quot;exit&quot;</span><span class="s0">, </span><span class="s2">&quot;new&quot;</span><span class="s0">, </span><span class="s2">&quot;old&quot;</span><span class="s0">];</span>
    <span class="s1">function </span><span class="s0">startViewAnimation(builder) {</span>
        <span class="s1">const </span><span class="s0">{ update, targets, options: defaultOptions } = builder;</span>
        <span class="s1">if </span><span class="s0">(!document.startViewTransition) {</span>
            <span class="s1">return new </span><span class="s0">Promise(async (resolve) =&gt; {</span>
                <span class="s1">await </span><span class="s0">update();</span>
                <span class="s0">resolve(</span><span class="s1">new </span><span class="s0">GroupAnimation([]));</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">// TODO: Go over existing targets and ensure they all have ids</span>
        <span class="s3">/**</span>
         <span class="s3">* If we don't have any animations defined for the root target,</span>
         <span class="s3">* remove it from being captured.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!hasTarget(</span><span class="s2">&quot;root&quot;</span><span class="s0">, targets)) {</span>
            <span class="s0">css.set(</span><span class="s2">&quot;:root&quot;</span><span class="s0">, {</span>
                <span class="s2">&quot;view-transition-name&quot;</span><span class="s0">: </span><span class="s2">&quot;none&quot;</span><span class="s0">,</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Set the timing curve to linear for all view transition layers.</span>
         <span class="s3">* This gets baked into the keyframes, which can't be changed</span>
         <span class="s3">* without breaking the generated animation.</span>
         <span class="s3">*</span>
         <span class="s3">* This allows us to set easing via updateTiming - which can be changed.</span>
         <span class="s3">*/</span>
        <span class="s0">css.set(</span><span class="s2">&quot;::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)&quot;</span><span class="s0">, { </span><span class="s2">&quot;animation-timing-function&quot;</span><span class="s0">: </span><span class="s2">&quot;linear !important&quot; </span><span class="s0">});</span>
        <span class="s0">css.commit(); </span><span class="s3">// Write</span>
        <span class="s1">const </span><span class="s0">transition = document.startViewTransition(async () =&gt; {</span>
            <span class="s1">await </span><span class="s0">update();</span>
            <span class="s3">// TODO: Go over new targets and ensure they all have ids</span>
        <span class="s0">});</span>
        <span class="s0">transition.finished.finally(() =&gt; {</span>
            <span class="s0">css.remove(); </span><span class="s3">// Write</span>
        <span class="s0">});</span>
        <span class="s1">return new </span><span class="s0">Promise((resolve) =&gt; {</span>
            <span class="s0">transition.ready.then(() =&gt; {</span>
                <span class="s1">const </span><span class="s0">generatedViewAnimations = getViewAnimations();</span>
                <span class="s1">const </span><span class="s0">animations = [];</span>
                <span class="s3">/**</span>
                 <span class="s3">* Create animations for each of our explicitly-defined subjects.</span>
                 <span class="s3">*/</span>
                <span class="s0">targets.forEach((definition, target) =&gt; {</span>
                    <span class="s3">// TODO: If target is not &quot;root&quot;, resolve elements</span>
                    <span class="s3">// and iterate over each</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key of definitionNames) {</span>
                        <span class="s1">if </span><span class="s0">(!definition[key])</span>
                            <span class="s1">continue</span><span class="s0">;</span>
                        <span class="s1">const </span><span class="s0">{ keyframes, options } = definition[key];</span>
                        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">[valueName, valueKeyframes] of Object.entries(keyframes)) {</span>
                            <span class="s1">if </span><span class="s0">(!valueKeyframes)</span>
                                <span class="s1">continue</span><span class="s0">;</span>
                            <span class="s1">const </span><span class="s0">valueOptions = {</span>
                                <span class="s0">...getValueTransition$1(defaultOptions, valueName),</span>
                                <span class="s0">...getValueTransition$1(options, valueName),</span>
                            <span class="s0">};</span>
                            <span class="s1">const </span><span class="s0">type = chooseLayerType(key);</span>
                            <span class="s3">/**</span>
                             <span class="s3">* If this is an opacity animation, and keyframes are not an array,</span>
                             <span class="s3">* we need to convert them into an array and set an initial value.</span>
                             <span class="s3">*/</span>
                            <span class="s1">if </span><span class="s0">(valueName === </span><span class="s2">&quot;opacity&quot; </span><span class="s0">&amp;&amp;</span>
                                <span class="s0">!Array.isArray(valueKeyframes)) {</span>
                                <span class="s1">const </span><span class="s0">initialValue = type === </span><span class="s2">&quot;new&quot; </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: </span><span class="s5">1</span><span class="s0">;</span>
                                <span class="s0">valueKeyframes = [initialValue, valueKeyframes];</span>
                            <span class="s0">}</span>
                            <span class="s3">/**</span>
                             <span class="s3">* Resolve stagger function if provided.</span>
                             <span class="s3">*/</span>
                            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">valueOptions.delay === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                                <span class="s0">valueOptions.delay = valueOptions.delay(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
                            <span class="s0">}</span>
                            <span class="s0">valueOptions.duration &amp;&amp; (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));</span>
                            <span class="s0">valueOptions.delay &amp;&amp; (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));</span>
                            <span class="s1">const </span><span class="s0">animation = </span><span class="s1">new </span><span class="s0">NativeAnimation({</span>
                                <span class="s0">...valueOptions,</span>
                                <span class="s0">element: document.documentElement,</span>
                                <span class="s0">name: valueName,</span>
                                <span class="s0">pseudoElement: </span><span class="s2">`::view-transition-</span><span class="s0">${type}</span><span class="s2">(</span><span class="s0">${target}</span><span class="s2">)`</span><span class="s0">,</span>
                                <span class="s0">keyframes: valueKeyframes,</span>
                            <span class="s0">});</span>
                            <span class="s0">animations.push(animation);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s3">/**</span>
                 <span class="s3">* Handle browser generated animations</span>
                 <span class="s3">*/</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">animation of generatedViewAnimations) {</span>
                    <span class="s1">if </span><span class="s0">(animation.playState === </span><span class="s2">&quot;finished&quot;</span><span class="s0">)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">{ effect } = animation;</span>
                    <span class="s1">if </span><span class="s0">(!effect || !(effect </span><span class="s1">instanceof </span><span class="s0">KeyframeEffect))</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">{ pseudoElement } = effect;</span>
                    <span class="s1">if </span><span class="s0">(!pseudoElement)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">name = getViewAnimationLayerInfo(pseudoElement);</span>
                    <span class="s1">if </span><span class="s0">(!name)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">targetDefinition = targets.get(name.layer);</span>
                    <span class="s1">if </span><span class="s0">(!targetDefinition) {</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If transition name is group then update the timing of the animation</span>
                         <span class="s3">* whereas if it's old or new then we could possibly replace it using</span>
                         <span class="s3">* the above method.</span>
                         <span class="s3">*/</span>
                        <span class="s1">const </span><span class="s0">transitionName = name.type === </span><span class="s2">&quot;group&quot; </span><span class="s0">? </span><span class="s2">&quot;layout&quot; </span><span class="s0">: </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                        <span class="s1">let </span><span class="s0">animationTransition = {</span>
                            <span class="s0">...getValueTransition$1(defaultOptions, transitionName),</span>
                        <span class="s0">};</span>
                        <span class="s0">animationTransition.duration &amp;&amp; (animationTransition.duration = secondsToMilliseconds(animationTransition.duration));</span>
                        <span class="s0">animationTransition =</span>
                            <span class="s0">applyGeneratorOptions(animationTransition);</span>
                        <span class="s1">const </span><span class="s0">easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);</span>
                        <span class="s0">effect.updateTiming({</span>
                            <span class="s0">delay: secondsToMilliseconds(animationTransition.delay ?? </span><span class="s5">0</span><span class="s0">),</span>
                            <span class="s0">duration: animationTransition.duration,</span>
                            <span class="s0">easing,</span>
                        <span class="s0">});</span>
                        <span class="s0">animations.push(</span><span class="s1">new </span><span class="s0">NativeAnimationWrapper(animation));</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(hasOpacity(targetDefinition, </span><span class="s2">&quot;enter&quot;</span><span class="s0">) &amp;&amp;</span>
                        <span class="s0">hasOpacity(targetDefinition, </span><span class="s2">&quot;exit&quot;</span><span class="s0">) &amp;&amp;</span>
                        <span class="s0">effect</span>
                            <span class="s0">.getKeyframes()</span>
                            <span class="s0">.some((keyframe) =&gt; keyframe.mixBlendMode)) {</span>
                        <span class="s0">animations.push(</span><span class="s1">new </span><span class="s0">NativeAnimationWrapper(animation));</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">animation.cancel();</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s0">resolve(</span><span class="s1">new </span><span class="s0">GroupAnimation(animations));</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hasOpacity(target, key) {</span>
        <span class="s1">return </span><span class="s0">target?.[key]?.keyframes.opacity;</span>
    <span class="s0">}</span>

    <span class="s1">let </span><span class="s0">builders = [];</span>
    <span class="s1">let </span><span class="s0">current = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">next() {</span>
        <span class="s0">current = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">[nextBuilder] = builders;</span>
        <span class="s1">if </span><span class="s0">(nextBuilder)</span>
            <span class="s0">start(nextBuilder);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">start(builder) {</span>
        <span class="s0">removeItem(builders, builder);</span>
        <span class="s0">current = builder;</span>
        <span class="s0">startViewAnimation(builder).then((animation) =&gt; {</span>
            <span class="s0">builder.notifyReady(animation);</span>
            <span class="s0">animation.finished.finally(next);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">processQueue() {</span>
        <span class="s3">/**</span>
         <span class="s3">* Iterate backwards over the builders array. We can ignore the</span>
         <span class="s3">* &quot;wait&quot; animations. If we have an interrupting animation in the</span>
         <span class="s3">* queue then we need to batch all preceeding animations into it.</span>
         <span class="s3">* Currently this only batches the update functions but will also</span>
         <span class="s3">* need to batch the targets.</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = builders.length - </span><span class="s5">1</span><span class="s0">; i &gt;= </span><span class="s5">0</span><span class="s0">; i--) {</span>
            <span class="s1">const </span><span class="s0">builder = builders[i];</span>
            <span class="s1">const </span><span class="s0">{ interrupt } = builder.options;</span>
            <span class="s1">if </span><span class="s0">(interrupt === </span><span class="s2">&quot;immediate&quot;</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">batchedUpdates = builders.slice(</span><span class="s5">0</span><span class="s0">, i + </span><span class="s5">1</span><span class="s0">).map((b) =&gt; b.update);</span>
                <span class="s1">const </span><span class="s0">remaining = builders.slice(i + </span><span class="s5">1</span><span class="s0">);</span>
                <span class="s0">builder.update = () =&gt; {</span>
                    <span class="s0">batchedUpdates.forEach((update) =&gt; update());</span>
                <span class="s0">};</span>
                <span class="s3">// Put the current builder at the front, followed by any &quot;wait&quot; builders</span>
                <span class="s0">builders = [builder, ...remaining];</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!current || builders[</span><span class="s5">0</span><span class="s0">]?.options.interrupt === </span><span class="s2">&quot;immediate&quot;</span><span class="s0">) {</span>
            <span class="s0">next();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">addToQueue(builder) {</span>
        <span class="s0">builders.push(builder);</span>
        <span class="s0">microtask.render(processQueue);</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">ViewTransitionBuilder {</span>
        <span class="s0">constructor(update, options = {}) {</span>
            <span class="s1">this</span><span class="s0">.currentSubject = </span><span class="s2">&quot;root&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.targets = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s1">this</span><span class="s0">.notifyReady = noop;</span>
            <span class="s1">this</span><span class="s0">.readyPromise = </span><span class="s1">new </span><span class="s0">Promise((resolve) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.notifyReady = resolve;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.update = update;</span>
            <span class="s1">this</span><span class="s0">.options = {</span>
                <span class="s0">interrupt: </span><span class="s2">&quot;wait&quot;</span><span class="s0">,</span>
                <span class="s0">...options,</span>
            <span class="s0">};</span>
            <span class="s0">addToQueue(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get(subject) {</span>
            <span class="s1">this</span><span class="s0">.currentSubject = subject;</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">layout(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;layout&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">new</span><span class="s0">(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;new&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">old(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;old&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">enter(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;enter&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">exit(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;exit&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">crossfade(options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;enter&quot;</span><span class="s0">, { opacity: </span><span class="s5">1 </span><span class="s0">}, options);</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;exit&quot;</span><span class="s0">, { opacity: </span><span class="s5">0 </span><span class="s0">}, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">updateTarget(target, keyframes, options = {}) {</span>
            <span class="s1">const </span><span class="s0">{ currentSubject, targets } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!targets.has(currentSubject)) {</span>
                <span class="s0">targets.set(currentSubject, {});</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">targetData = targets.get(currentSubject);</span>
            <span class="s0">targetData[target] = { keyframes, options };</span>
        <span class="s0">}</span>
        <span class="s0">then(resolve, reject) {</span>
            <span class="s1">return this</span><span class="s0">.readyPromise.then(resolve, reject);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">animateView(update, defaultOptions = {}) {</span>
        <span class="s1">return new </span><span class="s0">ViewTransitionBuilder(update, defaultOptions);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@deprecated</span>
     <span class="s3">*</span>
     <span class="s3">* Import as `frame` instead.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">sync = frame;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@deprecated</span>
     <span class="s3">*</span>
     <span class="s3">* Use cancelFrame(callback) instead.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">cancelSync = stepsOrder.reduce((acc, key) =&gt; {</span>
        <span class="s0">acc[key] = (process) =&gt; cancelFrame(process);</span>
        <span class="s1">return </span><span class="s0">acc;</span>
    <span class="s0">}, {});</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">MotionConfigContext = React$1.createContext({</span>
        <span class="s0">transformPagePoint: (p) =&gt; p,</span>
        <span class="s0">isStatic: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">reducedMotion: </span><span class="s2">&quot;never&quot;</span><span class="s0">,</span>
    <span class="s0">});</span>

    <span class="s3">/**</span>
     <span class="s3">* Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx</span>
     <span class="s3">*/</span>
    <span class="s3">/**</span>
     <span class="s3">* Set a given ref to a given value</span>
     <span class="s3">* This utility takes care of different types of refs: callback refs and RefObject(s)</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">setRef(ref, value) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">ref === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">ref(value);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(ref !== </span><span class="s1">null </span><span class="s0">&amp;&amp; ref !== undefined) {</span>
            <span class="s0">ref.current = value;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* A utility to compose multiple refs together</span>
     <span class="s3">* Accepts callback refs and RefObject(s)</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">composeRefs(...refs) {</span>
        <span class="s1">return </span><span class="s0">(node) =&gt; {</span>
            <span class="s1">let </span><span class="s0">hasCleanup = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">cleanups = refs.map((ref) =&gt; {</span>
                <span class="s1">const </span><span class="s0">cleanup = setRef(ref, node);</span>
                <span class="s1">if </span><span class="s0">(!hasCleanup &amp;&amp; </span><span class="s1">typeof </span><span class="s0">cleanup === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                    <span class="s0">hasCleanup = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">cleanup;</span>
            <span class="s0">});</span>
            <span class="s3">// React &lt;19 will log an error to the console if a callback ref returns a</span>
            <span class="s3">// value. We don't use ref cleanups internally so this will only happen if a</span>
            <span class="s3">// user's ref callback returns a value, which we only expect if they are</span>
            <span class="s3">// using the cleanup functionality added in React 19.</span>
            <span class="s1">if </span><span class="s0">(hasCleanup) {</span>
                <span class="s1">return </span><span class="s0">() =&gt; {</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; cleanups.length; i++) {</span>
                        <span class="s1">const </span><span class="s0">cleanup = cleanups[i];</span>
                        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">cleanup === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                            <span class="s0">cleanup();</span>
                        <span class="s0">}</span>
                        <span class="s1">else </span><span class="s0">{</span>
                            <span class="s0">setRef(refs[i], </span><span class="s1">null</span><span class="s0">);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* A custom hook that composes multiple refs</span>
     <span class="s3">* Accepts callback refs and RefObject(s)</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useComposedRefs(...refs) {</span>
        <span class="s3">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
        <span class="s1">return </span><span class="s0">React__namespace.useCallback(composeRefs(...refs), refs);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Measurement functionality has to be within a separate component</span>
     <span class="s3">* to leverage snapshot lifecycle.</span>
     <span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">PopChildMeasure </span><span class="s1">extends </span><span class="s0">React__namespace.Component {</span>
        <span class="s0">getSnapshotBeforeUpdate(prevProps) {</span>
            <span class="s1">const </span><span class="s0">element = </span><span class="s1">this</span><span class="s0">.props.childRef.current;</span>
            <span class="s1">if </span><span class="s0">(element &amp;&amp; prevProps.isPresent &amp;&amp; !</span><span class="s1">this</span><span class="s0">.props.isPresent) {</span>
                <span class="s1">const </span><span class="s0">parent = element.offsetParent;</span>
                <span class="s1">const </span><span class="s0">parentWidth = isHTMLElement(parent)</span>
                    <span class="s0">? parent.offsetWidth || </span><span class="s5">0</span>
                    <span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">size = </span><span class="s1">this</span><span class="s0">.props.sizeRef.current;</span>
                <span class="s0">size.height = element.offsetHeight || </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s0">size.width = element.offsetWidth || </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s0">size.top = element.offsetTop;</span>
                <span class="s0">size.left = element.offsetLeft;</span>
                <span class="s0">size.right = parentWidth - size.width - size.left;</span>
            <span class="s0">}</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Required with getSnapshotBeforeUpdate to stop React complaining.</span>
         <span class="s3">*/</span>
        <span class="s0">componentDidUpdate() { }</span>
        <span class="s0">render() {</span>
            <span class="s1">return this</span><span class="s0">.props.children;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">PopChild({ children, isPresent, anchorX, root }) {</span>
        <span class="s1">const </span><span class="s0">id = React$1.useId();</span>
        <span class="s1">const </span><span class="s0">ref = React$1.useRef(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">size = React$1.useRef({</span>
            <span class="s0">width: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s0">height: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s0">top: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s0">left: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s0">right: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">});</span>
        <span class="s1">const </span><span class="s0">{ nonce } = React$1.useContext(MotionConfigContext);</span>
        <span class="s1">const </span><span class="s0">composedRef = useComposedRefs(ref, children?.ref);</span>
        <span class="s3">/**</span>
         <span class="s3">* We create and inject a style block so we can apply this explicit</span>
         <span class="s3">* sizing in a non-destructive manner by just deleting the style block.</span>
         <span class="s3">*</span>
         <span class="s3">* We can't apply size via render as the measurement happens</span>
         <span class="s3">* in getSnapshotBeforeUpdate (post-render), likewise if we apply the</span>
         <span class="s3">* styles directly on the DOM node, we might be overwriting</span>
         <span class="s3">* styles set via the style prop.</span>
         <span class="s3">*/</span>
        <span class="s0">React$1.useInsertionEffect(() =&gt; {</span>
            <span class="s1">const </span><span class="s0">{ width, height, top, left, right } = size.current;</span>
            <span class="s1">if </span><span class="s0">(isPresent || !ref.current || !width || !height)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">x = anchorX === </span><span class="s2">&quot;left&quot; </span><span class="s0">? </span><span class="s2">`left: </span><span class="s0">${left}</span><span class="s2">` </span><span class="s0">: </span><span class="s2">`right: </span><span class="s0">${right}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s0">ref.current.dataset.motionPopId = id;</span>
            <span class="s1">const </span><span class="s0">style = document.createElement(</span><span class="s2">&quot;style&quot;</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(nonce)</span>
                <span class="s0">style.nonce = nonce;</span>
            <span class="s1">const </span><span class="s0">parent = root ?? document.head;</span>
            <span class="s0">parent.appendChild(style);</span>
            <span class="s1">if </span><span class="s0">(style.sheet) {</span>
                <span class="s0">style.sheet.insertRule(</span><span class="s2">`</span>
          <span class="s2">[data-motion-pop-id=&quot;</span><span class="s0">${id}</span><span class="s2">&quot;] { 
            position: absolute !important; 
            width: </span><span class="s0">${width}</span><span class="s2">px !important; 
            height: </span><span class="s0">${height}</span><span class="s2">px !important; 
            </span><span class="s0">${x}</span><span class="s2">px !important; 
            top: </span><span class="s0">${top}</span><span class="s2">px !important; 
          } 
        `</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s1">if </span><span class="s0">(parent.contains(style)) {</span>
                    <span class="s0">parent.removeChild(style);</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
        <span class="s0">}, [isPresent]);</span>
        <span class="s1">return </span><span class="s0">(jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React__namespace.cloneElement(children, { ref: composedRef }) }));</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) =&gt; {</span>
        <span class="s1">const </span><span class="s0">presenceChildren = useConstant(newChildrenMap);</span>
        <span class="s1">const </span><span class="s0">id = React$1.useId();</span>
        <span class="s1">let </span><span class="s0">isReusedContext = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">context = React$1.useMemo(() =&gt; {</span>
            <span class="s0">isReusedContext = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">id,</span>
                <span class="s0">initial,</span>
                <span class="s0">isPresent,</span>
                <span class="s0">custom,</span>
                <span class="s0">onExitComplete: (childId) =&gt; {</span>
                    <span class="s0">presenceChildren.set(childId, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">isComplete of presenceChildren.values()) {</span>
                        <span class="s1">if </span><span class="s0">(!isComplete)</span>
                            <span class="s1">return</span><span class="s0">; </span><span class="s3">// can stop searching when any is incomplete</span>
                    <span class="s0">}</span>
                    <span class="s0">onExitComplete &amp;&amp; onExitComplete();</span>
                <span class="s0">},</span>
                <span class="s0">register: (childId) =&gt; {</span>
                    <span class="s0">presenceChildren.set(childId, </span><span class="s1">false</span><span class="s0">);</span>
                    <span class="s1">return </span><span class="s0">() =&gt; presenceChildren.delete(childId);</span>
                <span class="s0">},</span>
            <span class="s0">};</span>
        <span class="s0">}, [isPresent, presenceChildren, onExitComplete]);</span>
        <span class="s3">/**</span>
         <span class="s3">* If the presence of a child affects the layout of the components around it,</span>
         <span class="s3">* we want to make a new context value to ensure they get re-rendered</span>
         <span class="s3">* so they can detect that layout change.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(presenceAffectsLayout &amp;&amp; isReusedContext) {</span>
            <span class="s0">context = { ...context };</span>
        <span class="s0">}</span>
        <span class="s0">React$1.useMemo(() =&gt; {</span>
            <span class="s0">presenceChildren.forEach((_, key) =&gt; presenceChildren.set(key, </span><span class="s1">false</span><span class="s0">));</span>
        <span class="s0">}, [isPresent]);</span>
        <span class="s3">/**</span>
         <span class="s3">* If there's no `motion` components to fire exit animations, we want to remove this</span>
         <span class="s3">* component immediately.</span>
         <span class="s3">*/</span>
        <span class="s0">React__namespace.useEffect(() =&gt; {</span>
            <span class="s0">!isPresent &amp;&amp;</span>
                <span class="s0">!presenceChildren.size &amp;&amp;</span>
                <span class="s0">onExitComplete &amp;&amp;</span>
                <span class="s0">onExitComplete();</span>
        <span class="s0">}, [isPresent]);</span>
        <span class="s1">if </span><span class="s0">(mode === </span><span class="s2">&quot;popLayout&quot;</span><span class="s0">) {</span>
            <span class="s0">children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, root: root, children: children }));</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">(jsx(PresenceContext.Provider, { value: context, children: children }));</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">newChildrenMap() {</span>
        <span class="s1">return new </span><span class="s0">Map();</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* When a component is the child of `AnimatePresence`, it can use `usePresence`</span>
     <span class="s3">* to access information about whether it's still present in the React tree.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* import { usePresence } from &quot;framer-motion&quot;</span>
     <span class="s3">*</span>
     <span class="s3">* export const Component = () =&gt; {</span>
     <span class="s3">*   const [isPresent, safeToRemove] = usePresence()</span>
     <span class="s3">*</span>
     <span class="s3">*   useEffect(() =&gt; {</span>
     <span class="s3">*     !isPresent &amp;&amp; setTimeout(safeToRemove, 1000)</span>
     <span class="s3">*   }, [isPresent])</span>
     <span class="s3">*</span>
     <span class="s3">*   return &lt;div /&gt;</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* If `isPresent` is `false`, it means that a component has been removed the tree, but</span>
     <span class="s3">* `AnimatePresence` won't really remove it until `safeToRemove` has been called.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">usePresence(subscribe = </span><span class="s1">true</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">context = React$1.useContext(PresenceContext);</span>
        <span class="s1">if </span><span class="s0">(context === </span><span class="s1">null</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">[</span><span class="s1">true</span><span class="s0">, </span><span class="s1">null</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">{ isPresent, onExitComplete, register } = context;</span>
        <span class="s3">// It's safe to call the following hooks conditionally (after an early return) because the context will always</span>
        <span class="s3">// either be null or non-null for the lifespan of the component.</span>
        <span class="s1">const </span><span class="s0">id = React$1.useId();</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(subscribe) {</span>
                <span class="s1">return </span><span class="s0">register(id);</span>
            <span class="s0">}</span>
        <span class="s0">}, [subscribe]);</span>
        <span class="s1">const </span><span class="s0">safeToRemove = React$1.useCallback(() =&gt; subscribe &amp;&amp; onExitComplete &amp;&amp; onExitComplete(id), [id, onExitComplete, subscribe]);</span>
        <span class="s1">return </span><span class="s0">!isPresent &amp;&amp; onExitComplete ? [</span><span class="s1">false</span><span class="s0">, safeToRemove] : [</span><span class="s1">true</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.</span>
     <span class="s3">* There is no `safeToRemove` function.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* import { useIsPresent } from &quot;framer-motion&quot;</span>
     <span class="s3">*</span>
     <span class="s3">* export const Component = () =&gt; {</span>
     <span class="s3">*   const isPresent = useIsPresent()</span>
     <span class="s3">*</span>
     <span class="s3">*   useEffect(() =&gt; {</span>
     <span class="s3">*     !isPresent &amp;&amp; console.log(&quot;I've been removed!&quot;)</span>
     <span class="s3">*   }, [isPresent])</span>
     <span class="s3">*</span>
     <span class="s3">*   return &lt;div /&gt;</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useIsPresent() {</span>
        <span class="s1">return </span><span class="s0">isPresent(React$1.useContext(PresenceContext));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isPresent(context) {</span>
        <span class="s1">return </span><span class="s0">context === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">true </span><span class="s0">: context.isPresent;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">getChildKey = (child) =&gt; child.key || </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">onlyElements(children) {</span>
        <span class="s1">const </span><span class="s0">filtered = [];</span>
        <span class="s3">// We use forEach here instead of map as map mutates the component key by preprending `.$`</span>
        <span class="s0">React$1.Children.forEach(children, (child) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(React$1.isValidElement(child))</span>
                <span class="s0">filtered.push(child);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">filtered;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* `AnimatePresence` enables the animation of components that have been removed from the tree.</span>
     <span class="s3">*</span>
     <span class="s3">* When adding/removing more than a single child, every child **must** be given a unique `key` prop.</span>
     <span class="s3">*</span>
     <span class="s3">* Any `motion` components that have an `exit` property defined will animate out when removed from</span>
     <span class="s3">* the tree.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* import { motion, AnimatePresence } from 'framer-motion'</span>
     <span class="s3">*</span>
     <span class="s3">* export const Items = ({ items }) =&gt; (</span>
     <span class="s3">*   &lt;AnimatePresence&gt;</span>
     <span class="s3">*     {items.map(item =&gt; (</span>
     <span class="s3">*       &lt;motion.div</span>
     <span class="s3">*         key={item.id}</span>
     <span class="s3">*         initial={{ opacity: 0 }}</span>
     <span class="s3">*         animate={{ opacity: 1 }}</span>
     <span class="s3">*         exit={{ opacity: 0 }}</span>
     <span class="s3">*       /&gt;</span>
     <span class="s3">*     ))}</span>
     <span class="s3">*   &lt;/AnimatePresence&gt;</span>
     <span class="s3">* )</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* You can sequence exit animations throughout a tree using variants.</span>
     <span class="s3">*</span>
     <span class="s3">* If a child contains multiple `motion` components with `exit` props, it will only unmount the child</span>
     <span class="s3">* once all `motion` components have finished animating out. Likewise, any components using</span>
     <span class="s3">* `usePresence` all need to call `safeToRemove`.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">AnimatePresence = ({ children, custom, initial = </span><span class="s1">true</span><span class="s0">, onExitComplete, presenceAffectsLayout = </span><span class="s1">true</span><span class="s0">, mode = </span><span class="s2">&quot;sync&quot;</span><span class="s0">, propagate = </span><span class="s1">false</span><span class="s0">, anchorX = </span><span class="s2">&quot;left&quot;</span><span class="s0">, root }) =&gt; {</span>
        <span class="s1">const </span><span class="s0">[isParentPresent, safeToRemove] = usePresence(propagate);</span>
        <span class="s3">/**</span>
         <span class="s3">* Filter any children that aren't ReactElements. We can only track components</span>
         <span class="s3">* between renders with a props.key.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">presentChildren = React$1.useMemo(() =&gt; onlyElements(children), [children]);</span>
        <span class="s3">/**</span>
         <span class="s3">* Track the keys of the currently rendered children. This is used to</span>
         <span class="s3">* determine which children are exiting.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">presentKeys = propagate &amp;&amp; !isParentPresent ? [] : presentChildren.map(getChildKey);</span>
        <span class="s3">/**</span>
         <span class="s3">* If `initial={false}` we only want to pass this to components in the first render.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">isInitialRender = React$1.useRef(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s3">/**</span>
         <span class="s3">* A ref containing the currently present children. When all exit animations</span>
         <span class="s3">* are complete, we use this to re-render the component with the latest children</span>
         <span class="s3">* *committed* rather than the latest children *rendered*.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">pendingPresentChildren = React$1.useRef(presentChildren);</span>
        <span class="s3">/**</span>
         <span class="s3">* Track which exiting children have finished animating out.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">exitComplete = useConstant(() =&gt; </span><span class="s1">new </span><span class="s0">Map());</span>
        <span class="s3">/**</span>
         <span class="s3">* Save children to render as React state. To ensure this component is concurrent-safe,</span>
         <span class="s3">* we check for exiting children via an effect.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">[diffedChildren, setDiffedChildren] = React$1.useState(presentChildren);</span>
        <span class="s1">const </span><span class="s0">[renderedChildren, setRenderedChildren] = React$1.useState(presentChildren);</span>
        <span class="s0">useIsomorphicLayoutEffect(() =&gt; {</span>
            <span class="s0">isInitialRender.current = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">pendingPresentChildren.current = presentChildren;</span>
            <span class="s3">/**</span>
             <span class="s3">* Update complete status of exiting children.</span>
             <span class="s3">*/</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; renderedChildren.length; i++) {</span>
                <span class="s1">const </span><span class="s0">key = getChildKey(renderedChildren[i]);</span>
                <span class="s1">if </span><span class="s0">(!presentKeys.includes(key)) {</span>
                    <span class="s1">if </span><span class="s0">(exitComplete.get(key) !== </span><span class="s1">true</span><span class="s0">) {</span>
                        <span class="s0">exitComplete.set(key, </span><span class="s1">false</span><span class="s0">);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">exitComplete.delete(key);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}, [renderedChildren, presentKeys.length, presentKeys.join(</span><span class="s2">&quot;-&quot;</span><span class="s0">)]);</span>
        <span class="s1">const </span><span class="s0">exitingChildren = [];</span>
        <span class="s1">if </span><span class="s0">(presentChildren !== diffedChildren) {</span>
            <span class="s1">let </span><span class="s0">nextChildren = [...presentChildren];</span>
            <span class="s3">/**</span>
             <span class="s3">* Loop through all the currently rendered components and decide which</span>
             <span class="s3">* are exiting.</span>
             <span class="s3">*/</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; renderedChildren.length; i++) {</span>
                <span class="s1">const </span><span class="s0">child = renderedChildren[i];</span>
                <span class="s1">const </span><span class="s0">key = getChildKey(child);</span>
                <span class="s1">if </span><span class="s0">(!presentKeys.includes(key)) {</span>
                    <span class="s0">nextChildren.splice(i, </span><span class="s5">0</span><span class="s0">, child);</span>
                    <span class="s0">exitingChildren.push(child);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're in &quot;wait&quot; mode, and we have exiting children, we want to</span>
             <span class="s3">* only render these until they've all exited.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(mode === </span><span class="s2">&quot;wait&quot; </span><span class="s0">&amp;&amp; exitingChildren.length) {</span>
                <span class="s0">nextChildren = exitingChildren;</span>
            <span class="s0">}</span>
            <span class="s0">setRenderedChildren(onlyElements(nextChildren));</span>
            <span class="s0">setDiffedChildren(presentChildren);</span>
            <span class="s3">/**</span>
             <span class="s3">* Early return to ensure once we've set state with the latest diffed</span>
             <span class="s3">* children, we can immediately re-render.</span>
             <span class="s3">*/</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(mode === </span><span class="s2">&quot;wait&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">renderedChildren.length &gt; </span><span class="s5">1</span><span class="s0">) {</span>
            <span class="s0">console.warn(</span><span class="s2">`You're attempting to animate multiple children within AnimatePresence, but its mode is set to &quot;wait&quot;. This will lead to odd visual behaviour.`</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If we've been provided a forceRender function by the LayoutGroupContext,</span>
         <span class="s3">* we can use it to force a re-render amongst all surrounding components once</span>
         <span class="s3">* all components have finished animating out.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">{ forceRender } = React$1.useContext(LayoutGroupContext);</span>
        <span class="s1">return </span><span class="s0">(jsx(Fragment, { children: renderedChildren.map((child) =&gt; {</span>
                <span class="s1">const </span><span class="s0">key = getChildKey(child);</span>
                <span class="s1">const </span><span class="s0">isPresent = propagate &amp;&amp; !isParentPresent</span>
                    <span class="s0">? </span><span class="s1">false</span>
                    <span class="s0">: presentChildren === renderedChildren ||</span>
                        <span class="s0">presentKeys.includes(key);</span>
                <span class="s1">const </span><span class="s0">onExit = () =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(exitComplete.has(key)) {</span>
                        <span class="s0">exitComplete.set(key, </span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">return</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">let </span><span class="s0">isEveryExitComplete = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">exitComplete.forEach((isExitComplete) =&gt; {</span>
                        <span class="s1">if </span><span class="s0">(!isExitComplete)</span>
                            <span class="s0">isEveryExitComplete = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">});</span>
                    <span class="s1">if </span><span class="s0">(isEveryExitComplete) {</span>
                        <span class="s0">forceRender?.();</span>
                        <span class="s0">setRenderedChildren(pendingPresentChildren.current);</span>
                        <span class="s0">propagate &amp;&amp; safeToRemove?.();</span>
                        <span class="s0">onExitComplete &amp;&amp; onExitComplete();</span>
                    <span class="s0">}</span>
                <span class="s0">};</span>
                <span class="s1">return </span><span class="s0">(jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial</span>
                        <span class="s0">? undefined</span>
                        <span class="s0">: </span><span class="s1">false</span><span class="s0">, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, root: root, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));</span>
            <span class="s0">}) }));</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Note: Still used by components generated by old versions of Framer</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">DeprecatedLayoutGroupContext = React$1.createContext(</span><span class="s1">null</span><span class="s0">);</span>

    <span class="s1">const </span><span class="s0">SCALE_PRECISION = </span><span class="s5">0.0001</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">SCALE_MIN = </span><span class="s5">1 </span><span class="s0">- SCALE_PRECISION;</span>
    <span class="s1">const </span><span class="s0">SCALE_MAX = </span><span class="s5">1 </span><span class="s0">+ SCALE_PRECISION;</span>
    <span class="s1">const </span><span class="s0">TRANSLATE_PRECISION = </span><span class="s5">0.01</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">TRANSLATE_MIN = </span><span class="s5">0 </span><span class="s0">- TRANSLATE_PRECISION;</span>
    <span class="s1">const </span><span class="s0">TRANSLATE_MAX = </span><span class="s5">0 </span><span class="s0">+ TRANSLATE_PRECISION;</span>
    <span class="s1">function </span><span class="s0">calcLength(axis) {</span>
        <span class="s1">return </span><span class="s0">axis.max - axis.min;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isNear(value, target, maxDistance) {</span>
        <span class="s1">return </span><span class="s0">Math.abs(value - target) &lt;= maxDistance;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcAxisDelta(delta, source, target, origin = </span><span class="s5">0.5</span><span class="s0">) {</span>
        <span class="s0">delta.origin = origin;</span>
        <span class="s0">delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);</span>
        <span class="s0">delta.scale = calcLength(target) / calcLength(source);</span>
        <span class="s0">delta.translate =</span>
            <span class="s0">mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;</span>
        <span class="s1">if </span><span class="s0">((delta.scale &gt;= SCALE_MIN &amp;&amp; delta.scale &lt;= SCALE_MAX) ||</span>
            <span class="s0">isNaN(delta.scale)) {</span>
            <span class="s0">delta.scale = </span><span class="s5">1.0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">((delta.translate &gt;= TRANSLATE_MIN &amp;&amp;</span>
            <span class="s0">delta.translate &lt;= TRANSLATE_MAX) ||</span>
            <span class="s0">isNaN(delta.translate)) {</span>
            <span class="s0">delta.translate = </span><span class="s5">0.0</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcBoxDelta(delta, source, target, origin) {</span>
        <span class="s0">calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);</span>
        <span class="s0">calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcRelativeAxis(target, relative, parent) {</span>
        <span class="s0">target.min = parent.min + relative.min;</span>
        <span class="s0">target.max = target.min + calcLength(relative);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcRelativeBox(target, relative, parent) {</span>
        <span class="s0">calcRelativeAxis(target.x, relative.x, parent.x);</span>
        <span class="s0">calcRelativeAxis(target.y, relative.y, parent.y);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcRelativeAxisPosition(target, layout, parent) {</span>
        <span class="s0">target.min = layout.min - parent.min;</span>
        <span class="s0">target.max = target.min + calcLength(layout);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcRelativePosition(target, layout, parent) {</span>
        <span class="s0">calcRelativeAxisPosition(target.x, layout.x, parent.x);</span>
        <span class="s0">calcRelativeAxisPosition(target.y, layout.y, parent.y);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">notify = (node) =&gt; !node.isLayoutDirty &amp;&amp; node.willUpdate(</span><span class="s1">false</span><span class="s0">);</span>
    <span class="s1">function </span><span class="s0">nodeGroup() {</span>
        <span class="s1">const </span><span class="s0">nodes = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s1">const </span><span class="s0">subscriptions = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
        <span class="s1">const </span><span class="s0">dirtyAll = () =&gt; nodes.forEach(notify);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">add: (node) =&gt; {</span>
                <span class="s0">nodes.add(node);</span>
                <span class="s0">subscriptions.set(node, node.addEventListener(</span><span class="s2">&quot;willUpdate&quot;</span><span class="s0">, dirtyAll));</span>
            <span class="s0">},</span>
            <span class="s0">remove: (node) =&gt; {</span>
                <span class="s0">nodes.delete(node);</span>
                <span class="s1">const </span><span class="s0">unsubscribe = subscriptions.get(node);</span>
                <span class="s1">if </span><span class="s0">(unsubscribe) {</span>
                    <span class="s0">unsubscribe();</span>
                    <span class="s0">subscriptions.delete(node);</span>
                <span class="s0">}</span>
                <span class="s0">dirtyAll();</span>
            <span class="s0">},</span>
            <span class="s0">dirty: dirtyAll,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isNotNull = (value) =&gt; value !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">getFinalKeyframe(keyframes, { repeat, repeatType = </span><span class="s2">&quot;loop&quot; </span><span class="s0">}, finalKeyframe) {</span>
        <span class="s1">const </span><span class="s0">resolvedKeyframes = keyframes.filter(isNotNull);</span>
        <span class="s1">const </span><span class="s0">index = repeat &amp;&amp; repeatType !== </span><span class="s2">&quot;loop&quot; </span><span class="s0">&amp;&amp; repeat % </span><span class="s5">2 </span><span class="s0">=== </span><span class="s5">1</span>
            <span class="s0">? </span><span class="s5">0</span>
            <span class="s0">: resolvedKeyframes.length - </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!index || finalKeyframe === undefined</span>
            <span class="s0">? resolvedKeyframes[index]</span>
            <span class="s0">: finalKeyframe;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">underDampedSpring = {</span>
        <span class="s0">type: </span><span class="s2">&quot;spring&quot;</span><span class="s0">,</span>
        <span class="s0">stiffness: </span><span class="s5">500</span><span class="s0">,</span>
        <span class="s0">damping: </span><span class="s5">25</span><span class="s0">,</span>
        <span class="s0">restSpeed: </span><span class="s5">10</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">criticallyDampedSpring = (target) =&gt; ({</span>
        <span class="s0">type: </span><span class="s2">&quot;spring&quot;</span><span class="s0">,</span>
        <span class="s0">stiffness: </span><span class="s5">550</span><span class="s0">,</span>
        <span class="s0">damping: target === </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">2 </span><span class="s0">* Math.sqrt(</span><span class="s5">550</span><span class="s0">) : </span><span class="s5">30</span><span class="s0">,</span>
        <span class="s0">restSpeed: </span><span class="s5">10</span><span class="s0">,</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">keyframesTransition = {</span>
        <span class="s0">type: </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,</span>
        <span class="s0">duration: </span><span class="s5">0.8</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* Default easing curve is a slightly shallower version of</span>
     <span class="s3">* the default browser easing curve.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">ease = {</span>
        <span class="s0">type: </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,</span>
        <span class="s0">ease: [</span><span class="s5">0.25</span><span class="s0">, </span><span class="s5">0.1</span><span class="s0">, </span><span class="s5">0.35</span><span class="s0">, </span><span class="s5">1</span><span class="s0">],</span>
        <span class="s0">duration: </span><span class="s5">0.3</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">getDefaultTransition = (valueKey, { keyframes }) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(keyframes.length &gt; </span><span class="s5">2</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">keyframesTransition;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(transformProps.has(valueKey)) {</span>
            <span class="s1">return </span><span class="s0">valueKey.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">)</span>
                <span class="s0">? criticallyDampedSpring(keyframes[</span><span class="s5">1</span><span class="s0">])</span>
                <span class="s0">: underDampedSpring;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">ease;</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Decide whether a transition is defined on a given Transition.</span>
     <span class="s3">* This filters out orchestration options and returns true</span>
     <span class="s3">* if any options are left.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {</span>
        <span class="s1">return </span><span class="s0">!!Object.keys(transition).length;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">animateMotionValue = (name, value, target, transition = {}, element, isHandoff) =&gt; (onComplete) =&gt; {</span>
        <span class="s1">const </span><span class="s0">valueTransition = getValueTransition$1(transition, name) || {};</span>
        <span class="s3">/**</span>
         <span class="s3">* Most transition values are currently completely overwritten by value-specific</span>
         <span class="s3">* transitions. In the future it'd be nicer to blend these transitions. But for now</span>
         <span class="s3">* delay actually does inherit from the root transition if not value-specific.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">delay = valueTransition.delay || transition.delay || </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Elapsed isn't a public transition option but can be passed through from</span>
         <span class="s3">* optimized appear effects in milliseconds.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">{ elapsed = </span><span class="s5">0 </span><span class="s0">} = transition;</span>
        <span class="s0">elapsed = elapsed - secondsToMilliseconds(delay);</span>
        <span class="s1">const </span><span class="s0">options = {</span>
            <span class="s0">keyframes: Array.isArray(target) ? target : [</span><span class="s1">null</span><span class="s0">, target],</span>
            <span class="s0">ease: </span><span class="s2">&quot;easeOut&quot;</span><span class="s0">,</span>
            <span class="s0">velocity: value.getVelocity(),</span>
            <span class="s0">...valueTransition,</span>
            <span class="s0">delay: -elapsed,</span>
            <span class="s0">onUpdate: (v) =&gt; {</span>
                <span class="s0">value.set(v);</span>
                <span class="s0">valueTransition.onUpdate &amp;&amp; valueTransition.onUpdate(v);</span>
            <span class="s0">},</span>
            <span class="s0">onComplete: () =&gt; {</span>
                <span class="s0">onComplete();</span>
                <span class="s0">valueTransition.onComplete &amp;&amp; valueTransition.onComplete();</span>
            <span class="s0">},</span>
            <span class="s0">name,</span>
            <span class="s0">motionValue: value,</span>
            <span class="s0">element: isHandoff ? undefined : element,</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* If there's no transition defined for this value, we can generate</span>
         <span class="s3">* unique transition settings for this value.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!isTransitionDefined(valueTransition)) {</span>
            <span class="s0">Object.assign(options, getDefaultTransition(name, options));</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Both WAAPI and our internal animation functions use durations</span>
         <span class="s3">* as defined by milliseconds, while our external API defines them</span>
         <span class="s3">* as seconds.</span>
         <span class="s3">*/</span>
        <span class="s0">options.duration &amp;&amp; (options.duration = secondsToMilliseconds(options.duration));</span>
        <span class="s0">options.repeatDelay &amp;&amp; (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));</span>
        <span class="s3">/**</span>
         <span class="s3">* Support deprecated way to set initial value. Prefer keyframe syntax.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(options.from !== undefined) {</span>
            <span class="s0">options.keyframes[</span><span class="s5">0</span><span class="s0">] = options.from;</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">shouldSkip = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(options.type === </span><span class="s1">false </span><span class="s0">||</span>
            <span class="s0">(options.duration === </span><span class="s5">0 </span><span class="s0">&amp;&amp; !options.repeatDelay)) {</span>
            <span class="s0">makeAnimationInstant(options);</span>
            <span class="s1">if </span><span class="s0">(options.delay === </span><span class="s5">0</span><span class="s0">) {</span>
                <span class="s0">shouldSkip = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(MotionGlobalConfig.instantAnimations ||</span>
            <span class="s0">MotionGlobalConfig.skipAnimations) {</span>
            <span class="s0">shouldSkip = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">makeAnimationInstant(options);</span>
            <span class="s0">options.delay = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If the transition type or easing has been explicitly set by the user</span>
         <span class="s3">* then we don't want to allow flattening the animation.</span>
         <span class="s3">*/</span>
        <span class="s0">options.allowFlatten = !valueTransition.type &amp;&amp; !valueTransition.ease;</span>
        <span class="s3">/**</span>
         <span class="s3">* If we can or must skip creating the animation, and apply only</span>
         <span class="s3">* the final keyframe, do so. We also check once keyframes are resolved but</span>
         <span class="s3">* this early check prevents the need to create an animation at all.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(shouldSkip &amp;&amp; !isHandoff &amp;&amp; value.get() !== undefined) {</span>
            <span class="s1">const </span><span class="s0">finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);</span>
            <span class="s1">if </span><span class="s0">(finalKeyframe !== undefined) {</span>
                <span class="s0">frame.update(() =&gt; {</span>
                    <span class="s0">options.onUpdate(finalKeyframe);</span>
                    <span class="s0">options.onComplete();</span>
                <span class="s0">});</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">valueTransition.isSync</span>
            <span class="s0">? </span><span class="s1">new </span><span class="s0">JSAnimation(options)</span>
            <span class="s0">: </span><span class="s1">new </span><span class="s0">AsyncMotionValueAnimation(options);</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">animateSingleValue(value, keyframes, options) {</span>
        <span class="s1">const </span><span class="s0">motionValue$1 = isMotionValue(value) ? value : motionValue(value);</span>
        <span class="s0">motionValue$1.start(animateMotionValue(</span><span class="s2">&quot;&quot;</span><span class="s0">, motionValue$1, keyframes, options));</span>
        <span class="s1">return </span><span class="s0">motionValue$1.animation;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Convert camelCase to dash-case properties.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">camelToDash = (str) =&gt; str.replace(</span><span class="s6">/([a-z])([A-Z])/gu</span><span class="s0">, </span><span class="s2">&quot;$1-$2&quot;</span><span class="s0">).toLowerCase();</span>

    <span class="s1">const </span><span class="s0">optimizedAppearDataId = </span><span class="s2">&quot;framerAppearId&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">optimizedAppearDataAttribute = </span><span class="s2">&quot;data-&quot; </span><span class="s0">+ camelToDash(optimizedAppearDataId);</span>

    <span class="s1">function </span><span class="s0">getOptimisedAppearId(visualElement) {</span>
        <span class="s1">return </span><span class="s0">visualElement.props[optimizedAppearDataAttribute];</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">compareByDepth = (a, b) =&gt; a.depth - b.depth;</span>

    <span class="s1">class </span><span class="s0">FlatTree {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.children = [];</span>
            <span class="s1">this</span><span class="s0">.isDirty = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">add(child) {</span>
            <span class="s0">addUniqueItem(</span><span class="s1">this</span><span class="s0">.children, child);</span>
            <span class="s1">this</span><span class="s0">.isDirty = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">remove(child) {</span>
            <span class="s0">removeItem(</span><span class="s1">this</span><span class="s0">.children, child);</span>
            <span class="s1">this</span><span class="s0">.isDirty = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">forEach(callback) {</span>
            <span class="s1">this</span><span class="s0">.isDirty &amp;&amp; </span><span class="s1">this</span><span class="s0">.children.sort(compareByDepth);</span>
            <span class="s1">this</span><span class="s0">.isDirty = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.children.forEach(callback);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Timeout defined in ms</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">delay(callback, timeout) {</span>
        <span class="s1">const </span><span class="s0">start = time.now();</span>
        <span class="s1">const </span><span class="s0">checkElapsed = ({ timestamp }) =&gt; {</span>
            <span class="s1">const </span><span class="s0">elapsed = timestamp - start;</span>
            <span class="s1">if </span><span class="s0">(elapsed &gt;= timeout) {</span>
                <span class="s0">cancelFrame(checkElapsed);</span>
                <span class="s0">callback(elapsed - timeout);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">frame.setup(checkElapsed, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">() =&gt; cancelFrame(checkElapsed);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself</span>
     <span class="s3">*</span>
     <span class="s3">* TODO: Remove and move to library</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">resolveMotionValue(value) {</span>
        <span class="s1">return </span><span class="s0">isMotionValue(value) ? value.get() : value;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">borders = [</span><span class="s2">&quot;TopLeft&quot;</span><span class="s0">, </span><span class="s2">&quot;TopRight&quot;</span><span class="s0">, </span><span class="s2">&quot;BottomLeft&quot;</span><span class="s0">, </span><span class="s2">&quot;BottomRight&quot;</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">numBorders = borders.length;</span>
    <span class="s1">const </span><span class="s0">asNumber = (value) =&gt; </span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;string&quot; </span><span class="s0">? parseFloat(value) : value;</span>
    <span class="s1">const </span><span class="s0">isPx = (value) =&gt; </span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot; </span><span class="s0">|| px.test(value);</span>
    <span class="s1">function </span><span class="s0">mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {</span>
        <span class="s1">if </span><span class="s0">(shouldCrossfadeOpacity) {</span>
            <span class="s0">target.opacity = mixNumber$1(</span><span class="s5">0</span><span class="s0">, lead.opacity ?? </span><span class="s5">1</span><span class="s0">, easeCrossfadeIn(progress));</span>
            <span class="s0">target.opacityExit = mixNumber$1(follow.opacity ?? </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, easeCrossfadeOut(progress));</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(isOnlyMember) {</span>
            <span class="s0">target.opacity = mixNumber$1(follow.opacity ?? </span><span class="s5">1</span><span class="s0">, lead.opacity ?? </span><span class="s5">1</span><span class="s0">, progress);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Mix border radius</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numBorders; i++) {</span>
            <span class="s1">const </span><span class="s0">borderLabel = </span><span class="s2">`border</span><span class="s0">${borders[i]}</span><span class="s2">Radius`</span><span class="s0">;</span>
            <span class="s1">let </span><span class="s0">followRadius = getRadius(follow, borderLabel);</span>
            <span class="s1">let </span><span class="s0">leadRadius = getRadius(lead, borderLabel);</span>
            <span class="s1">if </span><span class="s0">(followRadius === undefined &amp;&amp; leadRadius === undefined)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">followRadius || (followRadius = </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s0">leadRadius || (leadRadius = </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">canMix = followRadius === </span><span class="s5">0 </span><span class="s0">||</span>
                <span class="s0">leadRadius === </span><span class="s5">0 </span><span class="s0">||</span>
                <span class="s0">isPx(followRadius) === isPx(leadRadius);</span>
            <span class="s1">if </span><span class="s0">(canMix) {</span>
                <span class="s0">target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress), </span><span class="s5">0</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(percent.test(leadRadius) || percent.test(followRadius)) {</span>
                    <span class="s0">target[borderLabel] += </span><span class="s2">&quot;%&quot;</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">target[borderLabel] = leadRadius;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Mix rotation</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(follow.rotate || lead.rotate) {</span>
            <span class="s0">target.rotate = mixNumber$1(follow.rotate || </span><span class="s5">0</span><span class="s0">, lead.rotate || </span><span class="s5">0</span><span class="s0">, progress);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getRadius(values, radiusName) {</span>
        <span class="s1">return </span><span class="s0">values[radiusName] !== undefined</span>
            <span class="s0">? values[radiusName]</span>
            <span class="s0">: values.borderRadius;</span>
    <span class="s0">}</span>
    <span class="s3">// /**</span>
    <span class="s3">//  * We only want to mix the background color if there's a follow element</span>
    <span class="s3">//  * that we're not crossfading opacity between. For instance with switch</span>
    <span class="s3">//  * AnimateSharedLayout animations, this helps the illusion of a continuous</span>
    <span class="s3">//  * element being animated but also cuts down on the number of paints triggered</span>
    <span class="s3">//  * for elements where opacity is doing that work for us.</span>
    <span class="s3">//  */</span>
    <span class="s3">// if (</span>
    <span class="s3">//     !hasFollowElement &amp;&amp;</span>
    <span class="s3">//     latestLeadValues.backgroundColor &amp;&amp;</span>
    <span class="s3">//     latestFollowValues.backgroundColor</span>
    <span class="s3">// ) {</span>
    <span class="s3">//     /**</span>
    <span class="s3">//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.</span>
    <span class="s3">//      * We could probably create a mixer that runs at the start of the animation but</span>
    <span class="s3">//      * the idea behind the crossfader is that it runs dynamically between two potentially</span>
    <span class="s3">//      * changing targets (ie opacity or borderRadius may be animating independently via variants)</span>
    <span class="s3">//      */</span>
    <span class="s3">//     leadState.backgroundColor = followState.backgroundColor = mixColor(</span>
    <span class="s3">//         latestFollowValues.backgroundColor as string,</span>
    <span class="s3">//         latestLeadValues.backgroundColor as string</span>
    <span class="s3">//     )(p)</span>
    <span class="s3">// }</span>
    <span class="s1">const </span><span class="s0">easeCrossfadeIn = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">compress(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0.5</span><span class="s0">, circOut);</span>
    <span class="s1">const </span><span class="s0">easeCrossfadeOut = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">compress(</span><span class="s5">0.5</span><span class="s0">, </span><span class="s5">0.95</span><span class="s0">, noop);</span>
    <span class="s1">function </span><span class="s0">compress(min, max, easing) {</span>
        <span class="s1">return </span><span class="s0">(p) =&gt; {</span>
            <span class="s3">// Could replace ifs with clamp</span>
            <span class="s1">if </span><span class="s0">(p &lt; min)</span>
                <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(p &gt; max)</span>
                <span class="s1">return </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">easing(progress(min, max, p));</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Reset an axis to the provided origin box.</span>
     <span class="s3">*</span>
     <span class="s3">* This is a mutative operation.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">copyAxisInto(axis, originAxis) {</span>
        <span class="s0">axis.min = originAxis.min;</span>
        <span class="s0">axis.max = originAxis.max;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Reset a box to the provided origin box.</span>
     <span class="s3">*</span>
     <span class="s3">* This is a mutative operation.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">copyBoxInto(box, originBox) {</span>
        <span class="s0">copyAxisInto(box.x, originBox.x);</span>
        <span class="s0">copyAxisInto(box.y, originBox.y);</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Reset a delta to the provided origin box.</span>
     <span class="s3">*</span>
     <span class="s3">* This is a mutative operation.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">copyAxisDeltaInto(delta, originDelta) {</span>
        <span class="s0">delta.translate = originDelta.translate;</span>
        <span class="s0">delta.scale = originDelta.scale;</span>
        <span class="s0">delta.originPoint = originDelta.originPoint;</span>
        <span class="s0">delta.origin = originDelta.origin;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isIdentityScale(scale) {</span>
        <span class="s1">return </span><span class="s0">scale === undefined || scale === </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hasScale({ scale, scaleX, scaleY }) {</span>
        <span class="s1">return </span><span class="s0">(!isIdentityScale(scale) ||</span>
            <span class="s0">!isIdentityScale(scaleX) ||</span>
            <span class="s0">!isIdentityScale(scaleY));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hasTransform(values) {</span>
        <span class="s1">return </span><span class="s0">(hasScale(values) ||</span>
            <span class="s0">has2DTranslate(values) ||</span>
            <span class="s0">values.z ||</span>
            <span class="s0">values.rotate ||</span>
            <span class="s0">values.rotateX ||</span>
            <span class="s0">values.rotateY ||</span>
            <span class="s0">values.skewX ||</span>
            <span class="s0">values.skewY);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">has2DTranslate(values) {</span>
        <span class="s1">return </span><span class="s0">is2DTranslate(values.x) || is2DTranslate(values.y);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">is2DTranslate(value) {</span>
        <span class="s1">return </span><span class="s0">value &amp;&amp; value !== </span><span class="s2">&quot;0%&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Scales a point based on a factor and an originPoint</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">scalePoint(point, scale, originPoint) {</span>
        <span class="s1">const </span><span class="s0">distanceFromOrigin = point - originPoint;</span>
        <span class="s1">const </span><span class="s0">scaled = scale * distanceFromOrigin;</span>
        <span class="s1">return </span><span class="s0">originPoint + scaled;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Applies a translate/scale delta to a point</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">applyPointDelta(point, translate, scale, originPoint, boxScale) {</span>
        <span class="s1">if </span><span class="s0">(boxScale !== undefined) {</span>
            <span class="s0">point = scalePoint(point, boxScale, originPoint);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">scalePoint(point, scale, originPoint) + translate;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Applies a translate/scale delta to an axis</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">applyAxisDelta(axis, translate = </span><span class="s5">0</span><span class="s0">, scale = </span><span class="s5">1</span><span class="s0">, originPoint, boxScale) {</span>
        <span class="s0">axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);</span>
        <span class="s0">axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Applies a translate/scale delta to a box</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">applyBoxDelta(box, { x, y }) {</span>
        <span class="s0">applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);</span>
        <span class="s0">applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">TREE_SCALE_SNAP_MIN = </span><span class="s5">0.999999999999</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">TREE_SCALE_SNAP_MAX = </span><span class="s5">1.0000000000001</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms</span>
     <span class="s3">* in a tree upon our box before then calculating how to project it into our desired viewport-relative box</span>
     <span class="s3">*</span>
     <span class="s3">* This is the final nested loop within updateLayoutDelta for future refactoring</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">applyTreeDeltas(box, treeScale, treePath, isSharedTransition = </span><span class="s1">false</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">treeLength = treePath.length;</span>
        <span class="s1">if </span><span class="s0">(!treeLength)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s3">// Reset the treeScale</span>
        <span class="s0">treeScale.x = treeScale.y = </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">node;</span>
        <span class="s1">let </span><span class="s0">delta;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; treeLength; i++) {</span>
            <span class="s0">node = treePath[i];</span>
            <span class="s0">delta = node.projectionDelta;</span>
            <span class="s3">/**</span>
             <span class="s3">* TODO: Prefer to remove this, but currently we have motion components with</span>
             <span class="s3">* display: contents in Framer.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">{ visualElement } = node.options;</span>
            <span class="s1">if </span><span class="s0">(visualElement &amp;&amp;</span>
                <span class="s0">visualElement.props.style &amp;&amp;</span>
                <span class="s0">visualElement.props.style.display === </span><span class="s2">&quot;contents&quot;</span><span class="s0">) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(isSharedTransition &amp;&amp;</span>
                <span class="s0">node.options.layoutScroll &amp;&amp;</span>
                <span class="s0">node.scroll &amp;&amp;</span>
                <span class="s0">node !== node.root) {</span>
                <span class="s0">transformBox(box, {</span>
                    <span class="s0">x: -node.scroll.offset.x,</span>
                    <span class="s0">y: -node.scroll.offset.y,</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(delta) {</span>
                <span class="s3">// Incoporate each ancestor's scale into a culmulative treeScale for this component</span>
                <span class="s0">treeScale.x *= delta.x.scale;</span>
                <span class="s0">treeScale.y *= delta.y.scale;</span>
                <span class="s3">// Apply each ancestor's calculated delta into this component's recorded layout box</span>
                <span class="s0">applyBoxDelta(box, delta);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(isSharedTransition &amp;&amp; hasTransform(node.latestValues)) {</span>
                <span class="s0">transformBox(box, node.latestValues);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Snap tree scale back to 1 if it's within a non-perceivable threshold.</span>
         <span class="s3">* This will help reduce useless scales getting rendered.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(treeScale.x &lt; TREE_SCALE_SNAP_MAX &amp;&amp;</span>
            <span class="s0">treeScale.x &gt; TREE_SCALE_SNAP_MIN) {</span>
            <span class="s0">treeScale.x = </span><span class="s5">1.0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(treeScale.y &lt; TREE_SCALE_SNAP_MAX &amp;&amp;</span>
            <span class="s0">treeScale.y &gt; TREE_SCALE_SNAP_MIN) {</span>
            <span class="s0">treeScale.y = </span><span class="s5">1.0</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">translateAxis(axis, distance) {</span>
        <span class="s0">axis.min = axis.min + distance;</span>
        <span class="s0">axis.max = axis.max + distance;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Apply a transform to an axis from the latest resolved motion values.</span>
     <span class="s3">* This function basically acts as a bridge between a flat motion value map</span>
     <span class="s3">* and applyAxisDelta</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = </span><span class="s5">0.5</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);</span>
        <span class="s3">// Apply the axis delta to the final axis</span>
        <span class="s0">applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Apply a transform to a box from the latest resolved motion values.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">transformBox(box, transform) {</span>
        <span class="s0">transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);</span>
        <span class="s0">transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">removePointDelta(point, translate, scale, originPoint, boxScale) {</span>
        <span class="s0">point -= translate;</span>
        <span class="s0">point = scalePoint(point, </span><span class="s5">1 </span><span class="s0">/ scale, originPoint);</span>
        <span class="s1">if </span><span class="s0">(boxScale !== undefined) {</span>
            <span class="s0">point = scalePoint(point, </span><span class="s5">1 </span><span class="s0">/ boxScale, originPoint);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">point;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">removeAxisDelta(axis, translate = </span><span class="s5">0</span><span class="s0">, scale = </span><span class="s5">1</span><span class="s0">, origin = </span><span class="s5">0.5</span><span class="s0">, boxScale, originAxis = axis, sourceAxis = axis) {</span>
        <span class="s1">if </span><span class="s0">(percent.test(translate)) {</span>
            <span class="s0">translate = parseFloat(translate);</span>
            <span class="s1">const </span><span class="s0">relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / </span><span class="s5">100</span><span class="s0">);</span>
            <span class="s0">translate = relativeProgress - sourceAxis.min;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">translate !== </span><span class="s2">&quot;number&quot;</span><span class="s0">)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);</span>
        <span class="s1">if </span><span class="s0">(axis === originAxis)</span>
            <span class="s0">originPoint -= translate;</span>
        <span class="s0">axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);</span>
        <span class="s0">axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse</span>
     <span class="s3">* and acts as a bridge between motion values and removeAxisDelta</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {</span>
        <span class="s0">removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* The names of the motion values we want to apply as translation, scale and origin.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">xKeys = [</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;scaleX&quot;</span><span class="s0">, </span><span class="s2">&quot;originX&quot;</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">yKeys = [</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;scaleY&quot;</span><span class="s0">, </span><span class="s2">&quot;originY&quot;</span><span class="s0">];</span>
    <span class="s3">/**</span>
     <span class="s3">* Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse</span>
     <span class="s3">* and acts as a bridge between motion values and removeAxisDelta</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">removeBoxTransforms(box, transforms, originBox, sourceBox) {</span>
        <span class="s0">removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);</span>
        <span class="s0">removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">createAxisDelta = () =&gt; ({</span>
        <span class="s0">translate: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">scale: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s0">origin: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">originPoint: </span><span class="s5">0</span><span class="s0">,</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">createDelta = () =&gt; ({</span>
        <span class="s0">x: createAxisDelta(),</span>
        <span class="s0">y: createAxisDelta(),</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">createAxis = () =&gt; ({ min: </span><span class="s5">0</span><span class="s0">, max: </span><span class="s5">0 </span><span class="s0">});</span>
    <span class="s1">const </span><span class="s0">createBox = () =&gt; ({</span>
        <span class="s0">x: createAxis(),</span>
        <span class="s0">y: createAxis(),</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">isAxisDeltaZero(delta) {</span>
        <span class="s1">return </span><span class="s0">delta.translate === </span><span class="s5">0 </span><span class="s0">&amp;&amp; delta.scale === </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isDeltaZero(delta) {</span>
        <span class="s1">return </span><span class="s0">isAxisDeltaZero(delta.x) &amp;&amp; isAxisDeltaZero(delta.y);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">axisEquals(a, b) {</span>
        <span class="s1">return </span><span class="s0">a.min === b.min &amp;&amp; a.max === b.max;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">boxEquals(a, b) {</span>
        <span class="s1">return </span><span class="s0">axisEquals(a.x, b.x) &amp;&amp; axisEquals(a.y, b.y);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">axisEqualsRounded(a, b) {</span>
        <span class="s1">return </span><span class="s0">(Math.round(a.min) === Math.round(b.min) &amp;&amp;</span>
            <span class="s0">Math.round(a.max) === Math.round(b.max));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">boxEqualsRounded(a, b) {</span>
        <span class="s1">return </span><span class="s0">axisEqualsRounded(a.x, b.x) &amp;&amp; axisEqualsRounded(a.y, b.y);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">aspectRatio(box) {</span>
        <span class="s1">return </span><span class="s0">calcLength(box.x) / calcLength(box.y);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">axisDeltaEquals(a, b) {</span>
        <span class="s1">return </span><span class="s0">(a.translate === b.translate &amp;&amp;</span>
            <span class="s0">a.scale === b.scale &amp;&amp;</span>
            <span class="s0">a.originPoint === b.originPoint);</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">NodeStack {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.members = [];</span>
        <span class="s0">}</span>
        <span class="s0">add(node) {</span>
            <span class="s0">addUniqueItem(</span><span class="s1">this</span><span class="s0">.members, node);</span>
            <span class="s0">node.scheduleRender();</span>
        <span class="s0">}</span>
        <span class="s0">remove(node) {</span>
            <span class="s0">removeItem(</span><span class="s1">this</span><span class="s0">.members, node);</span>
            <span class="s1">if </span><span class="s0">(node === </span><span class="s1">this</span><span class="s0">.prevLead) {</span>
                <span class="s1">this</span><span class="s0">.prevLead = undefined;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node === </span><span class="s1">this</span><span class="s0">.lead) {</span>
                <span class="s1">const </span><span class="s0">prevLead = </span><span class="s1">this</span><span class="s0">.members[</span><span class="s1">this</span><span class="s0">.members.length - </span><span class="s5">1</span><span class="s0">];</span>
                <span class="s1">if </span><span class="s0">(prevLead) {</span>
                    <span class="s1">this</span><span class="s0">.promote(prevLead);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">relegate(node) {</span>
            <span class="s1">const </span><span class="s0">indexOfNode = </span><span class="s1">this</span><span class="s0">.members.findIndex((member) =&gt; node === member);</span>
            <span class="s1">if </span><span class="s0">(indexOfNode === </span><span class="s5">0</span><span class="s0">)</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Find the next projection node that is present</span>
             <span class="s3">*/</span>
            <span class="s1">let </span><span class="s0">prevLead;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = indexOfNode; i &gt;= </span><span class="s5">0</span><span class="s0">; i--) {</span>
                <span class="s1">const </span><span class="s0">member = </span><span class="s1">this</span><span class="s0">.members[i];</span>
                <span class="s1">if </span><span class="s0">(member.isPresent !== </span><span class="s1">false</span><span class="s0">) {</span>
                    <span class="s0">prevLead = member;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(prevLead) {</span>
                <span class="s1">this</span><span class="s0">.promote(prevLead);</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">promote(node, preserveFollowOpacity) {</span>
            <span class="s1">const </span><span class="s0">prevLead = </span><span class="s1">this</span><span class="s0">.lead;</span>
            <span class="s1">if </span><span class="s0">(node === prevLead)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.prevLead = prevLead;</span>
            <span class="s1">this</span><span class="s0">.lead = node;</span>
            <span class="s0">node.show();</span>
            <span class="s1">if </span><span class="s0">(prevLead) {</span>
                <span class="s0">prevLead.instance &amp;&amp; prevLead.scheduleRender();</span>
                <span class="s0">node.scheduleRender();</span>
                <span class="s0">node.resumeFrom = prevLead;</span>
                <span class="s1">if </span><span class="s0">(preserveFollowOpacity) {</span>
                    <span class="s0">node.resumeFrom.preserveOpacity = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(prevLead.snapshot) {</span>
                    <span class="s0">node.snapshot = prevLead.snapshot;</span>
                    <span class="s0">node.snapshot.latestValues =</span>
                        <span class="s0">prevLead.animationValues || prevLead.latestValues;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(node.root &amp;&amp; node.root.isUpdating) {</span>
                    <span class="s0">node.isLayoutDirty = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ crossfade } = node.options;</span>
                <span class="s1">if </span><span class="s0">(crossfade === </span><span class="s1">false</span><span class="s0">) {</span>
                    <span class="s0">prevLead.hide();</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* TODO:</span>
                 <span class="s3">*   - Test border radius when previous node was deleted</span>
                 <span class="s3">*   - boxShadow mixing</span>
                 <span class="s3">*   - Shared between element A in scrolled container and element B (scroll stays the same or changes)</span>
                 <span class="s3">*   - Shared between element A in transformed container and element B (transform stays the same or changes)</span>
                 <span class="s3">*   - Shared between element A in scrolled page and element B (scroll stays the same or changes)</span>
                 <span class="s3">* ---</span>
                 <span class="s3">*   - Crossfade opacity of root nodes</span>
                 <span class="s3">*   - layoutId changes after animation</span>
                 <span class="s3">*   - layoutId changes mid animation</span>
                 <span class="s3">*/</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">exitAnimationComplete() {</span>
            <span class="s1">this</span><span class="s0">.members.forEach((node) =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ options, resumingFrom } = node;</span>
                <span class="s0">options.onExitComplete &amp;&amp; options.onExitComplete();</span>
                <span class="s1">if </span><span class="s0">(resumingFrom) {</span>
                    <span class="s0">resumingFrom.options.onExitComplete &amp;&amp;</span>
                        <span class="s0">resumingFrom.options.onExitComplete();</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">scheduleRender() {</span>
            <span class="s1">this</span><span class="s0">.members.forEach((node) =&gt; {</span>
                <span class="s0">node.instance &amp;&amp; node.scheduleRender(</span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Clear any leads that have been removed this render to prevent them from being</span>
         <span class="s3">* used in future animations and to prevent memory leaks</span>
         <span class="s3">*/</span>
        <span class="s0">removeLeadSnapshot() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.lead &amp;&amp; </span><span class="s1">this</span><span class="s0">.lead.snapshot) {</span>
                <span class="s1">this</span><span class="s0">.lead.snapshot = undefined;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">scaleCorrectors = {};</span>
    <span class="s1">function </span><span class="s0">addScaleCorrector(correctors) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">correctors) {</span>
            <span class="s0">scaleCorrectors[key] = correctors[key];</span>
            <span class="s1">if </span><span class="s0">(isCSSVariableName(key)) {</span>
                <span class="s0">scaleCorrectors[key].isCSSVariable = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">buildProjectionTransform(delta, treeScale, latestTransform) {</span>
        <span class="s1">let </span><span class="s0">transform = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* The translations we use to calculate are always relative to the viewport coordinate space.</span>
         <span class="s3">* But when we apply scales, we also scale the coordinate space of an element and its children.</span>
         <span class="s3">* For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need</span>
         <span class="s3">* to move an element 100 pixels, we actually need to move it 200 in within that scaled space.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">xTranslate = delta.x.translate / treeScale.x;</span>
        <span class="s1">const </span><span class="s0">yTranslate = delta.y.translate / treeScale.y;</span>
        <span class="s1">const </span><span class="s0">zTranslate = latestTransform?.z || </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(xTranslate || yTranslate || zTranslate) {</span>
            <span class="s0">transform = </span><span class="s2">`translate3d(</span><span class="s0">${xTranslate}</span><span class="s2">px, </span><span class="s0">${yTranslate}</span><span class="s2">px, </span><span class="s0">${zTranslate}</span><span class="s2">px) `</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Apply scale correction for the tree transform.</span>
         <span class="s3">* This will apply scale to the screen-orientated axes.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(treeScale.x !== </span><span class="s5">1 </span><span class="s0">|| treeScale.y !== </span><span class="s5">1</span><span class="s0">) {</span>
            <span class="s0">transform += </span><span class="s2">`scale(</span><span class="s0">${</span><span class="s5">1 </span><span class="s0">/ treeScale.x}</span><span class="s2">, </span><span class="s0">${</span><span class="s5">1 </span><span class="s0">/ treeScale.y}</span><span class="s2">) `</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(latestTransform) {</span>
            <span class="s1">const </span><span class="s0">{ transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;</span>
            <span class="s1">if </span><span class="s0">(transformPerspective)</span>
                <span class="s0">transform = </span><span class="s2">`perspective(</span><span class="s0">${transformPerspective}</span><span class="s2">px) </span><span class="s0">${transform}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(rotate)</span>
                <span class="s0">transform += </span><span class="s2">`rotate(</span><span class="s0">${rotate}</span><span class="s2">deg) `</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(rotateX)</span>
                <span class="s0">transform += </span><span class="s2">`rotateX(</span><span class="s0">${rotateX}</span><span class="s2">deg) `</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(rotateY)</span>
                <span class="s0">transform += </span><span class="s2">`rotateY(</span><span class="s0">${rotateY}</span><span class="s2">deg) `</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(skewX)</span>
                <span class="s0">transform += </span><span class="s2">`skewX(</span><span class="s0">${skewX}</span><span class="s2">deg) `</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(skewY)</span>
                <span class="s0">transform += </span><span class="s2">`skewY(</span><span class="s0">${skewY}</span><span class="s2">deg) `</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Apply scale to match the size of the element to the size we want it.</span>
         <span class="s3">* This will apply scale to the element-orientated axes.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">elementScaleX = delta.x.scale * treeScale.x;</span>
        <span class="s1">const </span><span class="s0">elementScaleY = delta.y.scale * treeScale.y;</span>
        <span class="s1">if </span><span class="s0">(elementScaleX !== </span><span class="s5">1 </span><span class="s0">|| elementScaleY !== </span><span class="s5">1</span><span class="s0">) {</span>
            <span class="s0">transform += </span><span class="s2">`scale(</span><span class="s0">${elementScaleX}</span><span class="s2">, </span><span class="s0">${elementScaleY}</span><span class="s2">)`</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">transform || </span><span class="s2">&quot;none&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">eachAxis(callback) {</span>
        <span class="s1">return </span><span class="s0">[callback(</span><span class="s2">&quot;x&quot;</span><span class="s0">), callback(</span><span class="s2">&quot;y&quot;</span><span class="s0">)];</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* This should only ever be modified on the client otherwise it'll</span>
     <span class="s3">* persist through server requests. If we need instanced states we</span>
     <span class="s3">* could lazy-init via root.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">globalProjectionState = {</span>
        <span class="s3">/**</span>
         <span class="s3">* Global flag as to whether the tree has animated since the last time</span>
         <span class="s3">* we resized the window</span>
         <span class="s3">*/</span>
        <span class="s0">hasAnimatedSinceResize: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s3">/**</span>
         <span class="s3">* We set this to true once, on the first update. Any nodes added to the tree beyond that</span>
         <span class="s3">* update will be given a `data-projection-id` attribute.</span>
         <span class="s3">*/</span>
        <span class="s0">hasEverUpdated: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">metrics = {</span>
        <span class="s0">nodes: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">calculatedTargetDeltas: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">calculatedProjections: </span><span class="s5">0</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">transformAxes = [</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;X&quot;</span><span class="s0">, </span><span class="s2">&quot;Y&quot;</span><span class="s0">, </span><span class="s2">&quot;Z&quot;</span><span class="s0">];</span>
    <span class="s3">/**</span>
     <span class="s3">* We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1</span>
     <span class="s3">* which has a noticeable difference in spring animations</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">animationTarget = </span><span class="s5">1000</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">id$2 = </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {</span>
        <span class="s1">const </span><span class="s0">{ latestValues } = visualElement;</span>
        <span class="s3">// Record the distorting transform and then temporarily set it to 0</span>
        <span class="s1">if </span><span class="s0">(latestValues[key]) {</span>
            <span class="s0">values[key] = latestValues[key];</span>
            <span class="s0">visualElement.setStaticValue(key, </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(sharedAnimationValues) {</span>
                <span class="s0">sharedAnimationValues[key] = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">cancelTreeOptimisedTransformAnimations(projectionNode) {</span>
        <span class="s0">projectionNode.hasCheckedOptimisedAppear = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(projectionNode.root === projectionNode)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">{ visualElement } = projectionNode.options;</span>
        <span class="s1">if </span><span class="s0">(!visualElement)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">appearId = getOptimisedAppearId(visualElement);</span>
        <span class="s1">if </span><span class="s0">(window.MotionHasOptimisedAnimation(appearId, </span><span class="s2">&quot;transform&quot;</span><span class="s0">)) {</span>
            <span class="s1">const </span><span class="s0">{ layout, layoutId } = projectionNode.options;</span>
            <span class="s0">window.MotionCancelOptimisedAnimation(appearId, </span><span class="s2">&quot;transform&quot;</span><span class="s0">, frame, !(layout || layoutId));</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">{ parent } = projectionNode;</span>
        <span class="s1">if </span><span class="s0">(parent &amp;&amp; !parent.hasCheckedOptimisedAppear) {</span>
            <span class="s0">cancelTreeOptimisedTransformAnimations(parent);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {</span>
        <span class="s1">return class </span><span class="s0">ProjectionNode {</span>
            <span class="s0">constructor(latestValues = {}, parent = defaultParent?.()) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* A unique ID generated for every projection node.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.id = id$2++;</span>
                <span class="s3">/**</span>
                 <span class="s3">* An id that represents a unique session instigated by startUpdate.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.animationId = </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.animationCommitId = </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* A Set containing all this component's children. This is used to iterate</span>
                 <span class="s3">* through the children.</span>
                 <span class="s3">*</span>
                 <span class="s3">* TODO: This could be faster to iterate as a flat array stored on the root node.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.children = </span><span class="s1">new </span><span class="s0">Set();</span>
                <span class="s3">/**</span>
                 <span class="s3">* Options for the node. We use this to configure what kind of layout animations</span>
                 <span class="s3">* we should perform (if any).</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.options = {};</span>
                <span class="s3">/**</span>
                 <span class="s3">* We use this to detect when its safe to shut down part of a projection tree.</span>
                 <span class="s3">* We have to keep projecting children for scale correction and relative projection</span>
                 <span class="s3">* until all their parents stop performing layout animations.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.isTreeAnimating = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.isAnimationBlocked = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Flag to true if we think this layout has been changed. We can't always know this,</span>
                 <span class="s3">* currently we set it to true every time a component renders, or if it has a layoutDependency</span>
                 <span class="s3">* if that has changed between renders. Additionally, components can be grouped by LayoutGroup</span>
                 <span class="s3">* and if one node is dirtied, they all are.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.isLayoutDirty = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Flag to true if we think the projection calculations for this node needs</span>
                 <span class="s3">* recalculating as a result of an updated transform or layout animation.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.isProjectionDirty = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Flag to true if the layout *or* transform has changed. This then gets propagated</span>
                 <span class="s3">* throughout the projection tree, forcing any element below to recalculate on the next frame.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.isSharedProjectionDirty = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Flag transform dirty. This gets propagated throughout the whole tree but is only</span>
                 <span class="s3">* respected by shared nodes.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.isTransformDirty = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Block layout updates for instant layout transitions throughout the tree.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.updateManuallyBlocked = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.updateBlockedByResize = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`</span>
                 <span class="s3">* call.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.isUpdating = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this is an SVG element we currently disable projection transforms</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.isSVG = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Flag to true (during promotion) if a node doing an instant layout transition needs to reset</span>
                 <span class="s3">* its projection styles.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.needsReset = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Flags whether this node should have its transform reset prior to measuring.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.shouldResetTransform = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Store whether this node has been checked for optimised appear animations. As</span>
                 <span class="s3">* effects fire bottom-up, and we want to look up the tree for appear animations,</span>
                 <span class="s3">* this makes sure we only check each path once, stopping at nodes that</span>
                 <span class="s3">* have already been checked.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.hasCheckedOptimisedAppear = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* An object representing the calculated contextual/accumulated/tree scale.</span>
                 <span class="s3">* This will be used to scale calculcated projection transforms, as these are</span>
                 <span class="s3">* calculated in screen-space but need to be scaled for elements to layoutly</span>
                 <span class="s3">* make it to their calculated destinations.</span>
                 <span class="s3">*</span>
                 <span class="s3">* TODO: Lazy-init</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.treeScale = { x: </span><span class="s5">1</span><span class="s0">, y: </span><span class="s5">1 </span><span class="s0">};</span>
                <span class="s3">/**</span>
                 <span class="s3">*</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.eventHandlers = </span><span class="s1">new </span><span class="s0">Map();</span>
                <span class="s1">this</span><span class="s0">.hasTreeAnimated = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">// Note: Currently only running on root node</span>
                <span class="s1">this</span><span class="s0">.updateScheduled = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.scheduleUpdate = () =&gt; </span><span class="s1">this</span><span class="s0">.update();</span>
                <span class="s1">this</span><span class="s0">.projectionUpdateScheduled = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.checkUpdateFailed = () =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isUpdating) {</span>
                        <span class="s1">this</span><span class="s0">.isUpdating = </span><span class="s1">false</span><span class="s0">;</span>
                        <span class="s1">this</span><span class="s0">.clearAllSnapshots();</span>
                    <span class="s0">}</span>
                <span class="s0">};</span>
                <span class="s3">/**</span>
                 <span class="s3">* This is a multi-step process as shared nodes might be of different depths. Nodes</span>
                 <span class="s3">* are sorted by depth order, so we need to resolve the entire tree before moving to</span>
                 <span class="s3">* the next step.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.updateProjection = () =&gt; {</span>
                    <span class="s1">this</span><span class="s0">.projectionUpdateScheduled = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Reset debug counts. Manually resetting rather than creating a new</span>
                     <span class="s3">* object each frame.</span>
                     <span class="s3">*/</span>
                    <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
                        <span class="s0">metrics.nodes =</span>
                            <span class="s0">metrics.calculatedTargetDeltas =</span>
                                <span class="s0">metrics.calculatedProjections =</span>
                                    <span class="s5">0</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(propagateDirtyNodes);</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(resolveTargetDelta);</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(calcProjection);</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(cleanDirtyNodes);</span>
                    <span class="s1">if </span><span class="s0">(statsBuffer.addProjectionMetrics) {</span>
                        <span class="s0">statsBuffer.addProjectionMetrics(metrics);</span>
                    <span class="s0">}</span>
                <span class="s0">};</span>
                <span class="s3">/**</span>
                 <span class="s3">* Frame calculations</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.resolvedRelativeTargetAt = </span><span class="s5">0.0</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.hasProjected = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.isVisible = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.animationProgress = </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Shared layout</span>
                 <span class="s3">*/</span>
                <span class="s3">// TODO Only running on root node</span>
                <span class="s1">this</span><span class="s0">.sharedNodes = </span><span class="s1">new </span><span class="s0">Map();</span>
                <span class="s1">this</span><span class="s0">.latestValues = latestValues;</span>
                <span class="s1">this</span><span class="s0">.root = parent ? parent.root || parent : </span><span class="s1">this</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.path = parent ? [...parent.path, parent] : [];</span>
                <span class="s1">this</span><span class="s0">.parent = parent;</span>
                <span class="s1">this</span><span class="s0">.depth = parent ? parent.depth + </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.path.length; i++) {</span>
                    <span class="s1">this</span><span class="s0">.path[i].shouldResetTransform = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.root === </span><span class="s1">this</span><span class="s0">)</span>
                    <span class="s1">this</span><span class="s0">.nodes = </span><span class="s1">new </span><span class="s0">FlatTree();</span>
            <span class="s0">}</span>
            <span class="s0">addEventListener(name, handler) {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.eventHandlers.has(name)) {</span>
                    <span class="s1">this</span><span class="s0">.eventHandlers.set(name, </span><span class="s1">new </span><span class="s0">SubscriptionManager());</span>
                <span class="s0">}</span>
                <span class="s1">return this</span><span class="s0">.eventHandlers.get(name).add(handler);</span>
            <span class="s0">}</span>
            <span class="s0">notifyListeners(name, ...args) {</span>
                <span class="s1">const </span><span class="s0">subscriptionManager = </span><span class="s1">this</span><span class="s0">.eventHandlers.get(name);</span>
                <span class="s0">subscriptionManager &amp;&amp; subscriptionManager.notify(...args);</span>
            <span class="s0">}</span>
            <span class="s0">hasListeners(name) {</span>
                <span class="s1">return this</span><span class="s0">.eventHandlers.has(name);</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Lifecycles</span>
             <span class="s3">*/</span>
            <span class="s0">mount(instance) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.instance)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.isSVG = isSVGElement(instance) &amp;&amp; !isSVGSVGElement(instance);</span>
                <span class="s1">this</span><span class="s0">.instance = instance;</span>
                <span class="s1">const </span><span class="s0">{ layoutId, layout, visualElement } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">if </span><span class="s0">(visualElement &amp;&amp; !visualElement.current) {</span>
                    <span class="s0">visualElement.mount(instance);</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.root.nodes.add(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">this</span><span class="s0">.parent &amp;&amp; </span><span class="s1">this</span><span class="s0">.parent.children.add(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.root.hasTreeAnimated &amp;&amp; (layout || layoutId)) {</span>
                    <span class="s1">this</span><span class="s0">.isLayoutDirty = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(attachResizeListener) {</span>
                    <span class="s1">let </span><span class="s0">cancelDelay;</span>
                    <span class="s1">let </span><span class="s0">innerWidth = </span><span class="s5">0</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">resizeUnblockUpdate = () =&gt; (</span><span class="s1">this</span><span class="s0">.root.updateBlockedByResize = </span><span class="s1">false</span><span class="s0">);</span>
                    <span class="s3">// Set initial innerWidth in a frame.read callback to batch the read</span>
                    <span class="s0">frame.read(() =&gt; {</span>
                        <span class="s0">innerWidth = window.innerWidth;</span>
                    <span class="s0">});</span>
                    <span class="s0">attachResizeListener(instance, () =&gt; {</span>
                        <span class="s1">const </span><span class="s0">newInnerWidth = window.innerWidth;</span>
                        <span class="s1">if </span><span class="s0">(newInnerWidth === innerWidth)</span>
                            <span class="s1">return</span><span class="s0">;</span>
                        <span class="s0">innerWidth = newInnerWidth;</span>
                        <span class="s1">this</span><span class="s0">.root.updateBlockedByResize = </span><span class="s1">true</span><span class="s0">;</span>
                        <span class="s0">cancelDelay &amp;&amp; cancelDelay();</span>
                        <span class="s0">cancelDelay = delay(resizeUnblockUpdate, </span><span class="s5">250</span><span class="s0">);</span>
                        <span class="s1">if </span><span class="s0">(globalProjectionState.hasAnimatedSinceResize) {</span>
                            <span class="s0">globalProjectionState.hasAnimatedSinceResize = </span><span class="s1">false</span><span class="s0">;</span>
                            <span class="s1">this</span><span class="s0">.nodes.forEach(finishAnimation);</span>
                        <span class="s0">}</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(layoutId) {</span>
                    <span class="s1">this</span><span class="s0">.root.registerSharedNode(layoutId, </span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s3">// Only register the handler if it requires layout animation</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.animate !== </span><span class="s1">false </span><span class="s0">&amp;&amp;</span>
                    <span class="s0">visualElement &amp;&amp;</span>
                    <span class="s0">(layoutId || layout)) {</span>
                    <span class="s1">this</span><span class="s0">.addEventListener(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s0">, ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) =&gt; {</span>
                        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isTreeAnimationBlocked()) {</span>
                            <span class="s1">this</span><span class="s0">.target = undefined;</span>
                            <span class="s1">this</span><span class="s0">.relativeTarget = undefined;</span>
                            <span class="s1">return</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s3">// TODO: Check here if an animation exists</span>
                        <span class="s1">const </span><span class="s0">layoutTransition = </span><span class="s1">this</span><span class="s0">.options.transition ||</span>
                            <span class="s0">visualElement.getDefaultTransition() ||</span>
                            <span class="s0">defaultLayoutTransition;</span>
                        <span class="s1">const </span><span class="s0">{ onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();</span>
                        <span class="s3">/**</span>
                         <span class="s3">* The target layout of the element might stay the same,</span>
                         <span class="s3">* but its position relative to its parent has changed.</span>
                         <span class="s3">*/</span>
                        <span class="s1">const </span><span class="s0">hasTargetChanged = !</span><span class="s1">this</span><span class="s0">.targetLayout ||</span>
                            <span class="s0">!boxEqualsRounded(</span><span class="s1">this</span><span class="s0">.targetLayout, newLayout);</span>
                        <span class="s3">/* 
                         * Note: Disabled to fix relative animations always triggering new 
                         * layout animations. If this causes further issues, we can try 
                         * a different approach to detecting relative target changes. 
                         */</span>
                        <span class="s3">// || hasRelativeLayoutChanged</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If the layout hasn't seemed to have changed, it might be that the</span>
                         <span class="s3">* element is visually in the same place in the document but its position</span>
                         <span class="s3">* relative to its parent has indeed changed. So here we check for that.</span>
                         <span class="s3">*/</span>
                        <span class="s1">const </span><span class="s0">hasOnlyRelativeTargetChanged = !hasLayoutChanged &amp;&amp; hasRelativeLayoutChanged;</span>
                        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.layoutRoot ||</span>
                            <span class="s1">this</span><span class="s0">.resumeFrom ||</span>
                            <span class="s0">hasOnlyRelativeTargetChanged ||</span>
                            <span class="s0">(hasLayoutChanged &amp;&amp;</span>
                                <span class="s0">(hasTargetChanged || !</span><span class="s1">this</span><span class="s0">.currentAnimation))) {</span>
                            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resumeFrom) {</span>
                                <span class="s1">this</span><span class="s0">.resumingFrom = </span><span class="s1">this</span><span class="s0">.resumeFrom;</span>
                                <span class="s1">this</span><span class="s0">.resumingFrom.resumingFrom = undefined;</span>
                            <span class="s0">}</span>
                            <span class="s1">const </span><span class="s0">animationOptions = {</span>
                                <span class="s0">...getValueTransition$1(layoutTransition, </span><span class="s2">&quot;layout&quot;</span><span class="s0">),</span>
                                <span class="s0">onPlay: onLayoutAnimationStart,</span>
                                <span class="s0">onComplete: onLayoutAnimationComplete,</span>
                            <span class="s0">};</span>
                            <span class="s1">if </span><span class="s0">(visualElement.shouldReduceMotion ||</span>
                                <span class="s1">this</span><span class="s0">.options.layoutRoot) {</span>
                                <span class="s0">animationOptions.delay = </span><span class="s5">0</span><span class="s0">;</span>
                                <span class="s0">animationOptions.type = </span><span class="s1">false</span><span class="s0">;</span>
                            <span class="s0">}</span>
                            <span class="s1">this</span><span class="s0">.startAnimation(animationOptions);</span>
                            <span class="s3">/**</span>
                             <span class="s3">* Set animation origin after starting animation to avoid layout jump</span>
                             <span class="s3">* caused by stopping previous layout animation</span>
                             <span class="s3">*/</span>
                            <span class="s1">this</span><span class="s0">.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);</span>
                        <span class="s0">}</span>
                        <span class="s1">else </span><span class="s0">{</span>
                            <span class="s3">/**</span>
                             <span class="s3">* If the layout hasn't changed and we have an animation that hasn't started yet,</span>
                             <span class="s3">* finish it immediately. Otherwise it will be animating from a location</span>
                             <span class="s3">* that was probably never commited to screen and look like a jumpy box.</span>
                             <span class="s3">*/</span>
                            <span class="s1">if </span><span class="s0">(!hasLayoutChanged) {</span>
                                <span class="s0">finishAnimation(</span><span class="s1">this</span><span class="s0">);</span>
                            <span class="s0">}</span>
                            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLead() &amp;&amp; </span><span class="s1">this</span><span class="s0">.options.onExitComplete) {</span>
                                <span class="s1">this</span><span class="s0">.options.onExitComplete();</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                        <span class="s1">this</span><span class="s0">.targetLayout = newLayout;</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">unmount() {</span>
                <span class="s1">this</span><span class="s0">.options.layoutId &amp;&amp; </span><span class="s1">this</span><span class="s0">.willUpdate();</span>
                <span class="s1">this</span><span class="s0">.root.nodes.remove(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.getStack();</span>
                <span class="s0">stack &amp;&amp; stack.remove(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">this</span><span class="s0">.parent &amp;&amp; </span><span class="s1">this</span><span class="s0">.parent.children.delete(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">this</span><span class="s0">.instance = undefined;</span>
                <span class="s1">this</span><span class="s0">.eventHandlers.clear();</span>
                <span class="s0">cancelFrame(</span><span class="s1">this</span><span class="s0">.updateProjection);</span>
            <span class="s0">}</span>
            <span class="s3">// only on the root</span>
            <span class="s0">blockUpdate() {</span>
                <span class="s1">this</span><span class="s0">.updateManuallyBlocked = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">unblockUpdate() {</span>
                <span class="s1">this</span><span class="s0">.updateManuallyBlocked = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">isUpdateBlocked() {</span>
                <span class="s1">return this</span><span class="s0">.updateManuallyBlocked || </span><span class="s1">this</span><span class="s0">.updateBlockedByResize;</span>
            <span class="s0">}</span>
            <span class="s0">isTreeAnimationBlocked() {</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAnimationBlocked ||</span>
                    <span class="s0">(</span><span class="s1">this</span><span class="s0">.parent &amp;&amp; </span><span class="s1">this</span><span class="s0">.parent.isTreeAnimationBlocked()) ||</span>
                    <span class="s1">false</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s3">// Note: currently only running on root node</span>
            <span class="s0">startUpdate() {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isUpdateBlocked())</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.isUpdating = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.nodes &amp;&amp; </span><span class="s1">this</span><span class="s0">.nodes.forEach(resetSkewAndRotation);</span>
                <span class="s1">this</span><span class="s0">.animationId++;</span>
            <span class="s0">}</span>
            <span class="s0">getTransformTemplate() {</span>
                <span class="s1">const </span><span class="s0">{ visualElement } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">return </span><span class="s0">visualElement &amp;&amp; visualElement.getProps().transformTemplate;</span>
            <span class="s0">}</span>
            <span class="s0">willUpdate(shouldNotifyListeners = </span><span class="s1">true</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.root.hasTreeAnimated = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.root.isUpdateBlocked()) {</span>
                    <span class="s1">this</span><span class="s0">.options.onExitComplete &amp;&amp; </span><span class="s1">this</span><span class="s0">.options.onExitComplete();</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're running optimised appear animations then these must be</span>
                 <span class="s3">* cancelled before measuring the DOM. This is so we can measure</span>
                 <span class="s3">* the true layout of the element rather than the WAAPI animation</span>
                 <span class="s3">* which will be unaffected by the resetSkewAndRotate step.</span>
                 <span class="s3">*</span>
                 <span class="s3">* Note: This is a DOM write. Worst case scenario is this is sandwiched</span>
                 <span class="s3">* between other snapshot reads which will cause unnecessary style recalculations.</span>
                 <span class="s3">* This has to happen here though, as we don't yet know which nodes will need</span>
                 <span class="s3">* snapshots in startUpdate(), but we only want to cancel optimised animations</span>
                 <span class="s3">* if a layout animation measurement is actually going to be affected by them.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(window.MotionCancelOptimisedAnimation &amp;&amp;</span>
                    <span class="s0">!</span><span class="s1">this</span><span class="s0">.hasCheckedOptimisedAppear) {</span>
                    <span class="s0">cancelTreeOptimisedTransformAnimations(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">!</span><span class="s1">this</span><span class="s0">.root.isUpdating &amp;&amp; </span><span class="s1">this</span><span class="s0">.root.startUpdate();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLayoutDirty)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.isLayoutDirty = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.path.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.path[i];</span>
                    <span class="s0">node.shouldResetTransform = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">node.updateScroll(</span><span class="s2">&quot;snapshot&quot;</span><span class="s0">);</span>
                    <span class="s1">if </span><span class="s0">(node.options.layoutRoot) {</span>
                        <span class="s0">node.willUpdate(</span><span class="s1">false</span><span class="s0">);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ layoutId, layout } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">if </span><span class="s0">(layoutId === undefined &amp;&amp; !layout)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">transformTemplate = </span><span class="s1">this</span><span class="s0">.getTransformTemplate();</span>
                <span class="s1">this</span><span class="s0">.prevTransformTemplateValue = transformTemplate</span>
                    <span class="s0">? transformTemplate(</span><span class="s1">this</span><span class="s0">.latestValues, </span><span class="s2">&quot;&quot;</span><span class="s0">)</span>
                    <span class="s0">: undefined;</span>
                <span class="s1">this</span><span class="s0">.updateSnapshot();</span>
                <span class="s0">shouldNotifyListeners &amp;&amp; </span><span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;willUpdate&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">update() {</span>
                <span class="s1">this</span><span class="s0">.updateScheduled = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">updateWasBlocked = </span><span class="s1">this</span><span class="s0">.isUpdateBlocked();</span>
                <span class="s3">// When doing an instant transition, we skip the layout update,</span>
                <span class="s3">// but should still clean up the measurements so that the next</span>
                <span class="s3">// snapshot could be taken correctly.</span>
                <span class="s1">if </span><span class="s0">(updateWasBlocked) {</span>
                    <span class="s1">this</span><span class="s0">.unblockUpdate();</span>
                    <span class="s1">this</span><span class="s0">.clearAllSnapshots();</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(clearMeasurements);</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this is a repeat of didUpdate then ignore the animation.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.animationId &lt;= </span><span class="s1">this</span><span class="s0">.animationCommitId) {</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(clearIsLayoutDirty);</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.animationCommitId = </span><span class="s1">this</span><span class="s0">.animationId;</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isUpdating) {</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(clearIsLayoutDirty);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">this</span><span class="s0">.isUpdating = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Write</span>
                     <span class="s3">*/</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(resetTransformStyle);</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Read ==================</span>
                     <span class="s3">*/</span>
                    <span class="s3">// Update layout measurements of updated children</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(updateLayout);</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Write</span>
                     <span class="s3">*/</span>
                    <span class="s3">// Notify listeners that the layout is updated</span>
                    <span class="s1">this</span><span class="s0">.nodes.forEach(notifyLayoutUpdate);</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.clearAllSnapshots();</span>
                <span class="s3">/**</span>
                 <span class="s3">* Manually flush any pending updates. Ideally</span>
                 <span class="s3">* we could leave this to the following requestAnimationFrame but this seems</span>
                 <span class="s3">* to leave a flash of incorrectly styled content.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">now = time.now();</span>
                <span class="s0">frameData.delta = clamp(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1000 </span><span class="s0">/ </span><span class="s5">60</span><span class="s0">, now - frameData.timestamp);</span>
                <span class="s0">frameData.timestamp = now;</span>
                <span class="s0">frameData.isProcessing = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">frameSteps.update.process(frameData);</span>
                <span class="s0">frameSteps.preRender.process(frameData);</span>
                <span class="s0">frameSteps.render.process(frameData);</span>
                <span class="s0">frameData.isProcessing = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">didUpdate() {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.updateScheduled) {</span>
                    <span class="s1">this</span><span class="s0">.updateScheduled = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">microtask.read(</span><span class="s1">this</span><span class="s0">.scheduleUpdate);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">clearAllSnapshots() {</span>
                <span class="s1">this</span><span class="s0">.nodes.forEach(clearSnapshot);</span>
                <span class="s1">this</span><span class="s0">.sharedNodes.forEach(removeLeadSnapshots);</span>
            <span class="s0">}</span>
            <span class="s0">scheduleUpdateProjection() {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.projectionUpdateScheduled) {</span>
                    <span class="s1">this</span><span class="s0">.projectionUpdateScheduled = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">frame.preRender(</span><span class="s1">this</span><span class="s0">.updateProjection, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">scheduleCheckAfterUnmount() {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the unmounting node is in a layoutGroup and did trigger a willUpdate,</span>
                 <span class="s3">* we manually call didUpdate to give a chance to the siblings to animate.</span>
                 <span class="s3">* Otherwise, cleanup all snapshots to prevents future nodes from reusing them.</span>
                 <span class="s3">*/</span>
                <span class="s0">frame.postRender(() =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLayoutDirty) {</span>
                        <span class="s1">this</span><span class="s0">.root.didUpdate();</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">this</span><span class="s0">.root.checkUpdateFailed();</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Update measurements</span>
             <span class="s3">*/</span>
            <span class="s0">updateSnapshot() {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.snapshot || !</span><span class="s1">this</span><span class="s0">.instance)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.snapshot = </span><span class="s1">this</span><span class="s0">.measure();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.snapshot &amp;&amp;</span>
                    <span class="s0">!calcLength(</span><span class="s1">this</span><span class="s0">.snapshot.measuredBox.x) &amp;&amp;</span>
                    <span class="s0">!calcLength(</span><span class="s1">this</span><span class="s0">.snapshot.measuredBox.y)) {</span>
                    <span class="s1">this</span><span class="s0">.snapshot = undefined;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">updateLayout() {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.instance)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.updateScroll();</span>
                <span class="s1">if </span><span class="s0">(!(</span><span class="s1">this</span><span class="s0">.options.alwaysMeasureLayout &amp;&amp; </span><span class="s1">this</span><span class="s0">.isLead()) &amp;&amp;</span>
                    <span class="s0">!</span><span class="s1">this</span><span class="s0">.isLayoutDirty) {</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* When a node is mounted, it simply resumes from the prevLead's</span>
                 <span class="s3">* snapshot instead of taking a new one, but the ancestors scroll</span>
                 <span class="s3">* might have updated while the prevLead is unmounted. We need to</span>
                 <span class="s3">* update the scroll again to make sure the layout we measure is</span>
                 <span class="s3">* up to date.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resumeFrom &amp;&amp; !</span><span class="s1">this</span><span class="s0">.resumeFrom.instance) {</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.path.length; i++) {</span>
                        <span class="s1">const </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.path[i];</span>
                        <span class="s0">node.updateScroll();</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">prevLayout = </span><span class="s1">this</span><span class="s0">.layout;</span>
                <span class="s1">this</span><span class="s0">.layout = </span><span class="s1">this</span><span class="s0">.measure(</span><span class="s1">false</span><span class="s0">);</span>
                <span class="s1">this</span><span class="s0">.layoutCorrected = createBox();</span>
                <span class="s1">this</span><span class="s0">.isLayoutDirty = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.projectionDelta = undefined;</span>
                <span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;measure&quot;</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.layout.layoutBox);</span>
                <span class="s1">const </span><span class="s0">{ visualElement } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s0">visualElement &amp;&amp;</span>
                    <span class="s0">visualElement.notify(</span><span class="s2">&quot;LayoutMeasure&quot;</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);</span>
            <span class="s0">}</span>
            <span class="s0">updateScroll(phase = </span><span class="s2">&quot;measure&quot;</span><span class="s0">) {</span>
                <span class="s1">let </span><span class="s0">needsMeasurement = Boolean(</span><span class="s1">this</span><span class="s0">.options.layoutScroll &amp;&amp; </span><span class="s1">this</span><span class="s0">.instance);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.scroll &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.scroll.animationId === </span><span class="s1">this</span><span class="s0">.root.animationId &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.scroll.phase === phase) {</span>
                    <span class="s0">needsMeasurement = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(needsMeasurement &amp;&amp; </span><span class="s1">this</span><span class="s0">.instance) {</span>
                    <span class="s1">const </span><span class="s0">isRoot = checkIsScrollRoot(</span><span class="s1">this</span><span class="s0">.instance);</span>
                    <span class="s1">this</span><span class="s0">.scroll = {</span>
                        <span class="s0">animationId: </span><span class="s1">this</span><span class="s0">.root.animationId,</span>
                        <span class="s0">phase,</span>
                        <span class="s0">isRoot,</span>
                        <span class="s0">offset: measureScroll(</span><span class="s1">this</span><span class="s0">.instance),</span>
                        <span class="s0">wasRoot: </span><span class="s1">this</span><span class="s0">.scroll ? </span><span class="s1">this</span><span class="s0">.scroll.isRoot : isRoot,</span>
                    <span class="s0">};</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">resetTransform() {</span>
                <span class="s1">if </span><span class="s0">(!resetTransform)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">isResetRequested = </span><span class="s1">this</span><span class="s0">.isLayoutDirty ||</span>
                    <span class="s1">this</span><span class="s0">.shouldResetTransform ||</span>
                    <span class="s1">this</span><span class="s0">.options.alwaysMeasureLayout;</span>
                <span class="s1">const </span><span class="s0">hasProjection = </span><span class="s1">this</span><span class="s0">.projectionDelta &amp;&amp; !isDeltaZero(</span><span class="s1">this</span><span class="s0">.projectionDelta);</span>
                <span class="s1">const </span><span class="s0">transformTemplate = </span><span class="s1">this</span><span class="s0">.getTransformTemplate();</span>
                <span class="s1">const </span><span class="s0">transformTemplateValue = transformTemplate</span>
                    <span class="s0">? transformTemplate(</span><span class="s1">this</span><span class="s0">.latestValues, </span><span class="s2">&quot;&quot;</span><span class="s0">)</span>
                    <span class="s0">: undefined;</span>
                <span class="s1">const </span><span class="s0">transformTemplateHasChanged = transformTemplateValue !== </span><span class="s1">this</span><span class="s0">.prevTransformTemplateValue;</span>
                <span class="s1">if </span><span class="s0">(isResetRequested &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.instance &amp;&amp;</span>
                    <span class="s0">(hasProjection ||</span>
                        <span class="s0">hasTransform(</span><span class="s1">this</span><span class="s0">.latestValues) ||</span>
                        <span class="s0">transformTemplateHasChanged)) {</span>
                    <span class="s0">resetTransform(</span><span class="s1">this</span><span class="s0">.instance, transformTemplateValue);</span>
                    <span class="s1">this</span><span class="s0">.shouldResetTransform = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s1">this</span><span class="s0">.scheduleRender();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">measure(removeTransform = </span><span class="s1">true</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">pageBox = </span><span class="s1">this</span><span class="s0">.measurePageBox();</span>
                <span class="s1">let </span><span class="s0">layoutBox = </span><span class="s1">this</span><span class="s0">.removeElementScroll(pageBox);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Measurements taken during the pre-render stage</span>
                 <span class="s3">* still have transforms applied so we remove them</span>
                 <span class="s3">* via calculation.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(removeTransform) {</span>
                    <span class="s0">layoutBox = </span><span class="s1">this</span><span class="s0">.removeTransform(layoutBox);</span>
                <span class="s0">}</span>
                <span class="s0">roundBox(layoutBox);</span>
                <span class="s1">return </span><span class="s0">{</span>
                    <span class="s0">animationId: </span><span class="s1">this</span><span class="s0">.root.animationId,</span>
                    <span class="s0">measuredBox: pageBox,</span>
                    <span class="s0">layoutBox,</span>
                    <span class="s0">latestValues: {},</span>
                    <span class="s0">source: </span><span class="s1">this</span><span class="s0">.id,</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s0">measurePageBox() {</span>
                <span class="s1">const </span><span class="s0">{ visualElement } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">if </span><span class="s0">(!visualElement)</span>
                    <span class="s1">return </span><span class="s0">createBox();</span>
                <span class="s1">const </span><span class="s0">box = visualElement.measureViewportBox();</span>
                <span class="s1">const </span><span class="s0">wasInScrollRoot = </span><span class="s1">this</span><span class="s0">.scroll?.wasRoot || </span><span class="s1">this</span><span class="s0">.path.some(checkNodeWasScrollRoot);</span>
                <span class="s1">if </span><span class="s0">(!wasInScrollRoot) {</span>
                    <span class="s3">// Remove viewport scroll to give page-relative coordinates</span>
                    <span class="s1">const </span><span class="s0">{ scroll } = </span><span class="s1">this</span><span class="s0">.root;</span>
                    <span class="s1">if </span><span class="s0">(scroll) {</span>
                        <span class="s0">translateAxis(box.x, scroll.offset.x);</span>
                        <span class="s0">translateAxis(box.y, scroll.offset.y);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">box;</span>
            <span class="s0">}</span>
            <span class="s0">removeElementScroll(box) {</span>
                <span class="s1">const </span><span class="s0">boxWithoutScroll = createBox();</span>
                <span class="s0">copyBoxInto(boxWithoutScroll, box);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.scroll?.wasRoot) {</span>
                    <span class="s1">return </span><span class="s0">boxWithoutScroll;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Performance TODO: Keep a cumulative scroll offset down the tree</span>
                 <span class="s3">* rather than loop back up the path.</span>
                 <span class="s3">*/</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.path.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.path[i];</span>
                    <span class="s1">const </span><span class="s0">{ scroll, options } = node;</span>
                    <span class="s1">if </span><span class="s0">(node !== </span><span class="s1">this</span><span class="s0">.root &amp;&amp; scroll &amp;&amp; options.layoutScroll) {</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If this is a new scroll root, we want to remove all previous scrolls</span>
                         <span class="s3">* from the viewport box.</span>
                         <span class="s3">*/</span>
                        <span class="s1">if </span><span class="s0">(scroll.wasRoot) {</span>
                            <span class="s0">copyBoxInto(boxWithoutScroll, box);</span>
                        <span class="s0">}</span>
                        <span class="s0">translateAxis(boxWithoutScroll.x, scroll.offset.x);</span>
                        <span class="s0">translateAxis(boxWithoutScroll.y, scroll.offset.y);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">boxWithoutScroll;</span>
            <span class="s0">}</span>
            <span class="s0">applyTransform(box, transformOnly = </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">withTransforms = createBox();</span>
                <span class="s0">copyBoxInto(withTransforms, box);</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.path.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.path[i];</span>
                    <span class="s1">if </span><span class="s0">(!transformOnly &amp;&amp;</span>
                        <span class="s0">node.options.layoutScroll &amp;&amp;</span>
                        <span class="s0">node.scroll &amp;&amp;</span>
                        <span class="s0">node !== node.root) {</span>
                        <span class="s0">transformBox(withTransforms, {</span>
                            <span class="s0">x: -node.scroll.offset.x,</span>
                            <span class="s0">y: -node.scroll.offset.y,</span>
                        <span class="s0">});</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(!hasTransform(node.latestValues))</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">transformBox(withTransforms, node.latestValues);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(hasTransform(</span><span class="s1">this</span><span class="s0">.latestValues)) {</span>
                    <span class="s0">transformBox(withTransforms, </span><span class="s1">this</span><span class="s0">.latestValues);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">withTransforms;</span>
            <span class="s0">}</span>
            <span class="s0">removeTransform(box) {</span>
                <span class="s1">const </span><span class="s0">boxWithoutTransform = createBox();</span>
                <span class="s0">copyBoxInto(boxWithoutTransform, box);</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.path.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.path[i];</span>
                    <span class="s1">if </span><span class="s0">(!node.instance)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(!hasTransform(node.latestValues))</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">hasScale(node.latestValues) &amp;&amp; node.updateSnapshot();</span>
                    <span class="s1">const </span><span class="s0">sourceBox = createBox();</span>
                    <span class="s1">const </span><span class="s0">nodeBox = node.measurePageBox();</span>
                    <span class="s0">copyBoxInto(sourceBox, nodeBox);</span>
                    <span class="s0">removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(hasTransform(</span><span class="s1">this</span><span class="s0">.latestValues)) {</span>
                    <span class="s0">removeBoxTransforms(boxWithoutTransform, </span><span class="s1">this</span><span class="s0">.latestValues);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">boxWithoutTransform;</span>
            <span class="s0">}</span>
            <span class="s0">setTargetDelta(delta) {</span>
                <span class="s1">this</span><span class="s0">.targetDelta = delta;</span>
                <span class="s1">this</span><span class="s0">.root.scheduleUpdateProjection();</span>
                <span class="s1">this</span><span class="s0">.isProjectionDirty = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">setOptions(options) {</span>
                <span class="s1">this</span><span class="s0">.options = {</span>
                    <span class="s0">...</span><span class="s1">this</span><span class="s0">.options,</span>
                    <span class="s0">...options,</span>
                    <span class="s0">crossfade: options.crossfade !== undefined ? options.crossfade : </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s0">clearMeasurements() {</span>
                <span class="s1">this</span><span class="s0">.scroll = undefined;</span>
                <span class="s1">this</span><span class="s0">.layout = undefined;</span>
                <span class="s1">this</span><span class="s0">.snapshot = undefined;</span>
                <span class="s1">this</span><span class="s0">.prevTransformTemplateValue = undefined;</span>
                <span class="s1">this</span><span class="s0">.targetDelta = undefined;</span>
                <span class="s1">this</span><span class="s0">.target = undefined;</span>
                <span class="s1">this</span><span class="s0">.isLayoutDirty = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">forceRelativeParentToResolveTarget() {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.relativeParent)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the parent target isn't up-to-date, force it to update.</span>
                 <span class="s3">* This is an unfortunate de-optimisation as it means any updating relative</span>
                 <span class="s3">* projection will cause all the relative parents to recalculate back</span>
                 <span class="s3">* up the tree.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.relativeParent.resolvedRelativeTargetAt !==</span>
                    <span class="s0">frameData.timestamp) {</span>
                    <span class="s1">this</span><span class="s0">.relativeParent.resolveTargetDelta(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">resolveTargetDelta(forceRecalculation = </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* Once the dirty status of nodes has been spread through the tree, we also</span>
                 <span class="s3">* need to check if we have a shared node of a different depth that has itself</span>
                 <span class="s3">* been dirtied.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">lead = </span><span class="s1">this</span><span class="s0">.getLead();</span>
                <span class="s1">this</span><span class="s0">.isProjectionDirty || (</span><span class="s1">this</span><span class="s0">.isProjectionDirty = lead.isProjectionDirty);</span>
                <span class="s1">this</span><span class="s0">.isTransformDirty || (</span><span class="s1">this</span><span class="s0">.isTransformDirty = lead.isTransformDirty);</span>
                <span class="s1">this</span><span class="s0">.isSharedProjectionDirty || (</span><span class="s1">this</span><span class="s0">.isSharedProjectionDirty = lead.isSharedProjectionDirty);</span>
                <span class="s1">const </span><span class="s0">isShared = Boolean(</span><span class="s1">this</span><span class="s0">.resumingFrom) || </span><span class="s1">this </span><span class="s0">!== lead;</span>
                <span class="s3">/**</span>
                 <span class="s3">* We don't use transform for this step of processing so we don't</span>
                 <span class="s3">* need to check whether any nodes have changed transform.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">canSkip = !(forceRecalculation ||</span>
                    <span class="s0">(isShared &amp;&amp; </span><span class="s1">this</span><span class="s0">.isSharedProjectionDirty) ||</span>
                    <span class="s1">this</span><span class="s0">.isProjectionDirty ||</span>
                    <span class="s1">this</span><span class="s0">.parent?.isProjectionDirty ||</span>
                    <span class="s1">this</span><span class="s0">.attemptToResolveRelativeTarget ||</span>
                    <span class="s1">this</span><span class="s0">.root.updateBlockedByResize);</span>
                <span class="s1">if </span><span class="s0">(canSkip)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ layout, layoutId } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we have no layout, we can't perform projection, so early return</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.layout || !(layout || layoutId))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.resolvedRelativeTargetAt = frameData.timestamp;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we don't have a targetDelta but do have a layout, we can attempt to resolve</span>
                 <span class="s3">* a relativeParent. This will allow a component to perform scale correction</span>
                 <span class="s3">* even if no animation has started.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.targetDelta &amp;&amp; !</span><span class="s1">this</span><span class="s0">.relativeTarget) {</span>
                    <span class="s1">const </span><span class="s0">relativeParent = </span><span class="s1">this</span><span class="s0">.getClosestProjectingParent();</span>
                    <span class="s1">if </span><span class="s0">(relativeParent &amp;&amp;</span>
                        <span class="s0">relativeParent.layout &amp;&amp;</span>
                        <span class="s1">this</span><span class="s0">.animationProgress !== </span><span class="s5">1</span><span class="s0">) {</span>
                        <span class="s1">this</span><span class="s0">.relativeParent = relativeParent;</span>
                        <span class="s1">this</span><span class="s0">.forceRelativeParentToResolveTarget();</span>
                        <span class="s1">this</span><span class="s0">.relativeTarget = createBox();</span>
                        <span class="s1">this</span><span class="s0">.relativeTargetOrigin = createBox();</span>
                        <span class="s0">calcRelativePosition(</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin, </span><span class="s1">this</span><span class="s0">.layout.layoutBox, relativeParent.layout.layoutBox);</span>
                        <span class="s0">copyBoxInto(</span><span class="s1">this</span><span class="s0">.relativeTarget, </span><span class="s1">this</span><span class="s0">.relativeTargetOrigin);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">this</span><span class="s0">.relativeParent = </span><span class="s1">this</span><span class="s0">.relativeTarget = undefined;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we have no relative target or no target delta our target isn't valid</span>
                 <span class="s3">* for this frame.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.relativeTarget &amp;&amp; !</span><span class="s1">this</span><span class="s0">.targetDelta)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Lazy-init target data structure</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.target) {</span>
                    <span class="s1">this</span><span class="s0">.target = createBox();</span>
                    <span class="s1">this</span><span class="s0">.targetWithTransforms = createBox();</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we've got a relative box for this component, resolve it into a target relative to the parent.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.relativeTarget &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.relativeTargetOrigin &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.relativeParent &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.relativeParent.target) {</span>
                    <span class="s1">this</span><span class="s0">.forceRelativeParentToResolveTarget();</span>
                    <span class="s0">calcRelativeBox(</span><span class="s1">this</span><span class="s0">.target, </span><span class="s1">this</span><span class="s0">.relativeTarget, </span><span class="s1">this</span><span class="s0">.relativeParent.target);</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If we've only got a targetDelta, resolve it into a target</span>
                     <span class="s3">*/</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.targetDelta) {</span>
                    <span class="s1">if </span><span class="s0">(Boolean(</span><span class="s1">this</span><span class="s0">.resumingFrom)) {</span>
                        <span class="s3">// TODO: This is creating a new object every frame</span>
                        <span class="s1">this</span><span class="s0">.target = </span><span class="s1">this</span><span class="s0">.applyTransform(</span><span class="s1">this</span><span class="s0">.layout.layoutBox);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">copyBoxInto(</span><span class="s1">this</span><span class="s0">.target, </span><span class="s1">this</span><span class="s0">.layout.layoutBox);</span>
                    <span class="s0">}</span>
                    <span class="s0">applyBoxDelta(</span><span class="s1">this</span><span class="s0">.target, </span><span class="s1">this</span><span class="s0">.targetDelta);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If no target, use own layout as target</span>
                     <span class="s3">*/</span>
                    <span class="s0">copyBoxInto(</span><span class="s1">this</span><span class="s0">.target, </span><span class="s1">this</span><span class="s0">.layout.layoutBox);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we've been told to attempt to resolve a relative target, do so.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.attemptToResolveRelativeTarget) {</span>
                    <span class="s1">this</span><span class="s0">.attemptToResolveRelativeTarget = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">relativeParent = </span><span class="s1">this</span><span class="s0">.getClosestProjectingParent();</span>
                    <span class="s1">if </span><span class="s0">(relativeParent &amp;&amp;</span>
                        <span class="s0">Boolean(relativeParent.resumingFrom) ===</span>
                            <span class="s0">Boolean(</span><span class="s1">this</span><span class="s0">.resumingFrom) &amp;&amp;</span>
                        <span class="s0">!relativeParent.options.layoutScroll &amp;&amp;</span>
                        <span class="s0">relativeParent.target &amp;&amp;</span>
                        <span class="s1">this</span><span class="s0">.animationProgress !== </span><span class="s5">1</span><span class="s0">) {</span>
                        <span class="s1">this</span><span class="s0">.relativeParent = relativeParent;</span>
                        <span class="s1">this</span><span class="s0">.forceRelativeParentToResolveTarget();</span>
                        <span class="s1">this</span><span class="s0">.relativeTarget = createBox();</span>
                        <span class="s1">this</span><span class="s0">.relativeTargetOrigin = createBox();</span>
                        <span class="s0">calcRelativePosition(</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin, </span><span class="s1">this</span><span class="s0">.target, relativeParent.target);</span>
                        <span class="s0">copyBoxInto(</span><span class="s1">this</span><span class="s0">.relativeTarget, </span><span class="s1">this</span><span class="s0">.relativeTargetOrigin);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">this</span><span class="s0">.relativeParent = </span><span class="s1">this</span><span class="s0">.relativeTarget = undefined;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Increase debug counter for resolved target deltas</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
                    <span class="s0">metrics.calculatedTargetDeltas++;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">getClosestProjectingParent() {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.parent ||</span>
                    <span class="s0">hasScale(</span><span class="s1">this</span><span class="s0">.parent.latestValues) ||</span>
                    <span class="s0">has2DTranslate(</span><span class="s1">this</span><span class="s0">.parent.latestValues)) {</span>
                    <span class="s1">return </span><span class="s0">undefined;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parent.isProjecting()) {</span>
                    <span class="s1">return this</span><span class="s0">.parent;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">return this</span><span class="s0">.parent.getClosestProjectingParent();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">isProjecting() {</span>
                <span class="s1">return </span><span class="s0">Boolean((</span><span class="s1">this</span><span class="s0">.relativeTarget ||</span>
                    <span class="s1">this</span><span class="s0">.targetDelta ||</span>
                    <span class="s1">this</span><span class="s0">.options.layoutRoot) &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.layout);</span>
            <span class="s0">}</span>
            <span class="s0">calcProjection() {</span>
                <span class="s1">const </span><span class="s0">lead = </span><span class="s1">this</span><span class="s0">.getLead();</span>
                <span class="s1">const </span><span class="s0">isShared = Boolean(</span><span class="s1">this</span><span class="s0">.resumingFrom) || </span><span class="s1">this </span><span class="s0">!== lead;</span>
                <span class="s1">let </span><span class="s0">canSkip = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this is a normal layout animation and neither this node nor its nearest projecting</span>
                 <span class="s3">* is dirty then we can't skip.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isProjectionDirty || </span><span class="s1">this</span><span class="s0">.parent?.isProjectionDirty) {</span>
                    <span class="s0">canSkip = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this is a shared layout animation and this node's shared projection is dirty then</span>
                 <span class="s3">* we can't skip.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(isShared &amp;&amp;</span>
                    <span class="s0">(</span><span class="s1">this</span><span class="s0">.isSharedProjectionDirty || </span><span class="s1">this</span><span class="s0">.isTransformDirty)) {</span>
                    <span class="s0">canSkip = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we have resolved the target this frame we must recalculate the</span>
                 <span class="s3">* projection to ensure it visually represents the internal calculations.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resolvedRelativeTargetAt === frameData.timestamp) {</span>
                    <span class="s0">canSkip = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(canSkip)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ layout, layoutId } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this section of the tree isn't animating we can</span>
                 <span class="s3">* delete our target sources for the following frame.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.isTreeAnimating = Boolean((</span><span class="s1">this</span><span class="s0">.parent &amp;&amp; </span><span class="s1">this</span><span class="s0">.parent.isTreeAnimating) ||</span>
                    <span class="s1">this</span><span class="s0">.currentAnimation ||</span>
                    <span class="s1">this</span><span class="s0">.pendingAnimation);</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isTreeAnimating) {</span>
                    <span class="s1">this</span><span class="s0">.targetDelta = </span><span class="s1">this</span><span class="s0">.relativeTarget = undefined;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.layout || !(layout || layoutId))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Reset the corrected box with the latest values from box, as we're then going</span>
                 <span class="s3">* to perform mutative operations on it.</span>
                 <span class="s3">*/</span>
                <span class="s0">copyBoxInto(</span><span class="s1">this</span><span class="s0">.layoutCorrected, </span><span class="s1">this</span><span class="s0">.layout.layoutBox);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Record previous tree scales before updating.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">prevTreeScaleX = </span><span class="s1">this</span><span class="s0">.treeScale.x;</span>
                <span class="s1">const </span><span class="s0">prevTreeScaleY = </span><span class="s1">this</span><span class="s0">.treeScale.y;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Apply all the parent deltas to this box to produce the corrected box. This</span>
                 <span class="s3">* is the layout box, as it will appear on screen as a result of the transforms of its parents.</span>
                 <span class="s3">*/</span>
                <span class="s0">applyTreeDeltas(</span><span class="s1">this</span><span class="s0">.layoutCorrected, </span><span class="s1">this</span><span class="s0">.treeScale, </span><span class="s1">this</span><span class="s0">.path, isShared);</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this layer needs to perform scale correction but doesn't have a target,</span>
                 <span class="s3">* use the layout as the target.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(lead.layout &amp;&amp;</span>
                    <span class="s0">!lead.target &amp;&amp;</span>
                    <span class="s0">(</span><span class="s1">this</span><span class="s0">.treeScale.x !== </span><span class="s5">1 </span><span class="s0">|| </span><span class="s1">this</span><span class="s0">.treeScale.y !== </span><span class="s5">1</span><span class="s0">)) {</span>
                    <span class="s0">lead.target = lead.layout.layoutBox;</span>
                    <span class="s0">lead.targetWithTransforms = createBox();</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ target } = lead;</span>
                <span class="s1">if </span><span class="s0">(!target) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If we don't have a target to project into, but we were previously</span>
                     <span class="s3">* projecting, we want to remove the stored transform and schedule</span>
                     <span class="s3">* a render to ensure the elements reflect the removed transform.</span>
                     <span class="s3">*/</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.prevProjectionDelta) {</span>
                        <span class="s1">this</span><span class="s0">.createProjectionDeltas();</span>
                        <span class="s1">this</span><span class="s0">.scheduleRender();</span>
                    <span class="s0">}</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.projectionDelta || !</span><span class="s1">this</span><span class="s0">.prevProjectionDelta) {</span>
                    <span class="s1">this</span><span class="s0">.createProjectionDeltas();</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">copyAxisDeltaInto(</span><span class="s1">this</span><span class="s0">.prevProjectionDelta.x, </span><span class="s1">this</span><span class="s0">.projectionDelta.x);</span>
                    <span class="s0">copyAxisDeltaInto(</span><span class="s1">this</span><span class="s0">.prevProjectionDelta.y, </span><span class="s1">this</span><span class="s0">.projectionDelta.y);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Update the delta between the corrected box and the target box before user-set transforms were applied.</span>
                 <span class="s3">* This will allow us to calculate the corrected borderRadius and boxShadow to compensate</span>
                 <span class="s3">* for our layout reprojection, but still allow them to be scaled correctly by the user.</span>
                 <span class="s3">* It might be that to simplify this we may want to accept that user-set scale is also corrected</span>
                 <span class="s3">* and we wouldn't have to keep and calc both deltas, OR we could support a user setting</span>
                 <span class="s3">* to allow people to choose whether these styles are corrected based on just the</span>
                 <span class="s3">* layout reprojection or the final bounding box.</span>
                 <span class="s3">*/</span>
                <span class="s0">calcBoxDelta(</span><span class="s1">this</span><span class="s0">.projectionDelta, </span><span class="s1">this</span><span class="s0">.layoutCorrected, target, </span><span class="s1">this</span><span class="s0">.latestValues);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.treeScale.x !== prevTreeScaleX ||</span>
                    <span class="s1">this</span><span class="s0">.treeScale.y !== prevTreeScaleY ||</span>
                    <span class="s0">!axisDeltaEquals(</span><span class="s1">this</span><span class="s0">.projectionDelta.x, </span><span class="s1">this</span><span class="s0">.prevProjectionDelta.x) ||</span>
                    <span class="s0">!axisDeltaEquals(</span><span class="s1">this</span><span class="s0">.projectionDelta.y, </span><span class="s1">this</span><span class="s0">.prevProjectionDelta.y)) {</span>
                    <span class="s1">this</span><span class="s0">.hasProjected = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">this</span><span class="s0">.scheduleRender();</span>
                    <span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;projectionUpdate&quot;</span><span class="s0">, target);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Increase debug counter for recalculated projections</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
                    <span class="s0">metrics.calculatedProjections++;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">hide() {</span>
                <span class="s1">this</span><span class="s0">.isVisible = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">// TODO: Schedule render</span>
            <span class="s0">}</span>
            <span class="s0">show() {</span>
                <span class="s1">this</span><span class="s0">.isVisible = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s3">// TODO: Schedule render</span>
            <span class="s0">}</span>
            <span class="s0">scheduleRender(notifyAll = </span><span class="s1">true</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.options.visualElement?.scheduleRender();</span>
                <span class="s1">if </span><span class="s0">(notifyAll) {</span>
                    <span class="s1">const </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.getStack();</span>
                    <span class="s0">stack &amp;&amp; stack.scheduleRender();</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resumingFrom &amp;&amp; !</span><span class="s1">this</span><span class="s0">.resumingFrom.instance) {</span>
                    <span class="s1">this</span><span class="s0">.resumingFrom = undefined;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">createProjectionDeltas() {</span>
                <span class="s1">this</span><span class="s0">.prevProjectionDelta = createDelta();</span>
                <span class="s1">this</span><span class="s0">.projectionDelta = createDelta();</span>
                <span class="s1">this</span><span class="s0">.projectionDeltaWithTransform = createDelta();</span>
            <span class="s0">}</span>
            <span class="s0">setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">snapshot = </span><span class="s1">this</span><span class="s0">.snapshot;</span>
                <span class="s1">const </span><span class="s0">snapshotLatestValues = snapshot ? snapshot.latestValues : {};</span>
                <span class="s1">const </span><span class="s0">mixedValues = { ...</span><span class="s1">this</span><span class="s0">.latestValues };</span>
                <span class="s1">const </span><span class="s0">targetDelta = createDelta();</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.relativeParent ||</span>
                    <span class="s0">!</span><span class="s1">this</span><span class="s0">.relativeParent.options.layoutRoot) {</span>
                    <span class="s1">this</span><span class="s0">.relativeTarget = </span><span class="s1">this</span><span class="s0">.relativeTargetOrigin = undefined;</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;</span>
                <span class="s1">const </span><span class="s0">relativeLayout = createBox();</span>
                <span class="s1">const </span><span class="s0">snapshotSource = snapshot ? snapshot.source : undefined;</span>
                <span class="s1">const </span><span class="s0">layoutSource = </span><span class="s1">this</span><span class="s0">.layout ? </span><span class="s1">this</span><span class="s0">.layout.source : undefined;</span>
                <span class="s1">const </span><span class="s0">isSharedLayoutAnimation = snapshotSource !== layoutSource;</span>
                <span class="s1">const </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.getStack();</span>
                <span class="s1">const </span><span class="s0">isOnlyMember = !stack || stack.members.length &lt;= </span><span class="s5">1</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &amp;&amp;</span>
                    <span class="s0">!isOnlyMember &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.options.crossfade === </span><span class="s1">true </span><span class="s0">&amp;&amp;</span>
                    <span class="s0">!</span><span class="s1">this</span><span class="s0">.path.some(hasOpacityCrossfade));</span>
                <span class="s1">this</span><span class="s0">.animationProgress = </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s1">let </span><span class="s0">prevRelativeTarget;</span>
                <span class="s1">this</span><span class="s0">.mixTargetDelta = (latest) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">progress = latest / </span><span class="s5">1000</span><span class="s0">;</span>
                    <span class="s0">mixAxisDelta(targetDelta.x, delta.x, progress);</span>
                    <span class="s0">mixAxisDelta(targetDelta.y, delta.y, progress);</span>
                    <span class="s1">this</span><span class="s0">.setTargetDelta(targetDelta);</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.relativeTarget &amp;&amp;</span>
                        <span class="s1">this</span><span class="s0">.relativeTargetOrigin &amp;&amp;</span>
                        <span class="s1">this</span><span class="s0">.layout &amp;&amp;</span>
                        <span class="s1">this</span><span class="s0">.relativeParent &amp;&amp;</span>
                        <span class="s1">this</span><span class="s0">.relativeParent.layout) {</span>
                        <span class="s0">calcRelativePosition(relativeLayout, </span><span class="s1">this</span><span class="s0">.layout.layoutBox, </span><span class="s1">this</span><span class="s0">.relativeParent.layout.layoutBox);</span>
                        <span class="s0">mixBox(</span><span class="s1">this</span><span class="s0">.relativeTarget, </span><span class="s1">this</span><span class="s0">.relativeTargetOrigin, relativeLayout, progress);</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If this is an unchanged relative target we can consider the</span>
                         <span class="s3">* projection not dirty.</span>
                         <span class="s3">*/</span>
                        <span class="s1">if </span><span class="s0">(prevRelativeTarget &amp;&amp;</span>
                            <span class="s0">boxEquals(</span><span class="s1">this</span><span class="s0">.relativeTarget, prevRelativeTarget)) {</span>
                            <span class="s1">this</span><span class="s0">.isProjectionDirty = </span><span class="s1">false</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(!prevRelativeTarget)</span>
                            <span class="s0">prevRelativeTarget = createBox();</span>
                        <span class="s0">copyBoxInto(prevRelativeTarget, </span><span class="s1">this</span><span class="s0">.relativeTarget);</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(isSharedLayoutAnimation) {</span>
                        <span class="s1">this</span><span class="s0">.animationValues = mixedValues;</span>
                        <span class="s0">mixValues(mixedValues, snapshotLatestValues, </span><span class="s1">this</span><span class="s0">.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);</span>
                    <span class="s0">}</span>
                    <span class="s1">this</span><span class="s0">.root.scheduleUpdateProjection();</span>
                    <span class="s1">this</span><span class="s0">.scheduleRender();</span>
                    <span class="s1">this</span><span class="s0">.animationProgress = progress;</span>
                <span class="s0">};</span>
                <span class="s1">this</span><span class="s0">.mixTargetDelta(</span><span class="s1">this</span><span class="s0">.options.layoutRoot ? </span><span class="s5">1000 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">startAnimation(options) {</span>
                <span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;animationStart&quot;</span><span class="s0">);</span>
                <span class="s1">this</span><span class="s0">.currentAnimation?.stop();</span>
                <span class="s1">this</span><span class="s0">.resumingFrom?.currentAnimation?.stop();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.pendingAnimation) {</span>
                    <span class="s0">cancelFrame(</span><span class="s1">this</span><span class="s0">.pendingAnimation);</span>
                    <span class="s1">this</span><span class="s0">.pendingAnimation = undefined;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Start the animation in the next frame to have a frame with progress 0,</span>
                 <span class="s3">* where the target is the same as when the animation started, so we can</span>
                 <span class="s3">* calculate the relative positions correctly for instant transitions.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.pendingAnimation = frame.update(() =&gt; {</span>
                    <span class="s0">globalProjectionState.hasAnimatedSinceResize = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">activeAnimations.layout++;</span>
                    <span class="s1">this</span><span class="s0">.motionValue || (</span><span class="s1">this</span><span class="s0">.motionValue = motionValue(</span><span class="s5">0</span><span class="s0">));</span>
                    <span class="s1">this</span><span class="s0">.currentAnimation = animateSingleValue(</span><span class="s1">this</span><span class="s0">.motionValue, [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1000</span><span class="s0">], {</span>
                        <span class="s0">...options,</span>
                        <span class="s0">velocity: </span><span class="s5">0</span><span class="s0">,</span>
                        <span class="s0">isSync: </span><span class="s1">true</span><span class="s0">,</span>
                        <span class="s0">onUpdate: (latest) =&gt; {</span>
                            <span class="s1">this</span><span class="s0">.mixTargetDelta(latest);</span>
                            <span class="s0">options.onUpdate &amp;&amp; options.onUpdate(latest);</span>
                        <span class="s0">},</span>
                        <span class="s0">onStop: () =&gt; {</span>
                            <span class="s0">activeAnimations.layout--;</span>
                        <span class="s0">},</span>
                        <span class="s0">onComplete: () =&gt; {</span>
                            <span class="s0">activeAnimations.layout--;</span>
                            <span class="s0">options.onComplete &amp;&amp; options.onComplete();</span>
                            <span class="s1">this</span><span class="s0">.completeAnimation();</span>
                        <span class="s0">},</span>
                    <span class="s0">});</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resumingFrom) {</span>
                        <span class="s1">this</span><span class="s0">.resumingFrom.currentAnimation = </span><span class="s1">this</span><span class="s0">.currentAnimation;</span>
                    <span class="s0">}</span>
                    <span class="s1">this</span><span class="s0">.pendingAnimation = undefined;</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">completeAnimation() {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resumingFrom) {</span>
                    <span class="s1">this</span><span class="s0">.resumingFrom.currentAnimation = undefined;</span>
                    <span class="s1">this</span><span class="s0">.resumingFrom.preserveOpacity = undefined;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.getStack();</span>
                <span class="s0">stack &amp;&amp; stack.exitAnimationComplete();</span>
                <span class="s1">this</span><span class="s0">.resumingFrom =</span>
                    <span class="s1">this</span><span class="s0">.currentAnimation =</span>
                        <span class="s1">this</span><span class="s0">.animationValues =</span>
                            <span class="s0">undefined;</span>
                <span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;animationComplete&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">finishAnimation() {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentAnimation) {</span>
                    <span class="s1">this</span><span class="s0">.mixTargetDelta &amp;&amp; </span><span class="s1">this</span><span class="s0">.mixTargetDelta(animationTarget);</span>
                    <span class="s1">this</span><span class="s0">.currentAnimation.stop();</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.completeAnimation();</span>
            <span class="s0">}</span>
            <span class="s0">applyTransformsToTarget() {</span>
                <span class="s1">const </span><span class="s0">lead = </span><span class="s1">this</span><span class="s0">.getLead();</span>
                <span class="s1">let </span><span class="s0">{ targetWithTransforms, target, layout, latestValues } = lead;</span>
                <span class="s1">if </span><span class="s0">(!targetWithTransforms || !target || !layout)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're only animating position, and this element isn't the lead element,</span>
                 <span class="s3">* then instead of projecting into the lead box we instead want to calculate</span>
                 <span class="s3">* a new target that aligns the two boxes but maintains the layout shape.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this </span><span class="s0">!== lead &amp;&amp;</span>
                    <span class="s1">this</span><span class="s0">.layout &amp;&amp;</span>
                    <span class="s0">layout &amp;&amp;</span>
                    <span class="s0">shouldAnimatePositionOnly(</span><span class="s1">this</span><span class="s0">.options.animationType, </span><span class="s1">this</span><span class="s0">.layout.layoutBox, layout.layoutBox)) {</span>
                    <span class="s0">target = </span><span class="s1">this</span><span class="s0">.target || createBox();</span>
                    <span class="s1">const </span><span class="s0">xLength = calcLength(</span><span class="s1">this</span><span class="s0">.layout.layoutBox.x);</span>
                    <span class="s0">target.x.min = lead.target.x.min;</span>
                    <span class="s0">target.x.max = target.x.min + xLength;</span>
                    <span class="s1">const </span><span class="s0">yLength = calcLength(</span><span class="s1">this</span><span class="s0">.layout.layoutBox.y);</span>
                    <span class="s0">target.y.min = lead.target.y.min;</span>
                    <span class="s0">target.y.max = target.y.min + yLength;</span>
                <span class="s0">}</span>
                <span class="s0">copyBoxInto(targetWithTransforms, target);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.</span>
                 <span class="s3">* This is the final box that we will then project into by calculating a transform delta and</span>
                 <span class="s3">* applying it to the corrected box.</span>
                 <span class="s3">*/</span>
                <span class="s0">transformBox(targetWithTransforms, latestValues);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Update the delta between the corrected box and the final target box, after</span>
                 <span class="s3">* user-set transforms are applied to it. This will be used by the renderer to</span>
                 <span class="s3">* create a transform style that will reproject the element from its layout layout</span>
                 <span class="s3">* into the desired bounding box.</span>
                 <span class="s3">*/</span>
                <span class="s0">calcBoxDelta(</span><span class="s1">this</span><span class="s0">.projectionDeltaWithTransform, </span><span class="s1">this</span><span class="s0">.layoutCorrected, targetWithTransforms, latestValues);</span>
            <span class="s0">}</span>
            <span class="s0">registerSharedNode(layoutId, node) {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.sharedNodes.has(layoutId)) {</span>
                    <span class="s1">this</span><span class="s0">.sharedNodes.set(layoutId, </span><span class="s1">new </span><span class="s0">NodeStack());</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.sharedNodes.get(layoutId);</span>
                <span class="s0">stack.add(node);</span>
                <span class="s1">const </span><span class="s0">config = node.options.initialPromotionConfig;</span>
                <span class="s0">node.promote({</span>
                    <span class="s0">transition: config ? config.transition : undefined,</span>
                    <span class="s0">preserveFollowOpacity: config &amp;&amp; config.shouldPreserveFollowOpacity</span>
                        <span class="s0">? config.shouldPreserveFollowOpacity(node)</span>
                        <span class="s0">: undefined,</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">isLead() {</span>
                <span class="s1">const </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.getStack();</span>
                <span class="s1">return </span><span class="s0">stack ? stack.lead === </span><span class="s1">this </span><span class="s0">: </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">getLead() {</span>
                <span class="s1">const </span><span class="s0">{ layoutId } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">return </span><span class="s0">layoutId ? </span><span class="s1">this</span><span class="s0">.getStack()?.lead || </span><span class="s1">this </span><span class="s0">: </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">getPrevLead() {</span>
                <span class="s1">const </span><span class="s0">{ layoutId } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">return </span><span class="s0">layoutId ? </span><span class="s1">this</span><span class="s0">.getStack()?.prevLead : undefined;</span>
            <span class="s0">}</span>
            <span class="s0">getStack() {</span>
                <span class="s1">const </span><span class="s0">{ layoutId } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">if </span><span class="s0">(layoutId)</span>
                    <span class="s1">return this</span><span class="s0">.root.sharedNodes.get(layoutId);</span>
            <span class="s0">}</span>
            <span class="s0">promote({ needsReset, transition, preserveFollowOpacity, } = {}) {</span>
                <span class="s1">const </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.getStack();</span>
                <span class="s1">if </span><span class="s0">(stack)</span>
                    <span class="s0">stack.promote(</span><span class="s1">this</span><span class="s0">, preserveFollowOpacity);</span>
                <span class="s1">if </span><span class="s0">(needsReset) {</span>
                    <span class="s1">this</span><span class="s0">.projectionDelta = undefined;</span>
                    <span class="s1">this</span><span class="s0">.needsReset = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(transition)</span>
                    <span class="s1">this</span><span class="s0">.setOptions({ transition });</span>
            <span class="s0">}</span>
            <span class="s0">relegate() {</span>
                <span class="s1">const </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.getStack();</span>
                <span class="s1">if </span><span class="s0">(stack) {</span>
                    <span class="s1">return </span><span class="s0">stack.relegate(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">return false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">resetSkewAndRotation() {</span>
                <span class="s1">const </span><span class="s0">{ visualElement } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">if </span><span class="s0">(!visualElement)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s3">// If there's no detected skew or rotation values, we can early return without a forced render.</span>
                <span class="s1">let </span><span class="s0">hasDistortingTransform = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* An unrolled check for rotation values. Most elements don't have any rotation and</span>
                 <span class="s3">* skipping the nested loop and new object creation is 50% faster.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">{ latestValues } = visualElement;</span>
                <span class="s1">if </span><span class="s0">(latestValues.z ||</span>
                    <span class="s0">latestValues.rotate ||</span>
                    <span class="s0">latestValues.rotateX ||</span>
                    <span class="s0">latestValues.rotateY ||</span>
                    <span class="s0">latestValues.rotateZ ||</span>
                    <span class="s0">latestValues.skewX ||</span>
                    <span class="s0">latestValues.skewY) {</span>
                    <span class="s0">hasDistortingTransform = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">// If there's no distorting values, we don't need to do any more.</span>
                <span class="s1">if </span><span class="s0">(!hasDistortingTransform)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">resetValues = {};</span>
                <span class="s1">if </span><span class="s0">(latestValues.z) {</span>
                    <span class="s0">resetDistortingTransform(</span><span class="s2">&quot;z&quot;</span><span class="s0">, visualElement, resetValues, </span><span class="s1">this</span><span class="s0">.animationValues);</span>
                <span class="s0">}</span>
                <span class="s3">// Check the skew and rotate value of all axes and reset to 0</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; transformAxes.length; i++) {</span>
                    <span class="s0">resetDistortingTransform(</span><span class="s2">`rotate</span><span class="s0">${transformAxes[i]}</span><span class="s2">`</span><span class="s0">, visualElement, resetValues, </span><span class="s1">this</span><span class="s0">.animationValues);</span>
                    <span class="s0">resetDistortingTransform(</span><span class="s2">`skew</span><span class="s0">${transformAxes[i]}</span><span class="s2">`</span><span class="s0">, visualElement, resetValues, </span><span class="s1">this</span><span class="s0">.animationValues);</span>
                <span class="s0">}</span>
                <span class="s3">// Force a render of this element to apply the transform with all skews and rotations</span>
                <span class="s3">// set to 0.</span>
                <span class="s0">visualElement.render();</span>
                <span class="s3">// Put back all the values we reset</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">resetValues) {</span>
                    <span class="s0">visualElement.setStaticValue(key, resetValues[key]);</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.animationValues) {</span>
                        <span class="s1">this</span><span class="s0">.animationValues[key] = resetValues[key];</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s3">// Schedule a render for the next frame. This ensures we won't visually</span>
                <span class="s3">// see the element with the reset rotate value applied.</span>
                <span class="s0">visualElement.scheduleRender();</span>
            <span class="s0">}</span>
            <span class="s0">applyProjectionStyles(targetStyle, </span><span class="s3">// CSSStyleDeclaration - doesn't allow numbers to be assigned to properties</span>
            <span class="s0">styleProp) {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.instance || </span><span class="s1">this</span><span class="s0">.isSVG)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isVisible) {</span>
                    <span class="s0">targetStyle.visibility = </span><span class="s2">&quot;hidden&quot;</span><span class="s0">;</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">transformTemplate = </span><span class="s1">this</span><span class="s0">.getTransformTemplate();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.needsReset) {</span>
                    <span class="s1">this</span><span class="s0">.needsReset = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">targetStyle.visibility = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                    <span class="s0">targetStyle.opacity = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                    <span class="s0">targetStyle.pointerEvents =</span>
                        <span class="s0">resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                    <span class="s0">targetStyle.transform = transformTemplate</span>
                        <span class="s0">? transformTemplate(</span><span class="s1">this</span><span class="s0">.latestValues, </span><span class="s2">&quot;&quot;</span><span class="s0">)</span>
                        <span class="s0">: </span><span class="s2">&quot;none&quot;</span><span class="s0">;</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">lead = </span><span class="s1">this</span><span class="s0">.getLead();</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.projectionDelta || !</span><span class="s1">this</span><span class="s0">.layout || !lead.target) {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.layoutId) {</span>
                        <span class="s0">targetStyle.opacity =</span>
                            <span class="s1">this</span><span class="s0">.latestValues.opacity !== undefined</span>
                                <span class="s0">? </span><span class="s1">this</span><span class="s0">.latestValues.opacity</span>
                                <span class="s0">: </span><span class="s5">1</span><span class="s0">;</span>
                        <span class="s0">targetStyle.pointerEvents =</span>
                            <span class="s0">resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasProjected &amp;&amp; !hasTransform(</span><span class="s1">this</span><span class="s0">.latestValues)) {</span>
                        <span class="s0">targetStyle.transform = transformTemplate</span>
                            <span class="s0">? transformTemplate({}, </span><span class="s2">&quot;&quot;</span><span class="s0">)</span>
                            <span class="s0">: </span><span class="s2">&quot;none&quot;</span><span class="s0">;</span>
                        <span class="s1">this</span><span class="s0">.hasProjected = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">targetStyle.visibility = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">valuesToRender = lead.animationValues || lead.latestValues;</span>
                <span class="s1">this</span><span class="s0">.applyTransformsToTarget();</span>
                <span class="s1">let </span><span class="s0">transform = buildProjectionTransform(</span><span class="s1">this</span><span class="s0">.projectionDeltaWithTransform, </span><span class="s1">this</span><span class="s0">.treeScale, valuesToRender);</span>
                <span class="s1">if </span><span class="s0">(transformTemplate) {</span>
                    <span class="s0">transform = transformTemplate(valuesToRender, transform);</span>
                <span class="s0">}</span>
                <span class="s0">targetStyle.transform = transform;</span>
                <span class="s1">const </span><span class="s0">{ x, y } = </span><span class="s1">this</span><span class="s0">.projectionDelta;</span>
                <span class="s0">targetStyle.transformOrigin = </span><span class="s2">`</span><span class="s0">${x.origin * </span><span class="s5">100</span><span class="s0">}</span><span class="s2">% </span><span class="s0">${y.origin * </span><span class="s5">100</span><span class="s0">}</span><span class="s2">% 0`</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(lead.animationValues) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If the lead component is animating, assign this either the entering/leaving</span>
                     <span class="s3">* opacity</span>
                     <span class="s3">*/</span>
                    <span class="s0">targetStyle.opacity =</span>
                        <span class="s0">lead === </span><span class="s1">this</span>
                            <span class="s0">? valuesToRender.opacity ??</span>
                                <span class="s1">this</span><span class="s0">.latestValues.opacity ??</span>
                                <span class="s5">1</span>
                            <span class="s0">: </span><span class="s1">this</span><span class="s0">.preserveOpacity</span>
                                <span class="s0">? </span><span class="s1">this</span><span class="s0">.latestValues.opacity</span>
                                <span class="s0">: valuesToRender.opacityExit;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Or we're not animating at all, set the lead component to its layout</span>
                     <span class="s3">* opacity and other components to hidden.</span>
                     <span class="s3">*/</span>
                    <span class="s0">targetStyle.opacity =</span>
                        <span class="s0">lead === </span><span class="s1">this</span>
                            <span class="s0">? valuesToRender.opacity !== undefined</span>
                                <span class="s0">? valuesToRender.opacity</span>
                                <span class="s0">: </span><span class="s2">&quot;&quot;</span>
                            <span class="s0">: valuesToRender.opacityExit !== undefined</span>
                                <span class="s0">? valuesToRender.opacityExit</span>
                                <span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Apply scale correction</span>
                 <span class="s3">*/</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">scaleCorrectors) {</span>
                    <span class="s1">if </span><span class="s0">(valuesToRender[key] === undefined)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">{ correct, applyTo, isCSSVariable } = scaleCorrectors[key];</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Only apply scale correction to the value if we have an</span>
                     <span class="s3">* active projection transform. Otherwise these values become</span>
                     <span class="s3">* vulnerable to distortion if the element changes size without</span>
                     <span class="s3">* a corresponding layout animation.</span>
                     <span class="s3">*/</span>
                    <span class="s1">const </span><span class="s0">corrected = transform === </span><span class="s2">&quot;none&quot;</span>
                        <span class="s0">? valuesToRender[key]</span>
                        <span class="s0">: correct(valuesToRender[key], lead);</span>
                    <span class="s1">if </span><span class="s0">(applyTo) {</span>
                        <span class="s1">const </span><span class="s0">num = applyTo.length;</span>
                        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; num; i++) {</span>
                            <span class="s0">targetStyle[applyTo[i]] = corrected;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s3">// If this is a CSS variable, set it directly on the instance.</span>
                        <span class="s3">// Replacing this function from creating styles to setting them</span>
                        <span class="s3">// would be a good place to remove per frame object creation</span>
                        <span class="s1">if </span><span class="s0">(isCSSVariable) {</span>
                            <span class="s1">this</span><span class="s0">.options.visualElement.renderState.vars[key] = corrected;</span>
                        <span class="s0">}</span>
                        <span class="s1">else </span><span class="s0">{</span>
                            <span class="s0">targetStyle[key] = corrected;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Disable pointer events on follow components. This is to ensure</span>
                 <span class="s3">* that if a follow component covers a lead component it doesn't block</span>
                 <span class="s3">* pointer events on the lead.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.layoutId) {</span>
                    <span class="s0">targetStyle.pointerEvents =</span>
                        <span class="s0">lead === </span><span class="s1">this</span>
                            <span class="s0">? resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s2">&quot;&quot;</span>
                            <span class="s0">: </span><span class="s2">&quot;none&quot;</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">clearSnapshot() {</span>
                <span class="s1">this</span><span class="s0">.resumeFrom = </span><span class="s1">this</span><span class="s0">.snapshot = undefined;</span>
            <span class="s0">}</span>
            <span class="s3">// Only run on root</span>
            <span class="s0">resetTree() {</span>
                <span class="s1">this</span><span class="s0">.root.nodes.forEach((node) =&gt; node.currentAnimation?.stop());</span>
                <span class="s1">this</span><span class="s0">.root.nodes.forEach(clearMeasurements);</span>
                <span class="s1">this</span><span class="s0">.root.sharedNodes.clear();</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">updateLayout(node) {</span>
        <span class="s0">node.updateLayout();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">notifyLayoutUpdate(node) {</span>
        <span class="s1">const </span><span class="s0">snapshot = node.resumeFrom?.snapshot || node.snapshot;</span>
        <span class="s1">if </span><span class="s0">(node.isLead() &amp;&amp;</span>
            <span class="s0">node.layout &amp;&amp;</span>
            <span class="s0">snapshot &amp;&amp;</span>
            <span class="s0">node.hasListeners(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s0">)) {</span>
            <span class="s1">const </span><span class="s0">{ layoutBox: layout, measuredBox: measuredLayout } = node.layout;</span>
            <span class="s1">const </span><span class="s0">{ animationType } = node.options;</span>
            <span class="s1">const </span><span class="s0">isShared = snapshot.source !== node.layout.source;</span>
            <span class="s3">// TODO Maybe we want to also resize the layout snapshot so we don't trigger</span>
            <span class="s3">// animations for instance if layout=&quot;size&quot; and an element has only changed position</span>
            <span class="s1">if </span><span class="s0">(animationType === </span><span class="s2">&quot;size&quot;</span><span class="s0">) {</span>
                <span class="s0">eachAxis((axis) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">axisSnapshot = isShared</span>
                        <span class="s0">? snapshot.measuredBox[axis]</span>
                        <span class="s0">: snapshot.layoutBox[axis];</span>
                    <span class="s1">const </span><span class="s0">length = calcLength(axisSnapshot);</span>
                    <span class="s0">axisSnapshot.min = layout[axis].min;</span>
                    <span class="s0">axisSnapshot.max = axisSnapshot.min + length;</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {</span>
                <span class="s0">eachAxis((axis) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">axisSnapshot = isShared</span>
                        <span class="s0">? snapshot.measuredBox[axis]</span>
                        <span class="s0">: snapshot.layoutBox[axis];</span>
                    <span class="s1">const </span><span class="s0">length = calcLength(layout[axis]);</span>
                    <span class="s0">axisSnapshot.max = axisSnapshot.min + length;</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Ensure relative target gets resized and rerendererd</span>
                     <span class="s3">*/</span>
                    <span class="s1">if </span><span class="s0">(node.relativeTarget &amp;&amp; !node.currentAnimation) {</span>
                        <span class="s0">node.isProjectionDirty = </span><span class="s1">true</span><span class="s0">;</span>
                        <span class="s0">node.relativeTarget[axis].max =</span>
                            <span class="s0">node.relativeTarget[axis].min + length;</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">layoutDelta = createDelta();</span>
            <span class="s0">calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);</span>
            <span class="s1">const </span><span class="s0">visualDelta = createDelta();</span>
            <span class="s1">if </span><span class="s0">(isShared) {</span>
                <span class="s0">calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, </span><span class="s1">true</span><span class="s0">), snapshot.measuredBox);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">calcBoxDelta(visualDelta, layout, snapshot.layoutBox);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">hasLayoutChanged = !isDeltaZero(layoutDelta);</span>
            <span class="s1">let </span><span class="s0">hasRelativeLayoutChanged = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!node.resumeFrom) {</span>
                <span class="s1">const </span><span class="s0">relativeParent = node.getClosestProjectingParent();</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the relativeParent is itself resuming from a different element then</span>
                 <span class="s3">* the relative snapshot is not relavent</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(relativeParent &amp;&amp; !relativeParent.resumeFrom) {</span>
                    <span class="s1">const </span><span class="s0">{ snapshot: parentSnapshot, layout: parentLayout } = relativeParent;</span>
                    <span class="s1">if </span><span class="s0">(parentSnapshot &amp;&amp; parentLayout) {</span>
                        <span class="s1">const </span><span class="s0">relativeSnapshot = createBox();</span>
                        <span class="s0">calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);</span>
                        <span class="s1">const </span><span class="s0">relativeLayout = createBox();</span>
                        <span class="s0">calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);</span>
                        <span class="s1">if </span><span class="s0">(!boxEqualsRounded(relativeSnapshot, relativeLayout)) {</span>
                            <span class="s0">hasRelativeLayoutChanged = </span><span class="s1">true</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(relativeParent.options.layoutRoot) {</span>
                            <span class="s0">node.relativeTarget = relativeLayout;</span>
                            <span class="s0">node.relativeTargetOrigin = relativeSnapshot;</span>
                            <span class="s0">node.relativeParent = relativeParent;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">node.notifyListeners(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s0">, {</span>
                <span class="s0">layout,</span>
                <span class="s0">snapshot,</span>
                <span class="s0">delta: visualDelta,</span>
                <span class="s0">layoutDelta,</span>
                <span class="s0">hasLayoutChanged,</span>
                <span class="s0">hasRelativeLayoutChanged,</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(node.isLead()) {</span>
            <span class="s1">const </span><span class="s0">{ onExitComplete } = node.options;</span>
            <span class="s0">onExitComplete &amp;&amp; onExitComplete();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Clearing transition</span>
         <span class="s3">* TODO: Investigate why this transition is being passed in as {type: false } from Framer</span>
         <span class="s3">* and why we need it at all</span>
         <span class="s3">*/</span>
        <span class="s0">node.options.transition = undefined;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">propagateDirtyNodes(node) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Increase debug counter for nodes encountered this frame</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
            <span class="s0">metrics.nodes++;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!node.parent)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* If this node isn't projecting, propagate isProjectionDirty. It will have</span>
         <span class="s3">* no performance impact but it will allow the next child that *is* projecting</span>
         <span class="s3">* but *isn't* dirty to just check its parent to see if *any* ancestor needs</span>
         <span class="s3">* correcting.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!node.isProjecting()) {</span>
            <span class="s0">node.isProjectionDirty = node.parent.isProjectionDirty;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Propagate isSharedProjectionDirty and isTransformDirty</span>
         <span class="s3">* throughout the whole tree. A future revision can take another look at</span>
         <span class="s3">* this but for safety we still recalcualte shared nodes.</span>
         <span class="s3">*/</span>
        <span class="s0">node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||</span>
            <span class="s0">node.parent.isProjectionDirty ||</span>
            <span class="s0">node.parent.isSharedProjectionDirty));</span>
        <span class="s0">node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">cleanDirtyNodes(node) {</span>
        <span class="s0">node.isProjectionDirty =</span>
            <span class="s0">node.isSharedProjectionDirty =</span>
                <span class="s0">node.isTransformDirty =</span>
                    <span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">clearSnapshot(node) {</span>
        <span class="s0">node.clearSnapshot();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">clearMeasurements(node) {</span>
        <span class="s0">node.clearMeasurements();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">clearIsLayoutDirty(node) {</span>
        <span class="s0">node.isLayoutDirty = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resetTransformStyle(node) {</span>
        <span class="s1">const </span><span class="s0">{ visualElement } = node.options;</span>
        <span class="s1">if </span><span class="s0">(visualElement &amp;&amp; visualElement.getProps().onBeforeLayoutMeasure) {</span>
            <span class="s0">visualElement.notify(</span><span class="s2">&quot;BeforeLayoutMeasure&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">node.resetTransform();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">finishAnimation(node) {</span>
        <span class="s0">node.finishAnimation();</span>
        <span class="s0">node.targetDelta = node.relativeTarget = node.target = undefined;</span>
        <span class="s0">node.isProjectionDirty = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resolveTargetDelta(node) {</span>
        <span class="s0">node.resolveTargetDelta();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcProjection(node) {</span>
        <span class="s0">node.calcProjection();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resetSkewAndRotation(node) {</span>
        <span class="s0">node.resetSkewAndRotation();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">removeLeadSnapshots(stack) {</span>
        <span class="s0">stack.removeLeadSnapshot();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mixAxisDelta(output, delta, p) {</span>
        <span class="s0">output.translate = mixNumber$1(delta.translate, </span><span class="s5">0</span><span class="s0">, p);</span>
        <span class="s0">output.scale = mixNumber$1(delta.scale, </span><span class="s5">1</span><span class="s0">, p);</span>
        <span class="s0">output.origin = delta.origin;</span>
        <span class="s0">output.originPoint = delta.originPoint;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mixAxis(output, from, to, p) {</span>
        <span class="s0">output.min = mixNumber$1(from.min, to.min, p);</span>
        <span class="s0">output.max = mixNumber$1(from.max, to.max, p);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mixBox(output, from, to, p) {</span>
        <span class="s0">mixAxis(output.x, from.x, to.x, p);</span>
        <span class="s0">mixAxis(output.y, from.y, to.y, p);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hasOpacityCrossfade(node) {</span>
        <span class="s1">return </span><span class="s0">(node.animationValues &amp;&amp; node.animationValues.opacityExit !== undefined);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">defaultLayoutTransition = {</span>
        <span class="s0">duration: </span><span class="s5">0.45</span><span class="s0">,</span>
        <span class="s0">ease: [</span><span class="s5">0.4</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0.1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">],</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">userAgentContains = (string) =&gt; </span><span class="s1">typeof </span><span class="s0">navigator !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">&amp;&amp;</span>
        <span class="s0">navigator.userAgent &amp;&amp;</span>
        <span class="s0">navigator.userAgent.toLowerCase().includes(string);</span>
    <span class="s3">/**</span>
     <span class="s3">* Measured bounding boxes must be rounded in Safari and</span>
     <span class="s3">* left untouched in Chrome, otherwise non-integer layouts within scaled-up elements</span>
     <span class="s3">* can appear to jump.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">roundPoint = userAgentContains(</span><span class="s2">&quot;applewebkit/&quot;</span><span class="s0">) &amp;&amp; !userAgentContains(</span><span class="s2">&quot;chrome/&quot;</span><span class="s0">)</span>
        <span class="s0">? Math.round</span>
        <span class="s0">: noop;</span>
    <span class="s1">function </span><span class="s0">roundAxis(axis) {</span>
        <span class="s3">// Round to the nearest .5 pixels to support subpixel layouts</span>
        <span class="s0">axis.min = roundPoint(axis.min);</span>
        <span class="s0">axis.max = roundPoint(axis.max);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">roundBox(box) {</span>
        <span class="s0">roundAxis(box.x);</span>
        <span class="s0">roundAxis(box.y);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">shouldAnimatePositionOnly(animationType, snapshot, layout) {</span>
        <span class="s1">return </span><span class="s0">(animationType === </span><span class="s2">&quot;position&quot; </span><span class="s0">||</span>
            <span class="s0">(animationType === </span><span class="s2">&quot;preserve-aspect&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">!isNear(aspectRatio(snapshot), aspectRatio(layout), </span><span class="s5">0.2</span><span class="s0">)));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">checkNodeWasScrollRoot(node) {</span>
        <span class="s1">return </span><span class="s0">node !== node.root &amp;&amp; node.scroll?.wasRoot;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">addDomEvent(target, eventName, handler, options = { passive: </span><span class="s1">true </span><span class="s0">}) {</span>
        <span class="s0">target.addEventListener(eventName, handler, options);</span>
        <span class="s1">return </span><span class="s0">() =&gt; target.removeEventListener(eventName, handler);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">DocumentProjectionNode = createProjectionNode$1({</span>
        <span class="s0">attachResizeListener: (ref, notify) =&gt; addDomEvent(ref, </span><span class="s2">&quot;resize&quot;</span><span class="s0">, notify),</span>
        <span class="s0">measureScroll: () =&gt; ({</span>
            <span class="s0">x: document.documentElement.scrollLeft || document.body.scrollLeft,</span>
            <span class="s0">y: document.documentElement.scrollTop || document.body.scrollTop,</span>
        <span class="s0">}),</span>
        <span class="s0">checkIsScrollRoot: () =&gt; </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">});</span>

    <span class="s1">const </span><span class="s0">rootProjectionNode = {</span>
        <span class="s0">current: undefined,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">HTMLProjectionNode = createProjectionNode$1({</span>
        <span class="s0">measureScroll: (instance) =&gt; ({</span>
            <span class="s0">x: instance.scrollLeft,</span>
            <span class="s0">y: instance.scrollTop,</span>
        <span class="s0">}),</span>
        <span class="s0">defaultParent: () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!rootProjectionNode.current) {</span>
                <span class="s1">const </span><span class="s0">documentNode = </span><span class="s1">new </span><span class="s0">DocumentProjectionNode({});</span>
                <span class="s0">documentNode.mount(window);</span>
                <span class="s0">documentNode.setOptions({ layoutScroll: </span><span class="s1">true </span><span class="s0">});</span>
                <span class="s0">rootProjectionNode.current = documentNode;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">rootProjectionNode.current;</span>
        <span class="s0">},</span>
        <span class="s0">resetTransform: (instance, value) =&gt; {</span>
            <span class="s0">instance.style.transform = value !== undefined ? value : </span><span class="s2">&quot;none&quot;</span><span class="s0">;</span>
        <span class="s0">},</span>
        <span class="s0">checkIsScrollRoot: (instance) =&gt; Boolean(window.getComputedStyle(instance).position === </span><span class="s2">&quot;fixed&quot;</span><span class="s0">),</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">pixelsToPercent(pixels, axis) {</span>
        <span class="s1">if </span><span class="s0">(axis.max === axis.min)</span>
            <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">(pixels / (axis.max - axis.min)) * </span><span class="s5">100</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* We always correct borderRadius as a percentage rather than pixels to reduce paints.</span>
     <span class="s3">* For example, if you are projecting a box that is 100px wide with a 10px borderRadius</span>
     <span class="s3">* into a box that is 200px wide with a 20px borderRadius, that is actually a 10%</span>
     <span class="s3">* borderRadius in both states. If we animate between the two in pixels that will trigger</span>
     <span class="s3">* a paint each time. If we animate between the two in percentage we'll avoid a paint.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">correctBorderRadius = {</span>
        <span class="s0">correct: (latest, node) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!node.target)</span>
                <span class="s1">return </span><span class="s0">latest;</span>
            <span class="s3">/**</span>
             <span class="s3">* If latest is a string, if it's a percentage we can return immediately as it's</span>
             <span class="s3">* going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">latest === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(px.test(latest)) {</span>
                    <span class="s0">latest = parseFloat(latest);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">return </span><span class="s0">latest;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If latest is a number, it's a pixel value. We use the current viewportBox to calculate that</span>
             <span class="s3">* pixel value as a percentage of each axis</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">x = pixelsToPercent(latest, node.target.x);</span>
            <span class="s1">const </span><span class="s0">y = pixelsToPercent(latest, node.target.y);</span>
            <span class="s1">return </span><span class="s2">`</span><span class="s0">${x}</span><span class="s2">% </span><span class="s0">${y}</span><span class="s2">%`</span><span class="s0">;</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">correctBoxShadow = {</span>
        <span class="s0">correct: (latest, { treeScale, projectionDelta }) =&gt; {</span>
            <span class="s1">const </span><span class="s0">original = latest;</span>
            <span class="s1">const </span><span class="s0">shadow = complex.parse(latest);</span>
            <span class="s3">// TODO: Doesn't support multiple shadows</span>
            <span class="s1">if </span><span class="s0">(shadow.length &gt; </span><span class="s5">5</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">original;</span>
            <span class="s1">const </span><span class="s0">template = complex.createTransformer(latest);</span>
            <span class="s1">const </span><span class="s0">offset = </span><span class="s1">typeof </span><span class="s0">shadow[</span><span class="s5">0</span><span class="s0">] !== </span><span class="s2">&quot;number&quot; </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s3">// Calculate the overall context scale</span>
            <span class="s1">const </span><span class="s0">xScale = projectionDelta.x.scale * treeScale.x;</span>
            <span class="s1">const </span><span class="s0">yScale = projectionDelta.y.scale * treeScale.y;</span>
            <span class="s0">shadow[</span><span class="s5">0 </span><span class="s0">+ offset] /= xScale;</span>
            <span class="s0">shadow[</span><span class="s5">1 </span><span class="s0">+ offset] /= yScale;</span>
            <span class="s3">/**</span>
             <span class="s3">* Ideally we'd correct x and y scales individually, but because blur and</span>
             <span class="s3">* spread apply to both we have to take a scale average and apply that instead.</span>
             <span class="s3">* We could potentially improve the outcome of this by incorporating the ratio between</span>
             <span class="s3">* the two scales.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">averageScale = mixNumber$1(xScale, yScale, </span><span class="s5">0.5</span><span class="s0">);</span>
            <span class="s3">// Blur</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">shadow[</span><span class="s5">2 </span><span class="s0">+ offset] === </span><span class="s2">&quot;number&quot;</span><span class="s0">)</span>
                <span class="s0">shadow[</span><span class="s5">2 </span><span class="s0">+ offset] /= averageScale;</span>
            <span class="s3">// Spread</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">shadow[</span><span class="s5">3 </span><span class="s0">+ offset] === </span><span class="s2">&quot;number&quot;</span><span class="s0">)</span>
                <span class="s0">shadow[</span><span class="s5">3 </span><span class="s0">+ offset] /= averageScale;</span>
            <span class="s1">return </span><span class="s0">template(shadow);</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Bounding boxes tend to be defined as top, left, right, bottom. For various operations</span>
     <span class="s3">* it's easier to consider each axis individually. This function returns a bounding box</span>
     <span class="s3">* as a map of single-axis min/max values.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">convertBoundingBoxToBox({ top, left, right, bottom, }) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">x: { min: left, max: right },</span>
            <span class="s0">y: { min: top, max: bottom },</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">convertBoxToBoundingBox({ x, y }) {</span>
        <span class="s1">return </span><span class="s0">{ top: y.min, right: x.max, bottom: y.max, left: x.min };</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Applies a TransformPoint function to a bounding box. TransformPoint is usually a function</span>
     <span class="s3">* provided by Framer to allow measured points to be corrected for device scaling. This is used</span>
     <span class="s3">* when measuring DOM elements and DOM event points.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">transformBoxPoints(point, transformPoint) {</span>
        <span class="s1">if </span><span class="s0">(!transformPoint)</span>
            <span class="s1">return </span><span class="s0">point;</span>
        <span class="s1">const </span><span class="s0">topLeft = transformPoint({ x: point.left, y: point.top });</span>
        <span class="s1">const </span><span class="s0">bottomRight = transformPoint({ x: point.right, y: point.bottom });</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">top: topLeft.y,</span>
            <span class="s0">left: topLeft.x,</span>
            <span class="s0">bottom: bottomRight.y,</span>
            <span class="s0">right: bottomRight.x,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">measureViewportBox(instance, transformPoint) {</span>
        <span class="s1">return </span><span class="s0">convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">measurePageBox(element, rootProjectionNode, transformPagePoint) {</span>
        <span class="s1">const </span><span class="s0">viewportBox = measureViewportBox(element, transformPagePoint);</span>
        <span class="s1">const </span><span class="s0">{ scroll } = rootProjectionNode;</span>
        <span class="s1">if </span><span class="s0">(scroll) {</span>
            <span class="s0">translateAxis(viewportBox.x, scroll.offset.x);</span>
            <span class="s0">translateAxis(viewportBox.y, scroll.offset.y);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">viewportBox;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">featureProps = {</span>
        <span class="s0">animation: [</span>
            <span class="s2">&quot;animate&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;variants&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;whileHover&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;whileTap&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;exit&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;whileInView&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;whileFocus&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;whileDrag&quot;</span><span class="s0">,</span>
        <span class="s0">],</span>
        <span class="s0">exit: [</span><span class="s2">&quot;exit&quot;</span><span class="s0">],</span>
        <span class="s0">drag: [</span><span class="s2">&quot;drag&quot;</span><span class="s0">, </span><span class="s2">&quot;dragControls&quot;</span><span class="s0">],</span>
        <span class="s0">focus: [</span><span class="s2">&quot;whileFocus&quot;</span><span class="s0">],</span>
        <span class="s0">hover: [</span><span class="s2">&quot;whileHover&quot;</span><span class="s0">, </span><span class="s2">&quot;onHoverStart&quot;</span><span class="s0">, </span><span class="s2">&quot;onHoverEnd&quot;</span><span class="s0">],</span>
        <span class="s0">tap: [</span><span class="s2">&quot;whileTap&quot;</span><span class="s0">, </span><span class="s2">&quot;onTap&quot;</span><span class="s0">, </span><span class="s2">&quot;onTapStart&quot;</span><span class="s0">, </span><span class="s2">&quot;onTapCancel&quot;</span><span class="s0">],</span>
        <span class="s0">pan: [</span><span class="s2">&quot;onPan&quot;</span><span class="s0">, </span><span class="s2">&quot;onPanStart&quot;</span><span class="s0">, </span><span class="s2">&quot;onPanSessionStart&quot;</span><span class="s0">, </span><span class="s2">&quot;onPanEnd&quot;</span><span class="s0">],</span>
        <span class="s0">inView: [</span><span class="s2">&quot;whileInView&quot;</span><span class="s0">, </span><span class="s2">&quot;onViewportEnter&quot;</span><span class="s0">, </span><span class="s2">&quot;onViewportLeave&quot;</span><span class="s0">],</span>
        <span class="s0">layout: [</span><span class="s2">&quot;layout&quot;</span><span class="s0">, </span><span class="s2">&quot;layoutId&quot;</span><span class="s0">],</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">featureDefinitions = {};</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">featureProps) {</span>
        <span class="s0">featureDefinitions[key] = {</span>
            <span class="s0">isEnabled: (props) =&gt; featureProps[key].some((name) =&gt; !!props[name]),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s3">// Does this device prefer reduced motion? Returns `null` server-side.</span>
    <span class="s1">const </span><span class="s0">prefersReducedMotion = { current: </span><span class="s1">null </span><span class="s0">};</span>
    <span class="s1">const </span><span class="s0">hasReducedMotionListener = { current: </span><span class="s1">false </span><span class="s0">};</span>

    <span class="s1">function </span><span class="s0">initPrefersReducedMotion() {</span>
        <span class="s0">hasReducedMotionListener.current = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!isBrowser)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(window.matchMedia) {</span>
            <span class="s1">const </span><span class="s0">motionMediaQuery = window.matchMedia(</span><span class="s2">&quot;(prefers-reduced-motion)&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">setReducedMotionPreferences = () =&gt; (prefersReducedMotion.current = motionMediaQuery.matches);</span>
            <span class="s0">motionMediaQuery.addEventListener(</span><span class="s2">&quot;change&quot;</span><span class="s0">, setReducedMotionPreferences);</span>
            <span class="s0">setReducedMotionPreferences();</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">prefersReducedMotion.current = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">visualElementStore = </span><span class="s1">new </span><span class="s0">WeakMap();</span>

    <span class="s1">function </span><span class="s0">isAnimationControls(v) {</span>
        <span class="s1">return </span><span class="s0">(v !== </span><span class="s1">null </span><span class="s0">&amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">v.start === </span><span class="s2">&quot;function&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Decides if the supplied variable is variant label</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isVariantLabel(v) {</span>
        <span class="s1">return typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot; </span><span class="s0">|| Array.isArray(v);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">variantPriorityOrder = [</span>
        <span class="s2">&quot;animate&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;whileInView&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;whileFocus&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;whileHover&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;whileTap&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;whileDrag&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;exit&quot;</span><span class="s0">,</span>
    <span class="s0">];</span>
    <span class="s1">const </span><span class="s0">variantProps = [</span><span class="s2">&quot;initial&quot;</span><span class="s0">, ...variantPriorityOrder];</span>

    <span class="s1">function </span><span class="s0">isControllingVariants(props) {</span>
        <span class="s1">return </span><span class="s0">(isAnimationControls(props.animate) ||</span>
            <span class="s0">variantProps.some((name) =&gt; isVariantLabel(props[name])));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isVariantNode(props) {</span>
        <span class="s1">return </span><span class="s0">Boolean(isControllingVariants(props) || props.variants);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">updateMotionValuesFromProps(element, next, prev) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">next) {</span>
            <span class="s1">const </span><span class="s0">nextValue = next[key];</span>
            <span class="s1">const </span><span class="s0">prevValue = prev[key];</span>
            <span class="s1">if </span><span class="s0">(isMotionValue(nextValue)) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this is a motion value found in props or style, we want to add it</span>
                 <span class="s3">* to our visual element's motion value map.</span>
                 <span class="s3">*/</span>
                <span class="s0">element.addValue(key, nextValue);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(isMotionValue(prevValue)) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're swapping from a motion value to a static value,</span>
                 <span class="s3">* create a new motion value from that</span>
                 <span class="s3">*/</span>
                <span class="s0">element.addValue(key, motionValue(nextValue, { owner: element }));</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(prevValue !== nextValue) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this is a flat value that has changed, update the motion value</span>
                 <span class="s3">* or create one if it doesn't exist. We only want to do this if we're</span>
                 <span class="s3">* not handling the value with our animation state.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(element.hasValue(key)) {</span>
                    <span class="s1">const </span><span class="s0">existingValue = element.getValue(key);</span>
                    <span class="s1">if </span><span class="s0">(existingValue.liveStyle === </span><span class="s1">true</span><span class="s0">) {</span>
                        <span class="s0">existingValue.jump(nextValue);</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(!existingValue.hasAnimated) {</span>
                        <span class="s0">existingValue.set(nextValue);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">const </span><span class="s0">latestValue = element.getStaticValue(key);</span>
                    <span class="s0">element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">// Handle removed values</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">prev) {</span>
            <span class="s1">if </span><span class="s0">(next[key] === undefined)</span>
                <span class="s0">element.removeValue(key);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">next;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getValueState(visualElement) {</span>
        <span class="s1">const </span><span class="s0">state = [{}, {}];</span>
        <span class="s0">visualElement?.values.forEach((value, key) =&gt; {</span>
            <span class="s0">state[</span><span class="s5">0</span><span class="s0">][key] = value.get();</span>
            <span class="s0">state[</span><span class="s5">1</span><span class="s0">][key] = value.getVelocity();</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">state;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resolveVariantFromProps(props, definition, custom, visualElement) {</span>
        <span class="s3">/**</span>
         <span class="s3">* If the variant definition is a function, resolve.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">definition === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">[current, velocity] = getValueState(visualElement);</span>
            <span class="s0">definition = definition(custom !== undefined ? custom : props.custom, current, velocity);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If the variant definition is a variant label, or</span>
         <span class="s3">* the function returned a variant label, resolve.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">definition === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s0">definition = props.variants &amp;&amp; props.variants[definition];</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* At this point we've resolved both functions and variant labels,</span>
         <span class="s3">* but the resolved variant label might itself have been a function.</span>
         <span class="s3">* If so, resolve. This can only have returned a valid target object.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">definition === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">[current, velocity] = getValueState(visualElement);</span>
            <span class="s0">definition = definition(custom !== undefined ? custom : props.custom, current, velocity);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">definition;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">propEventHandlers = [</span>
        <span class="s2">&quot;AnimationStart&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;AnimationComplete&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Update&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;BeforeLayoutMeasure&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;LayoutMeasure&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;LayoutAnimationStart&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;LayoutAnimationComplete&quot;</span><span class="s0">,</span>
    <span class="s0">];</span>
    <span class="s3">/**</span>
     <span class="s3">* A VisualElement is an imperative abstraction around UI elements such as</span>
     <span class="s3">* HTMLElement, SVGElement, Three.Object3D etc.</span>
     <span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">VisualElement {</span>
        <span class="s3">/**</span>
         <span class="s3">* This method takes React props and returns found MotionValues. For example, HTML</span>
         <span class="s3">* MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.</span>
         <span class="s3">*</span>
         <span class="s3">* This isn't an abstract method as it needs calling in the constructor, but it is</span>
         <span class="s3">* intended to be one.</span>
         <span class="s3">*/</span>
        <span class="s0">scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {</span>
            <span class="s1">return </span><span class="s0">{};</span>
        <span class="s0">}</span>
        <span class="s0">constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {</span>
            <span class="s3">/**</span>
             <span class="s3">* A reference to the current underlying Instance, e.g. a HTMLElement</span>
             <span class="s3">* or Three.Mesh etc.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.current = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* A set containing references to this VisualElement's children.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.children = </span><span class="s1">new </span><span class="s0">Set();</span>
            <span class="s3">/**</span>
             <span class="s3">* Determine what role this visual element should take in the variant tree.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.isVariantNode = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isControllingVariants = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Decides whether this VisualElement should animate in reduced motion</span>
             <span class="s3">* mode.</span>
             <span class="s3">*</span>
             <span class="s3">* TODO: This is currently set on every individual VisualElement but feels</span>
             <span class="s3">* like it could be set globally.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.shouldReduceMotion = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* A map of all motion values attached to this visual element. Motion</span>
             <span class="s3">* values are source of truth for any given animated value. A motion</span>
             <span class="s3">* value might be provided externally by the component via props.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.values = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s1">this</span><span class="s0">.KeyframeResolver = KeyframeResolver;</span>
            <span class="s3">/**</span>
             <span class="s3">* Cleanup functions for active features (hover/tap/exit etc)</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.features = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* A map of every subscription that binds the provided or generated</span>
             <span class="s3">* motion values onChange listeners to this visual element.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.valueSubscriptions = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s3">/**</span>
             <span class="s3">* A reference to the previously-provided motion values as returned</span>
             <span class="s3">* from scrapeMotionValuesFromProps. We use the keys in here to determine</span>
             <span class="s3">* if any motion values need to be removed after props are updated.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.prevMotionValues = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* An object containing a SubscriptionManager for each active event.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.events = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* An object containing an unsubscribe function for each prop event subscription.</span>
             <span class="s3">* For example, every &quot;Update&quot; event can have multiple subscribers via</span>
             <span class="s3">* VisualElement.on(), but only one of those can be defined via the onUpdate prop.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.propEventSubscriptions = {};</span>
            <span class="s1">this</span><span class="s0">.notifyUpdate = () =&gt; </span><span class="s1">this</span><span class="s0">.notify(</span><span class="s2">&quot;Update&quot;</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.latestValues);</span>
            <span class="s1">this</span><span class="s0">.render = () =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.current)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.triggerBuild();</span>
                <span class="s1">this</span><span class="s0">.renderInstance(</span><span class="s1">this</span><span class="s0">.current, </span><span class="s1">this</span><span class="s0">.renderState, </span><span class="s1">this</span><span class="s0">.props.style, </span><span class="s1">this</span><span class="s0">.projection);</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.renderScheduledAt = </span><span class="s5">0.0</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.scheduleRender = () =&gt; {</span>
                <span class="s1">const </span><span class="s0">now = time.now();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.renderScheduledAt &lt; now) {</span>
                    <span class="s1">this</span><span class="s0">.renderScheduledAt = now;</span>
                    <span class="s0">frame.render(</span><span class="s1">this</span><span class="s0">.render, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">{ latestValues, renderState } = visualState;</span>
            <span class="s1">this</span><span class="s0">.latestValues = latestValues;</span>
            <span class="s1">this</span><span class="s0">.baseTarget = { ...latestValues };</span>
            <span class="s1">this</span><span class="s0">.initialValues = props.initial ? { ...latestValues } : {};</span>
            <span class="s1">this</span><span class="s0">.renderState = renderState;</span>
            <span class="s1">this</span><span class="s0">.parent = parent;</span>
            <span class="s1">this</span><span class="s0">.props = props;</span>
            <span class="s1">this</span><span class="s0">.presenceContext = presenceContext;</span>
            <span class="s1">this</span><span class="s0">.depth = parent ? parent.depth + </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.reducedMotionConfig = reducedMotionConfig;</span>
            <span class="s1">this</span><span class="s0">.options = options;</span>
            <span class="s1">this</span><span class="s0">.blockInitialAnimation = Boolean(blockInitialAnimation);</span>
            <span class="s1">this</span><span class="s0">.isControllingVariants = isControllingVariants(props);</span>
            <span class="s1">this</span><span class="s0">.isVariantNode = isVariantNode(props);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isVariantNode) {</span>
                <span class="s1">this</span><span class="s0">.variantChildren = </span><span class="s1">new </span><span class="s0">Set();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.manuallyAnimateOnMount = Boolean(parent &amp;&amp; parent.current);</span>
            <span class="s3">/**</span>
             <span class="s3">* Any motion values that are provided to the element when created</span>
             <span class="s3">* aren't yet bound to the element, as this would technically be impure.</span>
             <span class="s3">* However, we iterate through the motion values and set them to the</span>
             <span class="s3">* initial values for this component.</span>
             <span class="s3">*</span>
             <span class="s3">* TODO: This is impure and we should look at changing this to run on mount.</span>
             <span class="s3">* Doing so will break some tests but this isn't necessarily a breaking change,</span>
             <span class="s3">* more a reflection of the test.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">{ willChange, ...initialMotionValues } = </span><span class="s1">this</span><span class="s0">.scrapeMotionValuesFromProps(props, {}, </span><span class="s1">this</span><span class="s0">);</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">initialMotionValues) {</span>
                <span class="s1">const </span><span class="s0">value = initialMotionValues[key];</span>
                <span class="s1">if </span><span class="s0">(latestValues[key] !== undefined &amp;&amp; isMotionValue(value)) {</span>
                    <span class="s0">value.set(latestValues[key]);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">mount(instance) {</span>
            <span class="s1">this</span><span class="s0">.current = instance;</span>
            <span class="s0">visualElementStore.set(instance, </span><span class="s1">this</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.projection &amp;&amp; !</span><span class="s1">this</span><span class="s0">.projection.instance) {</span>
                <span class="s1">this</span><span class="s0">.projection.mount(instance);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parent &amp;&amp; </span><span class="s1">this</span><span class="s0">.isVariantNode &amp;&amp; !</span><span class="s1">this</span><span class="s0">.isControllingVariants) {</span>
                <span class="s1">this</span><span class="s0">.removeFromVariantTree = </span><span class="s1">this</span><span class="s0">.parent.addVariantChild(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.values.forEach((value, key) =&gt; </span><span class="s1">this</span><span class="s0">.bindToMotionValue(key, value));</span>
            <span class="s1">if </span><span class="s0">(!hasReducedMotionListener.current) {</span>
                <span class="s0">initPrefersReducedMotion();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.shouldReduceMotion =</span>
                <span class="s1">this</span><span class="s0">.reducedMotionConfig === </span><span class="s2">&quot;never&quot;</span>
                    <span class="s0">? </span><span class="s1">false</span>
                    <span class="s0">: </span><span class="s1">this</span><span class="s0">.reducedMotionConfig === </span><span class="s2">&quot;always&quot;</span>
                        <span class="s0">? </span><span class="s1">true</span>
                        <span class="s0">: prefersReducedMotion.current;</span>
            <span class="s0">{</span>
                <span class="s0">warnOnce(</span><span class="s1">this</span><span class="s0">.shouldReduceMotion !== </span><span class="s1">true</span><span class="s0">, </span><span class="s2">&quot;You have Reduced Motion enabled on your device. Animations may not appear as expected.&quot;</span><span class="s0">, </span><span class="s2">&quot;reduced-motion-disabled&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.parent?.addChild(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.update(</span><span class="s1">this</span><span class="s0">.props, </span><span class="s1">this</span><span class="s0">.presenceContext);</span>
        <span class="s0">}</span>
        <span class="s0">unmount() {</span>
            <span class="s1">this</span><span class="s0">.projection &amp;&amp; </span><span class="s1">this</span><span class="s0">.projection.unmount();</span>
            <span class="s0">cancelFrame(</span><span class="s1">this</span><span class="s0">.notifyUpdate);</span>
            <span class="s0">cancelFrame(</span><span class="s1">this</span><span class="s0">.render);</span>
            <span class="s1">this</span><span class="s0">.valueSubscriptions.forEach((remove) =&gt; remove());</span>
            <span class="s1">this</span><span class="s0">.valueSubscriptions.clear();</span>
            <span class="s1">this</span><span class="s0">.removeFromVariantTree &amp;&amp; </span><span class="s1">this</span><span class="s0">.removeFromVariantTree();</span>
            <span class="s1">this</span><span class="s0">.parent?.removeChild(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in this</span><span class="s0">.events) {</span>
                <span class="s1">this</span><span class="s0">.events[key].clear();</span>
            <span class="s0">}</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in this</span><span class="s0">.features) {</span>
                <span class="s1">const </span><span class="s0">feature = </span><span class="s1">this</span><span class="s0">.features[key];</span>
                <span class="s1">if </span><span class="s0">(feature) {</span>
                    <span class="s0">feature.unmount();</span>
                    <span class="s0">feature.isMounted = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.current = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">addChild(child) {</span>
            <span class="s1">this</span><span class="s0">.children.add(child);</span>
            <span class="s1">this</span><span class="s0">.enteringChildren ?? (</span><span class="s1">this</span><span class="s0">.enteringChildren = </span><span class="s1">new </span><span class="s0">Set());</span>
            <span class="s1">this</span><span class="s0">.enteringChildren.add(child);</span>
        <span class="s0">}</span>
        <span class="s0">removeChild(child) {</span>
            <span class="s1">this</span><span class="s0">.children.delete(child);</span>
            <span class="s1">this</span><span class="s0">.enteringChildren &amp;&amp; </span><span class="s1">this</span><span class="s0">.enteringChildren.delete(child);</span>
        <span class="s0">}</span>
        <span class="s0">bindToMotionValue(key, value) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.valueSubscriptions.has(key)) {</span>
                <span class="s1">this</span><span class="s0">.valueSubscriptions.get(key)();</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">valueIsTransform = transformProps.has(key);</span>
            <span class="s1">if </span><span class="s0">(valueIsTransform &amp;&amp; </span><span class="s1">this</span><span class="s0">.onBindTransform) {</span>
                <span class="s1">this</span><span class="s0">.onBindTransform();</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">removeOnChange = value.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, (latestValue) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.latestValues[key] = latestValue;</span>
                <span class="s1">this</span><span class="s0">.props.onUpdate &amp;&amp; frame.preRender(</span><span class="s1">this</span><span class="s0">.notifyUpdate);</span>
                <span class="s1">if </span><span class="s0">(valueIsTransform &amp;&amp; </span><span class="s1">this</span><span class="s0">.projection) {</span>
                    <span class="s1">this</span><span class="s0">.projection.isTransformDirty = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.scheduleRender();</span>
            <span class="s0">});</span>
            <span class="s1">let </span><span class="s0">removeSyncCheck;</span>
            <span class="s1">if </span><span class="s0">(window.MotionCheckAppearSync) {</span>
                <span class="s0">removeSyncCheck = window.MotionCheckAppearSync(</span><span class="s1">this</span><span class="s0">, key, value);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.valueSubscriptions.set(key, () =&gt; {</span>
                <span class="s0">removeOnChange();</span>
                <span class="s1">if </span><span class="s0">(removeSyncCheck)</span>
                    <span class="s0">removeSyncCheck();</span>
                <span class="s1">if </span><span class="s0">(value.owner)</span>
                    <span class="s0">value.stop();</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">sortNodePosition(other) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If these nodes aren't even of the same type we can't compare their depth.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.current ||</span>
                <span class="s0">!</span><span class="s1">this</span><span class="s0">.sortInstanceNodePosition ||</span>
                <span class="s1">this</span><span class="s0">.type !== other.type) {</span>
                <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">.sortInstanceNodePosition(</span><span class="s1">this</span><span class="s0">.current, other.current);</span>
        <span class="s0">}</span>
        <span class="s0">updateFeatures() {</span>
            <span class="s1">let </span><span class="s0">key = </span><span class="s2">&quot;animation&quot;</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">featureDefinitions) {</span>
                <span class="s1">const </span><span class="s0">featureDefinition = featureDefinitions[key];</span>
                <span class="s1">if </span><span class="s0">(!featureDefinition)</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ isEnabled, Feature: FeatureConstructor } = featureDefinition;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this feature is enabled but not active, make a new instance.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.features[key] &amp;&amp;</span>
                    <span class="s0">FeatureConstructor &amp;&amp;</span>
                    <span class="s0">isEnabled(</span><span class="s1">this</span><span class="s0">.props)) {</span>
                    <span class="s1">this</span><span class="s0">.features[key] = </span><span class="s1">new </span><span class="s0">FeatureConstructor(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we have a feature, mount or update it.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.features[key]) {</span>
                    <span class="s1">const </span><span class="s0">feature = </span><span class="s1">this</span><span class="s0">.features[key];</span>
                    <span class="s1">if </span><span class="s0">(feature.isMounted) {</span>
                        <span class="s0">feature.update();</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">feature.mount();</span>
                        <span class="s0">feature.isMounted = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">triggerBuild() {</span>
            <span class="s1">this</span><span class="s0">.build(</span><span class="s1">this</span><span class="s0">.renderState, </span><span class="s1">this</span><span class="s0">.latestValues, </span><span class="s1">this</span><span class="s0">.props);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Measure the current viewport box with or without transforms.</span>
         <span class="s3">* Only measures axis-aligned boxes, rotate and skew must be manually</span>
         <span class="s3">* removed with a re-render to work.</span>
         <span class="s3">*/</span>
        <span class="s0">measureViewportBox() {</span>
            <span class="s1">return this</span><span class="s0">.current</span>
                <span class="s0">? </span><span class="s1">this</span><span class="s0">.measureInstanceViewportBox(</span><span class="s1">this</span><span class="s0">.current, </span><span class="s1">this</span><span class="s0">.props)</span>
                <span class="s0">: createBox();</span>
        <span class="s0">}</span>
        <span class="s0">getStaticValue(key) {</span>
            <span class="s1">return this</span><span class="s0">.latestValues[key];</span>
        <span class="s0">}</span>
        <span class="s0">setStaticValue(key, value) {</span>
            <span class="s1">this</span><span class="s0">.latestValues[key] = value;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Update the provided props. Ensure any newly-added motion values are</span>
         <span class="s3">* added to our map, old ones removed, and listeners updated.</span>
         <span class="s3">*/</span>
        <span class="s0">update(props, presenceContext) {</span>
            <span class="s1">if </span><span class="s0">(props.transformTemplate || </span><span class="s1">this</span><span class="s0">.props.transformTemplate) {</span>
                <span class="s1">this</span><span class="s0">.scheduleRender();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.prevProps = </span><span class="s1">this</span><span class="s0">.props;</span>
            <span class="s1">this</span><span class="s0">.props = props;</span>
            <span class="s1">this</span><span class="s0">.prevPresenceContext = </span><span class="s1">this</span><span class="s0">.presenceContext;</span>
            <span class="s1">this</span><span class="s0">.presenceContext = presenceContext;</span>
            <span class="s3">/**</span>
             <span class="s3">* Update prop event handlers ie onAnimationStart, onAnimationComplete</span>
             <span class="s3">*/</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; propEventHandlers.length; i++) {</span>
                <span class="s1">const </span><span class="s0">key = propEventHandlers[i];</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.propEventSubscriptions[key]) {</span>
                    <span class="s1">this</span><span class="s0">.propEventSubscriptions[key]();</span>
                    <span class="s1">delete this</span><span class="s0">.propEventSubscriptions[key];</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">listenerName = (</span><span class="s2">&quot;on&quot; </span><span class="s0">+ key);</span>
                <span class="s1">const </span><span class="s0">listener = props[listenerName];</span>
                <span class="s1">if </span><span class="s0">(listener) {</span>
                    <span class="s1">this</span><span class="s0">.propEventSubscriptions[key] = </span><span class="s1">this</span><span class="s0">.on(key, listener);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.prevMotionValues = updateMotionValuesFromProps(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.scrapeMotionValuesFromProps(props, </span><span class="s1">this</span><span class="s0">.prevProps, </span><span class="s1">this</span><span class="s0">), </span><span class="s1">this</span><span class="s0">.prevMotionValues);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.handleChildMotionValue) {</span>
                <span class="s1">this</span><span class="s0">.handleChildMotionValue();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">getProps() {</span>
            <span class="s1">return this</span><span class="s0">.props;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Returns the variant definition with a given name.</span>
         <span class="s3">*/</span>
        <span class="s0">getVariant(name) {</span>
            <span class="s1">return this</span><span class="s0">.props.variants ? </span><span class="s1">this</span><span class="s0">.props.variants[name] : undefined;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Returns the defined default transition on this component.</span>
         <span class="s3">*/</span>
        <span class="s0">getDefaultTransition() {</span>
            <span class="s1">return this</span><span class="s0">.props.transition;</span>
        <span class="s0">}</span>
        <span class="s0">getTransformPagePoint() {</span>
            <span class="s1">return this</span><span class="s0">.props.transformPagePoint;</span>
        <span class="s0">}</span>
        <span class="s0">getClosestVariantNode() {</span>
            <span class="s1">return this</span><span class="s0">.isVariantNode</span>
                <span class="s0">? </span><span class="s1">this</span>
                <span class="s0">: </span><span class="s1">this</span><span class="s0">.parent</span>
                    <span class="s0">? </span><span class="s1">this</span><span class="s0">.parent.getClosestVariantNode()</span>
                    <span class="s0">: undefined;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Add a child visual element to our set of children.</span>
         <span class="s3">*/</span>
        <span class="s0">addVariantChild(child) {</span>
            <span class="s1">const </span><span class="s0">closestVariantNode = </span><span class="s1">this</span><span class="s0">.getClosestVariantNode();</span>
            <span class="s1">if </span><span class="s0">(closestVariantNode) {</span>
                <span class="s0">closestVariantNode.variantChildren &amp;&amp;</span>
                    <span class="s0">closestVariantNode.variantChildren.add(child);</span>
                <span class="s1">return </span><span class="s0">() =&gt; closestVariantNode.variantChildren.delete(child);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Add a motion value and bind it to this visual element.</span>
         <span class="s3">*/</span>
        <span class="s0">addValue(key, value) {</span>
            <span class="s3">// Remove existing value if it exists</span>
            <span class="s1">const </span><span class="s0">existingValue = </span><span class="s1">this</span><span class="s0">.values.get(key);</span>
            <span class="s1">if </span><span class="s0">(value !== existingValue) {</span>
                <span class="s1">if </span><span class="s0">(existingValue)</span>
                    <span class="s1">this</span><span class="s0">.removeValue(key);</span>
                <span class="s1">this</span><span class="s0">.bindToMotionValue(key, value);</span>
                <span class="s1">this</span><span class="s0">.values.set(key, value);</span>
                <span class="s1">this</span><span class="s0">.latestValues[key] = value.get();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Remove a motion value and unbind any active subscriptions.</span>
         <span class="s3">*/</span>
        <span class="s0">removeValue(key) {</span>
            <span class="s1">this</span><span class="s0">.values.delete(key);</span>
            <span class="s1">const </span><span class="s0">unsubscribe = </span><span class="s1">this</span><span class="s0">.valueSubscriptions.get(key);</span>
            <span class="s1">if </span><span class="s0">(unsubscribe) {</span>
                <span class="s0">unsubscribe();</span>
                <span class="s1">this</span><span class="s0">.valueSubscriptions.delete(key);</span>
            <span class="s0">}</span>
            <span class="s1">delete this</span><span class="s0">.latestValues[key];</span>
            <span class="s1">this</span><span class="s0">.removeValueFromRenderState(key, </span><span class="s1">this</span><span class="s0">.renderState);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Check whether we have a motion value for this key</span>
         <span class="s3">*/</span>
        <span class="s0">hasValue(key) {</span>
            <span class="s1">return this</span><span class="s0">.values.has(key);</span>
        <span class="s0">}</span>
        <span class="s0">getValue(key, defaultValue) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.props.values &amp;&amp; </span><span class="s1">this</span><span class="s0">.props.values[key]) {</span>
                <span class="s1">return this</span><span class="s0">.props.values[key];</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">value = </span><span class="s1">this</span><span class="s0">.values.get(key);</span>
            <span class="s1">if </span><span class="s0">(value === undefined &amp;&amp; defaultValue !== undefined) {</span>
                <span class="s0">value = motionValue(defaultValue === </span><span class="s1">null </span><span class="s0">? undefined : defaultValue, { owner: </span><span class="s1">this </span><span class="s0">});</span>
                <span class="s1">this</span><span class="s0">.addValue(key, value);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">value;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If we're trying to animate to a previously unencountered value,</span>
         <span class="s3">* we need to check for it in our state and as a last resort read it</span>
         <span class="s3">* directly from the instance (which might have performance implications).</span>
         <span class="s3">*/</span>
        <span class="s0">readValue(key, target) {</span>
            <span class="s1">let </span><span class="s0">value = </span><span class="s1">this</span><span class="s0">.latestValues[key] !== undefined || !</span><span class="s1">this</span><span class="s0">.current</span>
                <span class="s0">? </span><span class="s1">this</span><span class="s0">.latestValues[key]</span>
                <span class="s0">: </span><span class="s1">this</span><span class="s0">.getBaseTargetFromProps(</span><span class="s1">this</span><span class="s0">.props, key) ??</span>
                    <span class="s1">this</span><span class="s0">.readValueFromInstance(</span><span class="s1">this</span><span class="s0">.current, key, </span><span class="s1">this</span><span class="s0">.options);</span>
            <span class="s1">if </span><span class="s0">(value !== undefined &amp;&amp; value !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
                    <span class="s0">(isNumericalString(value) || isZeroValueString(value))) {</span>
                    <span class="s3">// If this is a number read as a string, ie &quot;0&quot; or &quot;200&quot;, convert it to a number</span>
                    <span class="s0">value = parseFloat(value);</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(!findValueType(value) &amp;&amp; complex.test(target)) {</span>
                    <span class="s0">value = getAnimatableNone(key, target);</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.setBaseTarget(key, isMotionValue(value) ? value.get() : value);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">isMotionValue(value) ? value.get() : value;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Set the base target to later animate back to. This is currently</span>
         <span class="s3">* only hydrated on creation and when we first read a value.</span>
         <span class="s3">*/</span>
        <span class="s0">setBaseTarget(key, value) {</span>
            <span class="s1">this</span><span class="s0">.baseTarget[key] = value;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Find the base target for a value thats been removed from all animation</span>
         <span class="s3">* props.</span>
         <span class="s3">*/</span>
        <span class="s0">getBaseTarget(key) {</span>
            <span class="s1">const </span><span class="s0">{ initial } = </span><span class="s1">this</span><span class="s0">.props;</span>
            <span class="s1">let </span><span class="s0">valueFromInitial;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">initial === </span><span class="s2">&quot;string&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">initial === </span><span class="s2">&quot;object&quot;</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">variant = resolveVariantFromProps(</span><span class="s1">this</span><span class="s0">.props, initial, </span><span class="s1">this</span><span class="s0">.presenceContext?.custom);</span>
                <span class="s1">if </span><span class="s0">(variant) {</span>
                    <span class="s0">valueFromInitial = variant[key];</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If this value still exists in the current initial variant, read that.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(initial &amp;&amp; valueFromInitial !== undefined) {</span>
                <span class="s1">return </span><span class="s0">valueFromInitial;</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Alternatively, if this VisualElement config has defined a getBaseTarget</span>
             <span class="s3">* so we can read the value from an alternative source, try that.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">target = </span><span class="s1">this</span><span class="s0">.getBaseTargetFromProps(</span><span class="s1">this</span><span class="s0">.props, key);</span>
            <span class="s1">if </span><span class="s0">(target !== undefined &amp;&amp; !isMotionValue(target))</span>
                <span class="s1">return </span><span class="s0">target;</span>
            <span class="s3">/**</span>
             <span class="s3">* If the value was initially defined on initial, but it doesn't any more,</span>
             <span class="s3">* return undefined. Otherwise return the value as initially read from the DOM.</span>
             <span class="s3">*/</span>
            <span class="s1">return this</span><span class="s0">.initialValues[key] !== undefined &amp;&amp;</span>
                <span class="s0">valueFromInitial === undefined</span>
                <span class="s0">? undefined</span>
                <span class="s0">: </span><span class="s1">this</span><span class="s0">.baseTarget[key];</span>
        <span class="s0">}</span>
        <span class="s0">on(eventName, callback) {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.events[eventName]) {</span>
                <span class="s1">this</span><span class="s0">.events[eventName] = </span><span class="s1">new </span><span class="s0">SubscriptionManager();</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">.events[eventName].add(callback);</span>
        <span class="s0">}</span>
        <span class="s0">notify(eventName, ...args) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.events[eventName]) {</span>
                <span class="s1">this</span><span class="s0">.events[eventName].notify(...args);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">scheduleRenderMicrotask() {</span>
            <span class="s0">microtask.render(</span><span class="s1">this</span><span class="s0">.render);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">DOMVisualElement </span><span class="s1">extends </span><span class="s0">VisualElement {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.KeyframeResolver = DOMKeyframesResolver;</span>
        <span class="s0">}</span>
        <span class="s0">sortInstanceNodePosition(a, b) {</span>
            <span class="s3">/**</span>
             <span class="s3">* compareDocumentPosition returns a bitmask, by using the bitwise &amp;</span>
             <span class="s3">* we're returning true if 2 in that bitmask is set to true. 2 is set</span>
             <span class="s3">* to true if b preceeds a.</span>
             <span class="s3">*/</span>
            <span class="s1">return </span><span class="s0">a.compareDocumentPosition(b) &amp; </span><span class="s5">2 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">getBaseTargetFromProps(props, key) {</span>
            <span class="s1">return </span><span class="s0">props.style</span>
                <span class="s0">? props.style[key]</span>
                <span class="s0">: undefined;</span>
        <span class="s0">}</span>
        <span class="s0">removeValueFromRenderState(key, { vars, style }) {</span>
            <span class="s1">delete </span><span class="s0">vars[key];</span>
            <span class="s1">delete </span><span class="s0">style[key];</span>
        <span class="s0">}</span>
        <span class="s0">handleChildMotionValue() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.childSubscription) {</span>
                <span class="s1">this</span><span class="s0">.childSubscription();</span>
                <span class="s1">delete this</span><span class="s0">.childSubscription;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">{ children } = </span><span class="s1">this</span><span class="s0">.props;</span>
            <span class="s1">if </span><span class="s0">(isMotionValue(children)) {</span>
                <span class="s1">this</span><span class="s0">.childSubscription = children.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, (latest) =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.current) {</span>
                        <span class="s1">this</span><span class="s0">.current.textContent = </span><span class="s2">`</span><span class="s0">${latest}</span><span class="s2">`</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">translateAlias = {</span>
        <span class="s0">x: </span><span class="s2">&quot;translateX&quot;</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s2">&quot;translateY&quot;</span><span class="s0">,</span>
        <span class="s0">z: </span><span class="s2">&quot;translateZ&quot;</span><span class="s0">,</span>
        <span class="s0">transformPerspective: </span><span class="s2">&quot;perspective&quot;</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">numTransforms = transformPropOrder.length;</span>
    <span class="s3">/**</span>
     <span class="s3">* Build a CSS transform style from individual x/y/scale etc properties.</span>
     <span class="s3">*</span>
     <span class="s3">* This outputs with a default order of transforms/scales/rotations, this can be customised by</span>
     <span class="s3">* providing a transformTemplate function.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">buildTransform(latestValues, transform, transformTemplate) {</span>
        <span class="s3">// The transform string we're going to build into.</span>
        <span class="s1">let </span><span class="s0">transformString = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">transformIsDefault = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Loop over all possible transforms in order, adding the ones that</span>
         <span class="s3">* are present to the transform string.</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numTransforms; i++) {</span>
            <span class="s1">const </span><span class="s0">key = transformPropOrder[i];</span>
            <span class="s1">const </span><span class="s0">value = latestValues[key];</span>
            <span class="s1">if </span><span class="s0">(value === undefined)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">let </span><span class="s0">valueIsDefault = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
                <span class="s0">valueIsDefault = value === (key.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">) ? </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">valueIsDefault = parseFloat(value) === </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!valueIsDefault || transformTemplate) {</span>
                <span class="s1">const </span><span class="s0">valueAsType = getValueAsType(value, numberValueTypes[key]);</span>
                <span class="s1">if </span><span class="s0">(!valueIsDefault) {</span>
                    <span class="s0">transformIsDefault = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">transformName = translateAlias[key] || key;</span>
                    <span class="s0">transformString += </span><span class="s2">`</span><span class="s0">${transformName}</span><span class="s2">(</span><span class="s0">${valueAsType}</span><span class="s2">) `</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(transformTemplate) {</span>
                    <span class="s0">transform[key] = valueAsType;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">transformString = transformString.trim();</span>
        <span class="s3">// If we have a custom `transform` template, pass our transform values and</span>
        <span class="s3">// generated transformString to that before returning</span>
        <span class="s1">if </span><span class="s0">(transformTemplate) {</span>
            <span class="s0">transformString = transformTemplate(transform, transformIsDefault ? </span><span class="s2">&quot;&quot; </span><span class="s0">: transformString);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(transformIsDefault) {</span>
            <span class="s0">transformString = </span><span class="s2">&quot;none&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">transformString;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">buildHTMLStyles(state, latestValues, transformTemplate) {</span>
        <span class="s1">const </span><span class="s0">{ style, vars, transformOrigin } = state;</span>
        <span class="s3">// Track whether we encounter any transform or transformOrigin values.</span>
        <span class="s1">let </span><span class="s0">hasTransform = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">hasTransformOrigin = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Loop over all our latest animated values and decide whether to handle them</span>
         <span class="s3">* as a style or CSS variable.</span>
         <span class="s3">*</span>
         <span class="s3">* Transforms and transform origins are kept separately for further processing.</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">latestValues) {</span>
            <span class="s1">const </span><span class="s0">value = latestValues[key];</span>
            <span class="s1">if </span><span class="s0">(transformProps.has(key)) {</span>
                <span class="s3">// If this is a transform, flag to enable further transform processing</span>
                <span class="s0">hasTransform = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(isCSSVariableName(key)) {</span>
                <span class="s0">vars[key] = value;</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// Convert the value to its default value type, ie 0 -&gt; &quot;0px&quot;</span>
                <span class="s1">const </span><span class="s0">valueAsType = getValueAsType(value, numberValueTypes[key]);</span>
                <span class="s1">if </span><span class="s0">(key.startsWith(</span><span class="s2">&quot;origin&quot;</span><span class="s0">)) {</span>
                    <span class="s3">// If this is a transform origin, flag and enable further transform-origin processing</span>
                    <span class="s0">hasTransformOrigin = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">transformOrigin[key] =</span>
                        <span class="s0">valueAsType;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">style[key] = valueAsType;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!latestValues.transform) {</span>
            <span class="s1">if </span><span class="s0">(hasTransform || transformTemplate) {</span>
                <span class="s0">style.transform = buildTransform(latestValues, state.transform, transformTemplate);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(style.transform) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we have previously created a transform but currently don't have any,</span>
                 <span class="s3">* reset transform style to none.</span>
                 <span class="s3">*/</span>
                <span class="s0">style.transform = </span><span class="s2">&quot;none&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Build a transformOrigin style. Uses the same defaults as the browser for</span>
         <span class="s3">* undefined origins.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(hasTransformOrigin) {</span>
            <span class="s1">const </span><span class="s0">{ originX = </span><span class="s2">&quot;50%&quot;</span><span class="s0">, originY = </span><span class="s2">&quot;50%&quot;</span><span class="s0">, originZ = </span><span class="s5">0</span><span class="s0">, } = transformOrigin;</span>
            <span class="s0">style.transformOrigin = </span><span class="s2">`</span><span class="s0">${originX} ${originY} ${originZ}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">renderHTML(element, { style, vars }, styleProp, projection) {</span>
        <span class="s1">const </span><span class="s0">elementStyle = element.style;</span>
        <span class="s1">let </span><span class="s0">key;</span>
        <span class="s1">for </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">style) {</span>
            <span class="s3">// CSSStyleDeclaration has [index: number]: string; in the types, so we use that as key type.</span>
            <span class="s0">elementStyle[key] = style[key];</span>
        <span class="s0">}</span>
        <span class="s3">// Write projection styles directly to element style</span>
        <span class="s0">projection?.applyProjectionStyles(elementStyle, styleProp);</span>
        <span class="s1">for </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">vars) {</span>
            <span class="s3">// Loop over any CSS variables and assign those.</span>
            <span class="s3">// They can only be assigned using `setProperty`.</span>
            <span class="s0">elementStyle.setProperty(key, vars[key]);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isForcedMotionValue(key, { layout, layoutId }) {</span>
        <span class="s1">return </span><span class="s0">(transformProps.has(key) ||</span>
            <span class="s0">key.startsWith(</span><span class="s2">&quot;origin&quot;</span><span class="s0">) ||</span>
            <span class="s0">((layout || layoutId !== undefined) &amp;&amp;</span>
                <span class="s0">(!!scaleCorrectors[key] || key === </span><span class="s2">&quot;opacity&quot;</span><span class="s0">)));</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {</span>
        <span class="s1">const </span><span class="s0">{ style } = props;</span>
        <span class="s1">const </span><span class="s0">newValues = {};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">style) {</span>
            <span class="s1">if </span><span class="s0">(isMotionValue(style[key]) ||</span>
                <span class="s0">(prevProps.style &amp;&amp;</span>
                    <span class="s0">isMotionValue(prevProps.style[key])) ||</span>
                <span class="s0">isForcedMotionValue(key, props) ||</span>
                <span class="s0">visualElement?.getValue(key)?.liveStyle !== undefined) {</span>
                <span class="s0">newValues[key] = style[key];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">newValues;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getComputedStyle$1(element) {</span>
        <span class="s1">return </span><span class="s0">window.getComputedStyle(element);</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">HTMLVisualElement </span><span class="s1">extends </span><span class="s0">DOMVisualElement {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.type = </span><span class="s2">&quot;html&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.renderInstance = renderHTML;</span>
        <span class="s0">}</span>
        <span class="s0">readValueFromInstance(instance, key) {</span>
            <span class="s1">if </span><span class="s0">(transformProps.has(key)) {</span>
                <span class="s1">return this</span><span class="s0">.projection?.isProjecting</span>
                    <span class="s0">? defaultTransformValue(key)</span>
                    <span class="s0">: readTransformValue(instance, key);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">const </span><span class="s0">computedStyle = getComputedStyle$1(instance);</span>
                <span class="s1">const </span><span class="s0">value = (isCSSVariableName(key)</span>
                    <span class="s0">? computedStyle.getPropertyValue(key)</span>
                    <span class="s0">: computedStyle[key]) || </span><span class="s5">0</span><span class="s0">;</span>
                <span class="s1">return typeof </span><span class="s0">value === </span><span class="s2">&quot;string&quot; </span><span class="s0">? value.trim() : value;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">measureInstanceViewportBox(instance, { transformPagePoint }) {</span>
            <span class="s1">return </span><span class="s0">measureViewportBox(instance, transformPagePoint);</span>
        <span class="s0">}</span>
        <span class="s0">build(renderState, latestValues, props) {</span>
            <span class="s0">buildHTMLStyles(renderState, latestValues, props.transformTemplate);</span>
        <span class="s0">}</span>
        <span class="s0">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span>
            <span class="s1">return </span><span class="s0">scrapeMotionValuesFromProps$1(props, prevProps, visualElement);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useIsMounted() {</span>
        <span class="s1">const </span><span class="s0">isMounted = React$1.useRef(</span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">useIsomorphicLayoutEffect(() =&gt; {</span>
            <span class="s0">isMounted.current = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">isMounted.current = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">};</span>
        <span class="s0">}, []);</span>
        <span class="s1">return </span><span class="s0">isMounted;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useForceUpdate() {</span>
        <span class="s1">const </span><span class="s0">isMounted = useIsMounted();</span>
        <span class="s1">const </span><span class="s0">[forcedRenderCount, setForcedRenderCount] = React$1.useState(</span><span class="s5">0</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">forceRender = React$1.useCallback(() =&gt; {</span>
            <span class="s0">isMounted.current &amp;&amp; setForcedRenderCount(forcedRenderCount + </span><span class="s5">1</span><span class="s0">);</span>
        <span class="s0">}, [forcedRenderCount]);</span>
        <span class="s3">/**</span>
         <span class="s3">* Defer this to the end of the next animation frame in case there are multiple</span>
         <span class="s3">* synchronous calls.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">deferredForceRender = React$1.useCallback(() =&gt; frame.postRender(forceRender), [forceRender]);</span>
        <span class="s1">return </span><span class="s0">[deferredForceRender, forcedRenderCount];</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">shouldInheritGroup = (inherit) =&gt; inherit === </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">shouldInheritId = (inherit) =&gt; shouldInheritGroup(inherit === </span><span class="s1">true</span><span class="s0">) || inherit === </span><span class="s2">&quot;id&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">LayoutGroup = ({ children, id, inherit = </span><span class="s1">true </span><span class="s0">}) =&gt; {</span>
        <span class="s1">const </span><span class="s0">layoutGroupContext = React$1.useContext(LayoutGroupContext);</span>
        <span class="s1">const </span><span class="s0">deprecatedLayoutGroupContext = React$1.useContext(DeprecatedLayoutGroupContext);</span>
        <span class="s1">const </span><span class="s0">[forceRender, key] = useForceUpdate();</span>
        <span class="s1">const </span><span class="s0">context = React$1.useRef(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;</span>
        <span class="s1">if </span><span class="s0">(context.current === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(shouldInheritId(inherit) &amp;&amp; upstreamId) {</span>
                <span class="s0">id = id ? upstreamId + </span><span class="s2">&quot;-&quot; </span><span class="s0">+ id : upstreamId;</span>
            <span class="s0">}</span>
            <span class="s0">context.current = {</span>
                <span class="s0">id,</span>
                <span class="s0">group: shouldInheritGroup(inherit)</span>
                    <span class="s0">? layoutGroupContext.group || nodeGroup()</span>
                    <span class="s0">: nodeGroup(),</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">memoizedContext = React$1.useMemo(() =&gt; ({ ...context.current, forceRender }), [key]);</span>
        <span class="s1">return </span><span class="s0">(jsx(LayoutGroupContext.Provider, { value: memoizedContext, children: children }));</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">LazyContext = React$1.createContext({ strict: </span><span class="s1">false </span><span class="s0">});</span>

    <span class="s1">function </span><span class="s0">loadFeatures(features) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">features) {</span>
            <span class="s0">featureDefinitions[key] = {</span>
                <span class="s0">...featureDefinitions[key],</span>
                <span class="s0">...features[key],</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Used in conjunction with the `m` component to reduce bundle size.</span>
     <span class="s3">*</span>
     <span class="s3">* `m` is a version of the `motion` component that only loads functionality</span>
     <span class="s3">* critical for the initial render.</span>
     <span class="s3">*</span>
     <span class="s3">* `LazyMotion` can then be used to either synchronously or asynchronously</span>
     <span class="s3">* load animation and gesture support.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* // Synchronous loading</span>
     <span class="s3">* import { LazyMotion, m, domAnimation } from &quot;framer-motion&quot;</span>
     <span class="s3">*</span>
     <span class="s3">* function App() {</span>
     <span class="s3">*   return (</span>
     <span class="s3">*     &lt;LazyMotion features={domAnimation}&gt;</span>
     <span class="s3">*       &lt;m.div animate={{ scale: 2 }} /&gt;</span>
     <span class="s3">*     &lt;/LazyMotion&gt;</span>
     <span class="s3">*   )</span>
     <span class="s3">* }</span>
     <span class="s3">*</span>
     <span class="s3">* // Asynchronous loading</span>
     <span class="s3">* import { LazyMotion, m } from &quot;framer-motion&quot;</span>
     <span class="s3">*</span>
     <span class="s3">* function App() {</span>
     <span class="s3">*   return (</span>
     <span class="s3">*     &lt;LazyMotion features={() =&gt; import('./path/to/domAnimation')}&gt;</span>
     <span class="s3">*       &lt;m.div animate={{ scale: 2 }} /&gt;</span>
     <span class="s3">*     &lt;/LazyMotion&gt;</span>
     <span class="s3">*   )</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">LazyMotion({ children, features, strict = </span><span class="s1">false </span><span class="s0">}) {</span>
        <span class="s1">const </span><span class="s0">[, setIsLoaded] = React$1.useState(!isLazyBundle(features));</span>
        <span class="s1">const </span><span class="s0">loadedRenderer = React$1.useRef(undefined);</span>
        <span class="s3">/**</span>
         <span class="s3">* If this is a synchronous load, load features immediately</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!isLazyBundle(features)) {</span>
            <span class="s1">const </span><span class="s0">{ renderer, ...loadedFeatures } = features;</span>
            <span class="s0">loadedRenderer.current = renderer;</span>
            <span class="s0">loadFeatures(loadedFeatures);</span>
        <span class="s0">}</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(isLazyBundle(features)) {</span>
                <span class="s0">features().then(({ renderer, ...loadedFeatures }) =&gt; {</span>
                    <span class="s0">loadFeatures(loadedFeatures);</span>
                    <span class="s0">loadedRenderer.current = renderer;</span>
                    <span class="s0">setIsLoaded(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}, []);</span>
        <span class="s1">return </span><span class="s0">(jsx(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children: children }));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isLazyBundle(features) {</span>
        <span class="s1">return typeof </span><span class="s0">features === </span><span class="s2">&quot;function&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of all valid MotionProps.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@privateRemarks</span>
     <span class="s3">* This doesn't throw if a `MotionProp` name is missing - it should.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">validMotionProps = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;animate&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;exit&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;variants&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;initial&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;style&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;values&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;variants&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;transition&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;transformTemplate&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;custom&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;inherit&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onBeforeLayoutMeasure&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onAnimationStart&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onAnimationComplete&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onUpdate&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onDragStart&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onDrag&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onDragEnd&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onMeasureDragConstraints&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onDirectionLock&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onDragTransitionEnd&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;_dragX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;_dragY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onHoverStart&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onHoverEnd&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onViewportEnter&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;onViewportLeave&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;globalTapTarget&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;ignoreStrict&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;viewport&quot;</span><span class="s0">,</span>
    <span class="s0">]);</span>
    <span class="s3">/**</span>
     <span class="s3">* Check whether a prop name is a valid `MotionProp` key.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">key - Name of the property to check</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">`true` is key is a valid `MotionProp`.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isValidMotionProp(key) {</span>
        <span class="s1">return </span><span class="s0">(key.startsWith(</span><span class="s2">&quot;while&quot;</span><span class="s0">) ||</span>
            <span class="s0">(key.startsWith(</span><span class="s2">&quot;drag&quot;</span><span class="s0">) &amp;&amp; key !== </span><span class="s2">&quot;draggable&quot;</span><span class="s0">) ||</span>
            <span class="s0">key.startsWith(</span><span class="s2">&quot;layout&quot;</span><span class="s0">) ||</span>
            <span class="s0">key.startsWith(</span><span class="s2">&quot;onTap&quot;</span><span class="s0">) ||</span>
            <span class="s0">key.startsWith(</span><span class="s2">&quot;onPan&quot;</span><span class="s0">) ||</span>
            <span class="s0">key.startsWith(</span><span class="s2">&quot;onLayout&quot;</span><span class="s0">) ||</span>
            <span class="s0">validMotionProps.has(key));</span>
    <span class="s0">}</span>

    <span class="s1">let </span><span class="s0">shouldForward = (key) =&gt; !isValidMotionProp(key);</span>
    <span class="s1">function </span><span class="s0">loadExternalIsValidProp(isValidProp) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">isValidProp !== </span><span class="s2">&quot;function&quot;</span><span class="s0">)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s3">// Explicitly filter our events</span>
        <span class="s0">shouldForward = (key) =&gt; key.startsWith(</span><span class="s2">&quot;on&quot;</span><span class="s0">) ? !isValidMotionProp(key) : isValidProp(key);</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Emotion and Styled Components both allow users to pass through arbitrary props to their components</span>
     <span class="s3">* to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which</span>
     <span class="s3">* of these should be passed to the underlying DOM node.</span>
     <span class="s3">*</span>
     <span class="s3">* However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props</span>
     <span class="s3">* as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props</span>
     <span class="s3">* passed through the `custom` prop so it doesn't *need* the payload or computational overhead of</span>
     <span class="s3">* `@emotion/is-prop-valid`, however to fix this problem we need to use it.</span>
     <span class="s3">*</span>
     <span class="s3">* By making it an optionalDependency we can offer this functionality only in the situations where it's</span>
     <span class="s3">* actually required.</span>
     <span class="s3">*/</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s3">/**</span>
         <span class="s3">* We attempt to import this package but require won't be defined in esm environments, in that case</span>
         <span class="s3">* isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed</span>
         <span class="s3">* in favour of explicit injection.</span>
         <span class="s3">*/</span>
        <span class="s0">loadExternalIsValidProp(require(</span><span class="s2">&quot;@emotion/is-prop-valid&quot;</span><span class="s0">).default);</span>
    <span class="s0">}</span>
    <span class="s1">catch </span><span class="s0">{</span>
        <span class="s3">// We don't need to actually do anything here - the fallback is the existing `isPropValid`.</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">filterProps(props, isDom, forwardMotionProps) {</span>
        <span class="s1">const </span><span class="s0">filteredProps = {};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">props) {</span>
            <span class="s3">/**</span>
             <span class="s3">* values is considered a valid prop by Emotion, so if it's present</span>
             <span class="s3">* this will be rendered out to the DOM unless explicitly filtered.</span>
             <span class="s3">*</span>
             <span class="s3">* We check the type as it could be used with the `feColorMatrix`</span>
             <span class="s3">* element, which we support.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(key === </span><span class="s2">&quot;values&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">props.values === </span><span class="s2">&quot;object&quot;</span><span class="s0">)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(shouldForward(key) ||</span>
                <span class="s0">(forwardMotionProps === </span><span class="s1">true </span><span class="s0">&amp;&amp; isValidMotionProp(key)) ||</span>
                <span class="s0">(!isDom &amp;&amp; !isValidMotionProp(key)) ||</span>
                <span class="s3">// If trying to use native HTML drag events, forward drag listeners</span>
                <span class="s0">(props[</span><span class="s2">&quot;draggable&quot;</span><span class="s0">] &amp;&amp;</span>
                    <span class="s0">key.startsWith(</span><span class="s2">&quot;onDrag&quot;</span><span class="s0">))) {</span>
                <span class="s0">filteredProps[key] =</span>
                    <span class="s0">props[key];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">filteredProps;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* `MotionConfig` is used to set configuration options for all children `motion` components.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* import { motion, MotionConfig } from &quot;framer-motion&quot;</span>
     <span class="s3">*</span>
     <span class="s3">* export function App() {</span>
     <span class="s3">*   return (</span>
     <span class="s3">*     &lt;MotionConfig transition={{ type: &quot;spring&quot; }}&gt;</span>
     <span class="s3">*       &lt;motion.div animate={{ x: 100 }} /&gt;</span>
     <span class="s3">*     &lt;/MotionConfig&gt;</span>
     <span class="s3">*   )</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">MotionConfig({ children, isValidProp, ...config }) {</span>
        <span class="s0">isValidProp &amp;&amp; loadExternalIsValidProp(isValidProp);</span>
        <span class="s3">/**</span>
         <span class="s3">* Inherit props from any parent MotionConfig components</span>
         <span class="s3">*/</span>
        <span class="s0">config = { ...React$1.useContext(MotionConfigContext), ...config };</span>
        <span class="s3">/**</span>
         <span class="s3">* Don't allow isStatic to change between renders as it affects how many hooks</span>
         <span class="s3">* motion components fire.</span>
         <span class="s3">*/</span>
        <span class="s0">config.isStatic = useConstant(() =&gt; config.isStatic);</span>
        <span class="s3">/**</span>
         <span class="s3">* Creating a new config context object will re-render every `motion` component</span>
         <span class="s3">* every time it renders. So we only want to create a new one sparingly.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">context = React$1.useMemo(() =&gt; config, [</span>
            <span class="s0">JSON.stringify(config.transition),</span>
            <span class="s0">config.transformPagePoint,</span>
            <span class="s0">config.reducedMotion,</span>
        <span class="s0">]);</span>
        <span class="s1">return </span><span class="s0">(jsx(MotionConfigContext.Provider, { value: context, children: children }));</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">ReorderContext = React$1.createContext(</span><span class="s1">null</span><span class="s0">);</span>

    <span class="s1">const </span><span class="s0">dashKeys = {</span>
        <span class="s0">offset: </span><span class="s2">&quot;stroke-dashoffset&quot;</span><span class="s0">,</span>
        <span class="s0">array: </span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">camelKeys = {</span>
        <span class="s0">offset: </span><span class="s2">&quot;strokeDashoffset&quot;</span><span class="s0">,</span>
        <span class="s0">array: </span><span class="s2">&quot;strokeDasharray&quot;</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* Build SVG path properties. Uses the path's measured length to convert</span>
     <span class="s3">* our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset</span>
     <span class="s3">* and stroke-dasharray attributes.</span>
     <span class="s3">*</span>
     <span class="s3">* This function is mutative to reduce per-frame GC.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">buildSVGPath(attrs, length, spacing = </span><span class="s5">1</span><span class="s0">, offset = </span><span class="s5">0</span><span class="s0">, useDashCase = </span><span class="s1">true</span><span class="s0">) {</span>
        <span class="s3">// Normalise path length by setting SVG attribute pathLength to 1</span>
        <span class="s0">attrs.pathLength = </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s3">// We use dash case when setting attributes directly to the DOM node and camel case</span>
        <span class="s3">// when defining props on a React component.</span>
        <span class="s1">const </span><span class="s0">keys = useDashCase ? dashKeys : camelKeys;</span>
        <span class="s3">// Build the dash offset</span>
        <span class="s0">attrs[keys.offset] = px.transform(-offset);</span>
        <span class="s3">// Build the dash array</span>
        <span class="s1">const </span><span class="s0">pathLength = px.transform(length);</span>
        <span class="s1">const </span><span class="s0">pathSpacing = px.transform(spacing);</span>
        <span class="s0">attrs[keys.array] = </span><span class="s2">`</span><span class="s0">${pathLength} ${pathSpacing}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Build SVG visual attributes, like cx and style.transform</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">buildSVGAttrs(state, { attrX, attrY, attrScale, pathLength, pathSpacing = </span><span class="s5">1</span><span class="s0">, pathOffset = </span><span class="s5">0</span><span class="s0">, </span>
    <span class="s3">// This is object creation, which we try to avoid per-frame.</span>
    <span class="s0">...latest }, isSVGTag, transformTemplate, styleProp) {</span>
        <span class="s0">buildHTMLStyles(state, latest, transformTemplate);</span>
        <span class="s3">/**</span>
         <span class="s3">* For svg tags we just want to make sure viewBox is animatable and treat all the styles</span>
         <span class="s3">* as normal HTML tags.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(isSVGTag) {</span>
            <span class="s1">if </span><span class="s0">(state.style.viewBox) {</span>
                <span class="s0">state.attrs.viewBox = state.style.viewBox;</span>
            <span class="s0">}</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">state.attrs = state.style;</span>
        <span class="s0">state.style = {};</span>
        <span class="s1">const </span><span class="s0">{ attrs, style } = state;</span>
        <span class="s3">/**</span>
         <span class="s3">* However, we apply transforms as CSS transforms.</span>
         <span class="s3">* So if we detect a transform, transformOrigin we take it from attrs and copy it into style.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(attrs.transform) {</span>
            <span class="s0">style.transform = attrs.transform;</span>
            <span class="s1">delete </span><span class="s0">attrs.transform;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(style.transform || attrs.transformOrigin) {</span>
            <span class="s0">style.transformOrigin = attrs.transformOrigin ?? </span><span class="s2">&quot;50% 50%&quot;</span><span class="s0">;</span>
            <span class="s1">delete </span><span class="s0">attrs.transformOrigin;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(style.transform) {</span>
            <span class="s3">/**</span>
             <span class="s3">* SVG's element transform-origin uses its own median as a reference.</span>
             <span class="s3">* Therefore, transformBox becomes a fill-box</span>
             <span class="s3">*/</span>
            <span class="s0">style.transformBox = styleProp?.transformBox ?? </span><span class="s2">&quot;fill-box&quot;</span><span class="s0">;</span>
            <span class="s1">delete </span><span class="s0">attrs.transformBox;</span>
        <span class="s0">}</span>
        <span class="s3">// Render attrX/attrY/attrScale as attributes</span>
        <span class="s1">if </span><span class="s0">(attrX !== undefined)</span>
            <span class="s0">attrs.x = attrX;</span>
        <span class="s1">if </span><span class="s0">(attrY !== undefined)</span>
            <span class="s0">attrs.y = attrY;</span>
        <span class="s1">if </span><span class="s0">(attrScale !== undefined)</span>
            <span class="s0">attrs.scale = attrScale;</span>
        <span class="s3">// Build SVG path if one has been defined</span>
        <span class="s1">if </span><span class="s0">(pathLength !== undefined) {</span>
            <span class="s0">buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, </span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A set of attribute names that are always read/written as camel case.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">camelCaseAttributes = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;baseFrequency&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;diffuseConstant&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;kernelMatrix&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;kernelUnitLength&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;keySplines&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;keyTimes&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;limitingConeAngle&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;markerHeight&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;markerWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;numOctaves&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;targetX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;targetY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;surfaceScale&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;specularConstant&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;specularExponent&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;stdDeviation&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;tableValues&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;viewBox&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;gradientTransform&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pathLength&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;startOffset&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;textLength&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;lengthAdjust&quot;</span><span class="s0">,</span>
    <span class="s0">]);</span>

    <span class="s1">const </span><span class="s0">isSVGTag = (tag) =&gt; </span><span class="s1">typeof </span><span class="s0">tag === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; tag.toLowerCase() === </span><span class="s2">&quot;svg&quot;</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">renderSVG(element, renderState, _styleProp, projection) {</span>
        <span class="s0">renderHTML(element, renderState, undefined, projection);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">renderState.attrs) {</span>
            <span class="s0">element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span>
        <span class="s1">const </span><span class="s0">newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">props) {</span>
            <span class="s1">if </span><span class="s0">(isMotionValue(props[key]) ||</span>
                <span class="s0">isMotionValue(prevProps[key])) {</span>
                <span class="s1">const </span><span class="s0">targetKey = transformPropOrder.indexOf(key) !== -</span><span class="s5">1</span>
                    <span class="s0">? </span><span class="s2">&quot;attr&quot; </span><span class="s0">+ key.charAt(</span><span class="s5">0</span><span class="s0">).toUpperCase() + key.substring(</span><span class="s5">1</span><span class="s0">)</span>
                    <span class="s0">: key;</span>
                <span class="s0">newValues[targetKey] = props[key];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">newValues;</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">SVGVisualElement </span><span class="s1">extends </span><span class="s0">DOMVisualElement {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.type = </span><span class="s2">&quot;svg&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isSVGTag = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.measureInstanceViewportBox = createBox;</span>
        <span class="s0">}</span>
        <span class="s0">getBaseTargetFromProps(props, key) {</span>
            <span class="s1">return </span><span class="s0">props[key];</span>
        <span class="s0">}</span>
        <span class="s0">readValueFromInstance(instance, key) {</span>
            <span class="s1">if </span><span class="s0">(transformProps.has(key)) {</span>
                <span class="s1">const </span><span class="s0">defaultType = getDefaultValueType(key);</span>
                <span class="s1">return </span><span class="s0">defaultType ? defaultType.default || </span><span class="s5">0 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;</span>
            <span class="s1">return </span><span class="s0">instance.getAttribute(key);</span>
        <span class="s0">}</span>
        <span class="s0">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span>
            <span class="s1">return </span><span class="s0">scrapeMotionValuesFromProps(props, prevProps, visualElement);</span>
        <span class="s0">}</span>
        <span class="s0">build(renderState, latestValues, props) {</span>
            <span class="s0">buildSVGAttrs(renderState, latestValues, </span><span class="s1">this</span><span class="s0">.isSVGTag, props.transformTemplate, props.style);</span>
        <span class="s0">}</span>
        <span class="s0">renderInstance(instance, renderState, styleProp, projection) {</span>
            <span class="s0">renderSVG(instance, renderState, styleProp, projection);</span>
        <span class="s0">}</span>
        <span class="s0">mount(instance) {</span>
            <span class="s1">this</span><span class="s0">.isSVGTag = isSVGTag(instance.tagName);</span>
            <span class="s1">super</span><span class="s0">.mount(instance);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* We keep these listed separately as we use the lowercase tag names as part</span>
     <span class="s3">* of the runtime bundle to detect SVG components</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">lowercaseSVGElements = [</span>
        <span class="s2">&quot;animate&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;circle&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;defs&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;desc&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;ellipse&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;g&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;image&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;line&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;filter&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marker&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;mask&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;path&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pattern&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;polygon&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;polyline&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rect&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;stop&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;switch&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;symbol&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;svg&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;text&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;tspan&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;use&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;view&quot;</span><span class="s0">,</span>
    <span class="s0">];</span>

    <span class="s1">function </span><span class="s0">isSVGComponent(Component) {</span>
        <span class="s1">if </span><span class="s0">(</span>
        <span class="s3">/**</span>
         <span class="s3">* If it's not a string, it's a custom React component. Currently we only support</span>
         <span class="s3">* HTML custom React components.</span>
         <span class="s3">*/</span>
        <span class="s1">typeof </span><span class="s0">Component !== </span><span class="s2">&quot;string&quot; </span><span class="s0">||</span>
            <span class="s3">/**</span>
             <span class="s3">* If it contains a dash, the element is a custom HTML webcomponent.</span>
             <span class="s3">*/</span>
            <span class="s0">Component.includes(</span><span class="s2">&quot;-&quot;</span><span class="s0">)) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span>
        <span class="s3">/**</span>
         <span class="s3">* If it's in our list of lowercase SVG tags, it's an SVG component</span>
         <span class="s3">*/</span>
        <span class="s0">lowercaseSVGElements.indexOf(Component) &gt; -</span><span class="s5">1 </span><span class="s0">||</span>
            <span class="s3">/**</span>
             <span class="s3">* If it contains a capital letter, it's an SVG component</span>
             <span class="s3">*/</span>
            <span class="s6">/[A-Z]/u</span><span class="s0">.test(Component)) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">createDomVisualElement = (Component, options) =&gt; {</span>
        <span class="s1">return </span><span class="s0">isSVGComponent(Component)</span>
            <span class="s0">? </span><span class="s1">new </span><span class="s0">SVGVisualElement(options)</span>
            <span class="s0">: </span><span class="s1">new </span><span class="s0">HTMLVisualElement(options, {</span>
                <span class="s0">allowProjection: Component !== React$1.Fragment,</span>
            <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">MotionContext = </span><span class="s3">/* @__PURE__ */ </span><span class="s0">React$1.createContext({});</span>

    <span class="s1">function </span><span class="s0">getCurrentTreeVariants(props, context) {</span>
        <span class="s1">if </span><span class="s0">(isControllingVariants(props)) {</span>
            <span class="s1">const </span><span class="s0">{ initial, animate } = props;</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">initial: initial === </span><span class="s1">false </span><span class="s0">|| isVariantLabel(initial)</span>
                    <span class="s0">? initial</span>
                    <span class="s0">: undefined,</span>
                <span class="s0">animate: isVariantLabel(animate) ? animate : undefined,</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">props.inherit !== </span><span class="s1">false </span><span class="s0">? context : {};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useCreateMotionContext(props) {</span>
        <span class="s1">const </span><span class="s0">{ initial, animate } = getCurrentTreeVariants(props, React$1.useContext(MotionContext));</span>
        <span class="s1">return </span><span class="s0">React$1.useMemo(() =&gt; ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">variantLabelsAsDependency(prop) {</span>
        <span class="s1">return </span><span class="s0">Array.isArray(prop) ? prop.join(</span><span class="s2">&quot; &quot;</span><span class="s0">) : prop;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">createHtmlRenderState = () =&gt; ({</span>
        <span class="s0">style: {},</span>
        <span class="s0">transform: {},</span>
        <span class="s0">transformOrigin: {},</span>
        <span class="s0">vars: {},</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">copyRawValuesOnly(target, source, props) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">source) {</span>
            <span class="s1">if </span><span class="s0">(!isMotionValue(source[key]) &amp;&amp; !isForcedMotionValue(key, props)) {</span>
                <span class="s0">target[key] = source[key];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">useInitialMotionValues({ transformTemplate }, visualState) {</span>
        <span class="s1">return </span><span class="s0">React$1.useMemo(() =&gt; {</span>
            <span class="s1">const </span><span class="s0">state = createHtmlRenderState();</span>
            <span class="s0">buildHTMLStyles(state, visualState, transformTemplate);</span>
            <span class="s1">return </span><span class="s0">Object.assign({}, state.vars, state.style);</span>
        <span class="s0">}, [visualState]);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">useStyle(props, visualState) {</span>
        <span class="s1">const </span><span class="s0">styleProp = props.style || {};</span>
        <span class="s1">const </span><span class="s0">style = {};</span>
        <span class="s3">/**</span>
         <span class="s3">* Copy non-Motion Values straight into style</span>
         <span class="s3">*/</span>
        <span class="s0">copyRawValuesOnly(style, styleProp, props);</span>
        <span class="s0">Object.assign(style, useInitialMotionValues(props, visualState));</span>
        <span class="s1">return </span><span class="s0">style;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">useHTMLProps(props, visualState) {</span>
        <span class="s3">// The `any` isn't ideal but it is the type of createElement props argument</span>
        <span class="s1">const </span><span class="s0">htmlProps = {};</span>
        <span class="s1">const </span><span class="s0">style = useStyle(props, visualState);</span>
        <span class="s1">if </span><span class="s0">(props.drag &amp;&amp; props.dragListener !== </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s3">// Disable the ghost element when a user drags</span>
            <span class="s0">htmlProps.draggable = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">// Disable text selection</span>
            <span class="s0">style.userSelect =</span>
                <span class="s0">style.WebkitUserSelect =</span>
                    <span class="s0">style.WebkitTouchCallout =</span>
                        <span class="s2">&quot;none&quot;</span><span class="s0">;</span>
            <span class="s3">// Disable scrolling on the draggable direction</span>
            <span class="s0">style.touchAction =</span>
                <span class="s0">props.drag === </span><span class="s1">true</span>
                    <span class="s0">? </span><span class="s2">&quot;none&quot;</span>
                    <span class="s0">: </span><span class="s2">`pan-</span><span class="s0">${props.drag === </span><span class="s2">&quot;x&quot; </span><span class="s0">? </span><span class="s2">&quot;y&quot; </span><span class="s0">: </span><span class="s2">&quot;x&quot;</span><span class="s0">}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(props.tabIndex === undefined &amp;&amp;</span>
            <span class="s0">(props.onTap || props.onTapStart || props.whileTap)) {</span>
            <span class="s0">htmlProps.tabIndex = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">htmlProps.style = style;</span>
        <span class="s1">return </span><span class="s0">htmlProps;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">createSvgRenderState = () =&gt; ({</span>
        <span class="s0">...createHtmlRenderState(),</span>
        <span class="s0">attrs: {},</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">useSVGProps(props, visualState, _isStatic, Component) {</span>
        <span class="s1">const </span><span class="s0">visualProps = React$1.useMemo(() =&gt; {</span>
            <span class="s1">const </span><span class="s0">state = createSvgRenderState();</span>
            <span class="s0">buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">...state.attrs,</span>
                <span class="s0">style: { ...state.style },</span>
            <span class="s0">};</span>
        <span class="s0">}, [visualState]);</span>
        <span class="s1">if </span><span class="s0">(props.style) {</span>
            <span class="s1">const </span><span class="s0">rawStyles = {};</span>
            <span class="s0">copyRawValuesOnly(rawStyles, props.style, props);</span>
            <span class="s0">visualProps.style = { ...rawStyles, ...visualProps.style };</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">visualProps;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useRender(Component, props, ref, { latestValues, }, isStatic, forwardMotionProps = </span><span class="s1">false</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">useVisualProps = isSVGComponent(Component)</span>
            <span class="s0">? useSVGProps</span>
            <span class="s0">: useHTMLProps;</span>
        <span class="s1">const </span><span class="s0">visualProps = useVisualProps(props, latestValues, isStatic, Component);</span>
        <span class="s1">const </span><span class="s0">filteredProps = filterProps(props, </span><span class="s1">typeof </span><span class="s0">Component === </span><span class="s2">&quot;string&quot;</span><span class="s0">, forwardMotionProps);</span>
        <span class="s1">const </span><span class="s0">elementProps = Component !== React$1.Fragment ? { ...filteredProps, ...visualProps, ref } : {};</span>
        <span class="s3">/**</span>
         <span class="s3">* If component has been handed a motion value as its child,</span>
         <span class="s3">* memoise its initial value and render that. Subsequent updates</span>
         <span class="s3">* will be handled by the onChange handler</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">{ children } = props;</span>
        <span class="s1">const </span><span class="s0">renderedChildren = React$1.useMemo(() =&gt; (isMotionValue(children) ? children.get() : children), [children]);</span>
        <span class="s1">return </span><span class="s0">React$1.createElement(Component, {</span>
            <span class="s0">...elementProps,</span>
            <span class="s0">children: renderedChildren,</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {</span>
        <span class="s1">const </span><span class="s0">state = {</span>
            <span class="s0">latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),</span>
            <span class="s0">renderState: createRenderState(),</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">state;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">makeLatestValues(props, context, presenceContext, scrapeMotionValues) {</span>
        <span class="s1">const </span><span class="s0">values = {};</span>
        <span class="s1">const </span><span class="s0">motionValues = scrapeMotionValues(props, {});</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">motionValues) {</span>
            <span class="s0">values[key] = resolveMotionValue(motionValues[key]);</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">{ initial, animate } = props;</span>
        <span class="s1">const </span><span class="s0">isControllingVariants$1 = isControllingVariants(props);</span>
        <span class="s1">const </span><span class="s0">isVariantNode$1 = isVariantNode(props);</span>
        <span class="s1">if </span><span class="s0">(context &amp;&amp;</span>
            <span class="s0">isVariantNode$1 &amp;&amp;</span>
            <span class="s0">!isControllingVariants$1 &amp;&amp;</span>
            <span class="s0">props.inherit !== </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(initial === undefined)</span>
                <span class="s0">initial = context.initial;</span>
            <span class="s1">if </span><span class="s0">(animate === undefined)</span>
                <span class="s0">animate = context.animate;</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">isInitialAnimationBlocked = presenceContext</span>
            <span class="s0">? presenceContext.initial === </span><span class="s1">false</span>
            <span class="s0">: </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">isInitialAnimationBlocked = isInitialAnimationBlocked || initial === </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">variantToSet = isInitialAnimationBlocked ? animate : initial;</span>
        <span class="s1">if </span><span class="s0">(variantToSet &amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">variantToSet !== </span><span class="s2">&quot;boolean&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">!isAnimationControls(variantToSet)) {</span>
            <span class="s1">const </span><span class="s0">list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; list.length; i++) {</span>
                <span class="s1">const </span><span class="s0">resolved = resolveVariantFromProps(props, list[i]);</span>
                <span class="s1">if </span><span class="s0">(resolved) {</span>
                    <span class="s1">const </span><span class="s0">{ transitionEnd, transition, ...target } = resolved;</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">target) {</span>
                        <span class="s1">let </span><span class="s0">valueTarget = target[key];</span>
                        <span class="s1">if </span><span class="s0">(Array.isArray(valueTarget)) {</span>
                            <span class="s3">/**</span>
                             <span class="s3">* Take final keyframe if the initial animation is blocked because</span>
                             <span class="s3">* we want to initialise at the end of that blocked animation.</span>
                             <span class="s3">*/</span>
                            <span class="s1">const </span><span class="s0">index = isInitialAnimationBlocked</span>
                                <span class="s0">? valueTarget.length - </span><span class="s5">1</span>
                                <span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
                            <span class="s0">valueTarget = valueTarget[index];</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(valueTarget !== </span><span class="s1">null</span><span class="s0">) {</span>
                            <span class="s0">values[key] = valueTarget;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">transitionEnd) {</span>
                        <span class="s0">values[key] = transitionEnd[key];</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">values;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">makeUseVisualState = (config) =&gt; (props, isStatic) =&gt; {</span>
        <span class="s1">const </span><span class="s0">context = React$1.useContext(MotionContext);</span>
        <span class="s1">const </span><span class="s0">presenceContext = React$1.useContext(PresenceContext);</span>
        <span class="s1">const </span><span class="s0">make = () =&gt; makeState(config, props, context, presenceContext);</span>
        <span class="s1">return </span><span class="s0">isStatic ? make() : useConstant(make);</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">useHTMLVisualState = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">makeUseVisualState({</span>
        <span class="s0">scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,</span>
        <span class="s0">createRenderState: createHtmlRenderState,</span>
    <span class="s0">});</span>

    <span class="s1">const </span><span class="s0">useSVGVisualState = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">makeUseVisualState({</span>
        <span class="s0">scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,</span>
        <span class="s0">createRenderState: createSvgRenderState,</span>
    <span class="s0">});</span>

    <span class="s1">const </span><span class="s0">motionComponentSymbol = Symbol.for(</span><span class="s2">&quot;motionComponentSymbol&quot;</span><span class="s0">);</span>

    <span class="s1">function </span><span class="s0">isRefObject(ref) {</span>
        <span class="s1">return </span><span class="s0">(ref &amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">ref === </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">Object.prototype.hasOwnProperty.call(ref, </span><span class="s2">&quot;current&quot;</span><span class="s0">));</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Creates a ref function that, when called, hydrates the provided</span>
     <span class="s3">* external ref and VisualElement.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useMotionRef(visualState, visualElement, externalRef) {</span>
        <span class="s1">return </span><span class="s0">React$1.useCallback((instance) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(instance) {</span>
                <span class="s0">visualState.onMount &amp;&amp; visualState.onMount(instance);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(visualElement) {</span>
                <span class="s1">if </span><span class="s0">(instance) {</span>
                    <span class="s0">visualElement.mount(instance);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">visualElement.unmount();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(externalRef) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">externalRef === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                    <span class="s0">externalRef(instance);</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(isRefObject(externalRef)) {</span>
                    <span class="s0">externalRef.current = instance;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}, </span>
        <span class="s3">/**</span>
         <span class="s3">* Include externalRef in dependencies to ensure the callback updates</span>
         <span class="s3">* when the ref changes, allowing proper ref forwarding.</span>
         <span class="s3">*/</span>
        <span class="s0">[visualElement]);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Internal, exported only for usage in Framer</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">SwitchLayoutGroupContext = React$1.createContext({});</span>

    <span class="s1">function </span><span class="s0">useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {</span>
        <span class="s1">const </span><span class="s0">{ visualElement: parent } = React$1.useContext(MotionContext);</span>
        <span class="s1">const </span><span class="s0">lazyContext = React$1.useContext(LazyContext);</span>
        <span class="s1">const </span><span class="s0">presenceContext = React$1.useContext(PresenceContext);</span>
        <span class="s1">const </span><span class="s0">reducedMotionConfig = React$1.useContext(MotionConfigContext).reducedMotion;</span>
        <span class="s1">const </span><span class="s0">visualElementRef = React$1.useRef(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s3">/**</span>
         <span class="s3">* If we haven't preloaded a renderer, check to see if we have one lazy-loaded</span>
         <span class="s3">*/</span>
        <span class="s0">createVisualElement =</span>
            <span class="s0">createVisualElement ||</span>
                <span class="s0">lazyContext.renderer;</span>
        <span class="s1">if </span><span class="s0">(!visualElementRef.current &amp;&amp; createVisualElement) {</span>
            <span class="s0">visualElementRef.current = createVisualElement(Component, {</span>
                <span class="s0">visualState,</span>
                <span class="s0">parent,</span>
                <span class="s0">props,</span>
                <span class="s0">presenceContext,</span>
                <span class="s0">blockInitialAnimation: presenceContext</span>
                    <span class="s0">? presenceContext.initial === </span><span class="s1">false</span>
                    <span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">reducedMotionConfig,</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">visualElement = visualElementRef.current;</span>
        <span class="s3">/**</span>
         <span class="s3">* Load Motion gesture and animation features. These are rendered as renderless</span>
         <span class="s3">* components so each feature can optionally make use of React lifecycle methods.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">initialLayoutGroupConfig = React$1.useContext(SwitchLayoutGroupContext);</span>
        <span class="s1">if </span><span class="s0">(visualElement &amp;&amp;</span>
            <span class="s0">!visualElement.projection &amp;&amp;</span>
            <span class="s0">ProjectionNodeConstructor &amp;&amp;</span>
            <span class="s0">(visualElement.type === </span><span class="s2">&quot;html&quot; </span><span class="s0">|| visualElement.type === </span><span class="s2">&quot;svg&quot;</span><span class="s0">)) {</span>
            <span class="s0">createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">isMounted = React$1.useRef(</span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">React$1.useInsertionEffect(() =&gt; {</span>
            <span class="s3">/**</span>
             <span class="s3">* Check the component has already mounted before calling</span>
             <span class="s3">* `update` unnecessarily. This ensures we skip the initial update.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(visualElement &amp;&amp; isMounted.current) {</span>
                <span class="s0">visualElement.update(props, presenceContext);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s3">/**</span>
         <span class="s3">* Cache this value as we want to know whether HandoffAppearAnimations</span>
         <span class="s3">* was present on initial render - it will be deleted after this.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">optimisedAppearId = props[optimizedAppearDataAttribute];</span>
        <span class="s1">const </span><span class="s0">wantsHandoff = React$1.useRef(Boolean(optimisedAppearId) &amp;&amp;</span>
            <span class="s0">!window.MotionHandoffIsComplete?.(optimisedAppearId) &amp;&amp;</span>
            <span class="s0">window.MotionHasOptimisedAnimation?.(optimisedAppearId));</span>
        <span class="s0">useIsomorphicLayoutEffect(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!visualElement)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">isMounted.current = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">window.MotionIsMounted = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">visualElement.updateFeatures();</span>
            <span class="s0">visualElement.scheduleRenderMicrotask();</span>
            <span class="s3">/**</span>
             <span class="s3">* Ideally this function would always run in a useEffect.</span>
             <span class="s3">*</span>
             <span class="s3">* However, if we have optimised appear animations to handoff from,</span>
             <span class="s3">* it needs to happen synchronously to ensure there's no flash of</span>
             <span class="s3">* incorrect styles in the event of a hydration error.</span>
             <span class="s3">*</span>
             <span class="s3">* So if we detect a situtation where optimised appear animations</span>
             <span class="s3">* are running, we use useLayoutEffect to trigger animations.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(wantsHandoff.current &amp;&amp; visualElement.animationState) {</span>
                <span class="s0">visualElement.animationState.animateChanges();</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!visualElement)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!wantsHandoff.current &amp;&amp; visualElement.animationState) {</span>
                <span class="s0">visualElement.animationState.animateChanges();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(wantsHandoff.current) {</span>
                <span class="s3">// This ensures all future calls to animateChanges() in this component will run in useEffect</span>
                <span class="s0">queueMicrotask(() =&gt; {</span>
                    <span class="s0">window.MotionHandoffMarkAsComplete?.(optimisedAppearId);</span>
                <span class="s0">});</span>
                <span class="s0">wantsHandoff.current = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Now we've finished triggering animations for this element we</span>
             <span class="s3">* can wipe the enteringChildren set for the next render.</span>
             <span class="s3">*/</span>
            <span class="s0">visualElement.enteringChildren = undefined;</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">visualElement;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {</span>
        <span class="s1">const </span><span class="s0">{ layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;</span>
        <span class="s0">visualElement.projection = </span><span class="s1">new </span><span class="s0">ProjectionNodeConstructor(visualElement.latestValues, props[</span><span class="s2">&quot;data-framer-portal-id&quot;</span><span class="s0">]</span>
            <span class="s0">? undefined</span>
            <span class="s0">: getClosestProjectingNode(visualElement.parent));</span>
        <span class="s0">visualElement.projection.setOptions({</span>
            <span class="s0">layoutId,</span>
            <span class="s0">layout,</span>
            <span class="s0">alwaysMeasureLayout: Boolean(drag) || (dragConstraints &amp;&amp; isRefObject(dragConstraints)),</span>
            <span class="s0">visualElement,</span>
            <span class="s3">/**</span>
             <span class="s3">* TODO: Update options in an effect. This could be tricky as it'll be too late</span>
             <span class="s3">* to update by the time layout animations run.</span>
             <span class="s3">* We also need to fix this safeToRemove by linking it up to the one returned by usePresence,</span>
             <span class="s3">* ensuring it gets called if there's no potential layout animations.</span>
             <span class="s3">*</span>
             <span class="s3">*/</span>
            <span class="s0">animationType: </span><span class="s1">typeof </span><span class="s0">layout === </span><span class="s2">&quot;string&quot; </span><span class="s0">? layout : </span><span class="s2">&quot;both&quot;</span><span class="s0">,</span>
            <span class="s0">initialPromotionConfig,</span>
            <span class="s0">crossfade: layoutCrossfade,</span>
            <span class="s0">layoutScroll,</span>
            <span class="s0">layoutRoot,</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getClosestProjectingNode(visualElement) {</span>
        <span class="s1">if </span><span class="s0">(!visualElement)</span>
            <span class="s1">return </span><span class="s0">undefined;</span>
        <span class="s1">return </span><span class="s0">visualElement.options.allowProjection !== </span><span class="s1">false</span>
            <span class="s0">? visualElement.projection</span>
            <span class="s0">: getClosestProjectingNode(visualElement.parent);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a `motion` component.</span>
     <span class="s3">*</span>
     <span class="s3">* This function accepts a Component argument, which can be either a string (ie &quot;div&quot;</span>
     <span class="s3">* for `motion.div`), or an actual React component.</span>
     <span class="s3">*</span>
     <span class="s3">* Alongside this is a config option which provides a way of rendering the provided</span>
     <span class="s3">* component &quot;offline&quot;, or outside the React render cycle.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">createMotionComponent(Component, { forwardMotionProps = </span><span class="s1">false </span><span class="s0">} = {}, preloadedFeatures, createVisualElement) {</span>
        <span class="s0">preloadedFeatures &amp;&amp; loadFeatures(preloadedFeatures);</span>
        <span class="s1">const </span><span class="s0">useVisualState = isSVGComponent(Component)</span>
            <span class="s0">? useSVGVisualState</span>
            <span class="s0">: useHTMLVisualState;</span>
        <span class="s1">function </span><span class="s0">MotionDOMComponent(props, externalRef) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If we need to measure the element we load this functionality in a</span>
             <span class="s3">* separate class component in order to gain access to getSnapshotBeforeUpdate.</span>
             <span class="s3">*/</span>
            <span class="s1">let </span><span class="s0">MeasureLayout;</span>
            <span class="s1">const </span><span class="s0">configAndProps = {</span>
                <span class="s0">...React$1.useContext(MotionConfigContext),</span>
                <span class="s0">...props,</span>
                <span class="s0">layoutId: useLayoutId(props),</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">{ isStatic } = configAndProps;</span>
            <span class="s1">const </span><span class="s0">context = useCreateMotionContext(props);</span>
            <span class="s1">const </span><span class="s0">visualState = useVisualState(props, isStatic);</span>
            <span class="s1">if </span><span class="s0">(!isStatic &amp;&amp; isBrowser) {</span>
                <span class="s0">useStrictMode(configAndProps, preloadedFeatures);</span>
                <span class="s1">const </span><span class="s0">layoutProjection = getProjectionFunctionality(configAndProps);</span>
                <span class="s0">MeasureLayout = layoutProjection.MeasureLayout;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Create a VisualElement for this component. A VisualElement provides a common</span>
                 <span class="s3">* interface to renderer-specific APIs (ie DOM/Three.js etc) as well as</span>
                 <span class="s3">* providing a way of rendering to these APIs outside of the React render loop</span>
                 <span class="s3">* for more performant animations and interactions</span>
                 <span class="s3">*/</span>
                <span class="s0">context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* The mount order and hierarchy is specific to ensure our element ref</span>
             <span class="s3">* is hydrated by the time features fire their effects.</span>
             <span class="s3">*/</span>
            <span class="s1">return </span><span class="s0">(jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout &amp;&amp; context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : </span><span class="s1">null</span><span class="s0">, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] }));</span>
        <span class="s0">}</span>
        <span class="s0">MotionDOMComponent.displayName = </span><span class="s2">`motion.</span><span class="s0">${</span><span class="s1">typeof </span><span class="s0">Component === </span><span class="s2">&quot;string&quot;</span>
        <span class="s0">? Component</span>
        <span class="s0">: </span><span class="s2">`create(</span><span class="s0">${Component.displayName ?? Component.name ?? </span><span class="s2">&quot;&quot;</span><span class="s0">}</span><span class="s2">)`</span><span class="s0">}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">ForwardRefMotionComponent = React$1.forwardRef(MotionDOMComponent);</span>
        <span class="s0">ForwardRefMotionComponent[motionComponentSymbol] = Component;</span>
        <span class="s1">return </span><span class="s0">ForwardRefMotionComponent;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">useLayoutId({ layoutId }) {</span>
        <span class="s1">const </span><span class="s0">layoutGroupId = React$1.useContext(LayoutGroupContext).id;</span>
        <span class="s1">return </span><span class="s0">layoutGroupId &amp;&amp; layoutId !== undefined</span>
            <span class="s0">? layoutGroupId + </span><span class="s2">&quot;-&quot; </span><span class="s0">+ layoutId</span>
            <span class="s0">: layoutId;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">useStrictMode(configAndProps, preloadedFeatures) {</span>
        <span class="s1">const </span><span class="s0">isStrict = React$1.useContext(LazyContext).strict;</span>
        <span class="s3">/**</span>
         <span class="s3">* If we're in development mode, check to make sure we're not rendering a motion component</span>
         <span class="s3">* as a child of LazyMotion, as this will break the file-size benefits of using it.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(preloadedFeatures &amp;&amp;</span>
            <span class="s0">isStrict) {</span>
            <span class="s1">const </span><span class="s0">strictMessage = </span><span class="s2">&quot;You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.&quot;</span><span class="s0">;</span>
            <span class="s0">configAndProps.ignoreStrict</span>
                <span class="s0">? exports.warning(</span><span class="s1">false</span><span class="s0">, strictMessage, </span><span class="s2">&quot;lazy-strict-mode&quot;</span><span class="s0">)</span>
                <span class="s0">: exports.invariant(</span><span class="s1">false</span><span class="s0">, strictMessage, </span><span class="s2">&quot;lazy-strict-mode&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getProjectionFunctionality(props) {</span>
        <span class="s1">const </span><span class="s0">{ drag, layout } = featureDefinitions;</span>
        <span class="s1">if </span><span class="s0">(!drag &amp;&amp; !layout)</span>
            <span class="s1">return </span><span class="s0">{};</span>
        <span class="s1">const </span><span class="s0">combined = { ...drag, ...layout };</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)</span>
                <span class="s0">? combined.MeasureLayout</span>
                <span class="s0">: undefined,</span>
            <span class="s0">ProjectionNode: combined.ProjectionNode,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createMotionProxy(preloadedFeatures, createVisualElement) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Proxy === </span><span class="s2">&quot;undefined&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">createMotionComponent;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.</span>
         <span class="s3">* Rather than generating them anew every render.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">componentCache = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s1">const </span><span class="s0">factory = (Component, options) =&gt; {</span>
            <span class="s1">return </span><span class="s0">createMotionComponent(Component, options, preloadedFeatures, createVisualElement);</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* Support for deprecated`motion(Component)` pattern</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">deprecatedFactoryFunction = (Component, options) =&gt; {</span>
            <span class="s0">{</span>
                <span class="s0">warnOnce(</span><span class="s1">false</span><span class="s0">, </span><span class="s2">&quot;motion() is deprecated. Use motion.create() instead.&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">factory(Component, options);</span>
        <span class="s0">};</span>
        <span class="s1">return new </span><span class="s0">Proxy(deprecatedFactoryFunction, {</span>
            <span class="s3">/**</span>
             <span class="s3">* Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.</span>
             <span class="s3">* The prop name is passed through as `key` and we can use that to generate a `motion`</span>
             <span class="s3">* DOM component with that name.</span>
             <span class="s3">*/</span>
            <span class="s0">get: (_target, key) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(key === </span><span class="s2">&quot;create&quot;</span><span class="s0">)</span>
                    <span class="s1">return </span><span class="s0">factory;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this element doesn't exist in the component cache, create it and cache.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!componentCache.has(key)) {</span>
                    <span class="s0">componentCache.set(key, createMotionComponent(key, undefined, preloadedFeatures, createVisualElement));</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">componentCache.get(key);</span>
            <span class="s0">},</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">resolveVariant(visualElement, definition, custom) {</span>
        <span class="s1">const </span><span class="s0">props = visualElement.getProps();</span>
        <span class="s1">return </span><span class="s0">resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isKeyframesTarget = (v) =&gt; {</span>
        <span class="s1">return </span><span class="s0">Array.isArray(v);</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Set VisualElement's MotionValue, creating a new MotionValue for it if</span>
     <span class="s3">* it doesn't exist.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">setMotionValue(visualElement, key, value) {</span>
        <span class="s1">if </span><span class="s0">(visualElement.hasValue(key)) {</span>
            <span class="s0">visualElement.getValue(key).set(value);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">visualElement.addValue(key, motionValue(value));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resolveFinalValueInKeyframes(v) {</span>
        <span class="s3">// TODO maybe throw if v.length - 1 is placeholder token?</span>
        <span class="s1">return </span><span class="s0">isKeyframesTarget(v) ? v[v.length - </span><span class="s5">1</span><span class="s0">] || </span><span class="s5">0 </span><span class="s0">: v;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">setTarget(visualElement, definition) {</span>
        <span class="s1">const </span><span class="s0">resolved = resolveVariant(visualElement, definition);</span>
        <span class="s1">let </span><span class="s0">{ transitionEnd = {}, transition = {}, ...target } = resolved || {};</span>
        <span class="s0">target = { ...target, ...transitionEnd };</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">target) {</span>
            <span class="s1">const </span><span class="s0">value = resolveFinalValueInKeyframes(target[key]);</span>
            <span class="s0">setMotionValue(visualElement, key, value);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isWillChangeMotionValue(value) {</span>
        <span class="s1">return </span><span class="s0">Boolean(isMotionValue(value) &amp;&amp; value.add);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">addValueToWillChange(visualElement, key) {</span>
        <span class="s1">const </span><span class="s0">willChange = visualElement.getValue(</span><span class="s2">&quot;willChange&quot;</span><span class="s0">);</span>
        <span class="s3">/**</span>
         <span class="s3">* It could be that a user has set willChange to a regular MotionValue,</span>
         <span class="s3">* in which case we can't add the value to it.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(isWillChangeMotionValue(willChange)) {</span>
            <span class="s1">return </span><span class="s0">willChange.add(key);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(!willChange &amp;&amp; MotionGlobalConfig.WillChange) {</span>
            <span class="s1">const </span><span class="s0">newWillChange = </span><span class="s1">new </span><span class="s0">MotionGlobalConfig.WillChange(</span><span class="s2">&quot;auto&quot;</span><span class="s0">);</span>
            <span class="s0">visualElement.addValue(</span><span class="s2">&quot;willChange&quot;</span><span class="s0">, newWillChange);</span>
            <span class="s0">newWillChange.add(key);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Decide whether we should block this animation. Previously, we achieved this</span>
     <span class="s3">* just by checking whether the key was listed in protectedKeys, but this</span>
     <span class="s3">* posed problems if an animation was triggered by afterChildren and protectedKeys</span>
     <span class="s3">* had been set to true in the meantime.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {</span>
        <span class="s1">const </span><span class="s0">shouldBlock = protectedKeys.hasOwnProperty(key) &amp;&amp; needsAnimating[key] !== </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">needsAnimating[key] = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">shouldBlock;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">animateTarget(visualElement, targetAndTransition, { delay = </span><span class="s5">0</span><span class="s0">, transitionOverride, type } = {}) {</span>
        <span class="s1">let </span><span class="s0">{ transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;</span>
        <span class="s1">if </span><span class="s0">(transitionOverride)</span>
            <span class="s0">transition = transitionOverride;</span>
        <span class="s1">const </span><span class="s0">animations = [];</span>
        <span class="s1">const </span><span class="s0">animationTypeState = type &amp;&amp;</span>
            <span class="s0">visualElement.animationState &amp;&amp;</span>
            <span class="s0">visualElement.animationState.getState()[type];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">target) {</span>
            <span class="s1">const </span><span class="s0">value = visualElement.getValue(key, visualElement.latestValues[key] ?? </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">valueTarget = target[key];</span>
            <span class="s1">if </span><span class="s0">(valueTarget === undefined ||</span>
                <span class="s0">(animationTypeState &amp;&amp;</span>
                    <span class="s0">shouldBlockAnimation(animationTypeState, key))) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">valueTransition = {</span>
                <span class="s0">delay,</span>
                <span class="s0">...getValueTransition$1(transition || {}, key),</span>
            <span class="s0">};</span>
            <span class="s3">/**</span>
             <span class="s3">* If the value is already at the defined target, skip the animation.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">currentValue = value.get();</span>
            <span class="s1">if </span><span class="s0">(currentValue !== undefined &amp;&amp;</span>
                <span class="s0">!value.isAnimating &amp;&amp;</span>
                <span class="s0">!Array.isArray(valueTarget) &amp;&amp;</span>
                <span class="s0">valueTarget === currentValue &amp;&amp;</span>
                <span class="s0">!valueTransition.velocity) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is the first time a value is being animated, check</span>
             <span class="s3">* to see if we're handling off from an existing animation.</span>
             <span class="s3">*/</span>
            <span class="s1">let </span><span class="s0">isHandoff = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(window.MotionHandoffAnimation) {</span>
                <span class="s1">const </span><span class="s0">appearId = getOptimisedAppearId(visualElement);</span>
                <span class="s1">if </span><span class="s0">(appearId) {</span>
                    <span class="s1">const </span><span class="s0">startTime = window.MotionHandoffAnimation(appearId, key, frame);</span>
                    <span class="s1">if </span><span class="s0">(startTime !== </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s0">valueTransition.startTime = startTime;</span>
                        <span class="s0">isHandoff = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">addValueToWillChange(visualElement, key);</span>
            <span class="s0">value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion &amp;&amp; positionalKeys.has(key)</span>
                <span class="s0">? { type: </span><span class="s1">false </span><span class="s0">}</span>
                <span class="s0">: valueTransition, visualElement, isHandoff));</span>
            <span class="s1">const </span><span class="s0">animation = value.animation;</span>
            <span class="s1">if </span><span class="s0">(animation) {</span>
                <span class="s0">animations.push(animation);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(transitionEnd) {</span>
            <span class="s0">Promise.all(animations).then(() =&gt; {</span>
                <span class="s0">frame.update(() =&gt; {</span>
                    <span class="s0">transitionEnd &amp;&amp; setTarget(visualElement, transitionEnd);</span>
                <span class="s0">});</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">animations;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">calcChildStagger(children, child, delayChildren, staggerChildren = </span><span class="s5">0</span><span class="s0">, staggerDirection = </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">index = Array.from(children)</span>
            <span class="s0">.sort((a, b) =&gt; a.sortNodePosition(b))</span>
            <span class="s0">.indexOf(child);</span>
        <span class="s1">const </span><span class="s0">numChildren = children.size;</span>
        <span class="s1">const </span><span class="s0">maxStaggerDuration = (numChildren - </span><span class="s5">1</span><span class="s0">) * staggerChildren;</span>
        <span class="s1">const </span><span class="s0">delayIsFunction = </span><span class="s1">typeof </span><span class="s0">delayChildren === </span><span class="s2">&quot;function&quot;</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">delayIsFunction</span>
            <span class="s0">? delayChildren(index, numChildren)</span>
            <span class="s0">: staggerDirection === </span><span class="s5">1</span>
                <span class="s0">? index * staggerChildren</span>
                <span class="s0">: maxStaggerDuration - index * staggerChildren;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">animateVariant(visualElement, variant, options = {}) {</span>
        <span class="s1">const </span><span class="s0">resolved = resolveVariant(visualElement, variant, options.type === </span><span class="s2">&quot;exit&quot;</span>
            <span class="s0">? visualElement.presenceContext?.custom</span>
            <span class="s0">: undefined);</span>
        <span class="s1">let </span><span class="s0">{ transition = visualElement.getDefaultTransition() || {} } = resolved || {};</span>
        <span class="s1">if </span><span class="s0">(options.transitionOverride) {</span>
            <span class="s0">transition = options.transitionOverride;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If we have a variant, create a callback that runs it as an animation.</span>
         <span class="s3">* Otherwise, we resolve a Promise immediately for a composable no-op.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">getAnimation = resolved</span>
            <span class="s0">? () =&gt; Promise.all(animateTarget(visualElement, resolved, options))</span>
            <span class="s0">: () =&gt; Promise.resolve();</span>
        <span class="s3">/**</span>
         <span class="s3">* If we have children, create a callback that runs all their animations.</span>
         <span class="s3">* Otherwise, we resolve a Promise immediately for a composable no-op.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">getChildAnimations = visualElement.variantChildren &amp;&amp; visualElement.variantChildren.size</span>
            <span class="s0">? (forwardDelay = </span><span class="s5">0</span><span class="s0">) =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ delayChildren = </span><span class="s5">0</span><span class="s0">, staggerChildren, staggerDirection, } = transition;</span>
                <span class="s1">return </span><span class="s0">animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);</span>
            <span class="s0">}</span>
            <span class="s0">: () =&gt; Promise.resolve();</span>
        <span class="s3">/**</span>
         <span class="s3">* If the transition explicitly defines a &quot;when&quot; option, we need to resolve either</span>
         <span class="s3">* this animation or all children animations before playing the other.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">{ when } = transition;</span>
        <span class="s1">if </span><span class="s0">(when) {</span>
            <span class="s1">const </span><span class="s0">[first, last] = when === </span><span class="s2">&quot;beforeChildren&quot;</span>
                <span class="s0">? [getAnimation, getChildAnimations]</span>
                <span class="s0">: [getChildAnimations, getAnimation];</span>
            <span class="s1">return </span><span class="s0">first().then(() =&gt; last());</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">Promise.all([getAnimation(), getChildAnimations(options.delay)]);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">animateChildren(visualElement, variant, delay = </span><span class="s5">0</span><span class="s0">, delayChildren = </span><span class="s5">0</span><span class="s0">, staggerChildren = </span><span class="s5">0</span><span class="s0">, staggerDirection = </span><span class="s5">1</span><span class="s0">, options) {</span>
        <span class="s1">const </span><span class="s0">animations = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">child of visualElement.variantChildren) {</span>
            <span class="s0">child.notify(</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s0">, variant);</span>
            <span class="s0">animations.push(animateVariant(child, variant, {</span>
                <span class="s0">...options,</span>
                <span class="s0">delay: delay +</span>
                    <span class="s0">(</span><span class="s1">typeof </span><span class="s0">delayChildren === </span><span class="s2">&quot;function&quot; </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: delayChildren) +</span>
                    <span class="s0">calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection),</span>
            <span class="s0">}).then(() =&gt; child.notify(</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s0">, variant)));</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">Promise.all(animations);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">animateVisualElement(visualElement, definition, options = {}) {</span>
        <span class="s0">visualElement.notify(</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s0">, definition);</span>
        <span class="s1">let </span><span class="s0">animation;</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(definition)) {</span>
            <span class="s1">const </span><span class="s0">animations = definition.map((variant) =&gt; animateVariant(visualElement, variant, options));</span>
            <span class="s0">animation = Promise.all(animations);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">definition === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s0">animation = animateVariant(visualElement, definition, options);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">resolvedDefinition = </span><span class="s1">typeof </span><span class="s0">definition === </span><span class="s2">&quot;function&quot;</span>
                <span class="s0">? resolveVariant(visualElement, definition, options.custom)</span>
                <span class="s0">: definition;</span>
            <span class="s0">animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">animation.then(() =&gt; {</span>
            <span class="s0">visualElement.notify(</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s0">, definition);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">shallowCompare(next, prev) {</span>
        <span class="s1">if </span><span class="s0">(!Array.isArray(prev))</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">prevLength = prev.length;</span>
        <span class="s1">if </span><span class="s0">(prevLength !== next.length)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; prevLength; i++) {</span>
            <span class="s1">if </span><span class="s0">(prev[i] !== next[i])</span>
                <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">numVariantProps = variantProps.length;</span>
    <span class="s1">function </span><span class="s0">getVariantContext(visualElement) {</span>
        <span class="s1">if </span><span class="s0">(!visualElement)</span>
            <span class="s1">return </span><span class="s0">undefined;</span>
        <span class="s1">if </span><span class="s0">(!visualElement.isControllingVariants) {</span>
            <span class="s1">const </span><span class="s0">context = visualElement.parent</span>
                <span class="s0">? getVariantContext(visualElement.parent) || {}</span>
                <span class="s0">: {};</span>
            <span class="s1">if </span><span class="s0">(visualElement.props.initial !== undefined) {</span>
                <span class="s0">context.initial = visualElement.props.initial;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">context;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">context = {};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numVariantProps; i++) {</span>
            <span class="s1">const </span><span class="s0">name = variantProps[i];</span>
            <span class="s1">const </span><span class="s0">prop = visualElement.props[name];</span>
            <span class="s1">if </span><span class="s0">(isVariantLabel(prop) || prop === </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s0">context[name] = prop;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">context;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">reversePriorityOrder = [...variantPriorityOrder].reverse();</span>
    <span class="s1">const </span><span class="s0">numAnimationTypes = variantPriorityOrder.length;</span>
    <span class="s1">function </span><span class="s0">animateList(visualElement) {</span>
        <span class="s1">return </span><span class="s0">(animations) =&gt; Promise.all(animations.map(({ animation, options }) =&gt; animateVisualElement(visualElement, animation, options)));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createAnimationState(visualElement) {</span>
        <span class="s1">let </span><span class="s0">animate = animateList(visualElement);</span>
        <span class="s1">let </span><span class="s0">state = createState();</span>
        <span class="s1">let </span><span class="s0">isInitialRender = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* This function will be used to reduce the animation definitions for</span>
         <span class="s3">* each active animation type into an object of resolved values for it.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">buildResolvedTypeValues = (type) =&gt; (acc, definition) =&gt; {</span>
            <span class="s1">const </span><span class="s0">resolved = resolveVariant(visualElement, definition, type === </span><span class="s2">&quot;exit&quot;</span>
                <span class="s0">? visualElement.presenceContext?.custom</span>
                <span class="s0">: undefined);</span>
            <span class="s1">if </span><span class="s0">(resolved) {</span>
                <span class="s1">const </span><span class="s0">{ transition, transitionEnd, ...target } = resolved;</span>
                <span class="s0">acc = { ...acc, ...target, ...transitionEnd };</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">acc;</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* This just allows us to inject mocked animation functions</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s1">function </span><span class="s0">setAnimateFunction(makeAnimator) {</span>
            <span class="s0">animate = makeAnimator(visualElement);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* When we receive new props, we need to:</span>
         <span class="s3">* 1. Create a list of protected keys for each type. This is a directory of</span>
         <span class="s3">*    value keys that are currently being &quot;handled&quot; by types of a higher priority</span>
         <span class="s3">*    so that whenever an animation is played of a given type, these values are</span>
         <span class="s3">*    protected from being animated.</span>
         <span class="s3">* 2. Determine if an animation type needs animating.</span>
         <span class="s3">* 3. Determine if any values have been removed from a type and figure out</span>
         <span class="s3">*    what to animate those to.</span>
         <span class="s3">*/</span>
        <span class="s1">function </span><span class="s0">animateChanges(changedActiveType) {</span>
            <span class="s1">const </span><span class="s0">{ props } = visualElement;</span>
            <span class="s1">const </span><span class="s0">context = getVariantContext(visualElement.parent) || {};</span>
            <span class="s3">/**</span>
             <span class="s3">* A list of animations that we'll build into as we iterate through the animation</span>
             <span class="s3">* types. This will get executed at the end of the function.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">animations = [];</span>
            <span class="s3">/**</span>
             <span class="s3">* Keep track of which values have been removed. Then, as we hit lower priority</span>
             <span class="s3">* animation types, we can check if they contain removed values and animate to that.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">removedKeys = </span><span class="s1">new </span><span class="s0">Set();</span>
            <span class="s3">/**</span>
             <span class="s3">* A dictionary of all encountered keys. This is an object to let us build into and</span>
             <span class="s3">* copy it without iteration. Each time we hit an animation type we set its protected</span>
             <span class="s3">* keys - the keys its not allowed to animate - to the latest version of this object.</span>
             <span class="s3">*/</span>
            <span class="s1">let </span><span class="s0">encounteredKeys = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* If a variant has been removed at a given index, and this component is controlling</span>
             <span class="s3">* variant animations, we want to ensure lower-priority variants are forced to animate.</span>
             <span class="s3">*/</span>
            <span class="s1">let </span><span class="s0">removedVariantIndex = Infinity;</span>
            <span class="s3">/**</span>
             <span class="s3">* Iterate through all animation types in reverse priority order. For each, we want to</span>
             <span class="s3">* detect which values it's handling and whether or not they've changed (and therefore</span>
             <span class="s3">* need to be animated). If any values have been removed, we want to detect those in</span>
             <span class="s3">* lower priority props and flag for animation.</span>
             <span class="s3">*/</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numAnimationTypes; i++) {</span>
                <span class="s1">const </span><span class="s0">type = reversePriorityOrder[i];</span>
                <span class="s1">const </span><span class="s0">typeState = state[type];</span>
                <span class="s1">const </span><span class="s0">prop = props[type] !== undefined</span>
                    <span class="s0">? props[type]</span>
                    <span class="s0">: context[type];</span>
                <span class="s1">const </span><span class="s0">propIsVariant = isVariantLabel(prop);</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this type has *just* changed isActive status, set activeDelta</span>
                 <span class="s3">* to that status. Otherwise set to null.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">activeDelta = type === changedActiveType ? typeState.isActive : </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(activeDelta === </span><span class="s1">false</span><span class="s0">)</span>
                    <span class="s0">removedVariantIndex = i;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this prop is an inherited variant, rather than been set directly on the</span>
                 <span class="s3">* component itself, we want to make sure we allow the parent to trigger animations.</span>
                 <span class="s3">*</span>
                 <span class="s3">* TODO: Can probably change this to a !isControllingVariants check</span>
                 <span class="s3">*/</span>
                <span class="s1">let </span><span class="s0">isInherited = prop === context[type] &amp;&amp;</span>
                    <span class="s0">prop !== props[type] &amp;&amp;</span>
                    <span class="s0">propIsVariant;</span>
                <span class="s1">if </span><span class="s0">(isInherited &amp;&amp;</span>
                    <span class="s0">isInitialRender &amp;&amp;</span>
                    <span class="s0">visualElement.manuallyAnimateOnMount) {</span>
                    <span class="s0">isInherited = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Set all encountered keys so far as the protected keys for this type. This will</span>
                 <span class="s3">* be any key that has been animated or otherwise handled by active, higher-priortiy types.</span>
                 <span class="s3">*/</span>
                <span class="s0">typeState.protectedKeys = { ...encounteredKeys };</span>
                <span class="s3">// Check if we can skip analysing this prop early</span>
                <span class="s1">if </span><span class="s0">(</span>
                <span class="s3">// If it isn't active and hasn't *just* been set as inactive</span>
                <span class="s0">(!typeState.isActive &amp;&amp; activeDelta === </span><span class="s1">null</span><span class="s0">) ||</span>
                    <span class="s3">// If we didn't and don't have any defined prop for this animation type</span>
                    <span class="s0">(!prop &amp;&amp; !typeState.prevProp) ||</span>
                    <span class="s3">// Or if the prop doesn't define an animation</span>
                    <span class="s0">isAnimationControls(prop) ||</span>
                    <span class="s1">typeof </span><span class="s0">prop === </span><span class="s2">&quot;boolean&quot;</span><span class="s0">) {</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* As we go look through the values defined on this type, if we detect</span>
                 <span class="s3">* a changed value or a value that was removed in a higher priority, we set</span>
                 <span class="s3">* this to true and add this prop to the animation list.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);</span>
                <span class="s1">let </span><span class="s0">shouldAnimateType = variantDidChange ||</span>
                    <span class="s3">// If we're making this variant active, we want to always make it active</span>
                    <span class="s0">(type === changedActiveType &amp;&amp;</span>
                        <span class="s0">typeState.isActive &amp;&amp;</span>
                        <span class="s0">!isInherited &amp;&amp;</span>
                        <span class="s0">propIsVariant) ||</span>
                    <span class="s3">// If we removed a higher-priority variant (i is in reverse order)</span>
                    <span class="s0">(i &gt; removedVariantIndex &amp;&amp; propIsVariant);</span>
                <span class="s1">let </span><span class="s0">handledRemovedValues = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* As animations can be set as variant lists, variants or target objects, we</span>
                 <span class="s3">* coerce everything to an array if it isn't one already</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">definitionList = Array.isArray(prop) ? prop : [prop];</span>
                <span class="s3">/**</span>
                 <span class="s3">* Build an object of all the resolved values. We'll use this in the subsequent</span>
                 <span class="s3">* animateChanges calls to determine whether a value has changed.</span>
                 <span class="s3">*/</span>
                <span class="s1">let </span><span class="s0">resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});</span>
                <span class="s1">if </span><span class="s0">(activeDelta === </span><span class="s1">false</span><span class="s0">)</span>
                    <span class="s0">resolvedValues = {};</span>
                <span class="s3">/**</span>
                 <span class="s3">* Now we need to loop through all the keys in the prev prop and this prop,</span>
                 <span class="s3">* and decide:</span>
                 <span class="s3">* 1. If the value has changed, and needs animating</span>
                 <span class="s3">* 2. If it has been removed, and needs adding to the removedKeys set</span>
                 <span class="s3">* 3. If it has been removed in a higher priority type and needs animating</span>
                 <span class="s3">* 4. If it hasn't been removed in a higher priority but hasn't changed, and</span>
                 <span class="s3">*    needs adding to the type's protectedKeys list.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">{ prevResolvedValues = {} } = typeState;</span>
                <span class="s1">const </span><span class="s0">allKeys = {</span>
                    <span class="s0">...prevResolvedValues,</span>
                    <span class="s0">...resolvedValues,</span>
                <span class="s0">};</span>
                <span class="s1">const </span><span class="s0">markToAnimate = (key) =&gt; {</span>
                    <span class="s0">shouldAnimateType = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(removedKeys.has(key)) {</span>
                        <span class="s0">handledRemovedValues = </span><span class="s1">true</span><span class="s0">;</span>
                        <span class="s0">removedKeys.delete(key);</span>
                    <span class="s0">}</span>
                    <span class="s0">typeState.needsAnimating[key] = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">motionValue = visualElement.getValue(key);</span>
                    <span class="s1">if </span><span class="s0">(motionValue)</span>
                        <span class="s0">motionValue.liveStyle = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">};</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">allKeys) {</span>
                    <span class="s1">const </span><span class="s0">next = resolvedValues[key];</span>
                    <span class="s1">const </span><span class="s0">prev = prevResolvedValues[key];</span>
                    <span class="s3">// If we've already handled this we can just skip ahead</span>
                    <span class="s1">if </span><span class="s0">(encounteredKeys.hasOwnProperty(key))</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If the value has changed, we probably want to animate it.</span>
                     <span class="s3">*/</span>
                    <span class="s1">let </span><span class="s0">valueHasChanged = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(isKeyframesTarget(next) &amp;&amp; isKeyframesTarget(prev)) {</span>
                        <span class="s0">valueHasChanged = !shallowCompare(next, prev);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">valueHasChanged = next !== prev;</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(valueHasChanged) {</span>
                        <span class="s1">if </span><span class="s0">(next !== undefined &amp;&amp; next !== </span><span class="s1">null</span><span class="s0">) {</span>
                            <span class="s3">// If next is defined and doesn't equal prev, it needs animating</span>
                            <span class="s0">markToAnimate(key);</span>
                        <span class="s0">}</span>
                        <span class="s1">else </span><span class="s0">{</span>
                            <span class="s3">// If it's undefined, it's been removed.</span>
                            <span class="s0">removedKeys.add(key);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(next !== undefined &amp;&amp; removedKeys.has(key)) {</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If next hasn't changed and it isn't undefined, we want to check if it's</span>
                         <span class="s3">* been removed by a higher priority</span>
                         <span class="s3">*/</span>
                        <span class="s0">markToAnimate(key);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If it hasn't changed, we add it to the list of protected values</span>
                         <span class="s3">* to ensure it doesn't get animated.</span>
                         <span class="s3">*/</span>
                        <span class="s0">typeState.protectedKeys[key] = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Update the typeState so next time animateChanges is called we can compare the</span>
                 <span class="s3">* latest prop and resolvedValues to these.</span>
                 <span class="s3">*/</span>
                <span class="s0">typeState.prevProp = prop;</span>
                <span class="s0">typeState.prevResolvedValues = resolvedValues;</span>
                <span class="s1">if </span><span class="s0">(typeState.isActive) {</span>
                    <span class="s0">encounteredKeys = { ...encounteredKeys, ...resolvedValues };</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(isInitialRender &amp;&amp; visualElement.blockInitialAnimation) {</span>
                    <span class="s0">shouldAnimateType = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this is an inherited prop we want to skip this animation</span>
                 <span class="s3">* unless the inherited variants haven't changed on this render.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">willAnimateViaParent = isInherited &amp;&amp; variantDidChange;</span>
                <span class="s1">const </span><span class="s0">needsAnimating = !willAnimateViaParent || handledRemovedValues;</span>
                <span class="s1">if </span><span class="s0">(shouldAnimateType &amp;&amp; needsAnimating) {</span>
                    <span class="s0">animations.push(...definitionList.map((animation) =&gt; {</span>
                        <span class="s1">const </span><span class="s0">options = { type };</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If we're performing the initial animation, but we're not</span>
                         <span class="s3">* rendering at the same time as the variant-controlling parent,</span>
                         <span class="s3">* we want to use the parent's transition to calculate the stagger.</span>
                         <span class="s3">*/</span>
                        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">animation === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
                            <span class="s0">isInitialRender &amp;&amp;</span>
                            <span class="s0">!willAnimateViaParent &amp;&amp;</span>
                            <span class="s0">visualElement.manuallyAnimateOnMount &amp;&amp;</span>
                            <span class="s0">visualElement.parent) {</span>
                            <span class="s1">const </span><span class="s0">{ parent } = visualElement;</span>
                            <span class="s1">const </span><span class="s0">parentVariant = resolveVariant(parent, animation);</span>
                            <span class="s1">if </span><span class="s0">(parent.enteringChildren &amp;&amp; parentVariant) {</span>
                                <span class="s1">const </span><span class="s0">{ delayChildren } = parentVariant.transition || {};</span>
                                <span class="s0">options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                        <span class="s1">return </span><span class="s0">{</span>
                            <span class="s0">animation: animation,</span>
                            <span class="s0">options,</span>
                        <span class="s0">};</span>
                    <span class="s0">}));</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If there are some removed value that haven't been dealt with,</span>
             <span class="s3">* we need to create a new animation that falls back either to the value</span>
             <span class="s3">* defined in the style prop, or the last read value.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(removedKeys.size) {</span>
                <span class="s1">const </span><span class="s0">fallbackAnimation = {};</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the initial prop contains a transition we can use that, otherwise</span>
                 <span class="s3">* allow the animation function to use the visual element's default.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">props.initial !== </span><span class="s2">&quot;boolean&quot;</span><span class="s0">) {</span>
                    <span class="s1">const </span><span class="s0">initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)</span>
                        <span class="s0">? props.initial[</span><span class="s5">0</span><span class="s0">]</span>
                        <span class="s0">: props.initial);</span>
                    <span class="s1">if </span><span class="s0">(initialTransition &amp;&amp; initialTransition.transition) {</span>
                        <span class="s0">fallbackAnimation.transition = initialTransition.transition;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s0">removedKeys.forEach((key) =&gt; {</span>
                    <span class="s1">const </span><span class="s0">fallbackTarget = visualElement.getBaseTarget(key);</span>
                    <span class="s1">const </span><span class="s0">motionValue = visualElement.getValue(key);</span>
                    <span class="s1">if </span><span class="s0">(motionValue)</span>
                        <span class="s0">motionValue.liveStyle = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s3">// @ts-expect-error - @mattgperry to figure if we should do something here</span>
                    <span class="s0">fallbackAnimation[key] = fallbackTarget ?? </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">});</span>
                <span class="s0">animations.push({ animation: fallbackAnimation });</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">shouldAnimate = Boolean(animations.length);</span>
            <span class="s1">if </span><span class="s0">(isInitialRender &amp;&amp;</span>
                <span class="s0">(props.initial === </span><span class="s1">false </span><span class="s0">|| props.initial === props.animate) &amp;&amp;</span>
                <span class="s0">!visualElement.manuallyAnimateOnMount) {</span>
                <span class="s0">shouldAnimate = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">isInitialRender = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">shouldAnimate ? animate(animations) : Promise.resolve();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Change whether a certain animation type is active.</span>
         <span class="s3">*/</span>
        <span class="s1">function </span><span class="s0">setActive(type, isActive) {</span>
            <span class="s3">// If the active state hasn't changed, we can safely do nothing here</span>
            <span class="s1">if </span><span class="s0">(state[type].isActive === isActive)</span>
                <span class="s1">return </span><span class="s0">Promise.resolve();</span>
            <span class="s3">// Propagate active change to children</span>
            <span class="s0">visualElement.variantChildren?.forEach((child) =&gt; child.animationState?.setActive(type, isActive));</span>
            <span class="s0">state[type].isActive = isActive;</span>
            <span class="s1">const </span><span class="s0">animations = animateChanges(type);</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">state) {</span>
                <span class="s0">state[key].protectedKeys = {};</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">animations;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">animateChanges,</span>
            <span class="s0">setActive,</span>
            <span class="s0">setAnimateFunction,</span>
            <span class="s0">getState: () =&gt; state,</span>
            <span class="s0">reset: () =&gt; {</span>
                <span class="s0">state = createState();</span>
                <span class="s0">isInitialRender = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">checkVariantsDidChange(prev, next) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">next === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">next !== prev;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(Array.isArray(next)) {</span>
            <span class="s1">return </span><span class="s0">!shallowCompare(next, prev);</span>
        <span class="s0">}</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createTypeState(isActive = </span><span class="s1">false</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">isActive,</span>
            <span class="s0">protectedKeys: {},</span>
            <span class="s0">needsAnimating: {},</span>
            <span class="s0">prevResolvedValues: {},</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createState() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">animate: createTypeState(</span><span class="s1">true</span><span class="s0">),</span>
            <span class="s0">whileInView: createTypeState(),</span>
            <span class="s0">whileHover: createTypeState(),</span>
            <span class="s0">whileTap: createTypeState(),</span>
            <span class="s0">whileDrag: createTypeState(),</span>
            <span class="s0">whileFocus: createTypeState(),</span>
            <span class="s0">exit: createTypeState(),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">Feature {</span>
        <span class="s0">constructor(node) {</span>
            <span class="s1">this</span><span class="s0">.isMounted = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.node = node;</span>
        <span class="s0">}</span>
        <span class="s0">update() { }</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">AnimationFeature </span><span class="s1">extends </span><span class="s0">Feature {</span>
        <span class="s3">/**</span>
         <span class="s3">* We dynamically generate the AnimationState manager as it contains a reference</span>
         <span class="s3">* to the underlying animation library. We only want to load that if we load this,</span>
         <span class="s3">* so people can optionally code split it out using the `m` component.</span>
         <span class="s3">*/</span>
        <span class="s0">constructor(node) {</span>
            <span class="s1">super</span><span class="s0">(node);</span>
            <span class="s0">node.animationState || (node.animationState = createAnimationState(node));</span>
        <span class="s0">}</span>
        <span class="s0">updateAnimationControlsSubscription() {</span>
            <span class="s1">const </span><span class="s0">{ animate } = </span><span class="s1">this</span><span class="s0">.node.getProps();</span>
            <span class="s1">if </span><span class="s0">(isAnimationControls(animate)) {</span>
                <span class="s1">this</span><span class="s0">.unmountControls = animate.subscribe(</span><span class="s1">this</span><span class="s0">.node);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Subscribe any provided AnimationControls to the component's VisualElement</span>
         <span class="s3">*/</span>
        <span class="s0">mount() {</span>
            <span class="s1">this</span><span class="s0">.updateAnimationControlsSubscription();</span>
        <span class="s0">}</span>
        <span class="s0">update() {</span>
            <span class="s1">const </span><span class="s0">{ animate } = </span><span class="s1">this</span><span class="s0">.node.getProps();</span>
            <span class="s1">const </span><span class="s0">{ animate: prevAnimate } = </span><span class="s1">this</span><span class="s0">.node.prevProps || {};</span>
            <span class="s1">if </span><span class="s0">(animate !== prevAnimate) {</span>
                <span class="s1">this</span><span class="s0">.updateAnimationControlsSubscription();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">unmount() {</span>
            <span class="s1">this</span><span class="s0">.node.animationState.reset();</span>
            <span class="s1">this</span><span class="s0">.unmountControls?.();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">let </span><span class="s0">id$1 = </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s1">class </span><span class="s0">ExitAnimationFeature </span><span class="s1">extends </span><span class="s0">Feature {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.id = id$1++;</span>
        <span class="s0">}</span>
        <span class="s0">update() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.node.presenceContext)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ isPresent, onExitComplete } = </span><span class="s1">this</span><span class="s0">.node.presenceContext;</span>
            <span class="s1">const </span><span class="s0">{ isPresent: prevIsPresent } = </span><span class="s1">this</span><span class="s0">.node.prevPresenceContext || {};</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.node.animationState || isPresent === prevIsPresent) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">exitAnimation = </span><span class="s1">this</span><span class="s0">.node.animationState.setActive(</span><span class="s2">&quot;exit&quot;</span><span class="s0">, !isPresent);</span>
            <span class="s1">if </span><span class="s0">(onExitComplete &amp;&amp; !isPresent) {</span>
                <span class="s0">exitAnimation.then(() =&gt; {</span>
                    <span class="s0">onExitComplete(</span><span class="s1">this</span><span class="s0">.id);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">mount() {</span>
            <span class="s1">const </span><span class="s0">{ register, onExitComplete } = </span><span class="s1">this</span><span class="s0">.node.presenceContext || {};</span>
            <span class="s1">if </span><span class="s0">(onExitComplete) {</span>
                <span class="s0">onExitComplete(</span><span class="s1">this</span><span class="s0">.id);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(register) {</span>
                <span class="s1">this</span><span class="s0">.unmount = register(</span><span class="s1">this</span><span class="s0">.id);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">unmount() { }</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">animations = {</span>
        <span class="s0">animation: {</span>
            <span class="s0">Feature: AnimationFeature,</span>
        <span class="s0">},</span>
        <span class="s0">exit: {</span>
            <span class="s0">Feature: ExitAnimationFeature,</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">extractEventInfo(event) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">point: {</span>
                <span class="s0">x: event.pageX,</span>
                <span class="s0">y: event.pageY,</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">addPointerInfo = (handler) =&gt; {</span>
        <span class="s1">return </span><span class="s0">(event) =&gt; isPrimaryPointer(event) &amp;&amp; handler(event, extractEventInfo(event));</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">addPointerEvent(target, eventName, handler, options) {</span>
        <span class="s1">return </span><span class="s0">addDomEvent(target, eventName, addPointerInfo(handler), options);</span>
    <span class="s0">}</span>

    <span class="s3">// Fixes https://github.com/motiondivision/motion/issues/2270</span>
    <span class="s1">const </span><span class="s0">getContextWindow = ({ current }) =&gt; {</span>
        <span class="s1">return </span><span class="s0">current ? current.ownerDocument.defaultView : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">distance = (a, b) =&gt; Math.abs(a - b);</span>
    <span class="s1">function </span><span class="s0">distance2D(a, b) {</span>
        <span class="s3">// Multi-dimensional</span>
        <span class="s1">const </span><span class="s0">xDelta = distance(a.x, b.x);</span>
        <span class="s1">const </span><span class="s0">yDelta = distance(a.y, b.y);</span>
        <span class="s1">return </span><span class="s0">Math.sqrt(xDelta ** </span><span class="s5">2 </span><span class="s0">+ yDelta ** </span><span class="s5">2</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@internal</span>
     <span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">PanSession {</span>
        <span class="s0">constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = </span><span class="s1">false</span><span class="s0">, distanceThreshold = </span><span class="s5">3</span><span class="s0">, } = {}) {</span>
            <span class="s3">/**</span>
             <span class="s3">* </span><span class="s4">@internal</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.startEvent = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* </span><span class="s4">@internal</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.lastMoveEvent = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* </span><span class="s4">@internal</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.lastMoveEventInfo = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* </span><span class="s4">@internal</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.handlers = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* </span><span class="s4">@internal</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.contextWindow = window;</span>
            <span class="s1">this</span><span class="s0">.updatePoint = () =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!(</span><span class="s1">this</span><span class="s0">.lastMoveEvent &amp;&amp; </span><span class="s1">this</span><span class="s0">.lastMoveEventInfo))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">info = getPanInfo(</span><span class="s1">this</span><span class="s0">.lastMoveEventInfo, </span><span class="s1">this</span><span class="s0">.history);</span>
                <span class="s1">const </span><span class="s0">isPanStarted = </span><span class="s1">this</span><span class="s0">.startEvent !== </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s3">// Only start panning if the offset is larger than 3 pixels. If we make it</span>
                <span class="s3">// any larger than this we'll want to reset the pointer history</span>
                <span class="s3">// on the first update to avoid visual snapping to the cursor.</span>
                <span class="s1">const </span><span class="s0">isDistancePastThreshold = distance2D(info.offset, { x: </span><span class="s5">0</span><span class="s0">, y: </span><span class="s5">0 </span><span class="s0">}) &gt;= </span><span class="s1">this</span><span class="s0">.distanceThreshold;</span>
                <span class="s1">if </span><span class="s0">(!isPanStarted &amp;&amp; !isDistancePastThreshold)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ point } = info;</span>
                <span class="s1">const </span><span class="s0">{ timestamp } = frameData;</span>
                <span class="s1">this</span><span class="s0">.history.push({ ...point, timestamp });</span>
                <span class="s1">const </span><span class="s0">{ onStart, onMove } = </span><span class="s1">this</span><span class="s0">.handlers;</span>
                <span class="s1">if </span><span class="s0">(!isPanStarted) {</span>
                    <span class="s0">onStart &amp;&amp; onStart(</span><span class="s1">this</span><span class="s0">.lastMoveEvent, info);</span>
                    <span class="s1">this</span><span class="s0">.startEvent = </span><span class="s1">this</span><span class="s0">.lastMoveEvent;</span>
                <span class="s0">}</span>
                <span class="s0">onMove &amp;&amp; onMove(</span><span class="s1">this</span><span class="s0">.lastMoveEvent, info);</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.handlePointerMove = (event, info) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.lastMoveEvent = event;</span>
                <span class="s1">this</span><span class="s0">.lastMoveEventInfo = transformPoint(info, </span><span class="s1">this</span><span class="s0">.transformPagePoint);</span>
                <span class="s3">// Throttle mouse move event to once per frame</span>
                <span class="s0">frame.update(</span><span class="s1">this</span><span class="s0">.updatePoint, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.handlePointerUp = (event, info) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.end();</span>
                <span class="s1">const </span><span class="s0">{ onEnd, onSessionEnd, resumeAnimation } = </span><span class="s1">this</span><span class="s0">.handlers;</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.dragSnapToOrigin)</span>
                    <span class="s0">resumeAnimation &amp;&amp; resumeAnimation();</span>
                <span class="s1">if </span><span class="s0">(!(</span><span class="s1">this</span><span class="s0">.lastMoveEvent &amp;&amp; </span><span class="s1">this</span><span class="s0">.lastMoveEventInfo))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">panInfo = getPanInfo(event.type === </span><span class="s2">&quot;pointercancel&quot;</span>
                    <span class="s0">? </span><span class="s1">this</span><span class="s0">.lastMoveEventInfo</span>
                    <span class="s0">: transformPoint(info, </span><span class="s1">this</span><span class="s0">.transformPagePoint), </span><span class="s1">this</span><span class="s0">.history);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.startEvent &amp;&amp; onEnd) {</span>
                    <span class="s0">onEnd(event, panInfo);</span>
                <span class="s0">}</span>
                <span class="s0">onSessionEnd &amp;&amp; onSessionEnd(event, panInfo);</span>
            <span class="s0">};</span>
            <span class="s3">// If we have more than one touch, don't start detecting this gesture</span>
            <span class="s1">if </span><span class="s0">(!isPrimaryPointer(event))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.dragSnapToOrigin = dragSnapToOrigin;</span>
            <span class="s1">this</span><span class="s0">.handlers = handlers;</span>
            <span class="s1">this</span><span class="s0">.transformPagePoint = transformPagePoint;</span>
            <span class="s1">this</span><span class="s0">.distanceThreshold = distanceThreshold;</span>
            <span class="s1">this</span><span class="s0">.contextWindow = contextWindow || window;</span>
            <span class="s1">const </span><span class="s0">info = extractEventInfo(event);</span>
            <span class="s1">const </span><span class="s0">initialInfo = transformPoint(info, </span><span class="s1">this</span><span class="s0">.transformPagePoint);</span>
            <span class="s1">const </span><span class="s0">{ point } = initialInfo;</span>
            <span class="s1">const </span><span class="s0">{ timestamp } = frameData;</span>
            <span class="s1">this</span><span class="s0">.history = [{ ...point, timestamp }];</span>
            <span class="s1">const </span><span class="s0">{ onSessionStart } = handlers;</span>
            <span class="s0">onSessionStart &amp;&amp;</span>
                <span class="s0">onSessionStart(event, getPanInfo(initialInfo, </span><span class="s1">this</span><span class="s0">.history));</span>
            <span class="s1">this</span><span class="s0">.removeListeners = pipe(addPointerEvent(</span><span class="s1">this</span><span class="s0">.contextWindow, </span><span class="s2">&quot;pointermove&quot;</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.handlePointerMove), addPointerEvent(</span><span class="s1">this</span><span class="s0">.contextWindow, </span><span class="s2">&quot;pointerup&quot;</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.handlePointerUp), addPointerEvent(</span><span class="s1">this</span><span class="s0">.contextWindow, </span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.handlePointerUp));</span>
        <span class="s0">}</span>
        <span class="s0">updateHandlers(handlers) {</span>
            <span class="s1">this</span><span class="s0">.handlers = handlers;</span>
        <span class="s0">}</span>
        <span class="s0">end() {</span>
            <span class="s1">this</span><span class="s0">.removeListeners &amp;&amp; </span><span class="s1">this</span><span class="s0">.removeListeners();</span>
            <span class="s0">cancelFrame(</span><span class="s1">this</span><span class="s0">.updatePoint);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">transformPoint(info, transformPagePoint) {</span>
        <span class="s1">return </span><span class="s0">transformPagePoint ? { point: transformPagePoint(info.point) } : info;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">subtractPoint(a, b) {</span>
        <span class="s1">return </span><span class="s0">{ x: a.x - b.x, y: a.y - b.y };</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getPanInfo({ point }, history) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">point,</span>
            <span class="s0">delta: subtractPoint(point, lastDevicePoint(history)),</span>
            <span class="s0">offset: subtractPoint(point, startDevicePoint(history)),</span>
            <span class="s0">velocity: getVelocity(history, </span><span class="s5">0.1</span><span class="s0">),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">startDevicePoint(history) {</span>
        <span class="s1">return </span><span class="s0">history[</span><span class="s5">0</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">lastDevicePoint(history) {</span>
        <span class="s1">return </span><span class="s0">history[history.length - </span><span class="s5">1</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getVelocity(history, timeDelta) {</span>
        <span class="s1">if </span><span class="s0">(history.length &lt; </span><span class="s5">2</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">{ x: </span><span class="s5">0</span><span class="s0">, y: </span><span class="s5">0 </span><span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">i = history.length - </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">timestampedPoint = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">lastPoint = lastDevicePoint(history);</span>
        <span class="s1">while </span><span class="s0">(i &gt;= </span><span class="s5">0</span><span class="s0">) {</span>
            <span class="s0">timestampedPoint = history[i];</span>
            <span class="s1">if </span><span class="s0">(lastPoint.timestamp - timestampedPoint.timestamp &gt;</span>
                <span class="s0">secondsToMilliseconds(timeDelta)) {</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">i--;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!timestampedPoint) {</span>
            <span class="s1">return </span><span class="s0">{ x: </span><span class="s5">0</span><span class="s0">, y: </span><span class="s5">0 </span><span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);</span>
        <span class="s1">if </span><span class="s0">(time === </span><span class="s5">0</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">{ x: </span><span class="s5">0</span><span class="s0">, y: </span><span class="s5">0 </span><span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">currentVelocity = {</span>
            <span class="s0">x: (lastPoint.x - timestampedPoint.x) / time,</span>
            <span class="s0">y: (lastPoint.y - timestampedPoint.y) / time,</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(currentVelocity.x === Infinity) {</span>
            <span class="s0">currentVelocity.x = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(currentVelocity.y === Infinity) {</span>
            <span class="s0">currentVelocity.y = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">currentVelocity;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Apply constraints to a point. These constraints are both physical along an</span>
     <span class="s3">* axis, and an elastic factor that determines how much to constrain the point</span>
     <span class="s3">* by if it does lie outside the defined parameters.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">applyConstraints(point, { min, max }, elastic) {</span>
        <span class="s1">if </span><span class="s0">(min !== undefined &amp;&amp; point &lt; min) {</span>
            <span class="s3">// If we have a min point defined, and this is outside of that, constrain</span>
            <span class="s0">point = elastic</span>
                <span class="s0">? mixNumber$1(min, point, elastic.min)</span>
                <span class="s0">: Math.max(point, min);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(max !== undefined &amp;&amp; point &gt; max) {</span>
            <span class="s3">// If we have a max point defined, and this is outside of that, constrain</span>
            <span class="s0">point = elastic</span>
                <span class="s0">? mixNumber$1(max, point, elastic.max)</span>
                <span class="s0">: Math.min(point, max);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">point;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Calculate constraints in terms of the viewport when defined relatively to the</span>
     <span class="s3">* measured axis. This is measured from the nearest edge, so a max constraint of 200</span>
     <span class="s3">* on an axis with a max value of 300 would return a constraint of 500 - axis length</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">calcRelativeAxisConstraints(axis, min, max) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">min: min !== undefined ? axis.min + min : undefined,</span>
            <span class="s0">max: max !== undefined</span>
                <span class="s0">? axis.max + max - (axis.max - axis.min)</span>
                <span class="s0">: undefined,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Calculate constraints in terms of the viewport when</span>
     <span class="s3">* defined relatively to the measured bounding box.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">x: calcRelativeAxisConstraints(layoutBox.x, left, right),</span>
            <span class="s0">y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Calculate viewport constraints when defined as another viewport-relative axis</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">calcViewportAxisConstraints(layoutAxis, constraintsAxis) {</span>
        <span class="s1">let </span><span class="s0">min = constraintsAxis.min - layoutAxis.min;</span>
        <span class="s1">let </span><span class="s0">max = constraintsAxis.max - layoutAxis.max;</span>
        <span class="s3">// If the constraints axis is actually smaller than the layout axis then we can</span>
        <span class="s3">// flip the constraints</span>
        <span class="s1">if </span><span class="s0">(constraintsAxis.max - constraintsAxis.min &lt;</span>
            <span class="s0">layoutAxis.max - layoutAxis.min) {</span>
            <span class="s0">[min, max] = [max, min];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{ min, max };</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Calculate viewport constraints when defined as another viewport-relative box</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">calcViewportConstraints(layoutBox, constraintsBox) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),</span>
            <span class="s0">y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Calculate a transform origin relative to the source axis, between 0-1, that results</span>
     <span class="s3">* in an asthetically pleasing scale/transform needed to project from source to target.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">calcOrigin(source, target) {</span>
        <span class="s1">let </span><span class="s0">origin = </span><span class="s5">0.5</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">sourceLength = calcLength(source);</span>
        <span class="s1">const </span><span class="s0">targetLength = calcLength(target);</span>
        <span class="s1">if </span><span class="s0">(targetLength &gt; sourceLength) {</span>
            <span class="s0">origin = progress(target.min, target.max - sourceLength, source.min);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(sourceLength &gt; targetLength) {</span>
            <span class="s0">origin = progress(source.min, source.max - targetLength, target.min);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">clamp(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, origin);</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Rebase the calculated viewport constraints relative to the layout.min point.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">rebaseAxisConstraints(layout, constraints) {</span>
        <span class="s1">const </span><span class="s0">relativeConstraints = {};</span>
        <span class="s1">if </span><span class="s0">(constraints.min !== undefined) {</span>
            <span class="s0">relativeConstraints.min = constraints.min - layout.min;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(constraints.max !== undefined) {</span>
            <span class="s0">relativeConstraints.max = constraints.max - layout.min;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">relativeConstraints;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">defaultElastic = </span><span class="s5">0.35</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Accepts a dragElastic prop and returns resolved elastic values for each axis.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">resolveDragElastic(dragElastic = defaultElastic) {</span>
        <span class="s1">if </span><span class="s0">(dragElastic === </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s0">dragElastic = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(dragElastic === </span><span class="s1">true</span><span class="s0">) {</span>
            <span class="s0">dragElastic = defaultElastic;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">x: resolveAxisElastic(dragElastic, </span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s2">&quot;right&quot;</span><span class="s0">),</span>
            <span class="s0">y: resolveAxisElastic(dragElastic, </span><span class="s2">&quot;top&quot;</span><span class="s0">, </span><span class="s2">&quot;bottom&quot;</span><span class="s0">),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resolveAxisElastic(dragElastic, minLabel, maxLabel) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">min: resolvePointElastic(dragElastic, minLabel),</span>
            <span class="s0">max: resolvePointElastic(dragElastic, maxLabel),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resolvePointElastic(dragElastic, label) {</span>
        <span class="s1">return typeof </span><span class="s0">dragElastic === </span><span class="s2">&quot;number&quot;</span>
            <span class="s0">? dragElastic</span>
            <span class="s0">: dragElastic[label] || </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">elementDragControls = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">class </span><span class="s0">VisualElementDragControls {</span>
        <span class="s0">constructor(visualElement) {</span>
            <span class="s1">this</span><span class="s0">.openDragLock = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isDragging = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.currentDirection = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.originPoint = { x: </span><span class="s5">0</span><span class="s0">, y: </span><span class="s5">0 </span><span class="s0">};</span>
            <span class="s3">/**</span>
             <span class="s3">* The permitted boundaries of travel, in pixels.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.constraints = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.hasMutatedConstraints = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* The per-axis resolved elastic values.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.elastic = createBox();</span>
            <span class="s3">/**</span>
             <span class="s3">* The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.latestPointerEvent = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.latestPanInfo = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.visualElement = visualElement;</span>
        <span class="s0">}</span>
        <span class="s0">start(originEvent, { snapToCursor = </span><span class="s1">false</span><span class="s0">, distanceThreshold } = {}) {</span>
            <span class="s3">/**</span>
             <span class="s3">* Don't start dragging if this component is exiting</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">{ presenceContext } = </span><span class="s1">this</span><span class="s0">.visualElement;</span>
            <span class="s1">if </span><span class="s0">(presenceContext &amp;&amp; presenceContext.isPresent === </span><span class="s1">false</span><span class="s0">)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">onSessionStart = (event) =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ dragSnapToOrigin } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
                <span class="s3">// Stop or pause any animations on both axis values immediately. This allows the user to throw and catch</span>
                <span class="s3">// the component.</span>
                <span class="s0">dragSnapToOrigin ? </span><span class="s1">this</span><span class="s0">.pauseAnimation() : </span><span class="s1">this</span><span class="s0">.stopAnimation();</span>
                <span class="s1">if </span><span class="s0">(snapToCursor) {</span>
                    <span class="s1">this</span><span class="s0">.snapToCursor(extractEventInfo(event).point);</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">onStart = (event, info) =&gt; {</span>
                <span class="s3">// Attempt to grab the global drag gesture lock - maybe make this part of PanSession</span>
                <span class="s1">const </span><span class="s0">{ drag, dragPropagation, onDragStart } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
                <span class="s1">if </span><span class="s0">(drag &amp;&amp; !dragPropagation) {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.openDragLock)</span>
                        <span class="s1">this</span><span class="s0">.openDragLock();</span>
                    <span class="s1">this</span><span class="s0">.openDragLock = setDragLock(drag);</span>
                    <span class="s3">// If we don 't have the lock, don't start dragging</span>
                    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.openDragLock)</span>
                        <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.latestPointerEvent = event;</span>
                <span class="s1">this</span><span class="s0">.latestPanInfo = info;</span>
                <span class="s1">this</span><span class="s0">.isDragging = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.currentDirection = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.resolveConstraints();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.visualElement.projection) {</span>
                    <span class="s1">this</span><span class="s0">.visualElement.projection.isAnimationBlocked = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">this</span><span class="s0">.visualElement.projection.target = undefined;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Record gesture origin</span>
                 <span class="s3">*/</span>
                <span class="s0">eachAxis((axis) =&gt; {</span>
                    <span class="s1">let </span><span class="s0">current = </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis).get() || </span><span class="s5">0</span><span class="s0">;</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If the MotionValue is a percentage value convert to px</span>
                     <span class="s3">*/</span>
                    <span class="s1">if </span><span class="s0">(percent.test(current)) {</span>
                        <span class="s1">const </span><span class="s0">{ projection } = </span><span class="s1">this</span><span class="s0">.visualElement;</span>
                        <span class="s1">if </span><span class="s0">(projection &amp;&amp; projection.layout) {</span>
                            <span class="s1">const </span><span class="s0">measuredAxis = projection.layout.layoutBox[axis];</span>
                            <span class="s1">if </span><span class="s0">(measuredAxis) {</span>
                                <span class="s1">const </span><span class="s0">length = calcLength(measuredAxis);</span>
                                <span class="s0">current = length * (parseFloat(current) / </span><span class="s5">100</span><span class="s0">);</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">this</span><span class="s0">.originPoint[axis] = current;</span>
                <span class="s0">});</span>
                <span class="s3">// Fire onDragStart event</span>
                <span class="s1">if </span><span class="s0">(onDragStart) {</span>
                    <span class="s0">frame.postRender(() =&gt; onDragStart(event, info));</span>
                <span class="s0">}</span>
                <span class="s0">addValueToWillChange(</span><span class="s1">this</span><span class="s0">.visualElement, </span><span class="s2">&quot;transform&quot;</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">{ animationState } = </span><span class="s1">this</span><span class="s0">.visualElement;</span>
                <span class="s0">animationState &amp;&amp; animationState.setActive(</span><span class="s2">&quot;whileDrag&quot;</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">onMove = (event, info) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.latestPointerEvent = event;</span>
                <span class="s1">this</span><span class="s0">.latestPanInfo = info;</span>
                <span class="s1">const </span><span class="s0">{ dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
                <span class="s3">// If we didn't successfully receive the gesture lock, early return.</span>
                <span class="s1">if </span><span class="s0">(!dragPropagation &amp;&amp; !</span><span class="s1">this</span><span class="s0">.openDragLock)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ offset } = info;</span>
                <span class="s3">// Attempt to detect drag direction if directionLock is true</span>
                <span class="s1">if </span><span class="s0">(dragDirectionLock &amp;&amp; </span><span class="s1">this</span><span class="s0">.currentDirection === </span><span class="s1">null</span><span class="s0">) {</span>
                    <span class="s1">this</span><span class="s0">.currentDirection = getCurrentDirection(offset);</span>
                    <span class="s3">// If we've successfully set a direction, notify listener</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentDirection !== </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s0">onDirectionLock &amp;&amp; onDirectionLock(</span><span class="s1">this</span><span class="s0">.currentDirection);</span>
                    <span class="s0">}</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">// Update each point with the latest position</span>
                <span class="s1">this</span><span class="s0">.updateAxis(</span><span class="s2">&quot;x&quot;</span><span class="s0">, info.point, offset);</span>
                <span class="s1">this</span><span class="s0">.updateAxis(</span><span class="s2">&quot;y&quot;</span><span class="s0">, info.point, offset);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Ideally we would leave the renderer to fire naturally at the end of</span>
                 <span class="s3">* this frame but if the element is about to change layout as the result</span>
                 <span class="s3">* of a re-render we want to ensure the browser can read the latest</span>
                 <span class="s3">* bounding box to ensure the pointer and element don't fall out of sync.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.visualElement.render();</span>
                <span class="s3">/**</span>
                 <span class="s3">* This must fire after the render call as it might trigger a state</span>
                 <span class="s3">* change which itself might trigger a layout update.</span>
                 <span class="s3">*/</span>
                <span class="s0">onDrag &amp;&amp; onDrag(event, info);</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">onSessionEnd = (event, info) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.latestPointerEvent = event;</span>
                <span class="s1">this</span><span class="s0">.latestPanInfo = info;</span>
                <span class="s1">this</span><span class="s0">.stop(event, info);</span>
                <span class="s1">this</span><span class="s0">.latestPointerEvent = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.latestPanInfo = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">resumeAnimation = () =&gt; eachAxis((axis) =&gt; </span><span class="s1">this</span><span class="s0">.getAnimationState(axis) === </span><span class="s2">&quot;paused&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s1">this</span><span class="s0">.getAxisMotionValue(axis).animation?.play());</span>
            <span class="s1">const </span><span class="s0">{ dragSnapToOrigin } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
            <span class="s1">this</span><span class="s0">.panSession = </span><span class="s1">new </span><span class="s0">PanSession(originEvent, {</span>
                <span class="s0">onSessionStart,</span>
                <span class="s0">onStart,</span>
                <span class="s0">onMove,</span>
                <span class="s0">onSessionEnd,</span>
                <span class="s0">resumeAnimation,</span>
            <span class="s0">}, {</span>
                <span class="s0">transformPagePoint: </span><span class="s1">this</span><span class="s0">.visualElement.getTransformPagePoint(),</span>
                <span class="s0">dragSnapToOrigin,</span>
                <span class="s0">distanceThreshold,</span>
                <span class="s0">contextWindow: getContextWindow(</span><span class="s1">this</span><span class="s0">.visualElement),</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s0">stop(event, panInfo) {</span>
            <span class="s1">const </span><span class="s0">finalEvent = event || </span><span class="s1">this</span><span class="s0">.latestPointerEvent;</span>
            <span class="s1">const </span><span class="s0">finalPanInfo = panInfo || </span><span class="s1">this</span><span class="s0">.latestPanInfo;</span>
            <span class="s1">const </span><span class="s0">isDragging = </span><span class="s1">this</span><span class="s0">.isDragging;</span>
            <span class="s1">this</span><span class="s0">.cancel();</span>
            <span class="s1">if </span><span class="s0">(!isDragging || !finalPanInfo || !finalEvent)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ velocity } = finalPanInfo;</span>
            <span class="s1">this</span><span class="s0">.startAnimation(velocity);</span>
            <span class="s1">const </span><span class="s0">{ onDragEnd } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
            <span class="s1">if </span><span class="s0">(onDragEnd) {</span>
                <span class="s0">frame.postRender(() =&gt; onDragEnd(finalEvent, finalPanInfo));</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s0">cancel() {</span>
            <span class="s1">this</span><span class="s0">.isDragging = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ projection, animationState } = </span><span class="s1">this</span><span class="s0">.visualElement;</span>
            <span class="s1">if </span><span class="s0">(projection) {</span>
                <span class="s0">projection.isAnimationBlocked = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.panSession &amp;&amp; </span><span class="s1">this</span><span class="s0">.panSession.end();</span>
            <span class="s1">this</span><span class="s0">.panSession = undefined;</span>
            <span class="s1">const </span><span class="s0">{ dragPropagation } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
            <span class="s1">if </span><span class="s0">(!dragPropagation &amp;&amp; </span><span class="s1">this</span><span class="s0">.openDragLock) {</span>
                <span class="s1">this</span><span class="s0">.openDragLock();</span>
                <span class="s1">this</span><span class="s0">.openDragLock = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">animationState &amp;&amp; animationState.setActive(</span><span class="s2">&quot;whileDrag&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">updateAxis(axis, _point, offset) {</span>
            <span class="s1">const </span><span class="s0">{ drag } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
            <span class="s3">// If we're not dragging this axis, do an early return.</span>
            <span class="s1">if </span><span class="s0">(!offset || !shouldDrag(axis, drag, </span><span class="s1">this</span><span class="s0">.currentDirection))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">axisValue = </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis);</span>
            <span class="s1">let </span><span class="s0">next = </span><span class="s1">this</span><span class="s0">.originPoint[axis] + offset[axis];</span>
            <span class="s3">// Apply constraints</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.constraints &amp;&amp; </span><span class="s1">this</span><span class="s0">.constraints[axis]) {</span>
                <span class="s0">next = applyConstraints(next, </span><span class="s1">this</span><span class="s0">.constraints[axis], </span><span class="s1">this</span><span class="s0">.elastic[axis]);</span>
            <span class="s0">}</span>
            <span class="s0">axisValue.set(next);</span>
        <span class="s0">}</span>
        <span class="s0">resolveConstraints() {</span>
            <span class="s1">const </span><span class="s0">{ dragConstraints, dragElastic } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
            <span class="s1">const </span><span class="s0">layout = </span><span class="s1">this</span><span class="s0">.visualElement.projection &amp;&amp;</span>
                <span class="s0">!</span><span class="s1">this</span><span class="s0">.visualElement.projection.layout</span>
                <span class="s0">? </span><span class="s1">this</span><span class="s0">.visualElement.projection.measure(</span><span class="s1">false</span><span class="s0">)</span>
                <span class="s0">: </span><span class="s1">this</span><span class="s0">.visualElement.projection?.layout;</span>
            <span class="s1">const </span><span class="s0">prevConstraints = </span><span class="s1">this</span><span class="s0">.constraints;</span>
            <span class="s1">if </span><span class="s0">(dragConstraints &amp;&amp; isRefObject(dragConstraints)) {</span>
                <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.constraints) {</span>
                    <span class="s1">this</span><span class="s0">.constraints = </span><span class="s1">this</span><span class="s0">.resolveRefConstraints();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(dragConstraints &amp;&amp; layout) {</span>
                    <span class="s1">this</span><span class="s0">.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">this</span><span class="s0">.constraints = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.elastic = resolveDragElastic(dragElastic);</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're outputting to external MotionValues, we want to rebase the measured constraints</span>
             <span class="s3">* from viewport-relative to component-relative.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(prevConstraints !== </span><span class="s1">this</span><span class="s0">.constraints &amp;&amp;</span>
                <span class="s0">layout &amp;&amp;</span>
                <span class="s1">this</span><span class="s0">.constraints &amp;&amp;</span>
                <span class="s0">!</span><span class="s1">this</span><span class="s0">.hasMutatedConstraints) {</span>
                <span class="s0">eachAxis((axis) =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.constraints !== </span><span class="s1">false </span><span class="s0">&amp;&amp;</span>
                        <span class="s1">this</span><span class="s0">.getAxisMotionValue(axis)) {</span>
                        <span class="s1">this</span><span class="s0">.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], </span><span class="s1">this</span><span class="s0">.constraints[axis]);</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">resolveRefConstraints() {</span>
            <span class="s1">const </span><span class="s0">{ dragConstraints: constraints, onMeasureDragConstraints } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
            <span class="s1">if </span><span class="s0">(!constraints || !isRefObject(constraints))</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">constraintsElement = constraints.current;</span>
            <span class="s0">exports.invariant(constraintsElement !== </span><span class="s1">null</span><span class="s0">, </span><span class="s2">&quot;If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.&quot;</span><span class="s0">, </span><span class="s2">&quot;drag-constraints-ref&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">{ projection } = </span><span class="s1">this</span><span class="s0">.visualElement;</span>
            <span class="s3">// TODO</span>
            <span class="s1">if </span><span class="s0">(!projection || !projection.layout)</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">constraintsBox = measurePageBox(constraintsElement, projection.root, </span><span class="s1">this</span><span class="s0">.visualElement.getTransformPagePoint());</span>
            <span class="s1">let </span><span class="s0">measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);</span>
            <span class="s3">/**</span>
             <span class="s3">* If there's an onMeasureDragConstraints listener we call it and</span>
             <span class="s3">* if different constraints are returned, set constraints to that</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(onMeasureDragConstraints) {</span>
                <span class="s1">const </span><span class="s0">userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));</span>
                <span class="s1">this</span><span class="s0">.hasMutatedConstraints = !!userConstraints;</span>
                <span class="s1">if </span><span class="s0">(userConstraints) {</span>
                    <span class="s0">measuredConstraints = convertBoundingBoxToBox(userConstraints);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">measuredConstraints;</span>
        <span class="s0">}</span>
        <span class="s0">startAnimation(velocity) {</span>
            <span class="s1">const </span><span class="s0">{ drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
            <span class="s1">const </span><span class="s0">constraints = </span><span class="s1">this</span><span class="s0">.constraints || {};</span>
            <span class="s1">const </span><span class="s0">momentumAnimations = eachAxis((axis) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!shouldDrag(axis, drag, </span><span class="s1">this</span><span class="s0">.currentDirection)) {</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">let </span><span class="s0">transition = (constraints &amp;&amp; constraints[axis]) || {};</span>
                <span class="s1">if </span><span class="s0">(dragSnapToOrigin)</span>
                    <span class="s0">transition = { min: </span><span class="s5">0</span><span class="s0">, max: </span><span class="s5">0 </span><span class="s0">};</span>
                <span class="s3">/**</span>
                 <span class="s3">* Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame</span>
                 <span class="s3">* of spring animations so we should look into adding a disable spring option to `inertia`.</span>
                 <span class="s3">* We could do something here where we affect the `bounceStiffness` and `bounceDamping`</span>
                 <span class="s3">* using the value of `dragElastic`.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">bounceStiffness = dragElastic ? </span><span class="s5">200 </span><span class="s0">: </span><span class="s5">1000000</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">bounceDamping = dragElastic ? </span><span class="s5">40 </span><span class="s0">: </span><span class="s5">10000000</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">inertia = {</span>
                    <span class="s0">type: </span><span class="s2">&quot;inertia&quot;</span><span class="s0">,</span>
                    <span class="s0">velocity: dragMomentum ? velocity[axis] : </span><span class="s5">0</span><span class="s0">,</span>
                    <span class="s0">bounceStiffness,</span>
                    <span class="s0">bounceDamping,</span>
                    <span class="s0">timeConstant: </span><span class="s5">750</span><span class="s0">,</span>
                    <span class="s0">restDelta: </span><span class="s5">1</span><span class="s0">,</span>
                    <span class="s0">restSpeed: </span><span class="s5">10</span><span class="s0">,</span>
                    <span class="s0">...dragTransition,</span>
                    <span class="s0">...transition,</span>
                <span class="s0">};</span>
                <span class="s3">// If we're not animating on an externally-provided `MotionValue` we can use the</span>
                <span class="s3">// component's animation controls which will handle interactions with whileHover (etc),</span>
                <span class="s3">// otherwise we just have to animate the `MotionValue` itself.</span>
                <span class="s1">return this</span><span class="s0">.startAxisValueAnimation(axis, inertia);</span>
            <span class="s0">});</span>
            <span class="s3">// Run all animations and then resolve the new drag constraints.</span>
            <span class="s1">return </span><span class="s0">Promise.all(momentumAnimations).then(onDragTransitionEnd);</span>
        <span class="s0">}</span>
        <span class="s0">startAxisValueAnimation(axis, transition) {</span>
            <span class="s1">const </span><span class="s0">axisValue = </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis);</span>
            <span class="s0">addValueToWillChange(</span><span class="s1">this</span><span class="s0">.visualElement, axis);</span>
            <span class="s1">return </span><span class="s0">axisValue.start(animateMotionValue(axis, axisValue, </span><span class="s5">0</span><span class="s0">, transition, </span><span class="s1">this</span><span class="s0">.visualElement, </span><span class="s1">false</span><span class="s0">));</span>
        <span class="s0">}</span>
        <span class="s0">stopAnimation() {</span>
            <span class="s0">eachAxis((axis) =&gt; </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis).stop());</span>
        <span class="s0">}</span>
        <span class="s0">pauseAnimation() {</span>
            <span class="s0">eachAxis((axis) =&gt; </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis).animation?.pause());</span>
        <span class="s0">}</span>
        <span class="s0">getAnimationState(axis) {</span>
            <span class="s1">return this</span><span class="s0">.getAxisMotionValue(axis).animation?.state;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Drag works differently depending on which props are provided.</span>
         <span class="s3">*</span>
         <span class="s3">* - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.</span>
         <span class="s3">* - Otherwise, we apply the delta to the x/y motion values.</span>
         <span class="s3">*/</span>
        <span class="s0">getAxisMotionValue(axis) {</span>
            <span class="s1">const </span><span class="s0">dragKey = </span><span class="s2">`_drag</span><span class="s0">${axis.toUpperCase()}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">props = </span><span class="s1">this</span><span class="s0">.visualElement.getProps();</span>
            <span class="s1">const </span><span class="s0">externalMotionValue = props[dragKey];</span>
            <span class="s1">return </span><span class="s0">externalMotionValue</span>
                <span class="s0">? externalMotionValue</span>
                <span class="s0">: </span><span class="s1">this</span><span class="s0">.visualElement.getValue(axis, (props.initial</span>
                    <span class="s0">? props.initial[axis]</span>
                    <span class="s0">: undefined) || </span><span class="s5">0</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">snapToCursor(point) {</span>
            <span class="s0">eachAxis((axis) =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ drag } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
                <span class="s3">// If we're not dragging this axis, do an early return.</span>
                <span class="s1">if </span><span class="s0">(!shouldDrag(axis, drag, </span><span class="s1">this</span><span class="s0">.currentDirection))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">{ projection } = </span><span class="s1">this</span><span class="s0">.visualElement;</span>
                <span class="s1">const </span><span class="s0">axisValue = </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis);</span>
                <span class="s1">if </span><span class="s0">(projection &amp;&amp; projection.layout) {</span>
                    <span class="s1">const </span><span class="s0">{ min, max } = projection.layout.layoutBox[axis];</span>
                    <span class="s0">axisValue.set(point[axis] - mixNumber$1(min, max, </span><span class="s5">0.5</span><span class="s0">));</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* When the viewport resizes we want to check if the measured constraints</span>
         <span class="s3">* have changed and, if so, reposition the element within those new constraints</span>
         <span class="s3">* relative to where it was before the resize.</span>
         <span class="s3">*/</span>
        <span class="s0">scalePositionWithinConstraints() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.visualElement.current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ drag, dragConstraints } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
            <span class="s1">const </span><span class="s0">{ projection } = </span><span class="s1">this</span><span class="s0">.visualElement;</span>
            <span class="s1">if </span><span class="s0">(!isRefObject(dragConstraints) || !projection || !</span><span class="s1">this</span><span class="s0">.constraints)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Stop current animations as there can be visual glitching if we try to do</span>
             <span class="s3">* this mid-animation</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.stopAnimation();</span>
            <span class="s3">/**</span>
             <span class="s3">* Record the relative position of the dragged element relative to the</span>
             <span class="s3">* constraints box and save as a progress value.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">boxProgress = { x: </span><span class="s5">0</span><span class="s0">, y: </span><span class="s5">0 </span><span class="s0">};</span>
            <span class="s0">eachAxis((axis) =&gt; {</span>
                <span class="s1">const </span><span class="s0">axisValue = </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis);</span>
                <span class="s1">if </span><span class="s0">(axisValue &amp;&amp; </span><span class="s1">this</span><span class="s0">.constraints !== </span><span class="s1">false</span><span class="s0">) {</span>
                    <span class="s1">const </span><span class="s0">latest = axisValue.get();</span>
                    <span class="s0">boxProgress[axis] = calcOrigin({ min: latest, max: latest }, </span><span class="s1">this</span><span class="s0">.constraints[axis]);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s3">/**</span>
             <span class="s3">* Update the layout of this element and resolve the latest drag constraints</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">{ transformTemplate } = </span><span class="s1">this</span><span class="s0">.visualElement.getProps();</span>
            <span class="s1">this</span><span class="s0">.visualElement.current.style.transform = transformTemplate</span>
                <span class="s0">? transformTemplate({}, </span><span class="s2">&quot;&quot;</span><span class="s0">)</span>
                <span class="s0">: </span><span class="s2">&quot;none&quot;</span><span class="s0">;</span>
            <span class="s0">projection.root &amp;&amp; projection.root.updateScroll();</span>
            <span class="s0">projection.updateLayout();</span>
            <span class="s1">this</span><span class="s0">.resolveConstraints();</span>
            <span class="s3">/**</span>
             <span class="s3">* For each axis, calculate the current progress of the layout axis</span>
             <span class="s3">* within the new constraints.</span>
             <span class="s3">*/</span>
            <span class="s0">eachAxis((axis) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!shouldDrag(axis, drag, </span><span class="s1">null</span><span class="s0">))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Calculate a new transform based on the previous box progress</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">axisValue = </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis);</span>
                <span class="s1">const </span><span class="s0">{ min, max } = </span><span class="s1">this</span><span class="s0">.constraints[axis];</span>
                <span class="s0">axisValue.set(mixNumber$1(min, max, boxProgress[axis]));</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">addListeners() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.visualElement.current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">elementDragControls.set(</span><span class="s1">this</span><span class="s0">.visualElement, </span><span class="s1">this</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">element = </span><span class="s1">this</span><span class="s0">.visualElement.current;</span>
            <span class="s3">/**</span>
             <span class="s3">* Attach a pointerdown event listener on this DOM element to initiate drag tracking.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">stopPointerListener = addPointerEvent(element, </span><span class="s2">&quot;pointerdown&quot;</span><span class="s0">, (event) =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ drag, dragListener = </span><span class="s1">true </span><span class="s0">} = </span><span class="s1">this</span><span class="s0">.getProps();</span>
                <span class="s0">drag &amp;&amp; dragListener &amp;&amp; </span><span class="s1">this</span><span class="s0">.start(event);</span>
            <span class="s0">});</span>
            <span class="s1">const </span><span class="s0">measureDragConstraints = () =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ dragConstraints } = </span><span class="s1">this</span><span class="s0">.getProps();</span>
                <span class="s1">if </span><span class="s0">(isRefObject(dragConstraints) &amp;&amp; dragConstraints.current) {</span>
                    <span class="s1">this</span><span class="s0">.constraints = </span><span class="s1">this</span><span class="s0">.resolveRefConstraints();</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">{ projection } = </span><span class="s1">this</span><span class="s0">.visualElement;</span>
            <span class="s1">const </span><span class="s0">stopMeasureLayoutListener = projection.addEventListener(</span><span class="s2">&quot;measure&quot;</span><span class="s0">, measureDragConstraints);</span>
            <span class="s1">if </span><span class="s0">(projection &amp;&amp; !projection.layout) {</span>
                <span class="s0">projection.root &amp;&amp; projection.root.updateScroll();</span>
                <span class="s0">projection.updateLayout();</span>
            <span class="s0">}</span>
            <span class="s0">frame.read(measureDragConstraints);</span>
            <span class="s3">/**</span>
             <span class="s3">* Attach a window resize listener to scale the draggable target within its defined</span>
             <span class="s3">* constraints as the window resizes.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">stopResizeListener = addDomEvent(window, </span><span class="s2">&quot;resize&quot;</span><span class="s0">, () =&gt; </span><span class="s1">this</span><span class="s0">.scalePositionWithinConstraints());</span>
            <span class="s3">/**</span>
             <span class="s3">* If the element's layout changes, calculate the delta and apply that to</span>
             <span class="s3">* the drag gesture's origin point.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">stopLayoutUpdateListener = projection.addEventListener(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s0">, (({ delta, hasLayoutChanged }) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isDragging &amp;&amp; hasLayoutChanged) {</span>
                    <span class="s0">eachAxis((axis) =&gt; {</span>
                        <span class="s1">const </span><span class="s0">motionValue = </span><span class="s1">this</span><span class="s0">.getAxisMotionValue(axis);</span>
                        <span class="s1">if </span><span class="s0">(!motionValue)</span>
                            <span class="s1">return</span><span class="s0">;</span>
                        <span class="s1">this</span><span class="s0">.originPoint[axis] += delta[axis].translate;</span>
                        <span class="s0">motionValue.set(motionValue.get() + delta[axis].translate);</span>
                    <span class="s0">});</span>
                    <span class="s1">this</span><span class="s0">.visualElement.render();</span>
                <span class="s0">}</span>
            <span class="s0">}));</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">stopResizeListener();</span>
                <span class="s0">stopPointerListener();</span>
                <span class="s0">stopMeasureLayoutListener();</span>
                <span class="s0">stopLayoutUpdateListener &amp;&amp; stopLayoutUpdateListener();</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s0">getProps() {</span>
            <span class="s1">const </span><span class="s0">props = </span><span class="s1">this</span><span class="s0">.visualElement.getProps();</span>
            <span class="s1">const </span><span class="s0">{ drag = </span><span class="s1">false</span><span class="s0">, dragDirectionLock = </span><span class="s1">false</span><span class="s0">, dragPropagation = </span><span class="s1">false</span><span class="s0">, dragConstraints = </span><span class="s1">false</span><span class="s0">, dragElastic = defaultElastic, dragMomentum = </span><span class="s1">true</span><span class="s0">, } = props;</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">...props,</span>
                <span class="s0">drag,</span>
                <span class="s0">dragDirectionLock,</span>
                <span class="s0">dragPropagation,</span>
                <span class="s0">dragConstraints,</span>
                <span class="s0">dragElastic,</span>
                <span class="s0">dragMomentum,</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">shouldDrag(direction, drag, currentDirection) {</span>
        <span class="s1">return </span><span class="s0">((drag === </span><span class="s1">true </span><span class="s0">|| drag === direction) &amp;&amp;</span>
            <span class="s0">(currentDirection === </span><span class="s1">null </span><span class="s0">|| currentDirection === direction));</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Based on an x/y offset determine the current drag direction. If both axis' offsets are lower</span>
     <span class="s3">* than the provided threshold, return `null`.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">offset - The x/y offset from origin.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">getCurrentDirection(offset, lockThreshold = </span><span class="s5">10</span><span class="s0">) {</span>
        <span class="s1">let </span><span class="s0">direction = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(Math.abs(offset.y) &gt; lockThreshold) {</span>
            <span class="s0">direction = </span><span class="s2">&quot;y&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(Math.abs(offset.x) &gt; lockThreshold) {</span>
            <span class="s0">direction = </span><span class="s2">&quot;x&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">direction;</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">DragGesture </span><span class="s1">extends </span><span class="s0">Feature {</span>
        <span class="s0">constructor(node) {</span>
            <span class="s1">super</span><span class="s0">(node);</span>
            <span class="s1">this</span><span class="s0">.removeGroupControls = noop;</span>
            <span class="s1">this</span><span class="s0">.removeListeners = noop;</span>
            <span class="s1">this</span><span class="s0">.controls = </span><span class="s1">new </span><span class="s0">VisualElementDragControls(node);</span>
        <span class="s0">}</span>
        <span class="s0">mount() {</span>
            <span class="s3">// If we've been provided a DragControls for manual control over the drag gesture,</span>
            <span class="s3">// subscribe this component to it on mount.</span>
            <span class="s1">const </span><span class="s0">{ dragControls } = </span><span class="s1">this</span><span class="s0">.node.getProps();</span>
            <span class="s1">if </span><span class="s0">(dragControls) {</span>
                <span class="s1">this</span><span class="s0">.removeGroupControls = dragControls.subscribe(</span><span class="s1">this</span><span class="s0">.controls);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.removeListeners = </span><span class="s1">this</span><span class="s0">.controls.addListeners() || noop;</span>
        <span class="s0">}</span>
        <span class="s0">unmount() {</span>
            <span class="s1">this</span><span class="s0">.removeGroupControls();</span>
            <span class="s1">this</span><span class="s0">.removeListeners();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">asyncHandler = (handler) =&gt; (event, info) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(handler) {</span>
            <span class="s0">frame.postRender(() =&gt; handler(event, info));</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s1">class </span><span class="s0">PanGesture </span><span class="s1">extends </span><span class="s0">Feature {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.removePointerDownListener = noop;</span>
        <span class="s0">}</span>
        <span class="s0">onPointerDown(pointerDownEvent) {</span>
            <span class="s1">this</span><span class="s0">.session = </span><span class="s1">new </span><span class="s0">PanSession(pointerDownEvent, </span><span class="s1">this</span><span class="s0">.createPanHandlers(), {</span>
                <span class="s0">transformPagePoint: </span><span class="s1">this</span><span class="s0">.node.getTransformPagePoint(),</span>
                <span class="s0">contextWindow: getContextWindow(</span><span class="s1">this</span><span class="s0">.node),</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">createPanHandlers() {</span>
            <span class="s1">const </span><span class="s0">{ onPanSessionStart, onPanStart, onPan, onPanEnd } = </span><span class="s1">this</span><span class="s0">.node.getProps();</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">onSessionStart: asyncHandler(onPanSessionStart),</span>
                <span class="s0">onStart: asyncHandler(onPanStart),</span>
                <span class="s0">onMove: onPan,</span>
                <span class="s0">onEnd: (event, info) =&gt; {</span>
                    <span class="s1">delete this</span><span class="s0">.session;</span>
                    <span class="s1">if </span><span class="s0">(onPanEnd) {</span>
                        <span class="s0">frame.postRender(() =&gt; onPanEnd(event, info));</span>
                    <span class="s0">}</span>
                <span class="s0">},</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s0">mount() {</span>
            <span class="s1">this</span><span class="s0">.removePointerDownListener = addPointerEvent(</span><span class="s1">this</span><span class="s0">.node.current, </span><span class="s2">&quot;pointerdown&quot;</span><span class="s0">, (event) =&gt; </span><span class="s1">this</span><span class="s0">.onPointerDown(event));</span>
        <span class="s0">}</span>
        <span class="s0">update() {</span>
            <span class="s1">this</span><span class="s0">.session &amp;&amp; </span><span class="s1">this</span><span class="s0">.session.updateHandlers(</span><span class="s1">this</span><span class="s0">.createPanHandlers());</span>
        <span class="s0">}</span>
        <span class="s0">unmount() {</span>
            <span class="s1">this</span><span class="s0">.removePointerDownListener();</span>
            <span class="s1">this</span><span class="s0">.session &amp;&amp; </span><span class="s1">this</span><span class="s0">.session.end();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Track whether we've taken any snapshots yet. If not,</span>
     <span class="s3">* we can safely skip notification of didUpdate.</span>
     <span class="s3">*</span>
     <span class="s3">* Difficult to capture in a test but to prevent flickering</span>
     <span class="s3">* we must set this to true either on update or unmount.</span>
     <span class="s3">* Running `next-env/layout-id` in Safari will show this behaviour if broken.</span>
     <span class="s3">*/</span>
    <span class="s1">let </span><span class="s0">hasTakenAnySnapshot = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">class </span><span class="s0">MeasureLayoutWithContext </span><span class="s1">extends </span><span class="s0">React$1.Component {</span>
        <span class="s3">/**</span>
         <span class="s3">* This only mounts projection nodes for components that</span>
         <span class="s3">* need measuring, we might want to do it for all components</span>
         <span class="s3">* in order to incorporate transforms</span>
         <span class="s3">*/</span>
        <span class="s0">componentDidMount() {</span>
            <span class="s1">const </span><span class="s0">{ visualElement, layoutGroup, switchLayoutGroup, layoutId } = </span><span class="s1">this</span><span class="s0">.props;</span>
            <span class="s1">const </span><span class="s0">{ projection } = visualElement;</span>
            <span class="s0">addScaleCorrector(defaultScaleCorrectors);</span>
            <span class="s1">if </span><span class="s0">(projection) {</span>
                <span class="s1">if </span><span class="s0">(layoutGroup.group)</span>
                    <span class="s0">layoutGroup.group.add(projection);</span>
                <span class="s1">if </span><span class="s0">(switchLayoutGroup &amp;&amp; switchLayoutGroup.register &amp;&amp; layoutId) {</span>
                    <span class="s0">switchLayoutGroup.register(projection);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(hasTakenAnySnapshot) {</span>
                    <span class="s0">projection.root.didUpdate();</span>
                <span class="s0">}</span>
                <span class="s0">projection.addEventListener(</span><span class="s2">&quot;animationComplete&quot;</span><span class="s0">, () =&gt; {</span>
                    <span class="s1">this</span><span class="s0">.safeToRemove();</span>
                <span class="s0">});</span>
                <span class="s0">projection.setOptions({</span>
                    <span class="s0">...projection.options,</span>
                    <span class="s0">onExitComplete: () =&gt; </span><span class="s1">this</span><span class="s0">.safeToRemove(),</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">globalProjectionState.hasEverUpdated = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">getSnapshotBeforeUpdate(prevProps) {</span>
            <span class="s1">const </span><span class="s0">{ layoutDependency, visualElement, drag, isPresent } = </span><span class="s1">this</span><span class="s0">.props;</span>
            <span class="s1">const </span><span class="s0">{ projection } = visualElement;</span>
            <span class="s1">if </span><span class="s0">(!projection)</span>
                <span class="s1">return null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* TODO: We use this data in relegate to determine whether to</span>
             <span class="s3">* promote a previous element. There's no guarantee its presence data</span>
             <span class="s3">* will have updated by this point - if a bug like this arises it will</span>
             <span class="s3">* have to be that we markForRelegation and then find a new lead some other way,</span>
             <span class="s3">* perhaps in didUpdate</span>
             <span class="s3">*/</span>
            <span class="s0">projection.isPresent = isPresent;</span>
            <span class="s0">hasTakenAnySnapshot = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(drag ||</span>
                <span class="s0">prevProps.layoutDependency !== layoutDependency ||</span>
                <span class="s0">layoutDependency === undefined ||</span>
                <span class="s0">prevProps.isPresent !== isPresent) {</span>
                <span class="s0">projection.willUpdate();</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.safeToRemove();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(prevProps.isPresent !== isPresent) {</span>
                <span class="s1">if </span><span class="s0">(isPresent) {</span>
                    <span class="s0">projection.promote();</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(!projection.relegate()) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If there's another stack member taking over from this one,</span>
                     <span class="s3">* it's in charge of the exit animation and therefore should</span>
                     <span class="s3">* be in charge of the safe to remove. Otherwise we call it here.</span>
                     <span class="s3">*/</span>
                    <span class="s0">frame.postRender(() =&gt; {</span>
                        <span class="s1">const </span><span class="s0">stack = projection.getStack();</span>
                        <span class="s1">if </span><span class="s0">(!stack || !stack.members.length) {</span>
                            <span class="s1">this</span><span class="s0">.safeToRemove();</span>
                        <span class="s0">}</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">componentDidUpdate() {</span>
            <span class="s1">const </span><span class="s0">{ projection } = </span><span class="s1">this</span><span class="s0">.props.visualElement;</span>
            <span class="s1">if </span><span class="s0">(projection) {</span>
                <span class="s0">projection.root.didUpdate();</span>
                <span class="s0">microtask.postRender(() =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(!projection.currentAnimation &amp;&amp; projection.isLead()) {</span>
                        <span class="s1">this</span><span class="s0">.safeToRemove();</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">componentWillUnmount() {</span>
            <span class="s1">const </span><span class="s0">{ visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = </span><span class="s1">this</span><span class="s0">.props;</span>
            <span class="s1">const </span><span class="s0">{ projection } = visualElement;</span>
            <span class="s0">hasTakenAnySnapshot = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(projection) {</span>
                <span class="s0">projection.scheduleCheckAfterUnmount();</span>
                <span class="s1">if </span><span class="s0">(layoutGroup &amp;&amp; layoutGroup.group)</span>
                    <span class="s0">layoutGroup.group.remove(projection);</span>
                <span class="s1">if </span><span class="s0">(promoteContext &amp;&amp; promoteContext.deregister)</span>
                    <span class="s0">promoteContext.deregister(projection);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">safeToRemove() {</span>
            <span class="s1">const </span><span class="s0">{ safeToRemove } = </span><span class="s1">this</span><span class="s0">.props;</span>
            <span class="s0">safeToRemove &amp;&amp; safeToRemove();</span>
        <span class="s0">}</span>
        <span class="s0">render() {</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">MeasureLayout(props) {</span>
        <span class="s1">const </span><span class="s0">[isPresent, safeToRemove] = usePresence();</span>
        <span class="s1">const </span><span class="s0">layoutGroup = React$1.useContext(LayoutGroupContext);</span>
        <span class="s1">return </span><span class="s0">(jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: React$1.useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">defaultScaleCorrectors = {</span>
        <span class="s0">borderRadius: {</span>
            <span class="s0">...correctBorderRadius,</span>
            <span class="s0">applyTo: [</span>
                <span class="s2">&quot;borderTopLeftRadius&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;borderTopRightRadius&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;borderBottomLeftRadius&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;borderBottomRightRadius&quot;</span><span class="s0">,</span>
            <span class="s0">],</span>
        <span class="s0">},</span>
        <span class="s0">borderTopLeftRadius: correctBorderRadius,</span>
        <span class="s0">borderTopRightRadius: correctBorderRadius,</span>
        <span class="s0">borderBottomLeftRadius: correctBorderRadius,</span>
        <span class="s0">borderBottomRightRadius: correctBorderRadius,</span>
        <span class="s0">boxShadow: correctBoxShadow,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">drag = {</span>
        <span class="s0">pan: {</span>
            <span class="s0">Feature: PanGesture,</span>
        <span class="s0">},</span>
        <span class="s0">drag: {</span>
            <span class="s0">Feature: DragGesture,</span>
            <span class="s0">ProjectionNode: HTMLProjectionNode,</span>
            <span class="s0">MeasureLayout,</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">handleHoverEvent(node, event, lifecycle) {</span>
        <span class="s1">const </span><span class="s0">{ props } = node;</span>
        <span class="s1">if </span><span class="s0">(node.animationState &amp;&amp; props.whileHover) {</span>
            <span class="s0">node.animationState.setActive(</span><span class="s2">&quot;whileHover&quot;</span><span class="s0">, lifecycle === </span><span class="s2">&quot;Start&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">eventName = (</span><span class="s2">&quot;onHover&quot; </span><span class="s0">+ lifecycle);</span>
        <span class="s1">const </span><span class="s0">callback = props[eventName];</span>
        <span class="s1">if </span><span class="s0">(callback) {</span>
            <span class="s0">frame.postRender(() =&gt; callback(event, extractEventInfo(event)));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">HoverGesture </span><span class="s1">extends </span><span class="s0">Feature {</span>
        <span class="s0">mount() {</span>
            <span class="s1">const </span><span class="s0">{ current } = </span><span class="s1">this</span><span class="s0">.node;</span>
            <span class="s1">if </span><span class="s0">(!current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.unmount = hover(current, (_element, startEvent) =&gt; {</span>
                <span class="s0">handleHoverEvent(</span><span class="s1">this</span><span class="s0">.node, startEvent, </span><span class="s2">&quot;Start&quot;</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">(endEvent) =&gt; handleHoverEvent(</span><span class="s1">this</span><span class="s0">.node, endEvent, </span><span class="s2">&quot;End&quot;</span><span class="s0">);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">unmount() { }</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">FocusGesture </span><span class="s1">extends </span><span class="s0">Feature {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.isActive = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">onFocus() {</span>
            <span class="s1">let </span><span class="s0">isFocusVisible = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* If this element doesn't match focus-visible then don't</span>
             <span class="s3">* apply whileHover. But, if matches throws that focus-visible</span>
             <span class="s3">* is not a valid selector then in that browser outline styles will be applied</span>
             <span class="s3">* to the element by default and we want to match that behaviour with whileFocus.</span>
             <span class="s3">*/</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">isFocusVisible = </span><span class="s1">this</span><span class="s0">.node.current.matches(</span><span class="s2">&quot;:focus-visible&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(e) {</span>
                <span class="s0">isFocusVisible = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!isFocusVisible || !</span><span class="s1">this</span><span class="s0">.node.animationState)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.node.animationState.setActive(</span><span class="s2">&quot;whileFocus&quot;</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.isActive = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">onBlur() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isActive || !</span><span class="s1">this</span><span class="s0">.node.animationState)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.node.animationState.setActive(</span><span class="s2">&quot;whileFocus&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.isActive = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">mount() {</span>
            <span class="s1">this</span><span class="s0">.unmount = pipe(addDomEvent(</span><span class="s1">this</span><span class="s0">.node.current, </span><span class="s2">&quot;focus&quot;</span><span class="s0">, () =&gt; </span><span class="s1">this</span><span class="s0">.onFocus()), addDomEvent(</span><span class="s1">this</span><span class="s0">.node.current, </span><span class="s2">&quot;blur&quot;</span><span class="s0">, () =&gt; </span><span class="s1">this</span><span class="s0">.onBlur()));</span>
        <span class="s0">}</span>
        <span class="s0">unmount() { }</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">handlePressEvent(node, event, lifecycle) {</span>
        <span class="s1">const </span><span class="s0">{ props } = node;</span>
        <span class="s1">if </span><span class="s0">(node.current </span><span class="s1">instanceof </span><span class="s0">HTMLButtonElement &amp;&amp; node.current.disabled) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node.animationState &amp;&amp; props.whileTap) {</span>
            <span class="s0">node.animationState.setActive(</span><span class="s2">&quot;whileTap&quot;</span><span class="s0">, lifecycle === </span><span class="s2">&quot;Start&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">eventName = (</span><span class="s2">&quot;onTap&quot; </span><span class="s0">+ (lifecycle === </span><span class="s2">&quot;End&quot; </span><span class="s0">? </span><span class="s2">&quot;&quot; </span><span class="s0">: lifecycle));</span>
        <span class="s1">const </span><span class="s0">callback = props[eventName];</span>
        <span class="s1">if </span><span class="s0">(callback) {</span>
            <span class="s0">frame.postRender(() =&gt; callback(event, extractEventInfo(event)));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">PressGesture </span><span class="s1">extends </span><span class="s0">Feature {</span>
        <span class="s0">mount() {</span>
            <span class="s1">const </span><span class="s0">{ current } = </span><span class="s1">this</span><span class="s0">.node;</span>
            <span class="s1">if </span><span class="s0">(!current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.unmount = press(current, (_element, startEvent) =&gt; {</span>
                <span class="s0">handlePressEvent(</span><span class="s1">this</span><span class="s0">.node, startEvent, </span><span class="s2">&quot;Start&quot;</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">(endEvent, { success }) =&gt; handlePressEvent(</span><span class="s1">this</span><span class="s0">.node, endEvent, success ? </span><span class="s2">&quot;End&quot; </span><span class="s0">: </span><span class="s2">&quot;Cancel&quot;</span><span class="s0">);</span>
            <span class="s0">}, { useGlobalTarget: </span><span class="s1">this</span><span class="s0">.node.props.globalTapTarget });</span>
        <span class="s0">}</span>
        <span class="s0">unmount() { }</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Map an IntersectionHandler callback to an element. We only ever make one handler for one</span>
     <span class="s3">* element, so even though these handlers might all be triggered by different</span>
     <span class="s3">* observers, we can keep them in the same map.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">observerCallbacks = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s3">/**</span>
     <span class="s3">* Multiple observers can be created for multiple element/document roots. Each with</span>
     <span class="s3">* different settings. So here we store dictionaries of observers to each root,</span>
     <span class="s3">* using serialised settings (threshold/margin) as lookup keys.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">observers = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">const </span><span class="s0">fireObserverCallback = (entry) =&gt; {</span>
        <span class="s1">const </span><span class="s0">callback = observerCallbacks.get(entry.target);</span>
        <span class="s0">callback &amp;&amp; callback(entry);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">fireAllObserverCallbacks = (entries) =&gt; {</span>
        <span class="s0">entries.forEach(fireObserverCallback);</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">initIntersectionObserver({ root, ...options }) {</span>
        <span class="s1">const </span><span class="s0">lookupRoot = root || document;</span>
        <span class="s3">/**</span>
         <span class="s3">* If we don't have an observer lookup map for this root, create one.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!observers.has(lookupRoot)) {</span>
            <span class="s0">observers.set(lookupRoot, {});</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">rootObservers = observers.get(lookupRoot);</span>
        <span class="s1">const </span><span class="s0">key = JSON.stringify(options);</span>
        <span class="s3">/**</span>
         <span class="s3">* If we don't have an observer for this combination of root and settings,</span>
         <span class="s3">* create one.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!rootObservers[key]) {</span>
            <span class="s0">rootObservers[key] = </span><span class="s1">new </span><span class="s0">IntersectionObserver(fireAllObserverCallbacks, { root, ...options });</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">rootObservers[key];</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">observeIntersection(element, options, callback) {</span>
        <span class="s1">const </span><span class="s0">rootInteresectionObserver = initIntersectionObserver(options);</span>
        <span class="s0">observerCallbacks.set(element, callback);</span>
        <span class="s0">rootInteresectionObserver.observe(element);</span>
        <span class="s1">return </span><span class="s0">() =&gt; {</span>
            <span class="s0">observerCallbacks.delete(element);</span>
            <span class="s0">rootInteresectionObserver.unobserve(element);</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">thresholdNames = {</span>
        <span class="s0">some: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">all: </span><span class="s5">1</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">class </span><span class="s0">InViewFeature </span><span class="s1">extends </span><span class="s0">Feature {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.hasEnteredView = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isInView = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">startObserver() {</span>
            <span class="s1">this</span><span class="s0">.unmount();</span>
            <span class="s1">const </span><span class="s0">{ viewport = {} } = </span><span class="s1">this</span><span class="s0">.node.getProps();</span>
            <span class="s1">const </span><span class="s0">{ root, margin: rootMargin, amount = </span><span class="s2">&quot;some&quot;</span><span class="s0">, once } = viewport;</span>
            <span class="s1">const </span><span class="s0">options = {</span>
                <span class="s0">root: root ? root.current : undefined,</span>
                <span class="s0">rootMargin,</span>
                <span class="s0">threshold: </span><span class="s1">typeof </span><span class="s0">amount === </span><span class="s2">&quot;number&quot; </span><span class="s0">? amount : thresholdNames[amount],</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">onIntersectionUpdate = (entry) =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ isIntersecting } = entry;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If there's been no change in the viewport state, early return.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isInView === isIntersecting)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.isInView = isIntersecting;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Handle hasEnteredView. If this is only meant to run once, and</span>
                 <span class="s3">* element isn't visible, early return. Otherwise set hasEnteredView to true.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(once &amp;&amp; !isIntersecting &amp;&amp; </span><span class="s1">this</span><span class="s0">.hasEnteredView) {</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(isIntersecting) {</span>
                    <span class="s1">this</span><span class="s0">.hasEnteredView = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.node.animationState) {</span>
                    <span class="s1">this</span><span class="s0">.node.animationState.setActive(</span><span class="s2">&quot;whileInView&quot;</span><span class="s0">, isIntersecting);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Use the latest committed props rather than the ones in scope</span>
                 <span class="s3">* when this observer is created</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">{ onViewportEnter, onViewportLeave } = </span><span class="s1">this</span><span class="s0">.node.getProps();</span>
                <span class="s1">const </span><span class="s0">callback = isIntersecting ? onViewportEnter : onViewportLeave;</span>
                <span class="s0">callback &amp;&amp; callback(entry);</span>
            <span class="s0">};</span>
            <span class="s1">return </span><span class="s0">observeIntersection(</span><span class="s1">this</span><span class="s0">.node.current, options, onIntersectionUpdate);</span>
        <span class="s0">}</span>
        <span class="s0">mount() {</span>
            <span class="s1">this</span><span class="s0">.startObserver();</span>
        <span class="s0">}</span>
        <span class="s0">update() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">IntersectionObserver === </span><span class="s2">&quot;undefined&quot;</span><span class="s0">)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ props, prevProps } = </span><span class="s1">this</span><span class="s0">.node;</span>
            <span class="s1">const </span><span class="s0">hasOptionsChanged = [</span><span class="s2">&quot;amount&quot;</span><span class="s0">, </span><span class="s2">&quot;margin&quot;</span><span class="s0">, </span><span class="s2">&quot;root&quot;</span><span class="s0">].some(hasViewportOptionChanged(props, prevProps));</span>
            <span class="s1">if </span><span class="s0">(hasOptionsChanged) {</span>
                <span class="s1">this</span><span class="s0">.startObserver();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">unmount() { }</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {</span>
        <span class="s1">return </span><span class="s0">(name) =&gt; viewport[name] !== prevViewport[name];</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">gestureAnimations = {</span>
        <span class="s0">inView: {</span>
            <span class="s0">Feature: InViewFeature,</span>
        <span class="s0">},</span>
        <span class="s0">tap: {</span>
            <span class="s0">Feature: PressGesture,</span>
        <span class="s0">},</span>
        <span class="s0">focus: {</span>
            <span class="s0">Feature: FocusGesture,</span>
        <span class="s0">},</span>
        <span class="s0">hover: {</span>
            <span class="s0">Feature: HoverGesture,</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">layout = {</span>
        <span class="s0">layout: {</span>
            <span class="s0">ProjectionNode: HTMLProjectionNode,</span>
            <span class="s0">MeasureLayout,</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">featureBundle = {</span>
        <span class="s0">...animations,</span>
        <span class="s0">...gestureAnimations,</span>
        <span class="s0">...drag,</span>
        <span class="s0">...layout,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">motion = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createMotionProxy(featureBundle, createDomVisualElement);</span>

    <span class="s1">function </span><span class="s0">checkReorder(order, value, offset, velocity) {</span>
        <span class="s1">if </span><span class="s0">(!velocity)</span>
            <span class="s1">return </span><span class="s0">order;</span>
        <span class="s1">const </span><span class="s0">index = order.findIndex((item) =&gt; item.value === value);</span>
        <span class="s1">if </span><span class="s0">(index === -</span><span class="s5">1</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">order;</span>
        <span class="s1">const </span><span class="s0">nextOffset = velocity &gt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">nextItem = order[index + nextOffset];</span>
        <span class="s1">if </span><span class="s0">(!nextItem)</span>
            <span class="s1">return </span><span class="s0">order;</span>
        <span class="s1">const </span><span class="s0">item = order[index];</span>
        <span class="s1">const </span><span class="s0">nextLayout = nextItem.layout;</span>
        <span class="s1">const </span><span class="s0">nextItemCenter = mixNumber$1(nextLayout.min, nextLayout.max, </span><span class="s5">0.5</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">((nextOffset === </span><span class="s5">1 </span><span class="s0">&amp;&amp; item.layout.max + offset &gt; nextItemCenter) ||</span>
            <span class="s0">(nextOffset === -</span><span class="s5">1 </span><span class="s0">&amp;&amp; item.layout.min + offset &lt; nextItemCenter)) {</span>
            <span class="s1">return </span><span class="s0">moveItem(order, index, index + nextOffset);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">order;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">ReorderGroupComponent({ children, as = </span><span class="s2">&quot;ul&quot;</span><span class="s0">, axis = </span><span class="s2">&quot;y&quot;</span><span class="s0">, onReorder, values, ...props }, externalRef) {</span>
        <span class="s1">const </span><span class="s0">Component = useConstant(() =&gt; motion[as]);</span>
        <span class="s1">const </span><span class="s0">order = [];</span>
        <span class="s1">const </span><span class="s0">isReordering = React$1.useRef(</span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">exports.invariant(Boolean(values), </span><span class="s2">&quot;Reorder.Group must be provided a values prop&quot;</span><span class="s0">, </span><span class="s2">&quot;reorder-values&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">context = {</span>
            <span class="s0">axis,</span>
            <span class="s0">registerItem: (value, layout) =&gt; {</span>
                <span class="s3">// If the entry was already added, update it rather than adding it again</span>
                <span class="s1">const </span><span class="s0">idx = order.findIndex((entry) =&gt; value === entry.value);</span>
                <span class="s1">if </span><span class="s0">(idx !== -</span><span class="s5">1</span><span class="s0">) {</span>
                    <span class="s0">order[idx].layout = layout[axis];</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">order.push({ value: value, layout: layout[axis] });</span>
                <span class="s0">}</span>
                <span class="s0">order.sort(compareMin);</span>
            <span class="s0">},</span>
            <span class="s0">updateOrder: (item, offset, velocity) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(isReordering.current)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">newOrder = checkReorder(order, item, offset, velocity);</span>
                <span class="s1">if </span><span class="s0">(order !== newOrder) {</span>
                    <span class="s0">isReordering.current = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">onReorder(newOrder</span>
                        <span class="s0">.map(getValue)</span>
                        <span class="s0">.filter((value) =&gt; values.indexOf(value) !== -</span><span class="s5">1</span><span class="s0">));</span>
                <span class="s0">}</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s0">isReordering.current = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">(jsx(Component, { ...props, ref: externalRef, ignoreStrict: </span><span class="s1">true</span><span class="s0">, children: jsx(ReorderContext.Provider, { value: context, children: children }) }));</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">ReorderGroup = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">React$1.forwardRef(ReorderGroupComponent);</span>
    <span class="s1">function </span><span class="s0">getValue(item) {</span>
        <span class="s1">return </span><span class="s0">item.value;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">compareMin(a, b) {</span>
        <span class="s1">return </span><span class="s0">a.layout.min - b.layout.min;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Creates a `MotionValue` to track the state and velocity of a value.</span>
     <span class="s3">*</span>
     <span class="s3">* Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* export const MyComponent = () =&gt; {</span>
     <span class="s3">*   const scale = useMotionValue(1)</span>
     <span class="s3">*</span>
     <span class="s3">*   return &lt;motion.div style={{ scale }} /&gt;</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">initial - The initial state.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useMotionValue(initial) {</span>
        <span class="s1">const </span><span class="s0">value = useConstant(() =&gt; motionValue(initial));</span>
        <span class="s3">/**</span>
         <span class="s3">* If this motion value is being used in static mode, like on</span>
         <span class="s3">* the Framer canvas, force components to rerender when the motion</span>
         <span class="s3">* value is updated.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">{ isStatic } = React$1.useContext(MotionConfigContext);</span>
        <span class="s1">if </span><span class="s0">(isStatic) {</span>
            <span class="s1">const </span><span class="s0">[, setLatest] = React$1.useState(initial);</span>
            <span class="s0">React$1.useEffect(() =&gt; value.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, setLatest), []);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useCombineMotionValues(values, combineValues) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Initialise the returned motion value. This remains the same between renders.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">value = useMotionValue(combineValues());</span>
        <span class="s3">/**</span>
         <span class="s3">* Create a function that will update the template motion value with the latest values.</span>
         <span class="s3">* This is pre-bound so whenever a motion value updates it can schedule its</span>
         <span class="s3">* execution in Framesync. If it's already been scheduled it won't be fired twice</span>
         <span class="s3">* in a single frame.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">updateValue = () =&gt; value.set(combineValues());</span>
        <span class="s3">/**</span>
         <span class="s3">* Synchronously update the motion value with the latest values during the render.</span>
         <span class="s3">* This ensures that within a React render, the styles applied to the DOM are up-to-date.</span>
         <span class="s3">*/</span>
        <span class="s0">updateValue();</span>
        <span class="s3">/**</span>
         <span class="s3">* Subscribe to all motion values found within the template. Whenever any of them change,</span>
         <span class="s3">* schedule an update.</span>
         <span class="s3">*/</span>
        <span class="s0">useIsomorphicLayoutEffect(() =&gt; {</span>
            <span class="s1">const </span><span class="s0">scheduleUpdate = () =&gt; frame.preRender(updateValue, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">subscriptions = values.map((v) =&gt; v.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, scheduleUpdate));</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">subscriptions.forEach((unsubscribe) =&gt; unsubscribe());</span>
                <span class="s0">cancelFrame(updateValue);</span>
            <span class="s0">};</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useComputed(compute) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Open session of collectMotionValues. Any MotionValue that calls get()</span>
         <span class="s3">* will be saved into this array.</span>
         <span class="s3">*/</span>
        <span class="s0">collectMotionValues.current = [];</span>
        <span class="s0">compute();</span>
        <span class="s1">const </span><span class="s0">value = useCombineMotionValues(collectMotionValues.current, compute);</span>
        <span class="s3">/**</span>
         <span class="s3">* Synchronously close session of collectMotionValues.</span>
         <span class="s3">*/</span>
        <span class="s0">collectMotionValues.current = undefined;</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useTransform(input, inputRangeOrTransformer, outputRange, options) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">input === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">useComputed(input);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">transformer = </span><span class="s1">typeof </span><span class="s0">inputRangeOrTransformer === </span><span class="s2">&quot;function&quot;</span>
            <span class="s0">? inputRangeOrTransformer</span>
            <span class="s0">: transform(inputRangeOrTransformer, outputRange, options);</span>
        <span class="s1">return </span><span class="s0">Array.isArray(input)</span>
            <span class="s0">? useListTransform(input, transformer)</span>
            <span class="s0">: useListTransform([input], ([latest]) =&gt; transformer(latest));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">useListTransform(values, transformer) {</span>
        <span class="s1">const </span><span class="s0">latest = useConstant(() =&gt; []);</span>
        <span class="s1">return </span><span class="s0">useCombineMotionValues(values, () =&gt; {</span>
            <span class="s0">latest.length = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">numValues = values.length;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numValues; i++) {</span>
                <span class="s0">latest[i] = values[i].get();</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">transformer(latest);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useDefaultMotionValue(value, defaultValue = </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">isMotionValue(value) ? value : useMotionValue(defaultValue);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">ReorderItemComponent({ children, style = {}, value, as = </span><span class="s2">&quot;li&quot;</span><span class="s0">, onDrag, layout = </span><span class="s1">true</span><span class="s0">, ...props }, externalRef) {</span>
        <span class="s1">const </span><span class="s0">Component = useConstant(() =&gt; motion[as]);</span>
        <span class="s1">const </span><span class="s0">context = React$1.useContext(ReorderContext);</span>
        <span class="s1">const </span><span class="s0">point = {</span>
            <span class="s0">x: useDefaultMotionValue(style.x),</span>
            <span class="s0">y: useDefaultMotionValue(style.y),</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">zIndex = useTransform([point.x, point.y], ([latestX, latestY]) =&gt; latestX || latestY ? </span><span class="s5">1 </span><span class="s0">: </span><span class="s2">&quot;unset&quot;</span><span class="s0">);</span>
        <span class="s0">exports.invariant(Boolean(context), </span><span class="s2">&quot;Reorder.Item must be a child of Reorder.Group&quot;</span><span class="s0">, </span><span class="s2">&quot;reorder-item-child&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">{ axis, registerItem, updateOrder } = context;</span>
        <span class="s1">return </span><span class="s0">(jsx(Component, { drag: axis, ...props, dragSnapToOrigin: </span><span class="s1">true</span><span class="s0">, style: { ...style, x: point.x, y: point.y, zIndex }, layout: layout, onDrag: (event, gesturePoint) =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ velocity } = gesturePoint;</span>
                <span class="s0">velocity[axis] &amp;&amp;</span>
                    <span class="s0">updateOrder(value, point[axis].get(), velocity[axis]);</span>
                <span class="s0">onDrag &amp;&amp; onDrag(event, gesturePoint);</span>
            <span class="s0">}, onLayoutMeasure: (measured) =&gt; registerItem(value, measured), ref: externalRef, ignoreStrict: </span><span class="s1">true</span><span class="s0">, children: children }));</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">ReorderItem = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">React$1.forwardRef(ReorderItemComponent);</span>

    <span class="s1">var </span><span class="s0">namespace = </span><span class="s3">/*#__PURE__*/</span><span class="s0">Object.freeze({</span>
        <span class="s0">__proto__: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">Group: ReorderGroup,</span>
        <span class="s0">Item: ReorderItem</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">isDOMKeyframes(keyframes) {</span>
        <span class="s1">return typeof </span><span class="s0">keyframes === </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp; !Array.isArray(keyframes);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">resolveSubjects(subject, keyframes, scope, selectorCache) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">subject === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; isDOMKeyframes(keyframes)) {</span>
            <span class="s1">return </span><span class="s0">resolveElements(subject, scope, selectorCache);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(subject </span><span class="s1">instanceof </span><span class="s0">NodeList) {</span>
            <span class="s1">return </span><span class="s0">Array.from(subject);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(Array.isArray(subject)) {</span>
            <span class="s1">return </span><span class="s0">subject;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">[subject];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">calculateRepeatDuration(duration, repeat, _repeatDelay) {</span>
        <span class="s1">return </span><span class="s0">duration * (repeat + </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Given a absolute or relative time definition and current/prev time state of the sequence,</span>
     <span class="s3">* calculate an absolute time for the next keyframes.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">calcNextTime(current, next, prev, labels) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">next === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">next;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(next.startsWith(</span><span class="s2">&quot;-&quot;</span><span class="s0">) || next.startsWith(</span><span class="s2">&quot;+&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">Math.max(</span><span class="s5">0</span><span class="s0">, current + parseFloat(next));</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(next === </span><span class="s2">&quot;&lt;&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">prev;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(next.startsWith(</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">Math.max(</span><span class="s5">0</span><span class="s0">, prev + parseFloat(next.slice(</span><span class="s5">1</span><span class="s0">)));</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">labels.get(next) ?? current;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">eraseKeyframes(sequence, startTime, endTime) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; sequence.length; i++) {</span>
            <span class="s1">const </span><span class="s0">keyframe = sequence[i];</span>
            <span class="s1">if </span><span class="s0">(keyframe.at &gt; startTime &amp;&amp; keyframe.at &lt; endTime) {</span>
                <span class="s0">removeItem(sequence, keyframe);</span>
                <span class="s3">// If we remove this item we have to push the pointer back one</span>
                <span class="s0">i--;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Erase every existing value between currentTime and targetTime,</span>
         <span class="s3">* this will essentially splice this timeline into any currently</span>
         <span class="s3">* defined ones.</span>
         <span class="s3">*/</span>
        <span class="s0">eraseKeyframes(sequence, startTime, endTime);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; keyframes.length; i++) {</span>
            <span class="s0">sequence.push({</span>
                <span class="s0">value: keyframes[i],</span>
                <span class="s0">at: mixNumber$1(startTime, endTime, offset[i]),</span>
                <span class="s0">easing: getEasingForSegment(easing, i),</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Take an array of times that represent repeated keyframes. For instance</span>
     <span class="s3">* if we have original times of [0, 0.5, 1] then our repeated times will</span>
     <span class="s3">* be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back</span>
     <span class="s3">* down to a 0-1 scale.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">normalizeTimes(times, repeat) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; times.length; i++) {</span>
            <span class="s0">times[i] = times[i] / (repeat + </span><span class="s5">1</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">compareByTime(a, b) {</span>
        <span class="s1">if </span><span class="s0">(a.at === b.at) {</span>
            <span class="s1">if </span><span class="s0">(a.value === </span><span class="s1">null</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(b.value === </span><span class="s1">null</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">-</span><span class="s5">1</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">a.at - b.at;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">defaultSegmentEasing = </span><span class="s2">&quot;easeInOut&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">MAX_REPEAT = </span><span class="s5">20</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {</span>
        <span class="s1">const </span><span class="s0">defaultDuration = defaultTransition.duration || </span><span class="s5">0.3</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">animationDefinitions = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s1">const </span><span class="s0">sequences = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s1">const </span><span class="s0">elementCache = {};</span>
        <span class="s1">const </span><span class="s0">timeLabels = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s1">let </span><span class="s0">prevTime = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">currentTime = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">totalDuration = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Build the timeline by mapping over the sequence array and converting</span>
         <span class="s3">* the definitions into keyframes and offsets with absolute time values.</span>
         <span class="s3">* These will later get converted into relative offsets in a second pass.</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; sequence.length; i++) {</span>
            <span class="s1">const </span><span class="s0">segment = sequence[i];</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is a timeline label, mark it and skip the rest of this iteration.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">segment === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                <span class="s0">timeLabels.set(segment, currentTime);</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(!Array.isArray(segment)) {</span>
                <span class="s0">timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">[subject, keyframes, transition = {}] = segment;</span>
            <span class="s3">/**</span>
             <span class="s3">* If a relative or absolute time value has been specified we need to resolve</span>
             <span class="s3">* it in relation to the currentTime.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(transition.at !== undefined) {</span>
                <span class="s0">currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Keep track of the maximum duration in this definition. This will be</span>
             <span class="s3">* applied to currentTime once the definition has been parsed.</span>
             <span class="s3">*/</span>
            <span class="s1">let </span><span class="s0">maxDuration = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = </span><span class="s5">0</span><span class="s0">, numSubjects = </span><span class="s5">0</span><span class="s0">) =&gt; {</span>
                <span class="s1">const </span><span class="s0">valueKeyframesAsList = keyframesAsList(valueKeyframes);</span>
                <span class="s1">const </span><span class="s0">{ delay = </span><span class="s5">0</span><span class="s0">, times = defaultOffset$1(valueKeyframesAsList), type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">, repeat, repeatType, repeatDelay = </span><span class="s5">0</span><span class="s0">, ...remainingTransition } = valueTransition;</span>
                <span class="s1">let </span><span class="s0">{ ease = defaultTransition.ease || </span><span class="s2">&quot;easeOut&quot;</span><span class="s0">, duration } = valueTransition;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Resolve stagger() if defined.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">calculatedDelay = </span><span class="s1">typeof </span><span class="s0">delay === </span><span class="s2">&quot;function&quot;</span>
                    <span class="s0">? delay(elementIndex, numSubjects)</span>
                    <span class="s0">: delay;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If this animation should and can use a spring, generate a spring easing function.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">numKeyframes = valueKeyframesAsList.length;</span>
                <span class="s1">const </span><span class="s0">createGenerator = isGenerator(type)</span>
                    <span class="s0">? type</span>
                    <span class="s0">: generators?.[type || </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">];</span>
                <span class="s1">if </span><span class="s0">(numKeyframes &lt;= </span><span class="s5">2 </span><span class="s0">&amp;&amp; createGenerator) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* As we're creating an easing function from a spring,</span>
                     <span class="s3">* ideally we want to generate it using the real distance</span>
                     <span class="s3">* between the two keyframes. However this isn't always</span>
                     <span class="s3">* possible - in these situations we use 0-100.</span>
                     <span class="s3">*/</span>
                    <span class="s1">let </span><span class="s0">absoluteDelta = </span><span class="s5">100</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(numKeyframes === </span><span class="s5">2 </span><span class="s0">&amp;&amp;</span>
                        <span class="s0">isNumberKeyframesArray(valueKeyframesAsList)) {</span>
                        <span class="s1">const </span><span class="s0">delta = valueKeyframesAsList[</span><span class="s5">1</span><span class="s0">] - valueKeyframesAsList[</span><span class="s5">0</span><span class="s0">];</span>
                        <span class="s0">absoluteDelta = Math.abs(delta);</span>
                    <span class="s0">}</span>
                    <span class="s1">const </span><span class="s0">springTransition = { ...remainingTransition };</span>
                    <span class="s1">if </span><span class="s0">(duration !== undefined) {</span>
                        <span class="s0">springTransition.duration = secondsToMilliseconds(duration);</span>
                    <span class="s0">}</span>
                    <span class="s1">const </span><span class="s0">springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);</span>
                    <span class="s0">ease = springEasing.ease;</span>
                    <span class="s0">duration = springEasing.duration;</span>
                <span class="s0">}</span>
                <span class="s0">duration ?? (duration = defaultDuration);</span>
                <span class="s1">const </span><span class="s0">startTime = currentTime + calculatedDelay;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If there's only one time offset of 0, fill in a second with length 1</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(times.length === </span><span class="s5">1 </span><span class="s0">&amp;&amp; times[</span><span class="s5">0</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">) {</span>
                    <span class="s0">times[</span><span class="s5">1</span><span class="s0">] = </span><span class="s5">1</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* Fill out if offset if fewer offsets than keyframes</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">remainder = times.length - valueKeyframesAsList.length;</span>
                <span class="s0">remainder &gt; </span><span class="s5">0 </span><span class="s0">&amp;&amp; fillOffset(times, remainder);</span>
                <span class="s3">/**</span>
                 <span class="s3">* If only one value has been set, ie [1], push a null to the start of</span>
                 <span class="s3">* the keyframe array. This will let us mark a keyframe at this point</span>
                 <span class="s3">* that will later be hydrated with the previous value.</span>
                 <span class="s3">*/</span>
                <span class="s0">valueKeyframesAsList.length === </span><span class="s5">1 </span><span class="s0">&amp;&amp;</span>
                    <span class="s0">valueKeyframesAsList.unshift(</span><span class="s1">null</span><span class="s0">);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Handle repeat options</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(repeat) {</span>
                    <span class="s0">exports.invariant(repeat &lt; MAX_REPEAT, </span><span class="s2">&quot;Repeat count too high, must be less than 20&quot;</span><span class="s0">, </span><span class="s2">&quot;repeat-count-high&quot;</span><span class="s0">);</span>
                    <span class="s0">duration = calculateRepeatDuration(duration, repeat);</span>
                    <span class="s1">const </span><span class="s0">originalKeyframes = [...valueKeyframesAsList];</span>
                    <span class="s1">const </span><span class="s0">originalTimes = [...times];</span>
                    <span class="s0">ease = Array.isArray(ease) ? [...ease] : [ease];</span>
                    <span class="s1">const </span><span class="s0">originalEase = [...ease];</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">repeatIndex = </span><span class="s5">0</span><span class="s0">; repeatIndex &lt; repeat; repeatIndex++) {</span>
                        <span class="s0">valueKeyframesAsList.push(...originalKeyframes);</span>
                        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">keyframeIndex = </span><span class="s5">0</span><span class="s0">; keyframeIndex &lt; originalKeyframes.length; keyframeIndex++) {</span>
                            <span class="s0">times.push(originalTimes[keyframeIndex] + (repeatIndex + </span><span class="s5">1</span><span class="s0">));</span>
                            <span class="s0">ease.push(keyframeIndex === </span><span class="s5">0</span>
                                <span class="s0">? </span><span class="s2">&quot;linear&quot;</span>
                                <span class="s0">: getEasingForSegment(originalEase, keyframeIndex - </span><span class="s5">1</span><span class="s0">));</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s0">normalizeTimes(times, repeat);</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">targetTime = startTime + duration;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Add keyframes, mapping offsets to absolute time.</span>
                 <span class="s3">*/</span>
                <span class="s0">addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);</span>
                <span class="s0">maxDuration = Math.max(calculatedDelay + duration, maxDuration);</span>
                <span class="s0">totalDuration = Math.max(targetTime, totalDuration);</span>
            <span class="s0">};</span>
            <span class="s1">if </span><span class="s0">(isMotionValue(subject)) {</span>
                <span class="s1">const </span><span class="s0">subjectSequence = getSubjectSequence(subject, sequences);</span>
                <span class="s0">resolveValueSequence(keyframes, transition, getValueSequence(</span><span class="s2">&quot;default&quot;</span><span class="s0">, subjectSequence));</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">const </span><span class="s0">subjects = resolveSubjects(subject, keyframes, scope, elementCache);</span>
                <span class="s1">const </span><span class="s0">numSubjects = subjects.length;</span>
                <span class="s3">/**</span>
                 <span class="s3">* For every element in this segment, process the defined values.</span>
                 <span class="s3">*/</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">subjectIndex = </span><span class="s5">0</span><span class="s0">; subjectIndex &lt; numSubjects; subjectIndex++) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Cast necessary, but we know these are of this type</span>
                     <span class="s3">*/</span>
                    <span class="s0">keyframes = keyframes;</span>
                    <span class="s0">transition = transition;</span>
                    <span class="s1">const </span><span class="s0">thisSubject = subjects[subjectIndex];</span>
                    <span class="s1">const </span><span class="s0">subjectSequence = getSubjectSequence(thisSubject, sequences);</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">keyframes) {</span>
                        <span class="s0">resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">prevTime = currentTime;</span>
            <span class="s0">currentTime += maxDuration;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* For every element and value combination create a new animation.</span>
         <span class="s3">*/</span>
        <span class="s0">sequences.forEach((valueSequences, element) =&gt; {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">valueSequences) {</span>
                <span class="s1">const </span><span class="s0">valueSequence = valueSequences[key];</span>
                <span class="s3">/**</span>
                 <span class="s3">* Arrange all the keyframes in ascending time order.</span>
                 <span class="s3">*/</span>
                <span class="s0">valueSequence.sort(compareByTime);</span>
                <span class="s1">const </span><span class="s0">keyframes = [];</span>
                <span class="s1">const </span><span class="s0">valueOffset = [];</span>
                <span class="s1">const </span><span class="s0">valueEasing = [];</span>
                <span class="s3">/**</span>
                 <span class="s3">* For each keyframe, translate absolute times into</span>
                 <span class="s3">* relative offsets based on the total duration of the timeline.</span>
                 <span class="s3">*/</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; valueSequence.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">{ at, value, easing } = valueSequence[i];</span>
                    <span class="s0">keyframes.push(value);</span>
                    <span class="s0">valueOffset.push(progress(</span><span class="s5">0</span><span class="s0">, totalDuration, at));</span>
                    <span class="s0">valueEasing.push(easing || </span><span class="s2">&quot;easeOut&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the first keyframe doesn't land on offset: 0</span>
                 <span class="s3">* provide one by duplicating the initial keyframe. This ensures</span>
                 <span class="s3">* it snaps to the first keyframe when the animation starts.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(valueOffset[</span><span class="s5">0</span><span class="s0">] !== </span><span class="s5">0</span><span class="s0">) {</span>
                    <span class="s0">valueOffset.unshift(</span><span class="s5">0</span><span class="s0">);</span>
                    <span class="s0">keyframes.unshift(keyframes[</span><span class="s5">0</span><span class="s0">]);</span>
                    <span class="s0">valueEasing.unshift(defaultSegmentEasing);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the last keyframe doesn't land on offset: 1</span>
                 <span class="s3">* provide one with a null wildcard value. This will ensure it</span>
                 <span class="s3">* stays static until the end of the animation.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(valueOffset[valueOffset.length - </span><span class="s5">1</span><span class="s0">] !== </span><span class="s5">1</span><span class="s0">) {</span>
                    <span class="s0">valueOffset.push(</span><span class="s5">1</span><span class="s0">);</span>
                    <span class="s0">keyframes.push(</span><span class="s1">null</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(!animationDefinitions.has(element)) {</span>
                    <span class="s0">animationDefinitions.set(element, {</span>
                        <span class="s0">keyframes: {},</span>
                        <span class="s0">transition: {},</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">definition = animationDefinitions.get(element);</span>
                <span class="s0">definition.keyframes[key] = keyframes;</span>
                <span class="s0">definition.transition[key] = {</span>
                    <span class="s0">...defaultTransition,</span>
                    <span class="s0">duration: totalDuration,</span>
                    <span class="s0">ease: valueEasing,</span>
                    <span class="s0">times: valueOffset,</span>
                    <span class="s0">...sequenceTransition,</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">animationDefinitions;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getSubjectSequence(subject, sequences) {</span>
        <span class="s0">!sequences.has(subject) &amp;&amp; sequences.set(subject, {});</span>
        <span class="s1">return </span><span class="s0">sequences.get(subject);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getValueSequence(name, sequences) {</span>
        <span class="s1">if </span><span class="s0">(!sequences[name])</span>
            <span class="s0">sequences[name] = [];</span>
        <span class="s1">return </span><span class="s0">sequences[name];</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">keyframesAsList(keyframes) {</span>
        <span class="s1">return </span><span class="s0">Array.isArray(keyframes) ? keyframes : [keyframes];</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getValueTransition(transition, key) {</span>
        <span class="s1">return </span><span class="s0">transition &amp;&amp; transition[key]</span>
            <span class="s0">? {</span>
                <span class="s0">...transition,</span>
                <span class="s0">...transition[key],</span>
            <span class="s0">}</span>
            <span class="s0">: { ...transition };</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">isNumber = (keyframe) =&gt; </span><span class="s1">typeof </span><span class="s0">keyframe === </span><span class="s2">&quot;number&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">isNumberKeyframesArray = (keyframes) =&gt; keyframes.every(isNumber);</span>

    <span class="s1">function </span><span class="s0">isObjectKey(key, object) {</span>
        <span class="s1">return </span><span class="s0">key </span><span class="s1">in </span><span class="s0">object;</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">ObjectVisualElement </span><span class="s1">extends </span><span class="s0">VisualElement {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.type = </span><span class="s2">&quot;object&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">readValueFromInstance(instance, key) {</span>
            <span class="s1">if </span><span class="s0">(isObjectKey(key, instance)) {</span>
                <span class="s1">const </span><span class="s0">value = instance[key];</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;string&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s0">value;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">undefined;</span>
        <span class="s0">}</span>
        <span class="s0">getBaseTargetFromProps() {</span>
            <span class="s1">return </span><span class="s0">undefined;</span>
        <span class="s0">}</span>
        <span class="s0">removeValueFromRenderState(key, renderState) {</span>
            <span class="s1">delete </span><span class="s0">renderState.output[key];</span>
        <span class="s0">}</span>
        <span class="s0">measureInstanceViewportBox() {</span>
            <span class="s1">return </span><span class="s0">createBox();</span>
        <span class="s0">}</span>
        <span class="s0">build(renderState, latestValues) {</span>
            <span class="s0">Object.assign(renderState.output, latestValues);</span>
        <span class="s0">}</span>
        <span class="s0">renderInstance(instance, { output }) {</span>
            <span class="s0">Object.assign(instance, output);</span>
        <span class="s0">}</span>
        <span class="s0">sortInstanceNodePosition() {</span>
            <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createDOMVisualElement(element) {</span>
        <span class="s1">const </span><span class="s0">options = {</span>
            <span class="s0">presenceContext: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">props: {},</span>
            <span class="s0">visualState: {</span>
                <span class="s0">renderState: {</span>
                    <span class="s0">transform: {},</span>
                    <span class="s0">transformOrigin: {},</span>
                    <span class="s0">style: {},</span>
                    <span class="s0">vars: {},</span>
                    <span class="s0">attrs: {},</span>
                <span class="s0">},</span>
                <span class="s0">latestValues: {},</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">node = isSVGElement(element) &amp;&amp; !isSVGSVGElement(element)</span>
            <span class="s0">? </span><span class="s1">new </span><span class="s0">SVGVisualElement(options)</span>
            <span class="s0">: </span><span class="s1">new </span><span class="s0">HTMLVisualElement(options);</span>
        <span class="s0">node.mount(element);</span>
        <span class="s0">visualElementStore.set(element, node);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createObjectVisualElement(subject) {</span>
        <span class="s1">const </span><span class="s0">options = {</span>
            <span class="s0">presenceContext: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">props: {},</span>
            <span class="s0">visualState: {</span>
                <span class="s0">renderState: {</span>
                    <span class="s0">output: {},</span>
                <span class="s0">},</span>
                <span class="s0">latestValues: {},</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">node = </span><span class="s1">new </span><span class="s0">ObjectVisualElement(options);</span>
        <span class="s0">node.mount(subject);</span>
        <span class="s0">visualElementStore.set(subject, node);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isSingleValue(subject, keyframes) {</span>
        <span class="s1">return </span><span class="s0">(isMotionValue(subject) ||</span>
            <span class="s1">typeof </span><span class="s0">subject === </span><span class="s2">&quot;number&quot; </span><span class="s0">||</span>
            <span class="s0">(</span><span class="s1">typeof </span><span class="s0">subject === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; !isDOMKeyframes(keyframes)));</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Implementation</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">animateSubject(subject, keyframes, options, scope) {</span>
        <span class="s1">const </span><span class="s0">animations = [];</span>
        <span class="s1">if </span><span class="s0">(isSingleValue(subject, keyframes)) {</span>
            <span class="s0">animations.push(animateSingleValue(subject, isDOMKeyframes(keyframes)</span>
                <span class="s0">? keyframes.default || keyframes</span>
                <span class="s0">: keyframes, options ? options.default || options : options));</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">subjects = resolveSubjects(subject, keyframes, scope);</span>
            <span class="s1">const </span><span class="s0">numSubjects = subjects.length;</span>
            <span class="s0">exports.invariant(Boolean(numSubjects), </span><span class="s2">&quot;No valid elements provided.&quot;</span><span class="s0">, </span><span class="s2">&quot;no-valid-elements&quot;</span><span class="s0">);</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numSubjects; i++) {</span>
                <span class="s1">const </span><span class="s0">thisSubject = subjects[i];</span>
                <span class="s0">exports.invariant(thisSubject !== </span><span class="s1">null</span><span class="s0">, </span><span class="s2">&quot;You're trying to perform an animation on null. Ensure that selectors are correctly finding elements and refs are correctly hydrated.&quot;</span><span class="s0">, </span><span class="s2">&quot;animate-null&quot;</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">createVisualElement = thisSubject </span><span class="s1">instanceof </span><span class="s0">Element</span>
                    <span class="s0">? createDOMVisualElement</span>
                    <span class="s0">: createObjectVisualElement;</span>
                <span class="s1">if </span><span class="s0">(!visualElementStore.has(thisSubject)) {</span>
                    <span class="s0">createVisualElement(thisSubject);</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">visualElement = visualElementStore.get(thisSubject);</span>
                <span class="s1">const </span><span class="s0">transition = { ...options };</span>
                <span class="s3">/**</span>
                 <span class="s3">* Resolve stagger function if provided.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;delay&quot; </span><span class="s1">in </span><span class="s0">transition &amp;&amp;</span>
                    <span class="s1">typeof </span><span class="s0">transition.delay === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                    <span class="s0">transition.delay = transition.delay(i, numSubjects);</span>
                <span class="s0">}</span>
                <span class="s0">animations.push(...animateTarget(visualElement, { ...keyframes, transition }, {}));</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">animations;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">animateSequence(sequence, options, scope) {</span>
        <span class="s1">const </span><span class="s0">animations = [];</span>
        <span class="s1">const </span><span class="s0">animationDefinitions = createAnimationsFromSequence(sequence, options, scope, { spring });</span>
        <span class="s0">animationDefinitions.forEach(({ keyframes, transition }, subject) =&gt; {</span>
            <span class="s0">animations.push(...animateSubject(subject, keyframes, transition));</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">animations;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isSequence(value) {</span>
        <span class="s1">return </span><span class="s0">Array.isArray(value) &amp;&amp; value.some(Array.isArray);</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Creates an animation function that is optionally scoped</span>
     <span class="s3">* to a specific element.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">createScopedAnimate(scope) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Implementation</span>
         <span class="s3">*/</span>
        <span class="s1">function </span><span class="s0">scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {</span>
            <span class="s1">let </span><span class="s0">animations = [];</span>
            <span class="s1">let </span><span class="s0">animationOnComplete;</span>
            <span class="s1">if </span><span class="s0">(isSequence(subjectOrSequence)) {</span>
                <span class="s0">animations = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// Extract top-level onComplete so it doesn't get applied per-value</span>
                <span class="s1">const </span><span class="s0">{ onComplete, ...rest } = options || {};</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">onComplete === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                    <span class="s0">animationOnComplete = onComplete;</span>
                <span class="s0">}</span>
                <span class="s0">animations = animateSubject(subjectOrSequence, optionsOrKeyframes, rest, scope);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">animation = </span><span class="s1">new </span><span class="s0">GroupAnimationWithThen(animations);</span>
            <span class="s1">if </span><span class="s0">(animationOnComplete) {</span>
                <span class="s0">animation.finished.then(animationOnComplete);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(scope) {</span>
                <span class="s0">scope.animations.push(animation);</span>
                <span class="s0">animation.finished.then(() =&gt; {</span>
                    <span class="s0">removeItem(scope.animations, animation);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">animation;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">scopedAnimate;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">animate = createScopedAnimate();</span>

    <span class="s1">function </span><span class="s0">animateElements(elementOrSelector, keyframes, options, scope) {</span>
        <span class="s1">const </span><span class="s0">elements = resolveElements(elementOrSelector, scope);</span>
        <span class="s1">const </span><span class="s0">numElements = elements.length;</span>
        <span class="s0">exports.invariant(Boolean(numElements), </span><span class="s2">&quot;No valid elements provided.&quot;</span><span class="s0">, </span><span class="s2">&quot;no-valid-elements&quot;</span><span class="s0">);</span>
        <span class="s3">/**</span>
         <span class="s3">* WAAPI doesn't support interrupting animations.</span>
         <span class="s3">*</span>
         <span class="s3">* Therefore, starting animations requires a three-step process:</span>
         <span class="s3">* 1. Stop existing animations (write styles to DOM)</span>
         <span class="s3">* 2. Resolve keyframes (read styles from DOM)</span>
         <span class="s3">* 3. Create new animations (write styles to DOM)</span>
         <span class="s3">*</span>
         <span class="s3">* The hybrid `animate()` function uses AsyncAnimation to resolve</span>
         <span class="s3">* keyframes before creating new animations, which removes style</span>
         <span class="s3">* thrashing. Here, we have much stricter filesize constraints.</span>
         <span class="s3">* Therefore we do this in a synchronous way that ensures that</span>
         <span class="s3">* at least within `animate()` calls there is no style thrashing.</span>
         <span class="s3">*</span>
         <span class="s3">* In the motion-native-animate-mini-interrupt benchmark this</span>
         <span class="s3">* was 80% faster than a single loop.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">animationDefinitions = [];</span>
        <span class="s3">/**</span>
         <span class="s3">* Step 1: Build options and stop existing animations (write)</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numElements; i++) {</span>
            <span class="s1">const </span><span class="s0">element = elements[i];</span>
            <span class="s1">const </span><span class="s0">elementTransition = { ...options };</span>
            <span class="s3">/**</span>
             <span class="s3">* Resolve stagger function if provided.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">elementTransition.delay === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                <span class="s0">elementTransition.delay = elementTransition.delay(i, numElements);</span>
            <span class="s0">}</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">valueName </span><span class="s1">in </span><span class="s0">keyframes) {</span>
                <span class="s1">let </span><span class="s0">valueKeyframes = keyframes[valueName];</span>
                <span class="s1">if </span><span class="s0">(!Array.isArray(valueKeyframes)) {</span>
                    <span class="s0">valueKeyframes = [valueKeyframes];</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">valueOptions = {</span>
                    <span class="s0">...getValueTransition$1(elementTransition, valueName),</span>
                <span class="s0">};</span>
                <span class="s0">valueOptions.duration &amp;&amp; (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));</span>
                <span class="s0">valueOptions.delay &amp;&amp; (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));</span>
                <span class="s3">/**</span>
                 <span class="s3">* If there's an existing animation playing on this element then stop it</span>
                 <span class="s3">* before creating a new one.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">map = getAnimationMap(element);</span>
                <span class="s1">const </span><span class="s0">key = animationMapKey(valueName, valueOptions.pseudoElement || </span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">currentAnimation = map.get(key);</span>
                <span class="s0">currentAnimation &amp;&amp; currentAnimation.stop();</span>
                <span class="s0">animationDefinitions.push({</span>
                    <span class="s0">map,</span>
                    <span class="s0">key,</span>
                    <span class="s0">unresolvedKeyframes: valueKeyframes,</span>
                    <span class="s0">options: {</span>
                        <span class="s0">...valueOptions,</span>
                        <span class="s0">element,</span>
                        <span class="s0">name: valueName,</span>
                        <span class="s0">allowFlatten: !elementTransition.type &amp;&amp; !elementTransition.ease,</span>
                    <span class="s0">},</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Step 2: Resolve keyframes (read)</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; animationDefinitions.length; i++) {</span>
            <span class="s1">const </span><span class="s0">{ unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];</span>
            <span class="s1">const </span><span class="s0">{ element, name, pseudoElement } = animationOptions;</span>
            <span class="s1">if </span><span class="s0">(!pseudoElement &amp;&amp; unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">] === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">unresolvedKeyframes[</span><span class="s5">0</span><span class="s0">] = getComputedStyle$2(element, name);</span>
            <span class="s0">}</span>
            <span class="s0">fillWildcards(unresolvedKeyframes);</span>
            <span class="s0">applyPxDefaults(unresolvedKeyframes, name);</span>
            <span class="s3">/**</span>
             <span class="s3">* If we only have one keyframe, explicitly read the initial keyframe</span>
             <span class="s3">* from the computed style. This is to ensure consistency with WAAPI behaviour</span>
             <span class="s3">* for restarting animations, for instance .play() after finish, when it</span>
             <span class="s3">* has one vs two keyframes.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(!pseudoElement &amp;&amp; unresolvedKeyframes.length &lt; </span><span class="s5">2</span><span class="s0">) {</span>
                <span class="s0">unresolvedKeyframes.unshift(getComputedStyle$2(element, name));</span>
            <span class="s0">}</span>
            <span class="s0">animationOptions.keyframes = unresolvedKeyframes;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Step 3: Create new animations (write)</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">animations = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; animationDefinitions.length; i++) {</span>
            <span class="s1">const </span><span class="s0">{ map, key, options: animationOptions } = animationDefinitions[i];</span>
            <span class="s1">const </span><span class="s0">animation = </span><span class="s1">new </span><span class="s0">NativeAnimation(animationOptions);</span>
            <span class="s0">map.set(key, animation);</span>
            <span class="s0">animation.finished.finally(() =&gt; map.delete(key));</span>
            <span class="s0">animations.push(animation);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">animations;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">createScopedWaapiAnimate = (scope) =&gt; {</span>
        <span class="s1">function </span><span class="s0">scopedAnimate(elementOrSelector, keyframes, options) {</span>
            <span class="s1">return new </span><span class="s0">GroupAnimationWithThen(animateElements(elementOrSelector, keyframes, options, scope));</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">scopedAnimate;</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">animateMini = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createScopedWaapiAnimate();</span>

    <span class="s3">/**</span>
     <span class="s3">* A time in milliseconds, beyond which we consider the scroll velocity to be 0.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">maxElapsed = </span><span class="s5">50</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">createAxisInfo = () =&gt; ({</span>
        <span class="s0">current: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">offset: [],</span>
        <span class="s0">progress: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">scrollLength: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">targetOffset: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">targetLength: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">containerLength: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">velocity: </span><span class="s5">0</span><span class="s0">,</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">createScrollInfo = () =&gt; ({</span>
        <span class="s0">time: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">x: createAxisInfo(),</span>
        <span class="s0">y: createAxisInfo(),</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">keys = {</span>
        <span class="s0">x: {</span>
            <span class="s0">length: </span><span class="s2">&quot;Width&quot;</span><span class="s0">,</span>
            <span class="s0">position: </span><span class="s2">&quot;Left&quot;</span><span class="s0">,</span>
        <span class="s0">},</span>
        <span class="s0">y: {</span>
            <span class="s0">length: </span><span class="s2">&quot;Height&quot;</span><span class="s0">,</span>
            <span class="s0">position: </span><span class="s2">&quot;Top&quot;</span><span class="s0">,</span>
        <span class="s0">},</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">updateAxisInfo(element, axisName, info, time) {</span>
        <span class="s1">const </span><span class="s0">axis = info[axisName];</span>
        <span class="s1">const </span><span class="s0">{ length, position } = keys[axisName];</span>
        <span class="s1">const </span><span class="s0">prev = axis.current;</span>
        <span class="s1">const </span><span class="s0">prevTime = info.time;</span>
        <span class="s0">axis.current = element[</span><span class="s2">`scroll</span><span class="s0">${position}</span><span class="s2">`</span><span class="s0">];</span>
        <span class="s0">axis.scrollLength = element[</span><span class="s2">`scroll</span><span class="s0">${length}</span><span class="s2">`</span><span class="s0">] - element[</span><span class="s2">`client</span><span class="s0">${length}</span><span class="s2">`</span><span class="s0">];</span>
        <span class="s0">axis.offset.length = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">axis.offset[</span><span class="s5">0</span><span class="s0">] = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">axis.offset[</span><span class="s5">1</span><span class="s0">] = axis.scrollLength;</span>
        <span class="s0">axis.progress = progress(</span><span class="s5">0</span><span class="s0">, axis.scrollLength, axis.current);</span>
        <span class="s1">const </span><span class="s0">elapsed = time - prevTime;</span>
        <span class="s0">axis.velocity =</span>
            <span class="s0">elapsed &gt; maxElapsed</span>
                <span class="s0">? </span><span class="s5">0</span>
                <span class="s0">: velocityPerSecond(axis.current - prev, elapsed);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">updateScrollInfo(element, info, time) {</span>
        <span class="s0">updateAxisInfo(element, </span><span class="s2">&quot;x&quot;</span><span class="s0">, info, time);</span>
        <span class="s0">updateAxisInfo(element, </span><span class="s2">&quot;y&quot;</span><span class="s0">, info, time);</span>
        <span class="s0">info.time = time;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">calcInset(element, container) {</span>
        <span class="s1">const </span><span class="s0">inset = { x: </span><span class="s5">0</span><span class="s0">, y: </span><span class="s5">0 </span><span class="s0">};</span>
        <span class="s1">let </span><span class="s0">current = element;</span>
        <span class="s1">while </span><span class="s0">(current &amp;&amp; current !== container) {</span>
            <span class="s1">if </span><span class="s0">(isHTMLElement(current)) {</span>
                <span class="s0">inset.x += current.offsetLeft;</span>
                <span class="s0">inset.y += current.offsetTop;</span>
                <span class="s0">current = current.offsetParent;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(current.tagName === </span><span class="s2">&quot;svg&quot;</span><span class="s0">) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* This isn't an ideal approach to measuring the offset of &lt;svg /&gt; tags.</span>
                 <span class="s3">* It would be preferable, given they behave like HTMLElements in most ways</span>
                 <span class="s3">* to use offsetLeft/Top. But these don't exist on &lt;svg /&gt;. Likewise we</span>
                 <span class="s3">* can't use .getBBox() like most SVG elements as these provide the offset</span>
                 <span class="s3">* relative to the SVG itself, which for &lt;svg /&gt; is usually 0x0.</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">svgBoundingBox = current.getBoundingClientRect();</span>
                <span class="s0">current = current.parentElement;</span>
                <span class="s1">const </span><span class="s0">parentBoundingBox = current.getBoundingClientRect();</span>
                <span class="s0">inset.x += svgBoundingBox.left - parentBoundingBox.left;</span>
                <span class="s0">inset.y += svgBoundingBox.top - parentBoundingBox.top;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(current </span><span class="s1">instanceof </span><span class="s0">SVGGraphicsElement) {</span>
                <span class="s1">const </span><span class="s0">{ x, y } = current.getBBox();</span>
                <span class="s0">inset.x += x;</span>
                <span class="s0">inset.y += y;</span>
                <span class="s1">let </span><span class="s0">svg = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">let </span><span class="s0">parent = current.parentNode;</span>
                <span class="s1">while </span><span class="s0">(!svg) {</span>
                    <span class="s1">if </span><span class="s0">(parent.tagName === </span><span class="s2">&quot;svg&quot;</span><span class="s0">) {</span>
                        <span class="s0">svg = parent;</span>
                    <span class="s0">}</span>
                    <span class="s0">parent = current.parentNode;</span>
                <span class="s0">}</span>
                <span class="s0">current = svg;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">inset;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">namedEdges = {</span>
        <span class="s0">start: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">center: </span><span class="s5">0.5</span><span class="s0">,</span>
        <span class="s0">end: </span><span class="s5">1</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">resolveEdge(edge, length, inset = </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s1">let </span><span class="s0">delta = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* If we have this edge defined as a preset, replace the definition</span>
         <span class="s3">* with the numerical value.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(edge </span><span class="s1">in </span><span class="s0">namedEdges) {</span>
            <span class="s0">edge = namedEdges[edge];</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Handle unit values</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">edge === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">asNumber = parseFloat(edge);</span>
            <span class="s1">if </span><span class="s0">(edge.endsWith(</span><span class="s2">&quot;px&quot;</span><span class="s0">)) {</span>
                <span class="s0">delta = asNumber;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(edge.endsWith(</span><span class="s2">&quot;%&quot;</span><span class="s0">)) {</span>
                <span class="s0">edge = asNumber / </span><span class="s5">100</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(edge.endsWith(</span><span class="s2">&quot;vw&quot;</span><span class="s0">)) {</span>
                <span class="s0">delta = (asNumber / </span><span class="s5">100</span><span class="s0">) * document.documentElement.clientWidth;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(edge.endsWith(</span><span class="s2">&quot;vh&quot;</span><span class="s0">)) {</span>
                <span class="s0">delta = (asNumber / </span><span class="s5">100</span><span class="s0">) * document.documentElement.clientHeight;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">edge = asNumber;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If the edge is defined as a number, handle as a progress value.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">edge === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s0">delta = length * edge;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">inset + delta;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">defaultOffset = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">];</span>
    <span class="s1">function </span><span class="s0">resolveOffset(offset, containerLength, targetLength, targetInset) {</span>
        <span class="s1">let </span><span class="s0">offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;</span>
        <span class="s1">let </span><span class="s0">targetPoint = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">containerPoint = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">offset === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're provided offset: [0, 0.5, 1] then each number x should become</span>
             <span class="s3">* [x, x], so we default to the behaviour of mapping 0 =&gt; 0 of both target</span>
             <span class="s3">* and container etc.</span>
             <span class="s3">*/</span>
            <span class="s0">offsetDefinition = [offset, offset];</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">offset === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s0">offset = offset.trim();</span>
            <span class="s1">if </span><span class="s0">(offset.includes(</span><span class="s2">&quot; &quot;</span><span class="s0">)) {</span>
                <span class="s0">offsetDefinition = offset.split(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're provided a definition like &quot;100px&quot; then we want to apply</span>
                 <span class="s3">* that only to the top of the target point, leaving the container at 0.</span>
                 <span class="s3">* Whereas a named offset like &quot;end&quot; should be applied to both.</span>
                 <span class="s3">*/</span>
                <span class="s0">offsetDefinition = [offset, namedEdges[offset] ? offset : </span><span class="s2">`0`</span><span class="s0">];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">targetPoint = resolveEdge(offsetDefinition[</span><span class="s5">0</span><span class="s0">], targetLength, targetInset);</span>
        <span class="s0">containerPoint = resolveEdge(offsetDefinition[</span><span class="s5">1</span><span class="s0">], containerLength);</span>
        <span class="s1">return </span><span class="s0">targetPoint - containerPoint;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">ScrollOffset = {</span>
        <span class="s0">Enter: [</span>
            <span class="s0">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">],</span>
            <span class="s0">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">],</span>
        <span class="s0">],</span>
        <span class="s0">Exit: [</span>
            <span class="s0">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">],</span>
            <span class="s0">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">],</span>
        <span class="s0">],</span>
        <span class="s0">Any: [</span>
            <span class="s0">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">],</span>
            <span class="s0">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">],</span>
        <span class="s0">],</span>
        <span class="s0">All: [</span>
            <span class="s0">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">],</span>
            <span class="s0">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">],</span>
        <span class="s0">],</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">point = { x: </span><span class="s5">0</span><span class="s0">, y: </span><span class="s5">0 </span><span class="s0">};</span>
    <span class="s1">function </span><span class="s0">getTargetSize(target) {</span>
        <span class="s1">return </span><span class="s2">&quot;getBBox&quot; </span><span class="s1">in </span><span class="s0">target &amp;&amp; target.tagName !== </span><span class="s2">&quot;svg&quot;</span>
            <span class="s0">? target.getBBox()</span>
            <span class="s0">: { width: target.clientWidth, height: target.clientHeight };</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resolveOffsets(container, info, options) {</span>
        <span class="s1">const </span><span class="s0">{ offset: offsetDefinition = ScrollOffset.All } = options;</span>
        <span class="s1">const </span><span class="s0">{ target = container, axis = </span><span class="s2">&quot;y&quot; </span><span class="s0">} = options;</span>
        <span class="s1">const </span><span class="s0">lengthLabel = axis === </span><span class="s2">&quot;y&quot; </span><span class="s0">? </span><span class="s2">&quot;height&quot; </span><span class="s0">: </span><span class="s2">&quot;width&quot;</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">inset = target !== container ? calcInset(target, container) : point;</span>
        <span class="s3">/**</span>
         <span class="s3">* Measure the target and container. If they're the same thing then we</span>
         <span class="s3">* use the container's scrollWidth/Height as the target, from there</span>
         <span class="s3">* all other calculations can remain the same.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">targetSize = target === container</span>
            <span class="s0">? { width: container.scrollWidth, height: container.scrollHeight }</span>
            <span class="s0">: getTargetSize(target);</span>
        <span class="s1">const </span><span class="s0">containerSize = {</span>
            <span class="s0">width: container.clientWidth,</span>
            <span class="s0">height: container.clientHeight,</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* Reset the length of the resolved offset array rather than creating a new one.</span>
         <span class="s3">* TODO: More reusable data structures for targetSize/containerSize would also be good.</span>
         <span class="s3">*/</span>
        <span class="s0">info[axis].offset.length = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Populate the offset array by resolving the user's offset definition into</span>
         <span class="s3">* a list of pixel scroll offets.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">hasChanged = !info[axis].interpolate;</span>
        <span class="s1">const </span><span class="s0">numOffsets = offsetDefinition.length;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numOffsets; i++) {</span>
            <span class="s1">const </span><span class="s0">offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);</span>
            <span class="s1">if </span><span class="s0">(!hasChanged &amp;&amp; offset !== info[axis].interpolatorOffsets[i]) {</span>
                <span class="s0">hasChanged = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">info[axis].offset[i] = offset;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If the pixel scroll offsets have changed, create a new interpolator function</span>
         <span class="s3">* to map scroll value into a progress.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(hasChanged) {</span>
            <span class="s0">info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition), { clamp: </span><span class="s1">false </span><span class="s0">});</span>
            <span class="s0">info[axis].interpolatorOffsets = [...info[axis].offset];</span>
        <span class="s0">}</span>
        <span class="s0">info[axis].progress = clamp(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, info[axis].interpolate(info[axis].current));</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">measure(container, target = container, info) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Find inset of target within scrollable container</span>
         <span class="s3">*/</span>
        <span class="s0">info.x.targetOffset = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">info.y.targetOffset = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(target !== container) {</span>
            <span class="s1">let </span><span class="s0">node = target;</span>
            <span class="s1">while </span><span class="s0">(node &amp;&amp; node !== container) {</span>
                <span class="s0">info.x.targetOffset += node.offsetLeft;</span>
                <span class="s0">info.y.targetOffset += node.offsetTop;</span>
                <span class="s0">node = node.offsetParent;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">info.x.targetLength =</span>
            <span class="s0">target === container ? target.scrollWidth : target.clientWidth;</span>
        <span class="s0">info.y.targetLength =</span>
            <span class="s0">target === container ? target.scrollHeight : target.clientHeight;</span>
        <span class="s0">info.x.containerLength = container.clientWidth;</span>
        <span class="s0">info.y.containerLength = container.clientHeight;</span>
        <span class="s3">/**</span>
         <span class="s3">* In development mode ensure scroll containers aren't position: static as this makes</span>
         <span class="s3">* it difficult to measure their relative positions.</span>
         <span class="s3">*/</span>
        <span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(container &amp;&amp; target &amp;&amp; target !== container) {</span>
                <span class="s0">warnOnce(getComputedStyle(container).position !== </span><span class="s2">&quot;static&quot;</span><span class="s0">, </span><span class="s2">&quot;Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createOnScrollHandler(element, onScroll, info, options = {}) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">measure: (time) =&gt; {</span>
                <span class="s0">measure(element, options.target, info);</span>
                <span class="s0">updateScrollInfo(element, info, time);</span>
                <span class="s1">if </span><span class="s0">(options.offset || options.target) {</span>
                    <span class="s0">resolveOffsets(element, info, options);</span>
                <span class="s0">}</span>
            <span class="s0">},</span>
            <span class="s0">notify: () =&gt; onScroll(info),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">scrollListeners = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">const </span><span class="s0">resizeListeners = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">const </span><span class="s0">onScrollHandlers = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">const </span><span class="s0">getEventTarget = (element) =&gt; element === document.scrollingElement ? window : element;</span>
    <span class="s1">function </span><span class="s0">scrollInfo(onScroll, { container = document.scrollingElement, ...options } = {}) {</span>
        <span class="s1">if </span><span class="s0">(!container)</span>
            <span class="s1">return </span><span class="s0">noop;</span>
        <span class="s1">let </span><span class="s0">containerHandlers = onScrollHandlers.get(container);</span>
        <span class="s3">/**</span>
         <span class="s3">* Get the onScroll handlers for this container.</span>
         <span class="s3">* If one isn't found, create a new one.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!containerHandlers) {</span>
            <span class="s0">containerHandlers = </span><span class="s1">new </span><span class="s0">Set();</span>
            <span class="s0">onScrollHandlers.set(container, containerHandlers);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Create a new onScroll handler for the provided callback.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">info = createScrollInfo();</span>
        <span class="s1">const </span><span class="s0">containerHandler = createOnScrollHandler(container, onScroll, info, options);</span>
        <span class="s0">containerHandlers.add(containerHandler);</span>
        <span class="s3">/**</span>
         <span class="s3">* Check if there's a scroll event listener for this container.</span>
         <span class="s3">* If not, create one.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!scrollListeners.has(container)) {</span>
            <span class="s1">const </span><span class="s0">measureAll = () =&gt; {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">handler of containerHandlers) {</span>
                    <span class="s0">handler.measure(frameData.timestamp);</span>
                <span class="s0">}</span>
                <span class="s0">frame.preUpdate(notifyAll);</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">notifyAll = () =&gt; {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">handler of containerHandlers) {</span>
                    <span class="s0">handler.notify();</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">listener = () =&gt; frame.read(measureAll);</span>
            <span class="s0">scrollListeners.set(container, listener);</span>
            <span class="s1">const </span><span class="s0">target = getEventTarget(container);</span>
            <span class="s0">window.addEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">, listener, { passive: </span><span class="s1">true </span><span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(container !== document.documentElement) {</span>
                <span class="s0">resizeListeners.set(container, resize(container, listener));</span>
            <span class="s0">}</span>
            <span class="s0">target.addEventListener(</span><span class="s2">&quot;scroll&quot;</span><span class="s0">, listener, { passive: </span><span class="s1">true </span><span class="s0">});</span>
            <span class="s0">listener();</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">listener = scrollListeners.get(container);</span>
        <span class="s0">frame.read(listener, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">() =&gt; {</span>
            <span class="s0">cancelFrame(listener);</span>
            <span class="s3">/**</span>
             <span class="s3">* Check if we even have any handlers for this container.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">currentHandlers = onScrollHandlers.get(container);</span>
            <span class="s1">if </span><span class="s0">(!currentHandlers)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">currentHandlers.delete(containerHandler);</span>
            <span class="s1">if </span><span class="s0">(currentHandlers.size)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* If no more handlers, remove the scroll listener too.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">scrollListener = scrollListeners.get(container);</span>
            <span class="s0">scrollListeners.delete(container);</span>
            <span class="s1">if </span><span class="s0">(scrollListener) {</span>
                <span class="s0">getEventTarget(container).removeEventListener(</span><span class="s2">&quot;scroll&quot;</span><span class="s0">, scrollListener);</span>
                <span class="s0">resizeListeners.get(container)?.();</span>
                <span class="s0">window.removeEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">, scrollListener);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">timelineCache = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">function </span><span class="s0">scrollTimelineFallback(options) {</span>
        <span class="s1">const </span><span class="s0">currentTime = { value: </span><span class="s5">0 </span><span class="s0">};</span>
        <span class="s1">const </span><span class="s0">cancel = scrollInfo((info) =&gt; {</span>
            <span class="s0">currentTime.value = info[options.axis].progress * </span><span class="s5">100</span><span class="s0">;</span>
        <span class="s0">}, options);</span>
        <span class="s1">return </span><span class="s0">{ currentTime, cancel };</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getTimeline({ source, container, ...options }) {</span>
        <span class="s1">const </span><span class="s0">{ axis } = options;</span>
        <span class="s1">if </span><span class="s0">(source)</span>
            <span class="s0">container = source;</span>
        <span class="s1">const </span><span class="s0">containerCache = timelineCache.get(container) ?? </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">timelineCache.set(container, containerCache);</span>
        <span class="s1">const </span><span class="s0">targetKey = options.target ?? </span><span class="s2">&quot;self&quot;</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">targetCache = containerCache.get(targetKey) ?? {};</span>
        <span class="s1">const </span><span class="s0">axisKey = axis + (options.offset ?? []).join(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(!targetCache[axisKey]) {</span>
            <span class="s0">targetCache[axisKey] =</span>
                <span class="s0">!options.target &amp;&amp; supportsScrollTimeline()</span>
                    <span class="s0">? </span><span class="s1">new </span><span class="s0">ScrollTimeline({ source: container, axis })</span>
                    <span class="s0">: scrollTimelineFallback({ container, ...options });</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">targetCache[axisKey];</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">attachToAnimation(animation, options) {</span>
        <span class="s1">const </span><span class="s0">timeline = getTimeline(options);</span>
        <span class="s1">return </span><span class="s0">animation.attachTimeline({</span>
            <span class="s0">timeline: options.target ? undefined : timeline,</span>
            <span class="s0">observe: (valueAnimation) =&gt; {</span>
                <span class="s0">valueAnimation.pause();</span>
                <span class="s1">return </span><span class="s0">observeTimeline((progress) =&gt; {</span>
                    <span class="s0">valueAnimation.time =</span>
                        <span class="s0">valueAnimation.iterationDuration * progress;</span>
                <span class="s0">}, timeline);</span>
            <span class="s0">},</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* If the onScroll function has two arguments, it's expecting</span>
     <span class="s3">* more specific information about the scroll from scrollInfo.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isOnScrollWithInfo(onScroll) {</span>
        <span class="s1">return </span><span class="s0">onScroll.length === </span><span class="s5">2</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">attachToFunction(onScroll, options) {</span>
        <span class="s1">if </span><span class="s0">(isOnScrollWithInfo(onScroll)) {</span>
            <span class="s1">return </span><span class="s0">scrollInfo((info) =&gt; {</span>
                <span class="s0">onScroll(info[options.axis].progress, info);</span>
            <span class="s0">}, options);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">observeTimeline(onScroll, getTimeline(options));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">scroll(onScroll, { axis = </span><span class="s2">&quot;y&quot;</span><span class="s0">, container = document.scrollingElement, ...options } = {}) {</span>
        <span class="s1">if </span><span class="s0">(!container)</span>
            <span class="s1">return </span><span class="s0">noop;</span>
        <span class="s1">const </span><span class="s0">optionsWithDefaults = { axis, container, ...options };</span>
        <span class="s1">return typeof </span><span class="s0">onScroll === </span><span class="s2">&quot;function&quot;</span>
            <span class="s0">? attachToFunction(onScroll, optionsWithDefaults)</span>
            <span class="s0">: attachToAnimation(onScroll, optionsWithDefaults);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">thresholds = {</span>
        <span class="s0">some: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s0">all: </span><span class="s5">1</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = </span><span class="s2">&quot;some&quot; </span><span class="s0">} = {}) {</span>
        <span class="s1">const </span><span class="s0">elements = resolveElements(elementOrSelector);</span>
        <span class="s1">const </span><span class="s0">activeIntersections = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
        <span class="s1">const </span><span class="s0">onIntersectionChange = (entries) =&gt; {</span>
            <span class="s0">entries.forEach((entry) =&gt; {</span>
                <span class="s1">const </span><span class="s0">onEnd = activeIntersections.get(entry.target);</span>
                <span class="s3">/**</span>
                 <span class="s3">* If there's no change to the intersection, we don't need to</span>
                 <span class="s3">* do anything here.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(entry.isIntersecting === Boolean(onEnd))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(entry.isIntersecting) {</span>
                    <span class="s1">const </span><span class="s0">newOnEnd = onStart(entry.target, entry);</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">newOnEnd === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                        <span class="s0">activeIntersections.set(entry.target, newOnEnd);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">observer.unobserve(entry.target);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">onEnd === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                    <span class="s0">onEnd(entry);</span>
                    <span class="s0">activeIntersections.delete(entry.target);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">observer = </span><span class="s1">new </span><span class="s0">IntersectionObserver(onIntersectionChange, {</span>
            <span class="s0">root,</span>
            <span class="s0">rootMargin,</span>
            <span class="s0">threshold: </span><span class="s1">typeof </span><span class="s0">amount === </span><span class="s2">&quot;number&quot; </span><span class="s0">? amount : thresholds[amount],</span>
        <span class="s0">});</span>
        <span class="s0">elements.forEach((element) =&gt; observer.observe(element));</span>
        <span class="s1">return </span><span class="s0">() =&gt; observer.disconnect();</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">m = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createMotionProxy();</span>

    <span class="s1">function </span><span class="s0">useUnmountEffect(callback) {</span>
        <span class="s1">return </span><span class="s0">React$1.useEffect(() =&gt; () =&gt; callback(), []);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">domAnimation = {</span>
        <span class="s0">renderer: createDomVisualElement,</span>
        <span class="s0">...animations,</span>
        <span class="s0">...gestureAnimations,</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">domMax = {</span>
        <span class="s0">...domAnimation,</span>
        <span class="s0">...drag,</span>
        <span class="s0">...layout,</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">domMin = {</span>
        <span class="s0">renderer: createDomVisualElement,</span>
        <span class="s0">...animations,</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">useMotionValueEvent(value, event, callback) {</span>
        <span class="s3">/**</span>
         <span class="s3">* useInsertionEffect will create subscriptions before any other</span>
         <span class="s3">* effects will run. Effects run upwards through the tree so it</span>
         <span class="s3">* can be that binding a useLayoutEffect higher up the tree can</span>
         <span class="s3">* miss changes from lower down the tree.</span>
         <span class="s3">*/</span>
        <span class="s0">React$1.useInsertionEffect(() =&gt; value.on(event, callback), [value, event, callback]);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">createScrollMotionValues = () =&gt; ({</span>
        <span class="s0">scrollX: motionValue(</span><span class="s5">0</span><span class="s0">),</span>
        <span class="s0">scrollY: motionValue(</span><span class="s5">0</span><span class="s0">),</span>
        <span class="s0">scrollXProgress: motionValue(</span><span class="s5">0</span><span class="s0">),</span>
        <span class="s0">scrollYProgress: motionValue(</span><span class="s5">0</span><span class="s0">),</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">isRefPending = (ref) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(!ref)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!ref.current;</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">useScroll({ container, target, ...options } = {}) {</span>
        <span class="s1">const </span><span class="s0">values = useConstant(createScrollMotionValues);</span>
        <span class="s1">const </span><span class="s0">scrollAnimation = React$1.useRef(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">needsStart = React$1.useRef(</span><span class="s1">false</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">start = React$1.useCallback(() =&gt; {</span>
            <span class="s0">scrollAnimation.current = scroll((_progress, { x, y, }) =&gt; {</span>
                <span class="s0">values.scrollX.set(x.current);</span>
                <span class="s0">values.scrollXProgress.set(x.progress);</span>
                <span class="s0">values.scrollY.set(y.current);</span>
                <span class="s0">values.scrollYProgress.set(y.progress);</span>
            <span class="s0">}, {</span>
                <span class="s0">...options,</span>
                <span class="s0">container: container?.current || undefined,</span>
                <span class="s0">target: target?.current || undefined,</span>
            <span class="s0">});</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">scrollAnimation.current?.();</span>
            <span class="s0">};</span>
        <span class="s0">}, [container, target, JSON.stringify(options.offset)]);</span>
        <span class="s0">useIsomorphicLayoutEffect(() =&gt; {</span>
            <span class="s0">needsStart.current = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(isRefPending(container) || isRefPending(target)) {</span>
                <span class="s0">needsStart.current = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s0">start();</span>
            <span class="s0">}</span>
        <span class="s0">}, [start]);</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(needsStart.current) {</span>
                <span class="s0">exports.invariant(!isRefPending(container), </span><span class="s2">&quot;Container ref is defined but not hydrated&quot;</span><span class="s0">, </span><span class="s2">&quot;use-scroll-ref&quot;</span><span class="s0">);</span>
                <span class="s0">exports.invariant(!isRefPending(target), </span><span class="s2">&quot;Target ref is defined but not hydrated&quot;</span><span class="s0">, </span><span class="s2">&quot;use-scroll-ref&quot;</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">start();</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}, [start]);</span>
        <span class="s1">return </span><span class="s0">values;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">useElementScroll is deprecated. Convert to useScroll({ container: ref })</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useElementScroll(ref) {</span>
        <span class="s0">{</span>
            <span class="s0">warnOnce(</span><span class="s1">false</span><span class="s0">, </span><span class="s2">&quot;useElementScroll is deprecated. Convert to useScroll({ container: ref }).&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">useScroll({ container: ref });</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">useViewportScroll is deprecated. Convert to useScroll()</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useViewportScroll() {</span>
        <span class="s0">{</span>
            <span class="s0">warnOnce(</span><span class="s1">false</span><span class="s0">, </span><span class="s2">&quot;useViewportScroll is deprecated. Convert to useScroll().&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">useScroll();</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Combine multiple motion values into a new one using a string template literal.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* import {</span>
     <span class="s3">*   motion,</span>
     <span class="s3">*   useSpring,</span>
     <span class="s3">*   useMotionValue,</span>
     <span class="s3">*   useMotionTemplate</span>
     <span class="s3">* } from &quot;framer-motion&quot;</span>
     <span class="s3">*</span>
     <span class="s3">* function Component() {</span>
     <span class="s3">*   const shadowX = useSpring(0)</span>
     <span class="s3">*   const shadowY = useMotionValue(0)</span>
     <span class="s3">*   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`</span>
     <span class="s3">*</span>
     <span class="s3">*   return &lt;motion.div style={{ filter: shadow }} /&gt;</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useMotionTemplate(fragments, ...values) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Create a function that will build a string from the latest motion values.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">numFragments = fragments.length;</span>
        <span class="s1">function </span><span class="s0">buildValue() {</span>
            <span class="s1">let </span><span class="s0">output = </span><span class="s2">``</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">0</span><span class="s0">; i &lt; numFragments; i++) {</span>
                <span class="s0">output += fragments[i];</span>
                <span class="s1">const </span><span class="s0">value = values[i];</span>
                <span class="s1">if </span><span class="s0">(value) {</span>
                    <span class="s0">output += isMotionValue(value) ? value.get() : value;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">output;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">useCombineMotionValues(values.filter(isMotionValue), buildValue);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useSpring(source, options = {}) {</span>
        <span class="s1">const </span><span class="s0">{ isStatic } = React$1.useContext(MotionConfigContext);</span>
        <span class="s1">const </span><span class="s0">getFromSource = () =&gt; (isMotionValue(source) ? source.get() : source);</span>
        <span class="s3">// isStatic will never change, allowing early hooks return</span>
        <span class="s1">if </span><span class="s0">(isStatic) {</span>
            <span class="s1">return </span><span class="s0">useTransform(getFromSource);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">value = useMotionValue(getFromSource());</span>
        <span class="s0">React$1.useInsertionEffect(() =&gt; {</span>
            <span class="s1">return </span><span class="s0">attachSpring(value, source, options);</span>
        <span class="s0">}, [value, JSON.stringify(options)]);</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useAnimationFrame(callback) {</span>
        <span class="s1">const </span><span class="s0">initialTimestamp = React$1.useRef(</span><span class="s5">0</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">{ isStatic } = React$1.useContext(MotionConfigContext);</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(isStatic)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">provideTimeSinceStart = ({ timestamp, delta }) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!initialTimestamp.current)</span>
                    <span class="s0">initialTimestamp.current = timestamp;</span>
                <span class="s0">callback(timestamp - initialTimestamp.current, delta);</span>
            <span class="s0">};</span>
            <span class="s0">frame.update(provideTimeSinceStart, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">() =&gt; cancelFrame(provideTimeSinceStart);</span>
        <span class="s0">}, [callback]);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useTime() {</span>
        <span class="s1">const </span><span class="s0">time = useMotionValue(</span><span class="s5">0</span><span class="s0">);</span>
        <span class="s0">useAnimationFrame((t) =&gt; time.set(t));</span>
        <span class="s1">return </span><span class="s0">time;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.</span>
     <span class="s3">*</span>
     <span class="s3">* ```javascript</span>
     <span class="s3">* const x = useMotionValue(0)</span>
     <span class="s3">* const xVelocity = useVelocity(x)</span>
     <span class="s3">* const xAcceleration = useVelocity(xVelocity)</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useVelocity(value) {</span>
        <span class="s1">const </span><span class="s0">velocity = useMotionValue(value.getVelocity());</span>
        <span class="s1">const </span><span class="s0">updateVelocity = () =&gt; {</span>
            <span class="s1">const </span><span class="s0">latest = value.getVelocity();</span>
            <span class="s0">velocity.set(latest);</span>
            <span class="s3">/**</span>
             <span class="s3">* If we still have velocity, schedule an update for the next frame</span>
             <span class="s3">* to keep checking until it is zero.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(latest)</span>
                <span class="s0">frame.update(updateVelocity);</span>
        <span class="s0">};</span>
        <span class="s0">useMotionValueEvent(value, </span><span class="s2">&quot;change&quot;</span><span class="s0">, () =&gt; {</span>
            <span class="s3">// Schedule an update to this value at the end of the current frame.</span>
            <span class="s0">frame.update(updateVelocity, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">velocity;</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">WillChangeMotionValue </span><span class="s1">extends </span><span class="s0">MotionValue {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.isEnabled = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">add(name) {</span>
            <span class="s1">if </span><span class="s0">(transformProps.has(name) || acceleratedValues.has(name)) {</span>
                <span class="s1">this</span><span class="s0">.isEnabled = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.update();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">update() {</span>
            <span class="s1">this</span><span class="s0">.set(</span><span class="s1">this</span><span class="s0">.isEnabled ? </span><span class="s2">&quot;transform&quot; </span><span class="s0">: </span><span class="s2">&quot;auto&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useWillChange() {</span>
        <span class="s1">return </span><span class="s0">useConstant(() =&gt; </span><span class="s1">new </span><span class="s0">WillChangeMotionValue(</span><span class="s2">&quot;auto&quot;</span><span class="s0">));</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.</span>
     <span class="s3">*</span>
     <span class="s3">* This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing</span>
     <span class="s3">* `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.</span>
     <span class="s3">*</span>
     <span class="s3">* It will actively respond to changes and re-render your components with the latest setting.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* export function Sidebar({ isOpen }) {</span>
     <span class="s3">*   const shouldReduceMotion = useReducedMotion()</span>
     <span class="s3">*   const closedX = shouldReduceMotion ? 0 : &quot;-100%&quot;</span>
     <span class="s3">*</span>
     <span class="s3">*   return (</span>
     <span class="s3">*     &lt;motion.div animate={{</span>
     <span class="s3">*       opacity: isOpen ? 1 : 0,</span>
     <span class="s3">*       x: isOpen ? 0 : closedX</span>
     <span class="s3">*     }} /&gt;</span>
     <span class="s3">*   )</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">boolean</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useReducedMotion() {</span>
        <span class="s3">/**</span>
         <span class="s3">* Lazy initialisation of prefersReducedMotion</span>
         <span class="s3">*/</span>
        <span class="s0">!hasReducedMotionListener.current &amp;&amp; initPrefersReducedMotion();</span>
        <span class="s1">const </span><span class="s0">[shouldReduceMotion] = React$1.useState(prefersReducedMotion.current);</span>
        <span class="s0">{</span>
            <span class="s0">warnOnce(shouldReduceMotion !== </span><span class="s1">true</span><span class="s0">, </span><span class="s2">&quot;You have Reduced Motion enabled on your device. Animations may not appear as expected.&quot;</span><span class="s0">, </span><span class="s2">&quot;reduced-motion-disabled&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* TODO See if people miss automatically updating shouldReduceMotion setting</span>
         <span class="s3">*/</span>
        <span class="s1">return </span><span class="s0">shouldReduceMotion;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useReducedMotionConfig() {</span>
        <span class="s1">const </span><span class="s0">reducedMotionPreference = useReducedMotion();</span>
        <span class="s1">const </span><span class="s0">{ reducedMotion } = React$1.useContext(MotionConfigContext);</span>
        <span class="s1">if </span><span class="s0">(reducedMotion === </span><span class="s2">&quot;never&quot;</span><span class="s0">) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(reducedMotion === </span><span class="s2">&quot;always&quot;</span><span class="s0">) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">reducedMotionPreference;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">stopAnimation(visualElement) {</span>
        <span class="s0">visualElement.values.forEach((value) =&gt; value.stop());</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">setVariants(visualElement, variantLabels) {</span>
        <span class="s1">const </span><span class="s0">reversedLabels = [...variantLabels].reverse();</span>
        <span class="s0">reversedLabels.forEach((key) =&gt; {</span>
            <span class="s1">const </span><span class="s0">variant = visualElement.getVariant(key);</span>
            <span class="s0">variant &amp;&amp; setTarget(visualElement, variant);</span>
            <span class="s1">if </span><span class="s0">(visualElement.variantChildren) {</span>
                <span class="s0">visualElement.variantChildren.forEach((child) =&gt; {</span>
                    <span class="s0">setVariants(child, variantLabels);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">setValues(visualElement, definition) {</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(definition)) {</span>
            <span class="s1">return </span><span class="s0">setVariants(visualElement, definition);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">definition === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">setVariants(visualElement, [definition]);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">setTarget(visualElement, definition);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">animationControls() {</span>
        <span class="s3">/**</span>
         <span class="s3">* Track whether the host component has mounted.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">hasMounted = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* A collection of linked component animation controls.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">subscribers = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s1">const </span><span class="s0">controls = {</span>
            <span class="s0">subscribe(visualElement) {</span>
                <span class="s0">subscribers.add(visualElement);</span>
                <span class="s1">return </span><span class="s0">() =&gt; </span><span class="s1">void </span><span class="s0">subscribers.delete(visualElement);</span>
            <span class="s0">},</span>
            <span class="s0">start(definition, transitionOverride) {</span>
                <span class="s0">exports.invariant(hasMounted, </span><span class="s2">&quot;controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.&quot;</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">animations = [];</span>
                <span class="s0">subscribers.forEach((visualElement) =&gt; {</span>
                    <span class="s0">animations.push(animateVisualElement(visualElement, definition, {</span>
                        <span class="s0">transitionOverride,</span>
                    <span class="s0">}));</span>
                <span class="s0">});</span>
                <span class="s1">return </span><span class="s0">Promise.all(animations);</span>
            <span class="s0">},</span>
            <span class="s0">set(definition) {</span>
                <span class="s0">exports.invariant(hasMounted, </span><span class="s2">&quot;controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.&quot;</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">subscribers.forEach((visualElement) =&gt; {</span>
                    <span class="s0">setValues(visualElement, definition);</span>
                <span class="s0">});</span>
            <span class="s0">},</span>
            <span class="s0">stop() {</span>
                <span class="s0">subscribers.forEach((visualElement) =&gt; {</span>
                    <span class="s0">stopAnimation(visualElement);</span>
                <span class="s0">});</span>
            <span class="s0">},</span>
            <span class="s0">mount() {</span>
                <span class="s0">hasMounted = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">() =&gt; {</span>
                    <span class="s0">hasMounted = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">controls.stop();</span>
                <span class="s0">};</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">controls;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useAnimate() {</span>
        <span class="s1">const </span><span class="s0">scope = useConstant(() =&gt; ({</span>
            <span class="s0">current: </span><span class="s1">null</span><span class="s0">, </span><span class="s3">// Will be hydrated by React</span>
            <span class="s0">animations: [],</span>
        <span class="s0">}));</span>
        <span class="s1">const </span><span class="s0">animate = useConstant(() =&gt; createScopedAnimate(scope));</span>
        <span class="s0">useUnmountEffect(() =&gt; {</span>
            <span class="s0">scope.animations.forEach((animation) =&gt; animation.stop());</span>
            <span class="s0">scope.animations.length = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">[scope, animate];</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useAnimateMini() {</span>
        <span class="s1">const </span><span class="s0">scope = useConstant(() =&gt; ({</span>
            <span class="s0">current: </span><span class="s1">null</span><span class="s0">, </span><span class="s3">// Will be hydrated by React</span>
            <span class="s0">animations: [],</span>
        <span class="s0">}));</span>
        <span class="s1">const </span><span class="s0">animate = useConstant(() =&gt; createScopedWaapiAnimate(scope));</span>
        <span class="s0">useUnmountEffect(() =&gt; {</span>
            <span class="s0">scope.animations.forEach((animation) =&gt; animation.stop());</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">[scope, animate];</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Creates `LegacyAnimationControls`, which can be used to manually start, stop</span>
     <span class="s3">* and sequence animations on one or more components.</span>
     <span class="s3">*</span>
     <span class="s3">* The returned `LegacyAnimationControls` should be passed to the `animate` property</span>
     <span class="s3">* of the components you want to animate.</span>
     <span class="s3">*</span>
     <span class="s3">* These components can then be animated with the `start` method.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* import * as React from 'react'</span>
     <span class="s3">* import { motion, useAnimation } from 'framer-motion'</span>
     <span class="s3">*</span>
     <span class="s3">* export function MyComponent(props) {</span>
     <span class="s3">*    const controls = useAnimation()</span>
     <span class="s3">*</span>
     <span class="s3">*    controls.start({</span>
     <span class="s3">*        x: 100,</span>
     <span class="s3">*        transition: { duration: 0.5 },</span>
     <span class="s3">*    })</span>
     <span class="s3">*</span>
     <span class="s3">*    return &lt;motion.div animate={controls} /&gt;</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">Animation controller with `start` and `stop` methods</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useAnimationControls() {</span>
        <span class="s1">const </span><span class="s0">controls = useConstant(animationControls);</span>
        <span class="s0">useIsomorphicLayoutEffect(controls.mount, []);</span>
        <span class="s1">return </span><span class="s0">controls;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">useAnimation = useAnimationControls;</span>

    <span class="s1">function </span><span class="s0">usePresenceData() {</span>
        <span class="s1">const </span><span class="s0">context = React$1.useContext(PresenceContext);</span>
        <span class="s1">return </span><span class="s0">context ? context.custom : undefined;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Attaches an event listener directly to the provided DOM element.</span>
     <span class="s3">*</span>
     <span class="s3">* Bypassing React's event system can be desirable, for instance when attaching non-passive</span>
     <span class="s3">* event handlers.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const ref = useRef(null)</span>
     <span class="s3">*</span>
     <span class="s3">* useDomEvent(ref, 'wheel', onWheel, { passive: false })</span>
     <span class="s3">*</span>
     <span class="s3">* return &lt;div ref={ref} /&gt;</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">ref - React.RefObject that's been provided to the element you want to bind the listener to.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventName - Name of the event you want listen for.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">handler - Function to fire when receiving the event.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">options - Options to pass to `Event.addEventListener`.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useDomEvent(ref, eventName, handler, options) {</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s1">const </span><span class="s0">element = ref.current;</span>
            <span class="s1">if </span><span class="s0">(handler &amp;&amp; element) {</span>
                <span class="s1">return </span><span class="s0">addDomEvent(element, eventName, handler, options);</span>
            <span class="s0">}</span>
        <span class="s0">}, [ref, eventName, handler, options]);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const dragControls = useDragControls()</span>
     <span class="s3">*</span>
     <span class="s3">* function startDrag(event) {</span>
     <span class="s3">*   dragControls.start(event, { snapToCursor: true })</span>
     <span class="s3">* }</span>
     <span class="s3">*</span>
     <span class="s3">* return (</span>
     <span class="s3">*   &lt;&gt;</span>
     <span class="s3">*     &lt;div onPointerDown={startDrag} /&gt;</span>
     <span class="s3">*     &lt;motion.div drag=&quot;x&quot; dragControls={dragControls} /&gt;</span>
     <span class="s3">*   &lt;/&gt;</span>
     <span class="s3">* )</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">DragControls {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.componentControls = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Subscribe a component's internal `VisualElementDragControls` to the user-facing API.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s0">subscribe(controls) {</span>
            <span class="s1">this</span><span class="s0">.componentControls.add(controls);</span>
            <span class="s1">return </span><span class="s0">() =&gt; </span><span class="s1">this</span><span class="s0">.componentControls.delete(controls);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Start a drag gesture on every `motion` component that has this set of drag controls</span>
         <span class="s3">* passed into it via the `dragControls` prop.</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* dragControls.start(e, {</span>
         <span class="s3">*   snapToCursor: true</span>
         <span class="s3">* })</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">event - PointerEvent</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">options - Options</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">start(event, options) {</span>
            <span class="s1">this</span><span class="s0">.componentControls.forEach((controls) =&gt; {</span>
                <span class="s0">controls.start(event.nativeEvent || event, options);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Cancels a drag gesture.</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* dragControls.cancel()</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">cancel() {</span>
            <span class="s1">this</span><span class="s0">.componentControls.forEach((controls) =&gt; {</span>
                <span class="s0">controls.cancel();</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Stops a drag gesture.</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* dragControls.stop()</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@public</span>
         <span class="s3">*/</span>
        <span class="s0">stop() {</span>
            <span class="s1">this</span><span class="s0">.componentControls.forEach((controls) =&gt; {</span>
                <span class="s0">controls.stop();</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">createDragControls = () =&gt; </span><span class="s1">new </span><span class="s0">DragControls();</span>
    <span class="s3">/**</span>
     <span class="s3">* Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop</span>
     <span class="s3">* and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we</span>
     <span class="s3">* might want to initiate that dragging from a different component than the draggable one.</span>
     <span class="s3">*</span>
     <span class="s3">* By creating a `dragControls` using the `useDragControls` hook, we can pass this into</span>
     <span class="s3">* the draggable component's `dragControls` prop. It exposes a `start` method</span>
     <span class="s3">* that can start dragging from pointer events on other components.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const dragControls = useDragControls()</span>
     <span class="s3">*</span>
     <span class="s3">* function startDrag(event) {</span>
     <span class="s3">*   dragControls.start(event, { snapToCursor: true })</span>
     <span class="s3">* }</span>
     <span class="s3">*</span>
     <span class="s3">* return (</span>
     <span class="s3">*   &lt;&gt;</span>
     <span class="s3">*     &lt;div onPointerDown={startDrag} /&gt;</span>
     <span class="s3">*     &lt;motion.div drag=&quot;x&quot; dragControls={dragControls} /&gt;</span>
     <span class="s3">*   &lt;/&gt;</span>
     <span class="s3">* )</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useDragControls() {</span>
        <span class="s1">return </span><span class="s0">useConstant(createDragControls);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Checks if a component is a `motion` component.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isMotionComponent(component) {</span>
        <span class="s1">return </span><span class="s0">(component !== </span><span class="s1">null </span><span class="s0">&amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">component === </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">motionComponentSymbol </span><span class="s1">in </span><span class="s0">component);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Unwraps a `motion` component and returns either a string for `motion.div` or</span>
     <span class="s3">* the React component for `motion(Component)`.</span>
     <span class="s3">*</span>
     <span class="s3">* If the component is not a `motion` component it returns undefined.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">unwrapMotionComponent(component) {</span>
        <span class="s1">if </span><span class="s0">(isMotionComponent(component)) {</span>
            <span class="s1">return </span><span class="s0">component[motionComponentSymbol];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">undefined;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useInstantLayoutTransition() {</span>
        <span class="s1">return </span><span class="s0">startTransition;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">startTransition(callback) {</span>
        <span class="s1">if </span><span class="s0">(!rootProjectionNode.current)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">rootProjectionNode.current.isUpdating = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">rootProjectionNode.current.blockUpdate();</span>
        <span class="s0">callback &amp;&amp; callback();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useResetProjection() {</span>
        <span class="s1">const </span><span class="s0">reset = React$1.useCallback(() =&gt; {</span>
            <span class="s1">const </span><span class="s0">root = rootProjectionNode.current;</span>
            <span class="s1">if </span><span class="s0">(!root)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">root.resetTree();</span>
        <span class="s0">}, []);</span>
        <span class="s1">return </span><span class="s0">reset;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.</span>
     <span class="s3">*</span>
     <span class="s3">* An index value can be passed to the returned `cycle` function to cycle to a specific index.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* import * as React from &quot;react&quot;</span>
     <span class="s3">* import { motion, useCycle } from &quot;framer-motion&quot;</span>
     <span class="s3">*</span>
     <span class="s3">* export const MyComponent = () =&gt; {</span>
     <span class="s3">*   const [x, cycleX] = useCycle(0, 50, 100)</span>
     <span class="s3">*</span>
     <span class="s3">*   return (</span>
     <span class="s3">*     &lt;motion.div</span>
     <span class="s3">*       animate={{ x: x }}</span>
     <span class="s3">*       onTap={() =&gt; cycleX()}</span>
     <span class="s3">*      /&gt;</span>
     <span class="s3">*    )</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">items - items to cycle through</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">[currentState, cycleState]</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useCycle(...items) {</span>
        <span class="s1">const </span><span class="s0">index = React$1.useRef(</span><span class="s5">0</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">[item, setItem] = React$1.useState(items[index.current]);</span>
        <span class="s1">const </span><span class="s0">runCycle = React$1.useCallback((next) =&gt; {</span>
            <span class="s0">index.current =</span>
                <span class="s1">typeof </span><span class="s0">next !== </span><span class="s2">&quot;number&quot;</span>
                    <span class="s0">? wrap(</span><span class="s5">0</span><span class="s0">, items.length, index.current + </span><span class="s5">1</span><span class="s0">)</span>
                    <span class="s0">: next;</span>
            <span class="s0">setItem(items[index.current]);</span>
        <span class="s0">}, </span>
        <span class="s3">// The array will change on each call, but by putting items.length at</span>
        <span class="s3">// the front of this array, we guarantee the dependency comparison will match up</span>
        <span class="s3">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
        <span class="s0">[items.length, ...items]);</span>
        <span class="s1">return </span><span class="s0">[item, runCycle];</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useInView(ref, { root, margin, amount, once = </span><span class="s1">false</span><span class="s0">, initial = </span><span class="s1">false</span><span class="s0">, } = {}) {</span>
        <span class="s1">const </span><span class="s0">[isInView, setInView] = React$1.useState(initial);</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!ref.current || (once &amp;&amp; isInView))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">onEnter = () =&gt; {</span>
                <span class="s0">setInView(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">once ? undefined : () =&gt; setInView(</span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">options = {</span>
                <span class="s0">root: (root &amp;&amp; root.current) || undefined,</span>
                <span class="s0">margin,</span>
                <span class="s0">amount,</span>
            <span class="s0">};</span>
            <span class="s1">return </span><span class="s0">inView(ref.current, onEnter, options);</span>
        <span class="s0">}, [root, ref, margin, once, amount]);</span>
        <span class="s1">return </span><span class="s0">isInView;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">useInstantTransition() {</span>
        <span class="s1">const </span><span class="s0">[forceUpdate, forcedRenderCount] = useForceUpdate();</span>
        <span class="s1">const </span><span class="s0">startInstantLayoutTransition = useInstantLayoutTransition();</span>
        <span class="s1">const </span><span class="s0">unlockOnFrameRef = React$1.useRef(-</span><span class="s5">1</span><span class="s0">);</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s3">/**</span>
             <span class="s3">* Unblock after two animation frames, otherwise this will unblock too soon.</span>
             <span class="s3">*/</span>
            <span class="s0">frame.postRender(() =&gt; frame.postRender(() =&gt; {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the callback has been called again after the effect</span>
                 <span class="s3">* triggered this 2 frame delay, don't unblock animations. This</span>
                 <span class="s3">* prevents the previous effect from unblocking the current</span>
                 <span class="s3">* instant transition too soon. This becomes more likely when</span>
                 <span class="s3">* used in conjunction with React.startTransition().</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(forcedRenderCount !== unlockOnFrameRef.current)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">MotionGlobalConfig.instantAnimations = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}));</span>
        <span class="s0">}, [forcedRenderCount]);</span>
        <span class="s1">return </span><span class="s0">(callback) =&gt; {</span>
            <span class="s0">startInstantLayoutTransition(() =&gt; {</span>
                <span class="s0">MotionGlobalConfig.instantAnimations = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">forceUpdate();</span>
                <span class="s0">callback();</span>
                <span class="s0">unlockOnFrameRef.current = forcedRenderCount + </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">disableInstantTransitions() {</span>
        <span class="s0">MotionGlobalConfig.instantAnimations = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">usePageInView() {</span>
        <span class="s1">const </span><span class="s0">[isInView, setIsInView] = React$1.useState(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">React$1.useEffect(() =&gt; {</span>
            <span class="s1">const </span><span class="s0">handleVisibilityChange = () =&gt; setIsInView(!document.hidden);</span>
            <span class="s1">if </span><span class="s0">(document.hidden) {</span>
                <span class="s0">handleVisibilityChange();</span>
            <span class="s0">}</span>
            <span class="s0">document.addEventListener(</span><span class="s2">&quot;visibilitychange&quot;</span><span class="s0">, handleVisibilityChange);</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">document.removeEventListener(</span><span class="s2">&quot;visibilitychange&quot;</span><span class="s0">, handleVisibilityChange);</span>
            <span class="s0">};</span>
        <span class="s0">}, []);</span>
        <span class="s1">return </span><span class="s0">isInView;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">appearAnimationStore = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">const </span><span class="s0">appearComplete = </span><span class="s1">new </span><span class="s0">Map();</span>

    <span class="s1">const </span><span class="s0">appearStoreId = (elementId, valueName) =&gt; {</span>
        <span class="s1">const </span><span class="s0">key = transformProps.has(valueName) ? </span><span class="s2">&quot;transform&quot; </span><span class="s0">: valueName;</span>
        <span class="s1">return </span><span class="s2">`</span><span class="s0">${elementId}</span><span class="s2">: </span><span class="s0">${key}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">handoffOptimizedAppearAnimation(elementId, valueName, frame) {</span>
        <span class="s1">const </span><span class="s0">storeId = appearStoreId(elementId, valueName);</span>
        <span class="s1">const </span><span class="s0">optimisedAnimation = appearAnimationStore.get(storeId);</span>
        <span class="s1">if </span><span class="s0">(!optimisedAnimation) {</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">{ animation, startTime } = optimisedAnimation;</span>
        <span class="s1">function </span><span class="s0">cancelAnimation() {</span>
            <span class="s0">window.MotionCancelOptimisedAnimation?.(elementId, valueName, frame);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* We can cancel the animation once it's finished now that we've synced</span>
         <span class="s3">* with Motion.</span>
         <span class="s3">*</span>
         <span class="s3">* Prefer onfinish over finished as onfinish is backwards compatible with</span>
         <span class="s3">* older browsers.</span>
         <span class="s3">*/</span>
        <span class="s0">animation.onfinish = cancelAnimation;</span>
        <span class="s1">if </span><span class="s0">(startTime === </span><span class="s1">null </span><span class="s0">|| window.MotionHandoffIsComplete?.(elementId)) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If the startTime is null, this animation is the Paint Ready detection animation</span>
             <span class="s3">* and we can cancel it immediately without handoff.</span>
             <span class="s3">*</span>
             <span class="s3">* Or if we've already handed off the animation then we're now interrupting it.</span>
             <span class="s3">* In which case we need to cancel it.</span>
             <span class="s3">*/</span>
            <span class="s0">cancelAnimation();</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">startTime;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A single time to use across all animations to manually set startTime</span>
     <span class="s3">* and ensure they're all in sync.</span>
     <span class="s3">*/</span>
    <span class="s1">let </span><span class="s0">startFrameTime;</span>
    <span class="s3">/**</span>
     <span class="s3">* A dummy animation to detect when Chrome is ready to start</span>
     <span class="s3">* painting the page and hold off from triggering the real animation</span>
     <span class="s3">* until then. We only need one animation to detect paint ready.</span>
     <span class="s3">*</span>
     <span class="s3">* https://bugs.chromium.org/p/chromium/issues/detail?id=1406850</span>
     <span class="s3">*/</span>
    <span class="s1">let </span><span class="s0">readyAnimation;</span>
    <span class="s3">/**</span>
     <span class="s3">* Keep track of animations that were suspended vs cancelled so we</span>
     <span class="s3">* can easily resume them when we're done measuring layout.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">suspendedAnimations = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">function </span><span class="s0">resumeSuspendedAnimations() {</span>
        <span class="s0">suspendedAnimations.forEach((data) =&gt; {</span>
            <span class="s0">data.animation.play();</span>
            <span class="s0">data.animation.startTime = data.startTime;</span>
        <span class="s0">});</span>
        <span class="s0">suspendedAnimations.clear();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {</span>
        <span class="s3">// Prevent optimised appear animations if Motion has already started animating.</span>
        <span class="s1">if </span><span class="s0">(window.MotionIsMounted) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">id = element.dataset[optimizedAppearDataId];</span>
        <span class="s1">if </span><span class="s0">(!id)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;</span>
        <span class="s1">const </span><span class="s0">storeId = appearStoreId(id, name);</span>
        <span class="s1">if </span><span class="s0">(!readyAnimation) {</span>
            <span class="s0">readyAnimation = startWaapiAnimation(element, name, [keyframes[</span><span class="s5">0</span><span class="s0">], keyframes[</span><span class="s5">0</span><span class="s0">]], </span>
            <span class="s3">/**</span>
             <span class="s3">* 10 secs is basically just a super-safe duration to give Chrome</span>
             <span class="s3">* long enough to get the animation ready.</span>
             <span class="s3">*/</span>
            <span class="s0">{ duration: </span><span class="s5">10000</span><span class="s0">, ease: </span><span class="s2">&quot;linear&quot; </span><span class="s0">});</span>
            <span class="s0">appearAnimationStore.set(storeId, {</span>
                <span class="s0">animation: readyAnimation,</span>
                <span class="s0">startTime: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">});</span>
            <span class="s3">/**</span>
             <span class="s3">* If there's no readyAnimation then there's been no instantiation</span>
             <span class="s3">* of handoff animations.</span>
             <span class="s3">*/</span>
            <span class="s0">window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;</span>
            <span class="s0">window.MotionHasOptimisedAnimation = (elementId, valueName) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!elementId)</span>
                    <span class="s1">return false</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Keep a map of elementIds that have started animating. We check</span>
                 <span class="s3">* via ID instead of Element because of hydration errors and</span>
                 <span class="s3">* pre-hydration checks. We also actively record IDs as they start</span>
                 <span class="s3">* animating rather than simply checking for data-appear-id as</span>
                 <span class="s3">* this attrbute might be present but not lead to an animation, for</span>
                 <span class="s3">* instance if the element's appear animation is on a different</span>
                 <span class="s3">* breakpoint.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!valueName) {</span>
                    <span class="s1">return </span><span class="s0">appearComplete.has(elementId);</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">animationId = appearStoreId(elementId, valueName);</span>
                <span class="s1">return </span><span class="s0">Boolean(appearAnimationStore.get(animationId));</span>
            <span class="s0">};</span>
            <span class="s0">window.MotionHandoffMarkAsComplete = (elementId) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(appearComplete.has(elementId)) {</span>
                    <span class="s0">appearComplete.set(elementId, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s0">window.MotionHandoffIsComplete = (elementId) =&gt; {</span>
                <span class="s1">return </span><span class="s0">appearComplete.get(elementId) === </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">};</span>
            <span class="s3">/**</span>
             <span class="s3">* We only need to cancel transform animations as</span>
             <span class="s3">* they're the ones that will interfere with the</span>
             <span class="s3">* layout animation measurements.</span>
             <span class="s3">*/</span>
            <span class="s0">window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) =&gt; {</span>
                <span class="s1">const </span><span class="s0">animationId = appearStoreId(elementId, valueName);</span>
                <span class="s1">const </span><span class="s0">data = appearAnimationStore.get(animationId);</span>
                <span class="s1">if </span><span class="s0">(!data)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(frame &amp;&amp; canResume === undefined) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* Wait until the end of the subsequent frame to cancel the animation</span>
                     <span class="s3">* to ensure we don't remove the animation before the main thread has</span>
                     <span class="s3">* had a chance to resolve keyframes and render.</span>
                     <span class="s3">*/</span>
                    <span class="s0">frame.postRender(() =&gt; {</span>
                        <span class="s0">frame.postRender(() =&gt; {</span>
                            <span class="s0">data.animation.cancel();</span>
                        <span class="s0">});</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">data.animation.cancel();</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(frame &amp;&amp; canResume) {</span>
                    <span class="s0">suspendedAnimations.add(data);</span>
                    <span class="s0">frame.render(resumeSuspendedAnimations);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">appearAnimationStore.delete(animationId);</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If there are no more animations left, we can remove the cancel function.</span>
                     <span class="s3">* This will let us know when we can stop checking for conflicting layout animations.</span>
                     <span class="s3">*/</span>
                    <span class="s1">if </span><span class="s0">(!appearAnimationStore.size) {</span>
                        <span class="s0">window.MotionCancelOptimisedAnimation = undefined;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s0">window.MotionCheckAppearSync = (visualElement, valueName, value) =&gt; {</span>
                <span class="s1">const </span><span class="s0">appearId = getOptimisedAppearId(visualElement);</span>
                <span class="s1">if </span><span class="s0">(!appearId)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">valueIsOptimised = window.MotionHasOptimisedAnimation?.(appearId, valueName);</span>
                <span class="s1">const </span><span class="s0">externalAnimationValue = visualElement.props.values?.[valueName];</span>
                <span class="s1">if </span><span class="s0">(!valueIsOptimised || !externalAnimationValue)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">removeSyncCheck = value.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, (latestValue) =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(externalAnimationValue.get() !== latestValue) {</span>
                        <span class="s0">window.MotionCancelOptimisedAnimation?.(appearId, valueName);</span>
                        <span class="s0">removeSyncCheck();</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s1">return </span><span class="s0">removeSyncCheck;</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">startAnimation = () =&gt; {</span>
            <span class="s0">readyAnimation.cancel();</span>
            <span class="s1">const </span><span class="s0">appearAnimation = startWaapiAnimation(element, name, keyframes, options);</span>
            <span class="s3">/**</span>
             <span class="s3">* Record the time of the first started animation. We call performance.now() once</span>
             <span class="s3">* here and once in handoff to ensure we're getting</span>
             <span class="s3">* close to a frame-locked time. This keeps all animations in sync.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(startFrameTime === undefined) {</span>
                <span class="s0">startFrameTime = performance.now();</span>
            <span class="s0">}</span>
            <span class="s0">appearAnimation.startTime = startFrameTime;</span>
            <span class="s0">appearAnimationStore.set(storeId, {</span>
                <span class="s0">animation: appearAnimation,</span>
                <span class="s0">startTime: startFrameTime,</span>
            <span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(onReady)</span>
                <span class="s0">onReady(appearAnimation);</span>
        <span class="s0">};</span>
        <span class="s0">appearComplete.set(id, </span><span class="s1">false</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(readyAnimation.ready) {</span>
            <span class="s0">readyAnimation.ready.then(startAnimation).catch(noop);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">startAnimation();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">createObject = () =&gt; ({});</span>
    <span class="s1">class </span><span class="s0">StateVisualElement </span><span class="s1">extends </span><span class="s0">VisualElement {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">super</span><span class="s0">(...arguments);</span>
            <span class="s1">this</span><span class="s0">.measureInstanceViewportBox = createBox;</span>
        <span class="s0">}</span>
        <span class="s0">build() { }</span>
        <span class="s0">resetTransform() { }</span>
        <span class="s0">restoreTransform() { }</span>
        <span class="s0">removeValueFromRenderState() { }</span>
        <span class="s0">renderInstance() { }</span>
        <span class="s0">scrapeMotionValuesFromProps() {</span>
            <span class="s1">return </span><span class="s0">createObject();</span>
        <span class="s0">}</span>
        <span class="s0">getBaseTargetFromProps() {</span>
            <span class="s1">return </span><span class="s0">undefined;</span>
        <span class="s0">}</span>
        <span class="s0">readValueFromInstance(_state, key, options) {</span>
            <span class="s1">return </span><span class="s0">options.initialState[key] || </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">sortInstanceNodePosition() {</span>
            <span class="s1">return </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">useVisualState = makeUseVisualState({</span>
        <span class="s0">scrapeMotionValuesFromProps: createObject,</span>
        <span class="s0">createRenderState: createObject,</span>
    <span class="s0">});</span>
    <span class="s3">/**</span>
     <span class="s3">* This is not an officially supported API and may be removed</span>
     <span class="s3">* on any version.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useAnimatedState(initialState) {</span>
        <span class="s1">const </span><span class="s0">[animationState, setAnimationState] = React$1.useState(initialState);</span>
        <span class="s1">const </span><span class="s0">visualState = useVisualState({}, </span><span class="s1">false</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">element = useConstant(() =&gt; {</span>
            <span class="s1">return new </span><span class="s0">StateVisualElement({</span>
                <span class="s0">props: {</span>
                    <span class="s0">onUpdate: (v) =&gt; {</span>
                        <span class="s0">setAnimationState({ ...v });</span>
                    <span class="s0">},</span>
                <span class="s0">},</span>
                <span class="s0">visualState,</span>
                <span class="s0">presenceContext: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">}, { initialState });</span>
        <span class="s0">});</span>
        <span class="s0">React$1.useLayoutEffect(() =&gt; {</span>
            <span class="s0">element.mount({});</span>
            <span class="s1">return </span><span class="s0">() =&gt; element.unmount();</span>
        <span class="s0">}, [element]);</span>
        <span class="s1">const </span><span class="s0">startAnimation = useConstant(() =&gt; (animationDefinition) =&gt; {</span>
            <span class="s1">return </span><span class="s0">animateVisualElement(element, animationDefinition);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">[animationState, startAnimation];</span>
    <span class="s0">}</span>

    <span class="s1">let </span><span class="s0">id = </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">AnimateSharedLayout = ({ children }) =&gt; {</span>
        <span class="s0">React__namespace.useEffect(() =&gt; {</span>
            <span class="s0">exports.invariant(</span><span class="s1">false</span><span class="s0">, </span><span class="s2">&quot;AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations&quot;</span><span class="s0">);</span>
        <span class="s0">}, []);</span>
        <span class="s1">return </span><span class="s0">(jsx(LayoutGroup, { id: useConstant(() =&gt; </span><span class="s2">`asl-</span><span class="s0">${id++}</span><span class="s2">`</span><span class="s0">), children: children }));</span>
    <span class="s0">};</span>

    <span class="s3">// Keep things reasonable and avoid scale: Infinity. In practise we might need</span>
    <span class="s3">// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] =&gt; [0,1]</span>
    <span class="s3">// to simply hide content at unreasonable scales.</span>
    <span class="s1">const </span><span class="s0">maxScale = </span><span class="s5">100000</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">invertScale = (scale) =&gt; scale &gt; </span><span class="s5">0.001 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">/ scale : maxScale;</span>
    <span class="s1">let </span><span class="s0">hasWarned = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse</span>
     <span class="s3">* of their respective parent scales.</span>
     <span class="s3">*</span>
     <span class="s3">* This is useful for undoing the distortion of content when scaling a parent component.</span>
     <span class="s3">*</span>
     <span class="s3">* By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.</span>
     <span class="s3">* By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output</span>
     <span class="s3">* of those instead.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const MyComponent = () =&gt; {</span>
     <span class="s3">*   const { scaleX, scaleY } = useInvertedScale()</span>
     <span class="s3">*   return &lt;motion.div style={{ scaleX, scaleY }} /&gt;</span>
     <span class="s3">* }</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@deprecated</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">useInvertedScale(scale) {</span>
        <span class="s1">let </span><span class="s0">parentScaleX = useMotionValue(</span><span class="s5">1</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">parentScaleY = useMotionValue(</span><span class="s5">1</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">{ visualElement } = React$1.useContext(MotionContext);</span>
        <span class="s0">exports.invariant(!!(scale || visualElement), </span><span class="s2">&quot;If no scale values are provided, useInvertedScale must be used within a child of another motion component.&quot;</span><span class="s0">);</span>
        <span class="s0">exports.warning(hasWarned, </span><span class="s2">&quot;useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.&quot;</span><span class="s0">);</span>
        <span class="s0">hasWarned = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(scale) {</span>
            <span class="s0">parentScaleX = scale.scaleX || parentScaleX;</span>
            <span class="s0">parentScaleY = scale.scaleY || parentScaleY;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(visualElement) {</span>
            <span class="s0">parentScaleX = visualElement.getValue(</span><span class="s2">&quot;scaleX&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
            <span class="s0">parentScaleY = visualElement.getValue(</span><span class="s2">&quot;scaleY&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">scaleX = useTransform(parentScaleX, invertScale);</span>
        <span class="s1">const </span><span class="s0">scaleY = useTransform(parentScaleY, invertScale);</span>
        <span class="s1">return </span><span class="s0">{ scaleX, scaleY };</span>
    <span class="s0">}</span>

    <span class="s0">exports.AnimatePresence = AnimatePresence;</span>
    <span class="s0">exports.AnimateSharedLayout = AnimateSharedLayout;</span>
    <span class="s0">exports.AsyncMotionValueAnimation = AsyncMotionValueAnimation;</span>
    <span class="s0">exports.DOMKeyframesResolver = DOMKeyframesResolver;</span>
    <span class="s0">exports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;</span>
    <span class="s0">exports.DragControls = DragControls;</span>
    <span class="s0">exports.GroupAnimation = GroupAnimation;</span>
    <span class="s0">exports.GroupAnimationWithThen = GroupAnimationWithThen;</span>
    <span class="s0">exports.JSAnimation = JSAnimation;</span>
    <span class="s0">exports.KeyframeResolver = KeyframeResolver;</span>
    <span class="s0">exports.LayoutGroup = LayoutGroup;</span>
    <span class="s0">exports.LayoutGroupContext = LayoutGroupContext;</span>
    <span class="s0">exports.LazyMotion = LazyMotion;</span>
    <span class="s0">exports.MotionConfig = MotionConfig;</span>
    <span class="s0">exports.MotionConfigContext = MotionConfigContext;</span>
    <span class="s0">exports.MotionContext = MotionContext;</span>
    <span class="s0">exports.MotionGlobalConfig = MotionGlobalConfig;</span>
    <span class="s0">exports.MotionValue = MotionValue;</span>
    <span class="s0">exports.NativeAnimation = NativeAnimation;</span>
    <span class="s0">exports.NativeAnimationExtended = NativeAnimationExtended;</span>
    <span class="s0">exports.NativeAnimationWrapper = NativeAnimationWrapper;</span>
    <span class="s0">exports.PresenceContext = PresenceContext;</span>
    <span class="s0">exports.Reorder = namespace;</span>
    <span class="s0">exports.SubscriptionManager = SubscriptionManager;</span>
    <span class="s0">exports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;</span>
    <span class="s0">exports.ViewTransitionBuilder = ViewTransitionBuilder;</span>
    <span class="s0">exports.VisualElement = VisualElement;</span>
    <span class="s0">exports.WillChangeMotionValue = WillChangeMotionValue;</span>
    <span class="s0">exports.acceleratedValues = acceleratedValues;</span>
    <span class="s0">exports.activeAnimations = activeAnimations;</span>
    <span class="s0">exports.addAttrValue = addAttrValue;</span>
    <span class="s0">exports.addPointerEvent = addPointerEvent;</span>
    <span class="s0">exports.addPointerInfo = addPointerInfo;</span>
    <span class="s0">exports.addScaleCorrector = addScaleCorrector;</span>
    <span class="s0">exports.addStyleValue = addStyleValue;</span>
    <span class="s0">exports.addUniqueItem = addUniqueItem;</span>
    <span class="s0">exports.alpha = alpha;</span>
    <span class="s0">exports.analyseComplexValue = analyseComplexValue;</span>
    <span class="s0">exports.animate = animate;</span>
    <span class="s0">exports.animateMini = animateMini;</span>
    <span class="s0">exports.animateValue = animateValue;</span>
    <span class="s0">exports.animateView = animateView;</span>
    <span class="s0">exports.animateVisualElement = animateVisualElement;</span>
    <span class="s0">exports.animationControls = animationControls;</span>
    <span class="s0">exports.animationMapKey = animationMapKey;</span>
    <span class="s0">exports.animations = animations;</span>
    <span class="s0">exports.anticipate = anticipate;</span>
    <span class="s0">exports.applyGeneratorOptions = applyGeneratorOptions;</span>
    <span class="s0">exports.applyPxDefaults = applyPxDefaults;</span>
    <span class="s0">exports.attachSpring = attachSpring;</span>
    <span class="s0">exports.attrEffect = attrEffect;</span>
    <span class="s0">exports.backIn = backIn;</span>
    <span class="s0">exports.backInOut = backInOut;</span>
    <span class="s0">exports.backOut = backOut;</span>
    <span class="s0">exports.buildTransform = buildTransform;</span>
    <span class="s0">exports.calcGeneratorDuration = calcGeneratorDuration;</span>
    <span class="s0">exports.calcLength = calcLength;</span>
    <span class="s0">exports.cancelFrame = cancelFrame;</span>
    <span class="s0">exports.cancelMicrotask = cancelMicrotask;</span>
    <span class="s0">exports.cancelSync = cancelSync;</span>
    <span class="s0">exports.circIn = circIn;</span>
    <span class="s0">exports.circInOut = circInOut;</span>
    <span class="s0">exports.circOut = circOut;</span>
    <span class="s0">exports.clamp = clamp;</span>
    <span class="s0">exports.collectMotionValues = collectMotionValues;</span>
    <span class="s0">exports.color = color;</span>
    <span class="s0">exports.complex = complex;</span>
    <span class="s0">exports.convertOffsetToTimes = convertOffsetToTimes;</span>
    <span class="s0">exports.createBox = createBox;</span>
    <span class="s0">exports.createGeneratorEasing = createGeneratorEasing;</span>
    <span class="s0">exports.createRenderBatcher = createRenderBatcher;</span>
    <span class="s0">exports.createScopedAnimate = createScopedAnimate;</span>
    <span class="s0">exports.cubicBezier = cubicBezier;</span>
    <span class="s0">exports.cubicBezierAsString = cubicBezierAsString;</span>
    <span class="s0">exports.defaultEasing = defaultEasing;</span>
    <span class="s0">exports.defaultOffset = defaultOffset$1;</span>
    <span class="s0">exports.defaultTransformValue = defaultTransformValue;</span>
    <span class="s0">exports.defaultValueTypes = defaultValueTypes;</span>
    <span class="s0">exports.degrees = degrees;</span>
    <span class="s0">exports.delay = delay;</span>
    <span class="s0">exports.dimensionValueTypes = dimensionValueTypes;</span>
    <span class="s0">exports.disableInstantTransitions = disableInstantTransitions;</span>
    <span class="s0">exports.distance = distance;</span>
    <span class="s0">exports.distance2D = distance2D;</span>
    <span class="s0">exports.domAnimation = domAnimation;</span>
    <span class="s0">exports.domMax = domMax;</span>
    <span class="s0">exports.domMin = domMin;</span>
    <span class="s0">exports.easeIn = easeIn;</span>
    <span class="s0">exports.easeInOut = easeInOut;</span>
    <span class="s0">exports.easeOut = easeOut;</span>
    <span class="s0">exports.easingDefinitionToFunction = easingDefinitionToFunction;</span>
    <span class="s0">exports.fillOffset = fillOffset;</span>
    <span class="s0">exports.fillWildcards = fillWildcards;</span>
    <span class="s0">exports.filterProps = filterProps;</span>
    <span class="s0">exports.findDimensionValueType = findDimensionValueType;</span>
    <span class="s0">exports.findValueType = findValueType;</span>
    <span class="s0">exports.flushKeyframeResolvers = flushKeyframeResolvers;</span>
    <span class="s0">exports.frame = frame;</span>
    <span class="s0">exports.frameData = frameData;</span>
    <span class="s0">exports.frameSteps = frameSteps;</span>
    <span class="s0">exports.generateLinearEasing = generateLinearEasing;</span>
    <span class="s0">exports.getAnimatableNone = getAnimatableNone;</span>
    <span class="s0">exports.getAnimationMap = getAnimationMap;</span>
    <span class="s0">exports.getComputedStyle = getComputedStyle$2;</span>
    <span class="s0">exports.getDefaultValueType = getDefaultValueType;</span>
    <span class="s0">exports.getEasingForSegment = getEasingForSegment;</span>
    <span class="s0">exports.getMixer = getMixer;</span>
    <span class="s0">exports.getOriginIndex = getOriginIndex;</span>
    <span class="s0">exports.getValueAsType = getValueAsType;</span>
    <span class="s0">exports.getValueTransition = getValueTransition$1;</span>
    <span class="s0">exports.getVariableValue = getVariableValue;</span>
    <span class="s0">exports.getViewAnimationLayerInfo = getViewAnimationLayerInfo;</span>
    <span class="s0">exports.getViewAnimations = getViewAnimations;</span>
    <span class="s0">exports.hasWarned = hasWarned$1;</span>
    <span class="s0">exports.hex = hex;</span>
    <span class="s0">exports.hover = hover;</span>
    <span class="s0">exports.hsla = hsla;</span>
    <span class="s0">exports.hslaToRgba = hslaToRgba;</span>
    <span class="s0">exports.inView = inView;</span>
    <span class="s0">exports.inertia = inertia;</span>
    <span class="s0">exports.interpolate = interpolate;</span>
    <span class="s0">exports.invisibleValues = invisibleValues;</span>
    <span class="s0">exports.isBezierDefinition = isBezierDefinition;</span>
    <span class="s0">exports.isBrowser = isBrowser;</span>
    <span class="s0">exports.isCSSVariableName = isCSSVariableName;</span>
    <span class="s0">exports.isCSSVariableToken = isCSSVariableToken;</span>
    <span class="s0">exports.isDragActive = isDragActive;</span>
    <span class="s0">exports.isDragging = isDragging;</span>
    <span class="s0">exports.isEasingArray = isEasingArray;</span>
    <span class="s0">exports.isGenerator = isGenerator;</span>
    <span class="s0">exports.isHTMLElement = isHTMLElement;</span>
    <span class="s0">exports.isMotionComponent = isMotionComponent;</span>
    <span class="s0">exports.isMotionValue = isMotionValue;</span>
    <span class="s0">exports.isNodeOrChild = isNodeOrChild;</span>
    <span class="s0">exports.isNumericalString = isNumericalString;</span>
    <span class="s0">exports.isObject = isObject;</span>
    <span class="s0">exports.isPrimaryPointer = isPrimaryPointer;</span>
    <span class="s0">exports.isSVGElement = isSVGElement;</span>
    <span class="s0">exports.isSVGSVGElement = isSVGSVGElement;</span>
    <span class="s0">exports.isValidMotionProp = isValidMotionProp;</span>
    <span class="s0">exports.isWaapiSupportedEasing = isWaapiSupportedEasing;</span>
    <span class="s0">exports.isZeroValueString = isZeroValueString;</span>
    <span class="s0">exports.keyframes = keyframes;</span>
    <span class="s0">exports.m = m;</span>
    <span class="s0">exports.makeAnimationInstant = makeAnimationInstant;</span>
    <span class="s0">exports.makeUseVisualState = makeUseVisualState;</span>
    <span class="s0">exports.mapEasingToNativeEasing = mapEasingToNativeEasing;</span>
    <span class="s0">exports.mapValue = mapValue;</span>
    <span class="s0">exports.maxGeneratorDuration = maxGeneratorDuration;</span>
    <span class="s0">exports.memo = memo;</span>
    <span class="s0">exports.microtask = microtask;</span>
    <span class="s0">exports.millisecondsToSeconds = millisecondsToSeconds;</span>
    <span class="s0">exports.mirrorEasing = mirrorEasing;</span>
    <span class="s0">exports.mix = mix;</span>
    <span class="s0">exports.mixArray = mixArray;</span>
    <span class="s0">exports.mixColor = mixColor;</span>
    <span class="s0">exports.mixComplex = mixComplex;</span>
    <span class="s0">exports.mixImmediate = mixImmediate;</span>
    <span class="s0">exports.mixLinearColor = mixLinearColor;</span>
    <span class="s0">exports.mixNumber = mixNumber$1;</span>
    <span class="s0">exports.mixObject = mixObject;</span>
    <span class="s0">exports.mixVisibility = mixVisibility;</span>
    <span class="s0">exports.motion = motion;</span>
    <span class="s0">exports.motionValue = motionValue;</span>
    <span class="s0">exports.moveItem = moveItem;</span>
    <span class="s0">exports.noop = noop;</span>
    <span class="s0">exports.number = number;</span>
    <span class="s0">exports.numberValueTypes = numberValueTypes;</span>
    <span class="s0">exports.observeTimeline = observeTimeline;</span>
    <span class="s0">exports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;</span>
    <span class="s0">exports.parseCSSVariable = parseCSSVariable;</span>
    <span class="s0">exports.parseValueFromTransform = parseValueFromTransform;</span>
    <span class="s0">exports.percent = percent;</span>
    <span class="s0">exports.pipe = pipe;</span>
    <span class="s0">exports.positionalKeys = positionalKeys;</span>
    <span class="s0">exports.press = press;</span>
    <span class="s0">exports.progress = progress;</span>
    <span class="s0">exports.progressPercentage = progressPercentage;</span>
    <span class="s0">exports.propEffect = propEffect;</span>
    <span class="s0">exports.px = px;</span>
    <span class="s0">exports.readTransformValue = readTransformValue;</span>
    <span class="s0">exports.recordStats = recordStats;</span>
    <span class="s0">exports.removeItem = removeItem;</span>
    <span class="s0">exports.resize = resize;</span>
    <span class="s0">exports.resolveElements = resolveElements;</span>
    <span class="s0">exports.resolveMotionValue = resolveMotionValue;</span>
    <span class="s0">exports.reverseEasing = reverseEasing;</span>
    <span class="s0">exports.rgbUnit = rgbUnit;</span>
    <span class="s0">exports.rgba = rgba;</span>
    <span class="s0">exports.scale = scale;</span>
    <span class="s0">exports.scroll = scroll;</span>
    <span class="s0">exports.scrollInfo = scrollInfo;</span>
    <span class="s0">exports.secondsToMilliseconds = secondsToMilliseconds;</span>
    <span class="s0">exports.setDragLock = setDragLock;</span>
    <span class="s0">exports.setStyle = setStyle;</span>
    <span class="s0">exports.spring = spring;</span>
    <span class="s0">exports.springValue = springValue;</span>
    <span class="s0">exports.stagger = stagger;</span>
    <span class="s0">exports.startOptimizedAppearAnimation = startOptimizedAppearAnimation;</span>
    <span class="s0">exports.startWaapiAnimation = startWaapiAnimation;</span>
    <span class="s0">exports.statsBuffer = statsBuffer;</span>
    <span class="s0">exports.steps = steps;</span>
    <span class="s0">exports.styleEffect = styleEffect;</span>
    <span class="s0">exports.supportedWaapiEasing = supportedWaapiEasing;</span>
    <span class="s0">exports.supportsBrowserAnimation = supportsBrowserAnimation;</span>
    <span class="s0">exports.supportsFlags = supportsFlags;</span>
    <span class="s0">exports.supportsLinearEasing = supportsLinearEasing;</span>
    <span class="s0">exports.supportsPartialKeyframes = supportsPartialKeyframes;</span>
    <span class="s0">exports.supportsScrollTimeline = supportsScrollTimeline;</span>
    <span class="s0">exports.svgEffect = svgEffect;</span>
    <span class="s0">exports.sync = sync;</span>
    <span class="s0">exports.testValueType = testValueType;</span>
    <span class="s0">exports.time = time;</span>
    <span class="s0">exports.transform = transform;</span>
    <span class="s0">exports.transformPropOrder = transformPropOrder;</span>
    <span class="s0">exports.transformProps = transformProps;</span>
    <span class="s0">exports.transformValue = transformValue;</span>
    <span class="s0">exports.transformValueTypes = transformValueTypes;</span>
    <span class="s0">exports.unwrapMotionComponent = unwrapMotionComponent;</span>
    <span class="s0">exports.useAnimate = useAnimate;</span>
    <span class="s0">exports.useAnimateMini = useAnimateMini;</span>
    <span class="s0">exports.useAnimation = useAnimation;</span>
    <span class="s0">exports.useAnimationControls = useAnimationControls;</span>
    <span class="s0">exports.useAnimationFrame = useAnimationFrame;</span>
    <span class="s0">exports.useComposedRefs = useComposedRefs;</span>
    <span class="s0">exports.useCycle = useCycle;</span>
    <span class="s0">exports.useDeprecatedAnimatedState = useAnimatedState;</span>
    <span class="s0">exports.useDeprecatedInvertedScale = useInvertedScale;</span>
    <span class="s0">exports.useDomEvent = useDomEvent;</span>
    <span class="s0">exports.useDragControls = useDragControls;</span>
    <span class="s0">exports.useElementScroll = useElementScroll;</span>
    <span class="s0">exports.useForceUpdate = useForceUpdate;</span>
    <span class="s0">exports.useInView = useInView;</span>
    <span class="s0">exports.useInstantLayoutTransition = useInstantLayoutTransition;</span>
    <span class="s0">exports.useInstantTransition = useInstantTransition;</span>
    <span class="s0">exports.useIsPresent = useIsPresent;</span>
    <span class="s0">exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;</span>
    <span class="s0">exports.useMotionTemplate = useMotionTemplate;</span>
    <span class="s0">exports.useMotionValue = useMotionValue;</span>
    <span class="s0">exports.useMotionValueEvent = useMotionValueEvent;</span>
    <span class="s0">exports.usePageInView = usePageInView;</span>
    <span class="s0">exports.usePresence = usePresence;</span>
    <span class="s0">exports.usePresenceData = usePresenceData;</span>
    <span class="s0">exports.useReducedMotion = useReducedMotion;</span>
    <span class="s0">exports.useReducedMotionConfig = useReducedMotionConfig;</span>
    <span class="s0">exports.useResetProjection = useResetProjection;</span>
    <span class="s0">exports.useScroll = useScroll;</span>
    <span class="s0">exports.useSpring = useSpring;</span>
    <span class="s0">exports.useTime = useTime;</span>
    <span class="s0">exports.useTransform = useTransform;</span>
    <span class="s0">exports.useUnmountEffect = useUnmountEffect;</span>
    <span class="s0">exports.useVelocity = useVelocity;</span>
    <span class="s0">exports.useViewportScroll = useViewportScroll;</span>
    <span class="s0">exports.useWillChange = useWillChange;</span>
    <span class="s0">exports.velocityPerSecond = velocityPerSecond;</span>
    <span class="s0">exports.vh = vh;</span>
    <span class="s0">exports.visualElementStore = visualElementStore;</span>
    <span class="s0">exports.vw = vw;</span>
    <span class="s0">exports.warnOnce = warnOnce;</span>
    <span class="s0">exports.wrap = wrap;</span>

<span class="s0">}));</span>
</pre>
</body>
</html>