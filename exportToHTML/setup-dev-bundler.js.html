<html>
<head>
<title>setup-dev-bundler.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
setup-dev-bundler.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">propagateServerField: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">setupDevBundler: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">propagateServerField: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">propagateServerField;</span>
    <span class="s1">},</span>
    <span class="s1">setupDevBundler: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">setupDevBundler;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_getpagestaticinfo = require(</span><span class="s0">&quot;../../../build/analysis/get-page-static-info&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_swc = require(</span><span class="s0">&quot;../../../build/swc&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fs = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_url = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;url&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_querystring = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;querystring&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_watchpack = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/watchpack&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_env = require(</span><span class="s0">&quot;@next/env&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_findup = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/find-up&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_filesystem = require(</span><span class="s0">&quot;./filesystem&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../../../build/output/log&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_hotreloaderwebpack = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../../dev/hot-reloader-webpack&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_shared = require(</span><span class="s0">&quot;../../../trace/shared&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_loadjsconfig = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../../../build/load-jsconfig&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_findpagefile = require(</span><span class="s0">&quot;../find-page-file&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_events = require(</span><span class="s0">&quot;../../../telemetry/events&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../../../shared/lib/router/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_entries = require(</span><span class="s0">&quot;../../../build/entries&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_verifytypescriptsetup = require(</span><span class="s0">&quot;../../../lib/verify-typescript-setup&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_verifypartytownsetup = require(</span><span class="s0">&quot;../../../lib/verify-partytown-setup&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routeregex = require(</span><span class="s0">&quot;../../../shared/lib/router/utils/route-regex&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../../../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_builddataroute = require(</span><span class="s0">&quot;./build-data-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routematcher = require(</span><span class="s0">&quot;../../../shared/lib/router/utils/route-matcher&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepathsep = require(</span><span class="s0">&quot;../../../shared/lib/page-path/normalize-path-sep&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createclientrouterfilter = require(</span><span class="s0">&quot;../../../lib/create-client-router-filter&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_absolutepathtopage = require(</span><span class="s0">&quot;../../../shared/lib/page-path/absolute-path-to-page&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_generateinterceptionroutesrewrites = require(</span><span class="s0">&quot;../../../lib/generate-interception-routes-rewrites&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_middlewareroutematcher = require(</span><span class="s0">&quot;../../../shared/lib/router/utils/middleware-route-matcher&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../../../build/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_shared1 = require(</span><span class="s0">&quot;../../../build/webpack/plugins/next-types-plugin/shared&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hotreloadertypes = require(</span><span class="s0">&quot;../../dev/hot-reloader-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pagetypes = require(</span><span class="s0">&quot;../../../lib/page-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hotreloaderturbopack = require(</span><span class="s0">&quot;../../dev/hot-reloader-turbopack&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_encryptionutilsserver = require(</span><span class="s0">&quot;../../app-render/encryption-utils-server&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ismetadataroute = require(</span><span class="s0">&quot;../../../lib/metadata/is-metadata-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getmetadataroute = require(</span><span class="s0">&quot;../../../lib/metadata/get-metadata-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createenvdefinitions = require(</span><span class="s0">&quot;../experimental/create-env-definitions&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_jsconfigpathsplugin = require(</span><span class="s0">&quot;../../../build/webpack/plugins/jsconfig-paths-plugin&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_store = require(</span><span class="s0">&quot;../../../build/output/store&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils2 = require(</span><span class="s0">&quot;../../../shared/lib/turbopack/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_defineenv = require(</span><span class="s0">&quot;../../../build/define-env&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_internalerror = require(</span><span class="s0">&quot;../../../shared/lib/turbopack/internal-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepath = require(</span><span class="s0">&quot;../../../lib/normalize-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routetypesutils = require(</span><span class="s0">&quot;./route-types-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segment = require(</span><span class="s0">&quot;../../../shared/lib/segment&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ensureleadingslash = require(</span><span class="s0">&quot;../../../shared/lib/page-path/ensure-leading-slash&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">verifyTypeScript(opts) {</span>
    <span class="s2">let </span><span class="s1">usingTypeScript = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">verifyResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _verifytypescriptsetup.verifyTypeScriptSetup)({</span>
        <span class="s1">dir: opts.dir,</span>
        <span class="s1">distDir: opts.nextConfig.distDir,</span>
        <span class="s1">intentDirs: [</span>
            <span class="s1">opts.pagesDir,</span>
            <span class="s1">opts.appDir</span>
        <span class="s1">].filter(Boolean),</span>
        <span class="s1">typeCheckPreflight: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">tsconfigPath: opts.nextConfig.typescript.tsconfigPath,</span>
        <span class="s1">disableStaticImages: opts.nextConfig.images.disableStaticImages,</span>
        <span class="s1">hasAppDir: !!opts.appDir,</span>
        <span class="s1">hasPagesDir: !!opts.pagesDir</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(verifyResult.version) {</span>
        <span class="s1">usingTypeScript = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">usingTypeScript;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">propagateServerField(opts, field, args) {</span>
    <span class="s2">var </span><span class="s1">_opts_renderServer_instance, _opts_renderServer;</span>
    <span class="s2">await </span><span class="s1">((_opts_renderServer = opts.renderServer) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_opts_renderServer_instance = _opts_renderServer.instance) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _opts_renderServer_instance.propagateServerField(opts.dir, field, args));</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">startWatcher(opts) {</span>
    <span class="s2">const </span><span class="s1">{ nextConfig, appDir, pagesDir, dir, resetFetch } = opts;</span>
    <span class="s2">const </span><span class="s1">{ useFileSystemPublicRoutes } = nextConfig;</span>
    <span class="s2">const </span><span class="s1">distDir = _path.default.join(opts.dir, opts.nextConfig.distDir);</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _shared.setGlobal)(</span><span class="s0">'distDir'</span><span class="s1">, distDir);</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _shared.setGlobal)(</span><span class="s0">'phase'</span><span class="s1">, _constants.PHASE_DEVELOPMENT_SERVER);</span>
    <span class="s2">const </span><span class="s1">validFileMatcher = (</span><span class="s3">0</span><span class="s1">, _findpagefile.createValidFileMatcher)(nextConfig.pageExtensions, appDir);</span>
    <span class="s2">const </span><span class="s1">serverFields = {};</span>
    <span class="s4">// Update logging state once based on next.config.js when initializing</span>
    <span class="s1">_store.store.setState({</span>
        <span class="s1">logging: nextConfig.logging !== </span><span class="s2">false</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">hotReloader = opts.turbo ? </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _hotreloaderturbopack.createHotReloaderTurbopack)(opts, serverFields, distDir, resetFetch) : </span><span class="s2">new </span><span class="s1">_hotreloaderwebpack.default(opts.dir, {</span>
        <span class="s1">isSrcDir: opts.isSrcDir,</span>
        <span class="s1">appDir,</span>
        <span class="s1">pagesDir,</span>
        <span class="s1">distDir,</span>
        <span class="s1">config: opts.nextConfig,</span>
        <span class="s1">buildId: </span><span class="s0">'development'</span><span class="s1">,</span>
        <span class="s1">encryptionKey: </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _encryptionutilsserver.generateEncryptionKeyBase64)({</span>
            <span class="s1">isBuild: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">distDir</span>
        <span class="s1">}),</span>
        <span class="s1">telemetry: opts.telemetry,</span>
        <span class="s1">rewrites: opts.fsChecker.rewrites,</span>
        <span class="s1">previewProps: opts.fsChecker.prerenderManifest.preview,</span>
        <span class="s1">resetFetch</span>
    <span class="s1">});</span>
    <span class="s2">await </span><span class="s1">hotReloader.start();</span>
    <span class="s4">// have to write this after starting hot-reloader since that</span>
    <span class="s4">// cleans the dist dir</span>
    <span class="s2">const </span><span class="s1">distTypesDir = _path.default.join(distDir, </span><span class="s0">'types'</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _routetypesutils.writeRouteTypesManifest)({</span>
        <span class="s1">appRoutes: {},</span>
        <span class="s1">pageRoutes: {},</span>
        <span class="s1">layoutRoutes: {},</span>
        <span class="s1">appRouteHandlerRoutes: {},</span>
        <span class="s1">redirectRoutes: {},</span>
        <span class="s1">rewriteRoutes: {},</span>
        <span class="s1">appPagePaths: </span><span class="s2">new </span><span class="s1">Set(),</span>
        <span class="s1">pagesRouterPagePaths: </span><span class="s2">new </span><span class="s1">Set(),</span>
        <span class="s1">layoutPaths: </span><span class="s2">new </span><span class="s1">Set(),</span>
        <span class="s1">appRouteHandlers: </span><span class="s2">new </span><span class="s1">Set(),</span>
        <span class="s1">pageApiRoutes: </span><span class="s2">new </span><span class="s1">Set(),</span>
        <span class="s1">filePathToRoute: </span><span class="s2">new </span><span class="s1">Map()</span>
    <span class="s1">}, _path.default.join(distTypesDir, </span><span class="s0">'routes.d.ts'</span><span class="s1">), opts.nextConfig);</span>
    <span class="s2">const </span><span class="s1">usingTypeScript = </span><span class="s2">await </span><span class="s1">verifyTypeScript(opts);</span>
    <span class="s2">const </span><span class="s1">routesManifestPath = _path.default.join(distDir, _constants.ROUTES_MANIFEST);</span>
    <span class="s2">const </span><span class="s1">routesManifest = {</span>
        <span class="s1">version: </span><span class="s3">3</span><span class="s1">,</span>
        <span class="s1">caseSensitive: !!nextConfig.experimental.caseSensitiveRoutes,</span>
        <span class="s1">basePath: nextConfig.basePath,</span>
        <span class="s1">rewrites: opts.fsChecker.rewrites,</span>
        <span class="s1">redirects: opts.fsChecker.redirects,</span>
        <span class="s1">headers: opts.fsChecker.headers,</span>
        <span class="s1">i18n: nextConfig.i18n || undefined,</span>
        <span class="s1">skipMiddlewareUrlNormalize: nextConfig.skipMiddlewareUrlNormalize</span>
    <span class="s1">};</span>
    <span class="s2">await </span><span class="s1">_fs.default.promises.writeFile(routesManifestPath, JSON.stringify(routesManifest));</span>
    <span class="s2">const </span><span class="s1">prerenderManifestPath = _path.default.join(distDir, _constants.PRERENDER_MANIFEST);</span>
    <span class="s2">await </span><span class="s1">_fs.default.promises.writeFile(prerenderManifestPath, JSON.stringify(opts.fsChecker.prerenderManifest, </span><span class="s2">null</span><span class="s1">, </span><span class="s3">2</span><span class="s1">));</span>
    <span class="s2">if </span><span class="s1">(opts.nextConfig.experimental.nextScriptWorkers) {</span>
        <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _verifypartytownsetup.verifyPartytownSetup)(opts.dir, _path.default.join(distDir, _constants.CLIENT_STATIC_FILES_PATH));</span>
    <span class="s1">}</span>
    <span class="s1">opts.fsChecker.ensureCallback(async </span><span class="s2">function </span><span class="s1">ensure(item) {</span>
        <span class="s2">if </span><span class="s1">(item.type === </span><span class="s0">'appFile' </span><span class="s1">|| item.type === </span><span class="s0">'pageFile'</span><span class="s1">) {</span>
            <span class="s2">await </span><span class="s1">hotReloader.ensurePage({</span>
                <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">page: item.itemPath,</span>
                <span class="s1">isApp: item.type === </span><span class="s0">'appFile'</span><span class="s1">,</span>
                <span class="s1">definition: undefined</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">let </span><span class="s1">resolved = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">prevSortedRoutes = [];</span>
    <span class="s2">await new </span><span class="s1">Promise(async (resolve, reject)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(pagesDir) {</span>
            <span class="s4">// Watchpack doesn't emit an event for an empty directory</span>
            <span class="s1">_fs.default.readdir(pagesDir, (_, files)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(files == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: files.length) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!resolved) {</span>
                    <span class="s1">resolve();</span>
                    <span class="s1">resolved = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">pages = pagesDir ? [</span>
            <span class="s1">pagesDir</span>
        <span class="s1">] : [];</span>
        <span class="s2">const </span><span class="s1">app = appDir ? [</span>
            <span class="s1">appDir</span>
        <span class="s1">] : [];</span>
        <span class="s2">const </span><span class="s1">directories = [</span>
            <span class="s1">...pages,</span>
            <span class="s1">...app</span>
        <span class="s1">];</span>
        <span class="s2">const </span><span class="s1">rootDir = pagesDir || appDir;</span>
        <span class="s2">const </span><span class="s1">files = [</span>
            <span class="s1">...(</span><span class="s3">0</span><span class="s1">, _utils1.getPossibleMiddlewareFilenames)(_path.default.join(rootDir, </span><span class="s0">'..'</span><span class="s1">), nextConfig.pageExtensions),</span>
            <span class="s1">...(</span><span class="s3">0</span><span class="s1">, _utils1.getPossibleInstrumentationHookFilenames)(_path.default.join(rootDir, </span><span class="s0">'..'</span><span class="s1">), nextConfig.pageExtensions)</span>
        <span class="s1">];</span>
        <span class="s2">let </span><span class="s1">nestedMiddleware = [];</span>
        <span class="s2">const </span><span class="s1">envFiles = [</span>
            <span class="s0">'.env.development.local'</span><span class="s1">,</span>
            <span class="s0">'.env.local'</span><span class="s1">,</span>
            <span class="s0">'.env.development'</span><span class="s1">,</span>
            <span class="s0">'.env'</span>
        <span class="s1">].map((file)=&gt;_path.default.join(dir, file));</span>
        <span class="s1">files.push(...envFiles);</span>
        <span class="s4">// tsconfig/jsconfig paths hot-reloading</span>
        <span class="s2">const </span><span class="s1">tsconfigPaths = [</span>
            <span class="s1">_path.default.join(dir, </span><span class="s0">'tsconfig.json'</span><span class="s1">),</span>
            <span class="s1">_path.default.join(dir, </span><span class="s0">'jsconfig.json'</span><span class="s1">)</span>
        <span class="s1">];</span>
        <span class="s1">files.push(...tsconfigPaths);</span>
        <span class="s2">const </span><span class="s1">wp = </span><span class="s2">new </span><span class="s1">_watchpack.default({</span>
            <span class="s1">ignored: (pathname)=&gt;{</span>
                <span class="s2">return </span><span class="s1">!files.some((file)=&gt;file.startsWith(pathname)) &amp;&amp; !directories.some((d)=&gt;pathname.startsWith(d) || d.startsWith(pathname));</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">fileWatchTimes = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s2">let </span><span class="s1">enabledTypeScript = usingTypeScript;</span>
        <span class="s2">let </span><span class="s1">previousClientRouterFilters;</span>
        <span class="s2">let </span><span class="s1">previousConflictingPagePaths = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">const </span><span class="s1">routeTypesFilePath = _path.default.join(distDir, </span><span class="s0">'types'</span><span class="s1">, </span><span class="s0">'routes.d.ts'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">validatorFilePath = _path.default.join(distDir, </span><span class="s0">'types'</span><span class="s1">, </span><span class="s0">'validator.ts'</span><span class="s1">);</span>
        <span class="s1">wp.on(</span><span class="s0">'aggregated'</span><span class="s1">, async ()=&gt;{</span>
            <span class="s2">var </span><span class="s1">_serverFields_middleware, _serverFields_middleware1;</span>
            <span class="s2">let </span><span class="s1">middlewareMatchers;</span>
            <span class="s2">const </span><span class="s1">routedPages = [];</span>
            <span class="s2">const </span><span class="s1">knownFiles = wp.getTimeInfoEntries();</span>
            <span class="s2">const </span><span class="s1">appPaths = {};</span>
            <span class="s2">const </span><span class="s1">pageNameSet = </span><span class="s2">new </span><span class="s1">Set();</span>
            <span class="s2">const </span><span class="s1">conflictingAppPagePaths = </span><span class="s2">new </span><span class="s1">Set();</span>
            <span class="s2">const </span><span class="s1">appPageFilePaths = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">const </span><span class="s1">pagesPageFilePaths = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">const </span><span class="s1">appRouteHandlers = [];</span>
            <span class="s2">const </span><span class="s1">pageApiRoutes = [];</span>
            <span class="s2">const </span><span class="s1">pageRoutes = [];</span>
            <span class="s2">const </span><span class="s1">appRoutes = [];</span>
            <span class="s2">const </span><span class="s1">layoutRoutes = [];</span>
            <span class="s2">const </span><span class="s1">slots = [];</span>
            <span class="s2">let </span><span class="s1">envChange = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">tsconfigChange = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">conflictingPageChange = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">hasRootAppNotFound = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">{ appFiles, pageFiles } = opts.fsChecker;</span>
            <span class="s1">appFiles.clear();</span>
            <span class="s1">pageFiles.clear();</span>
            <span class="s1">_shared1.devPageFiles.clear();</span>
            <span class="s2">const </span><span class="s1">sortedKnownFiles = [</span>
                <span class="s1">...knownFiles.keys()</span>
            <span class="s1">].sort((</span><span class="s3">0</span><span class="s1">, _entries.sortByPageExts)(nextConfig.pageExtensions));</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">fileName of sortedKnownFiles){</span>
                <span class="s2">if </span><span class="s1">(!files.includes(fileName) &amp;&amp; !directories.some((d)=&gt;fileName.startsWith(d))) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">meta = knownFiles.get(fileName);</span>
                <span class="s2">const </span><span class="s1">watchTime = fileWatchTimes.get(fileName);</span>
                <span class="s4">// If the file is showing up for the first time or the meta.timestamp is changed since last time</span>
                <span class="s2">const </span><span class="s1">watchTimeChange = watchTime === undefined || watchTime &amp;&amp; watchTime !== (meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: meta.timestamp);</span>
                <span class="s1">fileWatchTimes.set(fileName, meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: meta.timestamp);</span>
                <span class="s2">if </span><span class="s1">(envFiles.includes(fileName)) {</span>
                    <span class="s2">if </span><span class="s1">(watchTimeChange) {</span>
                        <span class="s1">envChange = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(tsconfigPaths.includes(fileName)) {</span>
                    <span class="s2">if </span><span class="s1">(fileName.endsWith(</span><span class="s0">'tsconfig.json'</span><span class="s1">)) {</span>
                        <span class="s1">enabledTypeScript = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(watchTimeChange) {</span>
                        <span class="s1">tsconfigChange = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: meta.accuracy) === undefined || !validFileMatcher.isPageFile(fileName)) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">isAppPath = Boolean(appDir &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(fileName).startsWith((</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(appDir) + </span><span class="s0">'/'</span><span class="s1">));</span>
                <span class="s2">const </span><span class="s1">isPagePath = Boolean(pagesDir &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(fileName).startsWith((</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pagesDir) + </span><span class="s0">'/'</span><span class="s1">));</span>
                <span class="s2">const </span><span class="s1">rootFile = (</span><span class="s3">0</span><span class="s1">, _absolutepathtopage.absolutePathToPage)(fileName, {</span>
                    <span class="s1">dir: dir,</span>
                    <span class="s1">extensions: nextConfig.pageExtensions,</span>
                    <span class="s1">keepIndex: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">pagesType: _pagetypes.PAGE_TYPES.ROOT</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils1.isMiddlewareFile)(rootFile)) {</span>
                    <span class="s2">var </span><span class="s1">_staticInfo_middleware;</span>
                    <span class="s2">const </span><span class="s1">staticInfo = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _entries.getStaticInfoIncludingLayouts)({</span>
                        <span class="s1">pageFilePath: fileName,</span>
                        <span class="s1">config: nextConfig,</span>
                        <span class="s1">appDir: appDir,</span>
                        <span class="s1">page: rootFile,</span>
                        <span class="s1">isDev: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">isInsideAppDir: isAppPath,</span>
                        <span class="s1">pageExtensions: nextConfig.pageExtensions</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(nextConfig.output === </span><span class="s0">'export'</span><span class="s1">) {</span>
                        <span class="s1">_log.error(</span><span class="s0">'Middleware cannot be used with &quot;output: export&quot;. See more info here: https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s1">);</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">serverFields.actualMiddlewareFile = rootFile;</span>
                    <span class="s2">await </span><span class="s1">propagateServerField(opts, </span><span class="s0">'actualMiddlewareFile'</span><span class="s1">, serverFields.actualMiddlewareFile);</span>
                    <span class="s1">middlewareMatchers = ((_staticInfo_middleware = staticInfo.middleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _staticInfo_middleware.matchers) || [</span>
                        <span class="s1">{</span>
                            <span class="s1">regexp: </span><span class="s0">'.*'</span><span class="s1">,</span>
                            <span class="s1">originalSource: </span><span class="s0">'/:path*'</span>
                        <span class="s1">}</span>
                    <span class="s1">];</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils1.isInstrumentationHookFile)(rootFile)) {</span>
                    <span class="s1">serverFields.actualInstrumentationHookFile = rootFile;</span>
                    <span class="s2">await </span><span class="s1">propagateServerField(opts, </span><span class="s0">'actualInstrumentationHookFile'</span><span class="s1">, serverFields.actualInstrumentationHookFile);</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(fileName.endsWith(</span><span class="s0">'.ts'</span><span class="s1">) || fileName.endsWith(</span><span class="s0">'.tsx'</span><span class="s1">)) {</span>
                    <span class="s1">enabledTypeScript = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!(isAppPath || isPagePath)) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// Collect all current filenames for the TS plugin to use</span>
                <span class="s1">_shared1.devPageFiles.add(fileName);</span>
                <span class="s2">let </span><span class="s1">pageName = (</span><span class="s3">0</span><span class="s1">, _absolutepathtopage.absolutePathToPage)(fileName, {</span>
                    <span class="s1">dir: isAppPath ? appDir : pagesDir,</span>
                    <span class="s1">extensions: nextConfig.pageExtensions,</span>
                    <span class="s1">keepIndex: isAppPath,</span>
                    <span class="s1">pagesType: isAppPath ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.PAGES</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(isAppPath &amp;&amp; appDir &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _ismetadataroute.isMetadataRouteFile)(fileName.replace(appDir, </span><span class="s0">''</span><span class="s1">), nextConfig.pageExtensions, </span><span class="s2">true</span><span class="s1">)) {</span>
                    <span class="s2">const </span><span class="s1">staticInfo = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _getpagestaticinfo.getPageStaticInfo)({</span>
                        <span class="s1">pageFilePath: fileName,</span>
                        <span class="s1">nextConfig: {},</span>
                        <span class="s1">page: pageName,</span>
                        <span class="s1">isDev: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">pageType: _pagetypes.PAGE_TYPES.APP</span>
                    <span class="s1">});</span>
                    <span class="s1">pageName = (</span><span class="s3">0</span><span class="s1">, _getmetadataroute.normalizeMetadataPageToRoute)(pageName, !!(staticInfo.generateSitemaps || staticInfo.generateImageMetadata));</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!isAppPath &amp;&amp; pageName.startsWith(</span><span class="s0">'/api/'</span><span class="s1">) &amp;&amp; nextConfig.output === </span><span class="s0">'export'</span><span class="s1">) {</span>
                    <span class="s1">_log.error(</span><span class="s0">'API Routes cannot be used with &quot;output: export&quot;. See more info here: https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s1">);</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(isAppPath) {</span>
                    <span class="s2">const </span><span class="s1">isRootNotFound = validFileMatcher.isRootNotFound(fileName);</span>
                    <span class="s1">hasRootAppNotFound = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(isRootNotFound) {</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s4">// Ignore files/directories starting with `_` in the app directory</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pageName).includes(</span><span class="s0">'/_'</span><span class="s1">)) {</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s4">// Record parallel route slots for layout typing</span>
                    <span class="s4">// May run multiple times (e.g. if a parallel route</span>
                    <span class="s4">// has both a layout and a page, and children) but that's fine</span>
                    <span class="s2">const </span><span class="s1">segments = (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pageName).split(</span><span class="s0">'/'</span><span class="s1">);</span>
                    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = segments.length - </span><span class="s3">1</span><span class="s1">; i &gt;= </span><span class="s3">0</span><span class="s1">; i--){</span>
                        <span class="s2">const </span><span class="s1">segment = segments[i];</span>
                        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _segment.isParallelRouteSegment)(segment)) {</span>
                            <span class="s2">const </span><span class="s1">parentPath = (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(segments.slice(</span><span class="s3">0</span><span class="s1">, i).join(</span><span class="s0">'/'</span><span class="s1">));</span>
                            <span class="s2">const </span><span class="s1">slotName = segment.slice(</span><span class="s3">1</span><span class="s1">);</span>
                            <span class="s4">// check if the slot already exists</span>
                            <span class="s2">if </span><span class="s1">(slots.some((s)=&gt;s.name === slotName &amp;&amp; s.parent === parentPath)) </span><span class="s2">continue</span><span class="s1">;</span>
                            <span class="s1">slots.push({</span>
                                <span class="s1">name: slotName,</span>
                                <span class="s1">parent: parentPath</span>
                            <span class="s1">});</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s4">// Record layouts</span>
                    <span class="s2">if </span><span class="s1">(validFileMatcher.isAppLayoutPage(fileName)) {</span>
                        <span class="s1">layoutRoutes.push({</span>
                            <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _ensureleadingslash.ensureLeadingSlash)((</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)((</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pageName)).replace(</span><span class="s5">/\/layout$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)),</span>
                            <span class="s1">filePath: fileName</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!validFileMatcher.isAppRouterPage(fileName)) {</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">originalPageName = pageName;</span>
                    <span class="s1">pageName = (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(pageName).replace(</span><span class="s5">/%5F/g</span><span class="s1">, </span><span class="s0">'_'</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(!appPaths[pageName]) {</span>
                        <span class="s1">appPaths[pageName] = [];</span>
                    <span class="s1">}</span>
                    <span class="s1">appPaths[pageName].push(opts.turbo ? originalPageName.replace(</span><span class="s5">/%5F/g</span><span class="s1">, </span><span class="s0">'_'</span><span class="s1">) : originalPageName);</span>
                    <span class="s2">if </span><span class="s1">(useFileSystemPublicRoutes) {</span>
                        <span class="s1">appFiles.add(pageName);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(validFileMatcher.isAppRouterRoute(fileName)) {</span>
                        <span class="s1">appRouteHandlers.push({</span>
                            <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pageName),</span>
                            <span class="s1">filePath: fileName</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">appRoutes.push({</span>
                            <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pageName),</span>
                            <span class="s1">filePath: fileName</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(routedPages.includes(pageName)) {</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(useFileSystemPublicRoutes) {</span>
                        <span class="s1">pageFiles.add(pageName);</span>
                        <span class="s4">// always add to nextDataRoutes for now but in future only add</span>
                        <span class="s4">// entries that actually use getStaticProps/getServerSideProps</span>
                        <span class="s1">opts.fsChecker.nextDataRoutes.add(pageName);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(pageName.startsWith(</span><span class="s0">'/api/'</span><span class="s1">)) {</span>
                        <span class="s1">pageApiRoutes.push({</span>
                            <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pageName),</span>
                            <span class="s1">filePath: fileName</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">pageRoutes.push({</span>
                            <span class="s1">route: (</span><span class="s3">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(pageName),</span>
                            <span class="s1">filePath: fileName</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">// Record pages</span>
                <span class="s2">if </span><span class="s1">(isAppPath) {</span>
                    <span class="s1">appPageFilePaths.set(pageName, fileName);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">pagesPageFilePaths.set(pageName, fileName);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(appDir &amp;&amp; pageNameSet.has(pageName)) {</span>
                    <span class="s1">conflictingAppPagePaths.add(pageName);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">pageNameSet.add(pageName);</span>
                <span class="s1">}</span>
                <span class="s4">/**</span>
         <span class="s4">* If there is a middleware that is not declared in the root we will</span>
         <span class="s4">* warn without adding it so it doesn't make its way into the system.</span>
         <span class="s4">*/ </span><span class="s2">if </span><span class="s1">(</span><span class="s5">/[\\\\/]_middleware$/</span><span class="s1">.test(pageName)) {</span>
                    <span class="s1">nestedMiddleware.push(pageName);</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">routedPages.push(pageName);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">numConflicting = conflictingAppPagePaths.size;</span>
            <span class="s1">conflictingPageChange = numConflicting - previousConflictingPagePaths.size;</span>
            <span class="s2">if </span><span class="s1">(conflictingPageChange !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(numConflicting &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s2">let </span><span class="s1">errorMessage = </span><span class="s0">`Conflicting app and page file</span><span class="s1">${numConflicting === </span><span class="s3">1 </span><span class="s1">? </span><span class="s0">' was' </span><span class="s1">: </span><span class="s0">'s were'</span><span class="s1">} </span><span class="s0">found, please remove the conflicting files to continue:</span><span class="s6">\n</span><span class="s0">`</span><span class="s1">;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">p of conflictingAppPagePaths){</span>
                        <span class="s2">const </span><span class="s1">appPath = _path.default.relative(dir, appPageFilePaths.get(p));</span>
                        <span class="s2">const </span><span class="s1">pagesPath = _path.default.relative(dir, pagesPageFilePaths.get(p));</span>
                        <span class="s1">errorMessage += </span><span class="s0">`  &quot;</span><span class="s1">${pagesPath}</span><span class="s0">&quot; - &quot;</span><span class="s1">${appPath}</span><span class="s0">&quot;</span><span class="s6">\n</span><span class="s0">`</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">hotReloader.setHmrServerError(Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(errorMessage), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">}));</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(numConflicting === </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s1">hotReloader.clearHmrServerError();</span>
                    <span class="s2">await </span><span class="s1">propagateServerField(opts, </span><span class="s0">'reloadMatchers'</span><span class="s1">, undefined);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">previousConflictingPagePaths = conflictingAppPagePaths;</span>
            <span class="s2">let </span><span class="s1">clientRouterFilters;</span>
            <span class="s2">if </span><span class="s1">(nextConfig.experimental.clientRouterFilter) {</span>
                <span class="s1">clientRouterFilters = (</span><span class="s3">0</span><span class="s1">, _createclientrouterfilter.createClientRouterFilter)(Object.keys(appPaths), nextConfig.experimental.clientRouterFilterRedirects ? (nextConfig._originalRedirects || []).filter((r)=&gt;!r.internal) : [], nextConfig.experimental.clientRouterFilterAllowedRate);</span>
                <span class="s2">if </span><span class="s1">(!previousClientRouterFilters || JSON.stringify(previousClientRouterFilters) !== JSON.stringify(clientRouterFilters)) {</span>
                    <span class="s1">envChange = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">previousClientRouterFilters = clientRouterFilters;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!usingTypeScript &amp;&amp; enabledTypeScript) {</span>
                <span class="s4">// we tolerate the error here as this is best effort</span>
                <span class="s4">// and the manual install command will be shown</span>
                <span class="s2">await </span><span class="s1">verifyTypeScript(opts).then(()=&gt;{</span>
                    <span class="s1">tsconfigChange = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}).catch(()=&gt;{});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(envChange || tsconfigChange) {</span>
                <span class="s2">var </span><span class="s1">_hotReloader_activeWebpackConfigs;</span>
                <span class="s2">if </span><span class="s1">(envChange) {</span>
                    <span class="s2">var </span><span class="s1">_nextConfig_experimental;</span>
                    <span class="s2">const </span><span class="s1">{ loadedEnvFiles } = (</span><span class="s3">0</span><span class="s1">, _env.loadEnvConfig)(dir, process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">, _log, </span><span class="s2">true</span><span class="s1">, (envFilePath)=&gt;{</span>
                        <span class="s1">_log.info(</span><span class="s0">`Reload env: </span><span class="s1">${envFilePath}</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(usingTypeScript &amp;&amp; ((_nextConfig_experimental = nextConfig.experimental) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _nextConfig_experimental.typedEnv)) {</span>
                        <span class="s4">// do not await, this is not essential for further process</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _createenvdefinitions.createEnvDefinitions)({</span>
                            <span class="s1">distDir,</span>
                            <span class="s1">loadedEnvFiles: [</span>
                                <span class="s1">...loadedEnvFiles,</span>
                                <span class="s1">{</span>
                                    <span class="s1">path: nextConfig.configFileName,</span>
                                    <span class="s1">env: nextConfig.env,</span>
                                    <span class="s1">contents: </span><span class="s0">''</span>
                                <span class="s1">}</span>
                            <span class="s1">]</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">await </span><span class="s1">propagateServerField(opts, </span><span class="s0">'loadEnvConfig'</span><span class="s1">, [</span>
                        <span class="s1">{</span>
                            <span class="s1">dev: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">forceReload: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">silent: </span><span class="s2">true</span>
                        <span class="s1">}</span>
                    <span class="s1">]);</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">tsconfigResult;</span>
                <span class="s2">if </span><span class="s1">(tsconfigChange) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s1">tsconfigResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadjsconfig.default)(dir, nextConfig);</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_) {</span>
                    <span class="s4">/* do we want to log if there are syntax errors in tsconfig while editing? */ </span><span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(hotReloader.turbopackProject) {</span>
                    <span class="s2">var </span><span class="s1">_opts_nextConfig_turbopack;</span>
                    <span class="s2">const </span><span class="s1">hasRewrites = opts.fsChecker.rewrites.afterFiles.length &gt; </span><span class="s3">0 </span><span class="s1">|| opts.fsChecker.rewrites.beforeFiles.length &gt; </span><span class="s3">0 </span><span class="s1">|| opts.fsChecker.rewrites.fallback.length &gt; </span><span class="s3">0</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">rootPath = ((_opts_nextConfig_turbopack = opts.nextConfig.turbopack) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _opts_nextConfig_turbopack.root) || opts.nextConfig.outputFileTracingRoot || opts.dir;</span>
                    <span class="s2">await </span><span class="s1">hotReloader.turbopackProject.update({</span>
                        <span class="s1">defineEnv: (</span><span class="s3">0</span><span class="s1">, _swc.createDefineEnv)({</span>
                            <span class="s1">isTurbopack: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">clientRouterFilters,</span>
                            <span class="s1">config: nextConfig,</span>
                            <span class="s1">dev: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">distDir,</span>
                            <span class="s1">fetchCacheKeyPrefix: opts.nextConfig.experimental.fetchCacheKeyPrefix,</span>
                            <span class="s1">hasRewrites,</span>
                            <span class="s4">// TODO: Implement</span>
                            <span class="s1">middlewareMatchers: undefined,</span>
                            <span class="s1">projectPath: opts.dir,</span>
                            <span class="s1">rewrites: opts.fsChecker.rewrites</span>
                        <span class="s1">}),</span>
                        <span class="s1">rootPath,</span>
                        <span class="s1">projectPath: (</span><span class="s3">0</span><span class="s1">, _normalizepath.normalizePath)(_path.default.relative(rootPath, dir))</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">(_hotReloader_activeWebpackConfigs = hotReloader.activeWebpackConfigs) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _hotReloader_activeWebpackConfigs.forEach((config, idx)=&gt;{</span>
                    <span class="s2">const </span><span class="s1">isClient = idx === </span><span class="s3">0</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">isNodeServer = idx === </span><span class="s3">1</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">isEdgeServer = idx === </span><span class="s3">2</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">hasRewrites = opts.fsChecker.rewrites.afterFiles.length &gt; </span><span class="s3">0 </span><span class="s1">|| opts.fsChecker.rewrites.beforeFiles.length &gt; </span><span class="s3">0 </span><span class="s1">|| opts.fsChecker.rewrites.fallback.length &gt; </span><span class="s3">0</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(tsconfigChange) {</span>
                        <span class="s2">var </span><span class="s1">_config_resolve_plugins, _config_resolve;</span>
                        <span class="s1">(_config_resolve = config.resolve) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_config_resolve_plugins = _config_resolve.plugins) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _config_resolve_plugins.forEach((plugin)=&gt;{</span>
                            <span class="s4">// look for the JsConfigPathsPlugin and update with</span>
                            <span class="s4">// the latest paths/baseUrl config</span>
                            <span class="s2">if </span><span class="s1">(plugin </span><span class="s2">instanceof </span><span class="s1">_jsconfigpathsplugin.JsConfigPathsPlugin &amp;&amp; tsconfigResult) {</span>
                                <span class="s2">var </span><span class="s1">_config_resolve_modules, _config_resolve, _jsConfig_compilerOptions;</span>
                                <span class="s2">const </span><span class="s1">{ resolvedBaseUrl, jsConfig } = tsconfigResult;</span>
                                <span class="s2">const </span><span class="s1">currentResolvedBaseUrl = plugin.resolvedBaseUrl;</span>
                                <span class="s2">const </span><span class="s1">resolvedUrlIndex = (_config_resolve = config.resolve) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_config_resolve_modules = _config_resolve.modules) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _config_resolve_modules.findIndex((item)=&gt;item === (currentResolvedBaseUrl == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: currentResolvedBaseUrl.baseUrl));</span>
                                <span class="s2">if </span><span class="s1">(resolvedBaseUrl) {</span>
                                    <span class="s2">if </span><span class="s1">(resolvedBaseUrl.baseUrl !== (currentResolvedBaseUrl == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: currentResolvedBaseUrl.baseUrl)) {</span>
                                        <span class="s4">// remove old baseUrl and add new one</span>
                                        <span class="s2">if </span><span class="s1">(resolvedUrlIndex &amp;&amp; resolvedUrlIndex &gt; -</span><span class="s3">1</span><span class="s1">) {</span>
                                            <span class="s2">var </span><span class="s1">_config_resolve_modules1, _config_resolve1;</span>
                                            <span class="s1">(_config_resolve1 = config.resolve) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_config_resolve_modules1 = _config_resolve1.modules) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _config_resolve_modules1.splice(resolvedUrlIndex, </span><span class="s3">1</span><span class="s1">);</span>
                                        <span class="s1">}</span>
                                        <span class="s4">// If the resolvedBaseUrl is implicit we only remove the previous value.</span>
                                        <span class="s4">// Only add the baseUrl if it's explicitly set in tsconfig/jsconfig</span>
                                        <span class="s2">if </span><span class="s1">(!resolvedBaseUrl.isImplicit) {</span>
                                            <span class="s2">var </span><span class="s1">_config_resolve_modules2, _config_resolve2;</span>
                                            <span class="s1">(_config_resolve2 = config.resolve) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_config_resolve_modules2 = _config_resolve2.modules) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _config_resolve_modules2.push(resolvedBaseUrl.baseUrl);</span>
                                        <span class="s1">}</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                                <span class="s2">if </span><span class="s1">((jsConfig == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_jsConfig_compilerOptions = jsConfig.compilerOptions) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _jsConfig_compilerOptions.paths) &amp;&amp; resolvedBaseUrl) {</span>
                                    <span class="s1">Object.keys(plugin.paths).forEach((key)=&gt;{</span>
                                        <span class="s2">delete </span><span class="s1">plugin.paths[key];</span>
                                    <span class="s1">});</span>
                                    <span class="s1">Object.assign(plugin.paths, jsConfig.compilerOptions.paths);</span>
                                    <span class="s1">plugin.resolvedBaseUrl = resolvedBaseUrl;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(envChange) {</span>
                        <span class="s2">var </span><span class="s1">_config_plugins;</span>
                        <span class="s1">(_config_plugins = config.plugins) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _config_plugins.forEach((plugin)=&gt;{</span>
                            <span class="s4">// we look for the DefinePlugin definitions so we can</span>
                            <span class="s4">// update them on the active compilers</span>
                            <span class="s2">if </span><span class="s1">(plugin &amp;&amp; </span><span class="s2">typeof </span><span class="s1">plugin.definitions === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; plugin.definitions.__NEXT_DEFINE_ENV) {</span>
                                <span class="s2">const </span><span class="s1">newDefine = (</span><span class="s3">0</span><span class="s1">, _defineenv.getDefineEnv)({</span>
                                    <span class="s1">isTurbopack: </span><span class="s2">false</span><span class="s1">,</span>
                                    <span class="s1">clientRouterFilters,</span>
                                    <span class="s1">config: nextConfig,</span>
                                    <span class="s1">dev: </span><span class="s2">true</span><span class="s1">,</span>
                                    <span class="s1">distDir,</span>
                                    <span class="s1">fetchCacheKeyPrefix: opts.nextConfig.experimental.fetchCacheKeyPrefix,</span>
                                    <span class="s1">hasRewrites,</span>
                                    <span class="s1">isClient,</span>
                                    <span class="s1">isEdgeServer,</span>
                                    <span class="s1">isNodeServer,</span>
                                    <span class="s1">middlewareMatchers: undefined,</span>
                                    <span class="s1">projectPath: opts.dir,</span>
                                    <span class="s1">rewrites: opts.fsChecker.rewrites</span>
                                <span class="s1">});</span>
                                <span class="s1">Object.keys(plugin.definitions).forEach((key)=&gt;{</span>
                                    <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">newDefine)) {</span>
                                        <span class="s2">delete </span><span class="s1">plugin.definitions[key];</span>
                                    <span class="s1">}</span>
                                <span class="s1">});</span>
                                <span class="s1">Object.assign(plugin.definitions, newDefine);</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s2">await </span><span class="s1">hotReloader.invalidate({</span>
                    <span class="s1">reloadAfterInvalidation: envChange</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(nestedMiddleware.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">_log.error(Object.defineProperty(</span><span class="s2">new </span><span class="s1">_utils1.NestedMiddlewareError(nestedMiddleware, dir, pagesDir || appDir), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">}).message);</span>
                <span class="s1">nestedMiddleware = [];</span>
            <span class="s1">}</span>
            <span class="s4">// Make sure to sort parallel routes to make the result deterministic.</span>
            <span class="s1">serverFields.appPathRoutes = Object.fromEntries(Object.entries(appPaths).map(([k, v])=&gt;[</span>
                    <span class="s1">k,</span>
                    <span class="s1">v.sort()</span>
                <span class="s1">]));</span>
            <span class="s2">await </span><span class="s1">propagateServerField(opts, </span><span class="s0">'appPathRoutes'</span><span class="s1">, serverFields.appPathRoutes);</span>
            <span class="s4">// TODO: pass this to fsChecker/next-dev-server?</span>
            <span class="s1">serverFields.middleware = middlewareMatchers ? {</span>
                <span class="s1">match: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">page: </span><span class="s0">'/'</span><span class="s1">,</span>
                <span class="s1">matchers: middlewareMatchers</span>
            <span class="s1">} : undefined;</span>
            <span class="s2">await </span><span class="s1">propagateServerField(opts, </span><span class="s0">'middleware'</span><span class="s1">, serverFields.middleware);</span>
            <span class="s1">serverFields.hasAppNotFound = hasRootAppNotFound;</span>
            <span class="s1">opts.fsChecker.middlewareMatcher = ((_serverFields_middleware = serverFields.middleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _serverFields_middleware.matchers) ? (</span><span class="s3">0</span><span class="s1">, _middlewareroutematcher.getMiddlewareRouteMatcher)((_serverFields_middleware1 = serverFields.middleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _serverFields_middleware1.matchers) : undefined;</span>
            <span class="s2">const </span><span class="s1">interceptionRoutes = (</span><span class="s3">0</span><span class="s1">, _generateinterceptionroutesrewrites.generateInterceptionRoutesRewrites)(Object.keys(appPaths), opts.nextConfig.basePath).map((item)=&gt;(</span><span class="s3">0</span><span class="s1">, _filesystem.buildCustomRoute)(</span><span class="s0">'before_files_rewrite'</span><span class="s1">, item, opts.nextConfig.basePath, opts.nextConfig.experimental.caseSensitiveRoutes));</span>
            <span class="s1">opts.fsChecker.rewrites.beforeFiles.push(...interceptionRoutes);</span>
            <span class="s2">const </span><span class="s1">exportPathMap = </span><span class="s2">typeof </span><span class="s1">nextConfig.exportPathMap === </span><span class="s0">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">await </span><span class="s1">(nextConfig.exportPathMap == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: nextConfig.exportPathMap.call(nextConfig, {}, {</span>
                <span class="s1">dev: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">dir: opts.dir,</span>
                <span class="s1">outDir: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">distDir: distDir,</span>
                <span class="s1">buildId: </span><span class="s0">'development'</span>
            <span class="s1">})) || {};</span>
            <span class="s2">const </span><span class="s1">exportPathMapEntries = Object.entries(exportPathMap || {});</span>
            <span class="s2">if </span><span class="s1">(exportPathMapEntries.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">opts.fsChecker.exportPathMapRoutes = exportPathMapEntries.map(([key, value])=&gt;(</span><span class="s3">0</span><span class="s1">, _filesystem.buildCustomRoute)(</span><span class="s0">'before_files_rewrite'</span><span class="s1">, {</span>
                        <span class="s1">source: key,</span>
                        <span class="s1">destination: </span><span class="s0">`</span><span class="s1">${value.page}${value.query ? </span><span class="s0">'?' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${_querystring.default.stringify(value.query)}</span><span class="s0">`</span>
                    <span class="s1">}, opts.nextConfig.basePath, opts.nextConfig.experimental.caseSensitiveRoutes));</span>
            <span class="s1">}</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s4">// we serve a separate manifest with all pages for the client in</span>
                <span class="s4">// dev mode so that we can match a page after a rewrite on the client</span>
                <span class="s4">// before it has been built and is populated in the _buildManifest</span>
                <span class="s2">const </span><span class="s1">sortedRoutes = (</span><span class="s3">0</span><span class="s1">, _utils.getSortedRoutes)(routedPages);</span>
                <span class="s1">opts.fsChecker.dynamicRoutes = sortedRoutes.map((page)=&gt;{</span>
                    <span class="s2">const </span><span class="s1">regex = (</span><span class="s3">0</span><span class="s1">, _routeregex.getRouteRegex)(page);</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">regex: regex.re.toString(),</span>
                        <span class="s1">match: (</span><span class="s3">0</span><span class="s1">, _routematcher.getRouteMatcher)(regex),</span>
                        <span class="s1">page</span>
                    <span class="s1">};</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">dataRoutes = [];</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">page of sortedRoutes){</span>
                    <span class="s2">const </span><span class="s1">route = (</span><span class="s3">0</span><span class="s1">, _builddataroute.buildDataRoute)(page, </span><span class="s0">'development'</span><span class="s1">);</span>
                    <span class="s2">const </span><span class="s1">routeRegex = (</span><span class="s3">0</span><span class="s1">, _routeregex.getRouteRegex)(route.page);</span>
                    <span class="s1">dataRoutes.push({</span>
                        <span class="s1">...route,</span>
                        <span class="s1">regex: routeRegex.re.toString(),</span>
                        <span class="s1">match: (</span><span class="s3">0</span><span class="s1">, _routematcher.getRouteMatcher)({</span>
                            <span class="s4">// TODO: fix this in the manifest itself, must also be fixed in</span>
                            <span class="s4">// upstream builder that relies on this</span>
                            <span class="s1">re: opts.nextConfig.i18n ? </span><span class="s2">new </span><span class="s1">RegExp(route.dataRouteRegex.replace(</span><span class="s0">`/development/`</span><span class="s1">, </span><span class="s0">`/development/(?&lt;nextLocale&gt;[^/]+?)/`</span><span class="s1">)) : </span><span class="s2">new </span><span class="s1">RegExp(route.dataRouteRegex),</span>
                            <span class="s1">groups: routeRegex.groups</span>
                        <span class="s1">})</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">opts.fsChecker.dynamicRoutes.unshift(...dataRoutes);</span>
                <span class="s2">if </span><span class="s1">(!(prevSortedRoutes == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: prevSortedRoutes.every((val, idx)=&gt;val === sortedRoutes[idx]))) {</span>
                    <span class="s2">const </span><span class="s1">addedRoutes = sortedRoutes.filter((route)=&gt;!prevSortedRoutes.includes(route));</span>
                    <span class="s2">const </span><span class="s1">removedRoutes = prevSortedRoutes.filter((route)=&gt;!sortedRoutes.includes(route));</span>
                    <span class="s4">// emit the change so clients fetch the update</span>
                    <span class="s1">hotReloader.send({</span>
                        <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE,</span>
                        <span class="s1">data: [</span>
                            <span class="s1">{</span>
                                <span class="s1">devPagesManifest: </span><span class="s2">true</span>
                            <span class="s1">}</span>
                        <span class="s1">]</span>
                    <span class="s1">});</span>
                    <span class="s1">addedRoutes.forEach((route)=&gt;{</span>
                        <span class="s1">hotReloader.send({</span>
                            <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE,</span>
                            <span class="s1">data: [</span>
                                <span class="s1">route</span>
                            <span class="s1">]</span>
                        <span class="s1">});</span>
                    <span class="s1">});</span>
                    <span class="s1">removedRoutes.forEach((route)=&gt;{</span>
                        <span class="s1">hotReloader.send({</span>
                            <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE,</span>
                            <span class="s1">data: [</span>
                                <span class="s1">route</span>
                            <span class="s1">]</span>
                        <span class="s1">});</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">prevSortedRoutes = sortedRoutes;</span>
                <span class="s2">if </span><span class="s1">(usingTypeScript) {</span>
                    <span class="s2">const </span><span class="s1">routeTypesManifest = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _routetypesutils.createRouteTypesManifest)({</span>
                        <span class="s1">dir,</span>
                        <span class="s1">pageRoutes,</span>
                        <span class="s1">appRoutes,</span>
                        <span class="s1">layoutRoutes,</span>
                        <span class="s1">slots,</span>
                        <span class="s1">redirects: opts.nextConfig.redirects,</span>
                        <span class="s1">rewrites: opts.nextConfig.rewrites,</span>
                        <span class="s4">// Ensure relative paths in validator.ts are computed from validatorFilePath,</span>
                        <span class="s4">// matching behavior of build and CLI typegen.</span>
                        <span class="s1">validatorFilePath,</span>
                        <span class="s1">appRouteHandlers,</span>
                        <span class="s1">pageApiRoutes</span>
                    <span class="s1">});</span>
                    <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _routetypesutils.writeRouteTypesManifest)(routeTypesManifest, routeTypesFilePath, opts.nextConfig);</span>
                    <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _routetypesutils.writeValidatorFile)(routeTypesManifest, validatorFilePath);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!resolved) {</span>
                    <span class="s1">resolve();</span>
                    <span class="s1">resolved = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                <span class="s2">if </span><span class="s1">(!resolved) {</span>
                    <span class="s1">reject(e);</span>
                    <span class="s1">resolved = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">_log.warn(</span><span class="s0">'Failed to reload dynamic routes:'</span><span class="s1">, e);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s4">// Reload the matchers. The filesystem would have been written to,</span>
                <span class="s4">// and the matchers need to re-scan it to update the router.</span>
                <span class="s2">await </span><span class="s1">propagateServerField(opts, </span><span class="s0">'reloadMatchers'</span><span class="s1">, undefined);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">wp.watch({</span>
            <span class="s1">directories: [</span>
                <span class="s1">dir</span>
            <span class="s1">],</span>
            <span class="s1">startTime: </span><span class="s3">0</span>
        <span class="s1">});</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">clientPagesManifestPath = </span><span class="s0">`/_next/</span><span class="s1">${_constants.CLIENT_STATIC_FILES_PATH}</span><span class="s0">/development/</span><span class="s1">${_constants.DEV_CLIENT_PAGES_MANIFEST}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">opts.fsChecker.devVirtualFsItems.add(clientPagesManifestPath);</span>
    <span class="s2">const </span><span class="s1">devMiddlewareManifestPath = </span><span class="s0">`/_next/</span><span class="s1">${_constants.CLIENT_STATIC_FILES_PATH}</span><span class="s0">/development/</span><span class="s1">${_constants.DEV_CLIENT_MIDDLEWARE_MANIFEST}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">opts.fsChecker.devVirtualFsItems.add(devMiddlewareManifestPath);</span>
    <span class="s2">const </span><span class="s1">devTurbopackMiddlewareManifestPath = </span><span class="s0">`/_next/</span><span class="s1">${_constants.CLIENT_STATIC_FILES_PATH}</span><span class="s0">/development/</span><span class="s1">${_constants.TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">opts.fsChecker.devVirtualFsItems.add(devTurbopackMiddlewareManifestPath);</span>
    <span class="s1">async </span><span class="s2">function </span><span class="s1">requestHandler(req, res) {</span>
        <span class="s2">var </span><span class="s1">_parsedUrl_pathname, _parsedUrl_pathname1, _parsedUrl_pathname2;</span>
        <span class="s2">const </span><span class="s1">parsedUrl = _url.default.parse(req.url || </span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">((_parsedUrl_pathname = parsedUrl.pathname) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _parsedUrl_pathname.includes(clientPagesManifestPath)) {</span>
            <span class="s1">res.statusCode = </span><span class="s3">200</span><span class="s1">;</span>
            <span class="s1">res.setHeader(</span><span class="s0">'Content-Type'</span><span class="s1">, _constants1.JSON_CONTENT_TYPE_HEADER);</span>
            <span class="s1">res.end(JSON.stringify({</span>
                <span class="s1">pages: prevSortedRoutes.filter((route)=&gt;!opts.fsChecker.appFiles.has(route))</span>
            <span class="s1">}));</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">finished: </span><span class="s2">true</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(((_parsedUrl_pathname1 = parsedUrl.pathname) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _parsedUrl_pathname1.includes(devMiddlewareManifestPath)) || ((_parsedUrl_pathname2 = parsedUrl.pathname) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _parsedUrl_pathname2.includes(devTurbopackMiddlewareManifestPath))) {</span>
            <span class="s2">var </span><span class="s1">_serverFields_middleware;</span>
            <span class="s1">res.statusCode = </span><span class="s3">200</span><span class="s1">;</span>
            <span class="s1">res.setHeader(</span><span class="s0">'Content-Type'</span><span class="s1">, _constants1.JSON_CONTENT_TYPE_HEADER);</span>
            <span class="s1">res.end(JSON.stringify(((_serverFields_middleware = serverFields.middleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _serverFields_middleware.matchers) || []));</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">finished: </span><span class="s2">true</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">finished: </span><span class="s2">false</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">logErrorWithOriginalStack(err, type) {</span>
        <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_utils2.ModuleBuildError) {</span>
            <span class="s4">// Errors that may come from issues from the user's code</span>
            <span class="s1">_log.error(err.message);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_internalerror.TurbopackInternalError) {</span>
        <span class="s4">// An internal Turbopack error that has been handled by next-swc, written</span>
        <span class="s4">// to disk and a simplified message shown to user on the Rust side.</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === </span><span class="s0">'warning'</span><span class="s1">) {</span>
            <span class="s1">_log.warn(err);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === </span><span class="s0">'app-dir'</span><span class="s1">) {</span>
            <span class="s1">_log.error(err);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type) {</span>
            <span class="s1">_log.error(</span><span class="s0">`</span><span class="s1">${type}</span><span class="s0">:`</span><span class="s1">, err);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">_log.error(err);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">serverFields,</span>
        <span class="s1">hotReloader,</span>
        <span class="s1">requestHandler,</span>
        <span class="s1">logErrorWithOriginalStack,</span>
        <span class="s1">async ensureMiddleware (requestUrl) {</span>
            <span class="s2">if </span><span class="s1">(!serverFields.actualMiddlewareFile) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s2">return </span><span class="s1">hotReloader.ensurePage({</span>
                <span class="s1">page: serverFields.actualMiddlewareFile,</span>
                <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">definition: undefined,</span>
                <span class="s1">url: requestUrl</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">setupDevBundler(opts) {</span>
    <span class="s2">const </span><span class="s1">isSrcDir = _path.default.relative(opts.dir, opts.pagesDir || opts.appDir || </span><span class="s0">''</span><span class="s1">).startsWith(</span><span class="s0">'src'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">startWatcher({</span>
        <span class="s1">...opts,</span>
        <span class="s1">isSrcDir</span>
    <span class="s1">});</span>
    <span class="s1">opts.telemetry.record((</span><span class="s3">0</span><span class="s1">, _events.eventCliSession)(_path.default.join(opts.dir, opts.nextConfig.distDir), opts.nextConfig, {</span>
        <span class="s1">webpackVersion: </span><span class="s3">5</span><span class="s1">,</span>
        <span class="s1">isSrcDir,</span>
        <span class="s1">turboFlag: !!opts.turbo,</span>
        <span class="s1">cliCommand: </span><span class="s0">'dev'</span><span class="s1">,</span>
        <span class="s1">appDir: !!opts.appDir,</span>
        <span class="s1">pagesDir: !!opts.pagesDir,</span>
        <span class="s1">isCustomServer: !!opts.isCustomServer,</span>
        <span class="s1">hasNowJson: !!</span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _findup.default)(</span><span class="s0">'now.json'</span><span class="s1">, {</span>
            <span class="s1">cwd: opts.dir</span>
        <span class="s1">})</span>
    <span class="s1">}));</span>
    <span class="s4">// Track build features for dev server here:</span>
    <span class="s1">opts.telemetry.record({</span>
        <span class="s1">eventName: _events.EVENT_BUILD_FEATURE_USAGE,</span>
        <span class="s1">payload: {</span>
            <span class="s1">featureName: </span><span class="s0">'turbopackPersistentCaching'</span><span class="s1">,</span>
            <span class="s1">invocationCount: (</span><span class="s3">0</span><span class="s1">, _utils2.isPersistentCachingEnabled)(opts.nextConfig) ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
 <span class="s4">// Returns a trace rewritten through Turbopack's sourcemaps</span>

<span class="s4">//# sourceMappingURL=setup-dev-bundler.js.map</span></pre>
</body>
</html>