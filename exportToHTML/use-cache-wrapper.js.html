<html>
<head>
<title>use-cache-wrapper.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
use-cache-wrapper.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;cache&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">cache;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_server = require(</span><span class="s0">&quot;react-server-dom-webpack/server&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_client = require(</span><span class="s0">&quot;react-server-dom-webpack/client&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_static = require(</span><span class="s0">&quot;react-server-dom-webpack/static&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrenderingutils = require(</span><span class="s0">&quot;../dynamic-rendering-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_encryptionutils = require(</span><span class="s0">&quot;../app-render/encryption-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_encryption = require(</span><span class="s0">&quot;../app-render/encryption&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createerrorhandler = require(</span><span class="s0">&quot;../app-render/create-error-handler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;./constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_handlers = require(</span><span class="s0">&quot;./handlers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_usecacheerrors = require(</span><span class="s0">&quot;./use-cache-errors&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrendering = require(</span><span class="s0">&quot;../app-render/dynamic-rendering&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_searchparams = require(</span><span class="s0">&quot;../request/search-params&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_lazyresult = require(</span><span class="s0">&quot;../lib/lazy-result&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicaccessasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/dynamic-access-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_reactlargeshellerror = require(</span><span class="s0">&quot;../app-render/react-large-shell-error&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">isEdgeRuntime = process.env.NEXT_RUNTIME === </span><span class="s0">'edge'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">debug = process.env.NEXT_PRIVATE_DEBUG_CACHE ? console.debug.bind(console, </span><span class="s0">'use-cache:'</span><span class="s1">) : undefined;</span>
<span class="s2">const </span><span class="s1">filterStackFrame = process.env.NODE_ENV !== </span><span class="s0">'production' </span><span class="s1">? require(</span><span class="s0">'../lib/source-maps'</span><span class="s1">).filterStackFrameDEV : undefined;</span>
<span class="s2">const </span><span class="s1">findSourceMapURL = process.env.NODE_ENV !== </span><span class="s0">'production' </span><span class="s1">? require(</span><span class="s0">'../lib/source-maps'</span><span class="s1">).findSourceMapURLDEV : undefined;</span>
<span class="s2">function </span><span class="s1">generateCacheEntry(workStore, cacheContext, clientReferenceManifest, encodedArguments, fn, sharedErrorStack) {</span>
    <span class="s3">// We need to run this inside a clean AsyncLocalStorage snapshot so that the cache</span>
    <span class="s3">// generation cannot read anything from the context we're currently executing which</span>
    <span class="s3">// might include request specific things like cookies() inside a React.cache().</span>
    <span class="s3">// Note: It is important that we await at least once before this because it lets us</span>
    <span class="s3">// pop out of any stack specific contexts as well - aka &quot;Sync&quot; Local Storage.</span>
    <span class="s2">return </span><span class="s1">workStore.runInCleanSnapshot(generateCacheEntryWithRestoredWorkStore, workStore, cacheContext, clientReferenceManifest, encodedArguments, fn, sharedErrorStack);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateCacheEntryWithRestoredWorkStore(workStore, cacheContext, clientReferenceManifest, encodedArguments, fn, sharedErrorStack) {</span>
    <span class="s3">// Since we cleared the AsyncLocalStorage we need to restore the workStore.</span>
    <span class="s3">// Note: We explicitly don't restore the RequestStore nor the PrerenderStore.</span>
    <span class="s3">// We don't want any request specific information leaking an we don't want to create a</span>
    <span class="s3">// bloated fake request mock for every cache call. So any feature that currently lives</span>
    <span class="s3">// in RequestStore but should be available to Caches need to move to WorkStore.</span>
    <span class="s3">// PrerenderStore is not needed inside the cache scope because the outer most one will</span>
    <span class="s3">// be the one to report its result to the outer Prerender.</span>
    <span class="s2">return </span><span class="s1">_workasyncstorageexternal.workAsyncStorage.run(workStore, generateCacheEntryWithCacheContext, workStore, cacheContext, clientReferenceManifest, encodedArguments, fn, sharedErrorStack);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createUseCacheStore(workStore, cacheContext, defaultCacheLife) {</span>
    <span class="s2">if </span><span class="s1">(cacheContext.kind === </span><span class="s0">'private'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">outerWorkUnitStore = cacheContext.outerWorkUnitStore;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: </span><span class="s0">'private-cache'</span><span class="s1">,</span>
            <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
            <span class="s1">implicitTags: outerWorkUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: outerWorkUnitStore.implicitTags,</span>
            <span class="s1">revalidate: defaultCacheLife.revalidate,</span>
            <span class="s1">expire: defaultCacheLife.expire,</span>
            <span class="s1">stale: defaultCacheLife.stale,</span>
            <span class="s1">explicitRevalidate: undefined,</span>
            <span class="s1">explicitExpire: undefined,</span>
            <span class="s1">explicitStale: undefined,</span>
            <span class="s1">tags: </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">hmrRefreshHash: (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getHmrRefreshHash)(workStore, outerWorkUnitStore),</span>
            <span class="s1">isHmrRefresh: (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.isHmrRefresh)(workStore, outerWorkUnitStore),</span>
            <span class="s1">serverComponentsHmrCache: (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getServerComponentsHmrCache)(workStore, outerWorkUnitStore),</span>
            <span class="s1">forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),</span>
            <span class="s1">runtimeStagePromise: (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getRuntimeStagePromise)(outerWorkUnitStore),</span>
            <span class="s1">draftMode: (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getDraftModeProviderForCacheScope)(workStore, outerWorkUnitStore),</span>
            <span class="s1">rootParams: outerWorkUnitStore.rootParams,</span>
            <span class="s1">cookies: outerWorkUnitStore.cookies</span>
        <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">let </span><span class="s1">useCacheOrRequestStore;</span>
        <span class="s2">const </span><span class="s1">outerWorkUnitStore = cacheContext.outerWorkUnitStore;</span>
        <span class="s2">if </span><span class="s1">(outerWorkUnitStore) {</span>
            <span class="s2">switch</span><span class="s1">(outerWorkUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: outerWorkUnitStore.type){</span>
                <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s1">useCacheOrRequestStore = outerWorkUnitStore;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">outerWorkUnitStore;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: </span><span class="s0">'cache'</span><span class="s1">,</span>
            <span class="s1">phase: </span><span class="s0">'render'</span><span class="s1">,</span>
            <span class="s1">implicitTags: outerWorkUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: outerWorkUnitStore.implicitTags,</span>
            <span class="s1">revalidate: defaultCacheLife.revalidate,</span>
            <span class="s1">expire: defaultCacheLife.expire,</span>
            <span class="s1">stale: defaultCacheLife.stale,</span>
            <span class="s1">explicitRevalidate: undefined,</span>
            <span class="s1">explicitExpire: undefined,</span>
            <span class="s1">explicitStale: undefined,</span>
            <span class="s1">tags: </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">hmrRefreshHash: outerWorkUnitStore &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getHmrRefreshHash)(workStore, outerWorkUnitStore),</span>
            <span class="s1">isHmrRefresh: (useCacheOrRequestStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: useCacheOrRequestStore.isHmrRefresh) ?? </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">serverComponentsHmrCache: useCacheOrRequestStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: useCacheOrRequestStore.serverComponentsHmrCache,</span>
            <span class="s1">forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),</span>
            <span class="s1">draftMode: outerWorkUnitStore &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getDraftModeProviderForCacheScope)(workStore, outerWorkUnitStore)</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assertDefaultCacheLife(defaultCacheLife) {</span>
    <span class="s2">if </span><span class="s1">(!defaultCacheLife || defaultCacheLife.revalidate == </span><span class="s2">null </span><span class="s1">|| defaultCacheLife.expire == </span><span class="s2">null </span><span class="s1">|| defaultCacheLife.stale == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'A default cacheLife profile must always be provided.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E750&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateCacheEntryWithCacheContext(workStore, cacheContext, clientReferenceManifest, encodedArguments, fn, sharedErrorStack) {</span>
    <span class="s2">if </span><span class="s1">(!workStore.cacheLifeProfiles) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'cacheLifeProfiles should always be provided.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E748&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">defaultCacheLife = workStore.cacheLifeProfiles[</span><span class="s0">'default'</span><span class="s1">];</span>
    <span class="s1">assertDefaultCacheLife(defaultCacheLife);</span>
    <span class="s3">// Initialize the Store for this Cache entry.</span>
    <span class="s2">const </span><span class="s1">cacheStore = createUseCacheStore(workStore, cacheContext, defaultCacheLife);</span>
    <span class="s2">return </span><span class="s1">_workunitasyncstorageexternal.workUnitAsyncStorage.run(cacheStore, ()=&gt;_dynamicaccessasyncstorageexternal.dynamicAccessAsyncStorage.run({</span>
            <span class="s1">abortController: </span><span class="s2">new </span><span class="s1">AbortController()</span>
        <span class="s1">}, generateCacheEntryImpl, workStore, cacheContext, cacheStore, clientReferenceManifest, encodedArguments, fn, sharedErrorStack));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">propagateCacheLifeAndTagsToRevalidateStore(revalidateStore, entry) {</span>
    <span class="s2">const </span><span class="s1">outerTags = revalidateStore.tags ??= [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">tag of entry.tags){</span>
        <span class="s2">if </span><span class="s1">(!outerTags.includes(tag)) {</span>
            <span class="s1">outerTags.push(tag);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(revalidateStore.stale &gt; entry.stale) {</span>
        <span class="s1">revalidateStore.stale = entry.stale;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(revalidateStore.revalidate &gt; entry.revalidate) {</span>
        <span class="s1">revalidateStore.revalidate = entry.revalidate;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(revalidateStore.expire &gt; entry.expire) {</span>
        <span class="s1">revalidateStore.expire = entry.expire;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">propagateCacheLifeAndTags(cacheContext, entry) {</span>
    <span class="s2">if </span><span class="s1">(cacheContext.kind === </span><span class="s0">'private'</span><span class="s1">) {</span>
        <span class="s2">switch</span><span class="s1">(cacheContext.outerWorkUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                <span class="s1">propagateCacheLifeAndTagsToRevalidateStore(cacheContext.outerWorkUnitStore, entry);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s1">undefined:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">cacheContext.outerWorkUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_cacheContext_outerWorkUnitStore;</span>
        <span class="s2">switch</span><span class="s1">((_cacheContext_outerWorkUnitStore = cacheContext.outerWorkUnitStore) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _cacheContext_outerWorkUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s1">propagateCacheLifeAndTagsToRevalidateStore(cacheContext.outerWorkUnitStore, entry);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s1">undefined:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">cacheContext.outerWorkUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">collectResult(savedStream, workStore, cacheContext, innerCacheStore, startTime, errors) {</span>
    <span class="s3">// We create a buffered stream that collects all chunks until the end to</span>
    <span class="s3">// ensure that RSC has finished rendering and therefore we have collected</span>
    <span class="s3">// all tags. In the future the RSC API might allow for the equivalent of</span>
    <span class="s3">// the allReady Promise that exists on SSR streams.</span>
    <span class="s3">//</span>
    <span class="s3">// If something errored or rejected anywhere in the render, we close</span>
    <span class="s3">// the stream as errored. This lets a CacheHandler choose to save the</span>
    <span class="s3">// partial result up until that point for future hits for a while to avoid</span>
    <span class="s3">// unnecessary retries or not to retry. We use the end of the stream for</span>
    <span class="s3">// this to avoid another complicated side-channel. A receiver has to consider</span>
    <span class="s3">// that the stream might also error for other reasons anyway such as losing</span>
    <span class="s3">// connection.</span>
    <span class="s2">const </span><span class="s1">buffer = [];</span>
    <span class="s2">const </span><span class="s1">reader = savedStream.getReader();</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">entry; !(entry = </span><span class="s2">await </span><span class="s1">reader.read()).done;){</span>
            <span class="s1">buffer.push(entry.value);</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
        <span class="s1">errors.push(error);</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">idx = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">bufferStream = </span><span class="s2">new </span><span class="s1">ReadableStream({</span>
        <span class="s1">pull (controller) {</span>
            <span class="s2">if </span><span class="s1">(workStore.invalidDynamicUsageError) {</span>
                <span class="s1">controller.error(workStore.invalidDynamicUsageError);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(idx &lt; buffer.length) {</span>
                <span class="s1">controller.enqueue(buffer[idx++]);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(errors.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">// TODO: Should we use AggregateError here?</span>
                <span class="s1">controller.error(errors[</span><span class="s4">0</span><span class="s1">]);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">controller.close();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">collectedTags = innerCacheStore.tags;</span>
    <span class="s3">// If cacheLife() was used to set an explicit revalidate time we use that.</span>
    <span class="s3">// Otherwise, we use the lowest of all inner fetch()/unstable_cache() or nested &quot;use cache&quot;.</span>
    <span class="s3">// If they're lower than our default.</span>
    <span class="s2">const </span><span class="s1">collectedRevalidate = innerCacheStore.explicitRevalidate !== undefined ? innerCacheStore.explicitRevalidate : innerCacheStore.revalidate;</span>
    <span class="s2">const </span><span class="s1">collectedExpire = innerCacheStore.explicitExpire !== undefined ? innerCacheStore.explicitExpire : innerCacheStore.expire;</span>
    <span class="s2">const </span><span class="s1">collectedStale = innerCacheStore.explicitStale !== undefined ? innerCacheStore.explicitStale : innerCacheStore.stale;</span>
    <span class="s2">const </span><span class="s1">entry = {</span>
        <span class="s1">value: bufferStream,</span>
        <span class="s1">timestamp: startTime,</span>
        <span class="s1">revalidate: collectedRevalidate,</span>
        <span class="s1">expire: collectedExpire,</span>
        <span class="s1">stale: collectedStale,</span>
        <span class="s1">tags: collectedTags === </span><span class="s2">null </span><span class="s1">? [] : collectedTags</span>
    <span class="s1">};</span>
    <span class="s3">// Propagate tags/revalidate to the parent context.</span>
    <span class="s2">if </span><span class="s1">(cacheContext) {</span>
        <span class="s1">propagateCacheLifeAndTags(cacheContext, entry);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">cacheSignal = cacheContext.outerWorkUnitStore ? (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getCacheSignal)(cacheContext.outerWorkUnitStore) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
        <span class="s1">cacheSignal.endRead();</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">entry;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">generateCacheEntryImpl(workStore, cacheContext, innerCacheStore, clientReferenceManifest, encodedArguments, fn, sharedErrorStack) {</span>
    <span class="s2">const </span><span class="s1">temporaryReferences = (</span><span class="s4">0</span><span class="s1">, _server.createTemporaryReferenceSet)();</span>
    <span class="s2">const </span><span class="s1">outerWorkUnitStore = cacheContext.outerWorkUnitStore;</span>
    <span class="s2">const </span><span class="s1">[, , args] = </span><span class="s2">typeof </span><span class="s1">encodedArguments === </span><span class="s0">'string' </span><span class="s1">? </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _server.decodeReply)(encodedArguments, (</span><span class="s4">0</span><span class="s1">, _encryptionutils.getServerModuleMap)(), {</span>
        <span class="s1">temporaryReferences</span>
    <span class="s1">}) : </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _server.decodeReplyFromAsyncIterable)({</span>
        <span class="s1">async *[Symbol.asyncIterator] () {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entry of encodedArguments){</span>
                <span class="s2">yield </span><span class="s1">entry;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(outerWorkUnitStore) {</span>
                <span class="s2">switch</span><span class="s1">(outerWorkUnitStore.type){</span>
                    <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                        <span class="s3">// The encoded arguments might contain hanging promises. In</span>
                        <span class="s3">// this case we don't want to reject with &quot;Error: Connection</span>
                        <span class="s3">// closed.&quot;, so we intentionally keep the iterable alive.</span>
                        <span class="s3">// This is similar to the halting trick that we do while</span>
                        <span class="s3">// rendering.</span>
                        <span class="s2">await new </span><span class="s1">Promise((resolve)=&gt;{</span>
                            <span class="s2">if </span><span class="s1">(outerWorkUnitStore.renderSignal.aborted) {</span>
                                <span class="s1">resolve();</span>
                            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                <span class="s1">outerWorkUnitStore.renderSignal.addEventListener(</span><span class="s0">'abort'</span><span class="s1">, ()=&gt;resolve(), {</span>
                                    <span class="s1">once: </span><span class="s2">true</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">outerWorkUnitStore;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}, (</span><span class="s4">0</span><span class="s1">, _encryptionutils.getServerModuleMap)(), {</span>
        <span class="s1">temporaryReferences</span>
    <span class="s1">});</span>
    <span class="s3">// Track the timestamp when we started computing the result.</span>
    <span class="s2">const </span><span class="s1">startTime = performance.timeOrigin + performance.now();</span>
    <span class="s3">// Invoke the inner function to load a new result. We delay the invocation</span>
    <span class="s3">// though, until React awaits the promise so that React's request store (ALS)</span>
    <span class="s3">// is available when the function is invoked. This allows us, for example, to</span>
    <span class="s3">// capture logs so that we can later replay them.</span>
    <span class="s2">const </span><span class="s1">resultPromise = (</span><span class="s4">0</span><span class="s1">, _lazyresult.createLazyResult)(()=&gt;fn.apply(</span><span class="s2">null</span><span class="s1">, args));</span>
    <span class="s2">let </span><span class="s1">errors = [];</span>
    <span class="s3">// In the &quot;Cache&quot; environment, we only need to make sure that the error</span>
    <span class="s3">// digests are handled correctly. Error formatting and reporting is not</span>
    <span class="s3">// necessary here; the errors are encoded in the stream, and will be reported</span>
    <span class="s3">// in the &quot;Server&quot; environment.</span>
    <span class="s2">const </span><span class="s1">handleError = (error)=&gt;{</span>
        <span class="s2">const </span><span class="s1">digest = (</span><span class="s4">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(error);</span>
        <span class="s2">if </span><span class="s1">(digest) {</span>
            <span class="s2">return </span><span class="s1">digest;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _reactlargeshellerror.isReactLargeShellError)(error)) {</span>
            <span class="s3">// TODO: Aggregate</span>
            <span class="s1">console.error(error);</span>
            <span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'development'</span><span class="s1">) {</span>
            <span class="s3">// TODO: For now we're also reporting the error here, because in</span>
            <span class="s3">// production, the &quot;Server&quot; environment will only get the obfuscated</span>
            <span class="s3">// error (created by the Flight Client in the cache wrapper).</span>
            <span class="s1">console.error(error);</span>
        <span class="s1">}</span>
        <span class="s1">errors.push(error);</span>
    <span class="s1">};</span>
    <span class="s2">let </span><span class="s1">stream;</span>
    <span class="s2">switch</span><span class="s1">(outerWorkUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: outerWorkUnitStore.type){</span>
        <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">var </span><span class="s1">_dynamicAccessAsyncStorage_getStore;</span>
            <span class="s2">const </span><span class="s1">timeoutAbortController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
            <span class="s3">// If we're prerendering, we give you 50 seconds to fill a cache entry.</span>
            <span class="s3">// Otherwise we assume you stalled on hanging input and de-opt. This needs</span>
            <span class="s3">// to be lower than just the general timeout of 60 seconds.</span>
            <span class="s2">const </span><span class="s1">timer = setTimeout(()=&gt;{</span>
                <span class="s2">const </span><span class="s1">error = </span><span class="s2">new </span><span class="s1">_usecacheerrors.UseCacheTimeoutError();</span>
                <span class="s2">if </span><span class="s1">(sharedErrorStack) {</span>
                    <span class="s1">error.stack = error.name + </span><span class="s0">': ' </span><span class="s1">+ error.message + sharedErrorStack;</span>
                <span class="s1">}</span>
                <span class="s1">workStore.invalidDynamicUsageError = error;</span>
                <span class="s1">timeoutAbortController.abort(error);</span>
            <span class="s1">}, </span><span class="s4">50000</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">dynamicAccessAbortSignal = (_dynamicAccessAsyncStorage_getStore = _dynamicaccessasyncstorageexternal.dynamicAccessAsyncStorage.getStore()) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _dynamicAccessAsyncStorage_getStore.abortController.signal;</span>
            <span class="s2">const </span><span class="s1">abortSignal = dynamicAccessAbortSignal ? AbortSignal.any([</span>
                <span class="s1">dynamicAccessAbortSignal,</span>
                <span class="s1">outerWorkUnitStore.renderSignal,</span>
                <span class="s1">timeoutAbortController.signal</span>
            <span class="s1">]) : timeoutAbortController.signal;</span>
            <span class="s2">const </span><span class="s1">{ prelude } = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _static.unstable_prerender)(resultPromise, clientReferenceManifest.clientModules, {</span>
                <span class="s1">environmentName: </span><span class="s0">'Cache'</span><span class="s1">,</span>
                <span class="s1">filterStackFrame,</span>
                <span class="s1">signal: abortSignal,</span>
                <span class="s1">temporaryReferences,</span>
                <span class="s1">onError (error) {</span>
                    <span class="s2">if </span><span class="s1">(abortSignal.aborted &amp;&amp; abortSignal.reason === error) {</span>
                        <span class="s2">return </span><span class="s1">undefined;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">handleError(error);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">clearTimeout(timer);</span>
            <span class="s2">if </span><span class="s1">(timeoutAbortController.signal.aborted) {</span>
                <span class="s3">// When the timeout is reached we always error the stream. Even for</span>
                <span class="s3">// fallback shell prerenders we don't want to return a hanging promise,</span>
                <span class="s3">// which would allow the function to become a dynamic hole. Because that</span>
                <span class="s3">// would mean that a non-empty shell could be generated which would be</span>
                <span class="s3">// subject to revalidation, and we don't want to create long</span>
                <span class="s3">// revalidation times.</span>
                <span class="s1">stream = </span><span class="s2">new </span><span class="s1">ReadableStream({</span>
                    <span class="s1">start (controller) {</span>
                        <span class="s1">controller.error(timeoutAbortController.signal.reason);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(dynamicAccessAbortSignal == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: dynamicAccessAbortSignal.aborted) {</span>
                <span class="s3">// If the prerender is aborted because of dynamic access (e.g. reading</span>
                <span class="s3">// fallback params), we return a hanging promise. This essentially makes</span>
                <span class="s3">// the &quot;use cache&quot; function dynamic.</span>
                <span class="s2">const </span><span class="s1">hangingPromise = (</span><span class="s4">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(outerWorkUnitStore.renderSignal, workStore.route, abortSignal.reason);</span>
                <span class="s2">if </span><span class="s1">(outerWorkUnitStore.cacheSignal) {</span>
                    <span class="s1">outerWorkUnitStore.cacheSignal.endRead();</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">'prerender-dynamic'</span><span class="s1">,</span>
                    <span class="s1">hangingPromise</span>
                <span class="s1">};</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">stream = prelude;</span>
            <span class="s1">}</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s1">undefined:</span>
            <span class="s1">stream = (</span><span class="s4">0</span><span class="s1">, _server.renderToReadableStream)(resultPromise, clientReferenceManifest.clientModules, {</span>
                <span class="s1">environmentName: </span><span class="s0">'Cache'</span><span class="s1">,</span>
                <span class="s1">filterStackFrame,</span>
                <span class="s1">temporaryReferences,</span>
                <span class="s1">onError: handleError</span>
            <span class="s1">});</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">outerWorkUnitStore;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">[returnStream, savedStream] = stream.tee();</span>
    <span class="s2">const </span><span class="s1">pendingCacheEntry = collectResult(savedStream, workStore, cacheContext, innerCacheStore, startTime, errors);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s0">'cached'</span><span class="s1">,</span>
        <span class="s3">// Return the stream as we're creating it. This means that if it ends up</span>
        <span class="s3">// erroring we cannot return a stale-if-error version but it allows</span>
        <span class="s3">// streaming back the result earlier.</span>
        <span class="s1">stream: returnStream,</span>
        <span class="s1">pendingCacheEntry</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">cloneCacheEntry(entry) {</span>
    <span class="s2">const </span><span class="s1">[streamA, streamB] = entry.value.tee();</span>
    <span class="s1">entry.value = streamA;</span>
    <span class="s2">const </span><span class="s1">clonedEntry = {</span>
        <span class="s1">value: streamB,</span>
        <span class="s1">timestamp: entry.timestamp,</span>
        <span class="s1">revalidate: entry.revalidate,</span>
        <span class="s1">expire: entry.expire,</span>
        <span class="s1">stale: entry.stale,</span>
        <span class="s1">tags: entry.tags</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">entry,</span>
        <span class="s1">clonedEntry</span>
    <span class="s1">];</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">clonePendingCacheEntry(pendingCacheEntry) {</span>
    <span class="s2">const </span><span class="s1">entry = </span><span class="s2">await </span><span class="s1">pendingCacheEntry;</span>
    <span class="s2">return </span><span class="s1">cloneCacheEntry(entry);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getNthCacheEntry(split, i) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s2">await </span><span class="s1">split)[i];</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">encodeFormData(formData) {</span>
    <span class="s2">let </span><span class="s1">result = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">[key, value] of formData){</span>
        <span class="s3">// We don't need this key to be serializable but from a security perspective it should not be</span>
        <span class="s3">// possible to generate a string that looks the same from a different structure. To ensure this</span>
        <span class="s3">// we need a delimeter between fields but just using a delimeter is not enough since a string</span>
        <span class="s3">// might contain that delimeter. We use the length of each field as the delimeter to avoid</span>
        <span class="s3">// escaping the values.</span>
        <span class="s1">result += key.length.toString(</span><span class="s4">16</span><span class="s1">) + </span><span class="s0">':' </span><span class="s1">+ key;</span>
        <span class="s2">let </span><span class="s1">stringValue;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">stringValue = value;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s3">// The FormData might contain binary data that is not valid UTF-8 so this cache</span>
            <span class="s3">// key may generate a UCS-2 string. Passing this to another service needs to be</span>
            <span class="s3">// aware that the key might not be compatible.</span>
            <span class="s2">const </span><span class="s1">arrayBuffer = </span><span class="s2">await </span><span class="s1">value.arrayBuffer();</span>
            <span class="s2">if </span><span class="s1">(arrayBuffer.byteLength % </span><span class="s4">2 </span><span class="s1">=== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">stringValue = String.fromCodePoint(...</span><span class="s2">new </span><span class="s1">Uint16Array(arrayBuffer));</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">stringValue = String.fromCodePoint(...</span><span class="s2">new </span><span class="s1">Uint16Array(arrayBuffer, </span><span class="s4">0</span><span class="s1">, (arrayBuffer.byteLength - </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">)) + String.fromCodePoint(</span><span class="s2">new </span><span class="s1">Uint8Array(arrayBuffer, arrayBuffer.byteLength - </span><span class="s4">1</span><span class="s1">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">result += stringValue.length.toString(</span><span class="s4">16</span><span class="s1">) + </span><span class="s0">':' </span><span class="s1">+ stringValue;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createTrackedReadableStream(stream, cacheSignal) {</span>
    <span class="s2">const </span><span class="s1">reader = stream.getReader();</span>
    <span class="s2">return new </span><span class="s1">ReadableStream({</span>
        <span class="s1">async pull (controller) {</span>
            <span class="s2">const </span><span class="s1">{ done, value } = </span><span class="s2">await </span><span class="s1">reader.read();</span>
            <span class="s2">if </span><span class="s1">(done) {</span>
                <span class="s1">controller.close();</span>
                <span class="s1">cacheSignal.endRead();</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">controller.enqueue(value);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">wrapAsInvalidDynamicUsageError(error, sharedErrorStack, workStore) {</span>
    <span class="s2">if </span><span class="s1">(sharedErrorStack) {</span>
        <span class="s1">error.stack = error.name + </span><span class="s0">': ' </span><span class="s1">+ error.message + sharedErrorStack;</span>
    <span class="s1">}</span>
    <span class="s1">workStore.invalidDynamicUsageError ??= error;</span>
    <span class="s2">return </span><span class="s1">error;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">cache(kind, id, boundArgsLength, originalFn) {</span>
    <span class="s2">var </span><span class="s1">_sharedError_stack;</span>
    <span class="s2">const </span><span class="s1">isPrivate = kind === </span><span class="s0">'private'</span><span class="s1">;</span>
    <span class="s3">// Private caches are currently only stored in the Resume Data Cache (RDC),</span>
    <span class="s3">// and not in cache handlers.</span>
    <span class="s2">const </span><span class="s1">cacheHandler = isPrivate ? undefined : (</span><span class="s4">0</span><span class="s1">, _handlers.getCacheHandler)(kind);</span>
    <span class="s2">if </span><span class="s1">(!isPrivate &amp;&amp; !cacheHandler) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Unknown cache handler: ' </span><span class="s1">+ kind), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E248&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">// Capture a better error stack in this scope.</span>
    <span class="s2">const </span><span class="s1">sharedError = </span><span class="s2">new </span><span class="s1">Error();</span>
    <span class="s1">Error.captureStackTrace(sharedError, cache);</span>
    <span class="s2">const </span><span class="s1">sharedErrorStack = (_sharedError_stack = sharedError.stack) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _sharedError_stack.slice(sharedError.stack.indexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">));</span>
    <span class="s2">const </span><span class="s1">name = originalFn.name;</span>
    <span class="s2">const </span><span class="s1">cachedFn = {</span>
        <span class="s1">[name]: async </span><span class="s2">function</span><span class="s1">(...args) {</span>
            <span class="s2">const </span><span class="s1">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
            <span class="s2">if </span><span class="s1">(workStore === undefined) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'&quot;use cache&quot; cannot be used outside of App Router. Expected a WorkStore.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E279&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">fn = originalFn;</span>
            <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
            <span class="s2">let </span><span class="s1">cacheContext;</span>
            <span class="s2">if </span><span class="s1">(isPrivate) {</span>
                <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'&quot;use cache: private&quot;'</span><span class="s1">;</span>
                <span class="s2">switch</span><span class="s1">(workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: workUnitStore.type){</span>
                    <span class="s3">// &quot;use cache: private&quot; is dynamic in prerendering contexts.</span>
                    <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, expression);</span>
                    <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, workUnitStore.dynamicTracking);</span>
                    <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, workUnitStore);</span>
                    <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`</span><span class="s1">${expression} </span><span class="s0">must not be used within a client component. Next.js should be preventing </span><span class="s1">${expression} </span><span class="s0">from being allowed in client components statically, but did not in this case.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E741&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                        <span class="s1">{</span>
                            <span class="s2">throw </span><span class="s1">wrapAsInvalidDynamicUsageError(Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">// TODO: Add a link to an error documentation page when we have one.</span>
                            <span class="s0">`</span><span class="s1">${expression} </span><span class="s0">must not be used within </span><span class="s5">\`</span><span class="s0">unstable_cache()</span><span class="s5">\`</span><span class="s0">.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                <span class="s1">value: </span><span class="s0">&quot;E744&quot;</span><span class="s1">,</span>
                                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">configurable: </span><span class="s2">true</span>
                            <span class="s1">}), sharedErrorStack, workStore);</span>
                        <span class="s1">}</span>
                    <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                        <span class="s1">{</span>
                            <span class="s2">throw </span><span class="s1">wrapAsInvalidDynamicUsageError(Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">// TODO: Add a link to an error documentation page when we have one.</span>
                            <span class="s0">`</span><span class="s1">${expression} </span><span class="s0">must not be used within &quot;use cache&quot;. It can only be nested inside of another </span><span class="s1">${expression}</span><span class="s0">.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                <span class="s1">value: </span><span class="s0">&quot;E735&quot;</span><span class="s1">,</span>
                                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">configurable: </span><span class="s2">true</span>
                            <span class="s1">}), sharedErrorStack, workStore);</span>
                        <span class="s1">}</span>
                    <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                        <span class="s1">cacheContext = {</span>
                            <span class="s1">kind: </span><span class="s0">'private'</span><span class="s1">,</span>
                            <span class="s1">outerWorkUnitStore: workUnitStore</span>
                        <span class="s1">};</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">undefined:</span>
                        <span class="s2">throw </span><span class="s1">wrapAsInvalidDynamicUsageError(Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">// TODO: Add a link to an error documentation page when we have one.</span>
                        <span class="s0">`</span><span class="s1">${expression} </span><span class="s0">cannot be used outside of a request context.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E754&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">}), sharedErrorStack, workStore);</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">workUnitStore;</span>
                        <span class="s3">// This is dead code, but without throwing an error here, TypeScript</span>
                        <span class="s3">// will assume that cacheContext is used before being assigned.</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`Unexpected work unit store.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E737&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">switch</span><span class="s1">(workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: workUnitStore.type){</span>
                    <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                        <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'&quot;use cache&quot;'</span><span class="s1">;</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`</span><span class="s1">${expression} </span><span class="s0">must not be used within a client component. Next.js should be preventing </span><span class="s1">${expression} </span><span class="s0">from being allowed in client components statically, but did not in this case.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E741&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                    <span class="s3">// TODO: We should probably forbid nesting &quot;use cache&quot; inside</span>
                    <span class="s3">// unstable_cache. (fallthrough)</span>
                    <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s1">undefined:</span>
                        <span class="s1">cacheContext = {</span>
                            <span class="s1">kind: </span><span class="s0">'public'</span><span class="s1">,</span>
                            <span class="s1">outerWorkUnitStore: workUnitStore</span>
                        <span class="s1">};</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">workUnitStore;</span>
                        <span class="s3">// This is dead code, but without throwing an error here, TypeScript</span>
                        <span class="s3">// will assume that cacheContext is used before being assigned.</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`Unexpected work unit store.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E737&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// Get the clientReferenceManifest while we're still in the outer Context.</span>
            <span class="s3">// In case getClientReferenceManifestSingleton is implemented using AsyncLocalStorage.</span>
            <span class="s2">const </span><span class="s1">clientReferenceManifest = (</span><span class="s4">0</span><span class="s1">, _encryptionutils.getClientReferenceManifestForRsc)();</span>
            <span class="s3">// Because the Action ID is not yet unique per implementation of that Action we can't</span>
            <span class="s3">// safely reuse the results across builds yet. In the meantime we add the buildId to the</span>
            <span class="s3">// arguments as a seed to ensure they're not reused. Remove this once Action IDs hash</span>
            <span class="s3">// the implementation.</span>
            <span class="s2">const </span><span class="s1">buildId = workStore.buildId;</span>
            <span class="s3">// In dev mode, when the HMR refresh hash is set, we include it in the</span>
            <span class="s3">// cache key. This ensures that cache entries are not reused when server</span>
            <span class="s3">// components have been edited. This is a very coarse approach. But it's</span>
            <span class="s3">// also only a temporary solution until Action IDs are unique per</span>
            <span class="s3">// implementation. Remove this once Action IDs hash the implementation.</span>
            <span class="s2">const </span><span class="s1">hmrRefreshHash = workUnitStore &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getHmrRefreshHash)(workStore, workUnitStore);</span>
            <span class="s2">const </span><span class="s1">hangingInputAbortSignal = workUnitStore ? (</span><span class="s4">0</span><span class="s1">, _dynamicrendering.createHangingInputAbortSignal)(workUnitStore) : undefined;</span>
            <span class="s3">// In a runtime prerender, we have to make sure that APIs that would hang during a static prerender</span>
            <span class="s3">// are resolved with a delay, in the runtime stage. Private caches are one of these.</span>
            <span class="s2">if </span><span class="s1">(cacheContext.kind === </span><span class="s0">'private'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">runtimeStagePromise = (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getRuntimeStagePromise)(cacheContext.outerWorkUnitStore);</span>
                <span class="s2">if </span><span class="s1">(runtimeStagePromise) {</span>
                    <span class="s2">await </span><span class="s1">runtimeStagePromise;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">isPageOrLayout = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">// For page and layout components, the cache function is overwritten,</span>
            <span class="s3">// which allows us to apply special handling for params and searchParams.</span>
            <span class="s3">// For pages and layouts we're using the outer params prop, and not the</span>
            <span class="s3">// inner one that was serialized/deserialized. While it's not generally</span>
            <span class="s3">// true for &quot;use cache&quot; args, in the case of `params` the inner and outer</span>
            <span class="s3">// object are essentially equivalent, so this is safe to do (including</span>
            <span class="s3">// fallback params that are hanging promises). It allows us to avoid</span>
            <span class="s3">// waiting for the timeout, when prerendering a fallback shell of a cached</span>
            <span class="s3">// page or layout that awaits params.</span>
            <span class="s2">if </span><span class="s1">(isPageComponent(args)) {</span>
                <span class="s1">isPageOrLayout = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">[{ params: outerParams, searchParams: outerSearchParams }] = args;</span>
                <span class="s2">const </span><span class="s1">props = {</span>
                    <span class="s1">params: outerParams</span>
                <span class="s1">};</span>
                <span class="s2">if </span><span class="s1">(isPrivate) {</span>
                    <span class="s3">// Private caches allow accessing search params. We need to include</span>
                    <span class="s3">// them in the serialized args and when generating the cache key.</span>
                    <span class="s1">props.searchParams = outerSearchParams;</span>
                <span class="s1">}</span>
                <span class="s1">args = [</span>
                    <span class="s1">props</span>
                <span class="s1">];</span>
                <span class="s1">fn = ({</span>
                    <span class="s1">[name]: async ({ params: _innerParams, searchParams: innerSearchParams })=&gt;originalFn.apply(</span><span class="s2">null</span><span class="s1">, [</span>
                            <span class="s1">{</span>
                                <span class="s1">params: outerParams,</span>
                                <span class="s1">searchParams: innerSearchParams ?? </span><span class="s3">// For public caches, search params are omitted from the cache</span>
                                <span class="s3">// key (and the serialized args) to avoid mismatches between</span>
                                <span class="s3">// prerendering and resuming a cached page that does not</span>
                                <span class="s3">// access search params. This is also the reason why we're not</span>
                                <span class="s3">// using a hanging promise for search params. For cached pages</span>
                                <span class="s3">// that do access them, which is an invalid dynamic usage, we</span>
                                <span class="s3">// need to ensure that an error is shown.</span>
                                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _searchparams.makeErroringSearchParamsForUseCache)(workStore)</span>
                            <span class="s1">}</span>
                        <span class="s1">])</span>
                <span class="s1">})[name];</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isLayoutComponent(args)) {</span>
                <span class="s1">isPageOrLayout = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">[{ params: outerParams, $$isLayoutComponent, ...outerSlots }] = args;</span>
                <span class="s3">// Overwrite the props to omit $$isLayoutComponent.</span>
                <span class="s1">args = [</span>
                    <span class="s1">{</span>
                        <span class="s1">params: outerParams,</span>
                        <span class="s1">...outerSlots</span>
                    <span class="s1">}</span>
                <span class="s1">];</span>
                <span class="s1">fn = ({</span>
                    <span class="s1">[name]: async ({ params: _innerParams, ...innerSlots })=&gt;originalFn.apply(</span><span class="s2">null</span><span class="s1">, [</span>
                            <span class="s1">{</span>
                                <span class="s1">params: outerParams,</span>
                                <span class="s1">...innerSlots</span>
                            <span class="s1">}</span>
                        <span class="s1">])</span>
                <span class="s1">})[name];</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(boundArgsLength &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(args.length === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`Expected the &quot;use cache&quot; function </span><span class="s1">${JSON.stringify(fn.name)} </span><span class="s0">to receive its encrypted bound arguments as the first argument.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E524&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">encryptedBoundArgs = args.shift();</span>
                <span class="s2">const </span><span class="s1">boundArgs = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _encryption.decryptActionBoundArgs)(id, encryptedBoundArgs);</span>
                <span class="s2">if </span><span class="s1">(!Array.isArray(boundArgs)) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`Expected the bound arguments of &quot;use cache&quot; function </span><span class="s1">${JSON.stringify(fn.name)} </span><span class="s0">to deserialize into an array, got </span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">boundArgs} </span><span class="s0">instead.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E581&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(boundArgsLength !== boundArgs.length) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`Expected the &quot;use cache&quot; function </span><span class="s1">${JSON.stringify(fn.name)} </span><span class="s0">to receive </span><span class="s1">${boundArgsLength} </span><span class="s0">bound arguments, got </span><span class="s1">${boundArgs.length} </span><span class="s0">instead.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E559&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">args.unshift(boundArgs);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">temporaryReferences = (</span><span class="s4">0</span><span class="s1">, _client.createTemporaryReferenceSet)();</span>
            <span class="s3">// For private caches, which are allowed to read cookies, we still don't</span>
            <span class="s3">// need to include the cookies in the cache key. This is because we don't</span>
            <span class="s3">// store the cache entries in a cache handler, but only in the Resume Data</span>
            <span class="s3">// Cache (RDC). Private caches are only used during dynamic requests and</span>
            <span class="s3">// runtime prefetches. For dynamic requests, the RDC is immutable, so it</span>
            <span class="s3">// does not include any private caches. For runtime prefetches, the RDC is</span>
            <span class="s3">// mutable, but only lives as long as the request, so the key does not</span>
            <span class="s3">// need to include cookies.</span>
            <span class="s2">const </span><span class="s1">cacheKeyParts = hmrRefreshHash ? [</span>
                <span class="s1">buildId,</span>
                <span class="s1">id,</span>
                <span class="s1">args,</span>
                <span class="s1">hmrRefreshHash</span>
            <span class="s1">] : [</span>
                <span class="s1">buildId,</span>
                <span class="s1">id,</span>
                <span class="s1">args</span>
            <span class="s1">];</span>
            <span class="s2">const </span><span class="s1">encodeCacheKeyParts = ()=&gt;(</span><span class="s4">0</span><span class="s1">, _client.encodeReply)(cacheKeyParts, {</span>
                    <span class="s1">temporaryReferences,</span>
                    <span class="s1">signal: hangingInputAbortSignal</span>
                <span class="s1">});</span>
            <span class="s2">let </span><span class="s1">encodedCacheKeyParts;</span>
            <span class="s2">switch</span><span class="s1">(workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: workUnitStore.type){</span>
                <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s3">// We're currently only using `dynamicAccessAsyncStorage` for params,</span>
                <span class="s3">// which are always available in a runtime prerender, so they will never hang,</span>
                <span class="s3">// effectively making the tracking below a no-op.</span>
                <span class="s3">// However, a runtime prerender shares a lot of the semantics with a static prerender,</span>
                <span class="s3">// and might need to follow this codepath in the future</span>
                <span class="s3">// if we start using `dynamicAccessAsyncStorage` for other APIs.</span>
                <span class="s3">//</span>
                <span class="s3">// fallthrough</span>
                <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(!isPageOrLayout) {</span>
                        <span class="s3">// If the &quot;use cache&quot; function is not a page or a layout, we need to</span>
                        <span class="s3">// track dynamic access already when encoding the arguments. If</span>
                        <span class="s3">// params are passed explicitly into a &quot;use cache&quot; function (as</span>
                        <span class="s3">// opposed to receiving them automatically in a page or layout), we</span>
                        <span class="s3">// assume that the params are also accessed. This allows us to abort</span>
                        <span class="s3">// early, and treat the function as dynamic, instead of waiting for</span>
                        <span class="s3">// the timeout to be reached.</span>
                        <span class="s2">const </span><span class="s1">dynamicAccessAbortController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
                        <span class="s1">encodedCacheKeyParts = </span><span class="s2">await </span><span class="s1">_dynamicaccessasyncstorageexternal.dynamicAccessAsyncStorage.run({</span>
                            <span class="s1">abortController: dynamicAccessAbortController</span>
                        <span class="s1">}, encodeCacheKeyParts);</span>
                        <span class="s2">if </span><span class="s1">(dynamicAccessAbortController.signal.aborted) {</span>
                            <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, dynamicAccessAbortController.signal.reason.message);</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s3">// fallthrough</span>
                <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s1">undefined:</span>
                    <span class="s1">encodedCacheKeyParts = </span><span class="s2">await </span><span class="s1">encodeCacheKeyParts();</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">workUnitStore;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">serializedCacheKey = </span><span class="s2">typeof </span><span class="s1">encodedCacheKeyParts === </span><span class="s0">'string' </span><span class="s1">? </span><span class="s3">// Convert it to an ArrayBuffer if it wants to.</span>
            <span class="s1">encodedCacheKeyParts : </span><span class="s2">await </span><span class="s1">encodeFormData(encodedCacheKeyParts);</span>
            <span class="s2">let </span><span class="s1">stream = undefined;</span>
            <span class="s3">// Get an immutable and mutable versions of the resume data cache.</span>
            <span class="s2">const </span><span class="s1">prerenderResumeDataCache = workUnitStore ? (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getPrerenderResumeDataCache)(workUnitStore) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">renderResumeDataCache = workUnitStore ? (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getRenderResumeDataCache)(workUnitStore) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(renderResumeDataCache) {</span>
                <span class="s2">const </span><span class="s1">cacheSignal = workUnitStore ? (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getCacheSignal)(workUnitStore) : </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                    <span class="s1">cacheSignal.beginRead();</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">cachedEntry = renderResumeDataCache.cache.get(serializedCacheKey);</span>
                <span class="s2">if </span><span class="s1">(cachedEntry !== undefined) {</span>
                    <span class="s2">const </span><span class="s1">existingEntry = </span><span class="s2">await </span><span class="s1">cachedEntry;</span>
                    <span class="s1">propagateCacheLifeAndTags(cacheContext, existingEntry);</span>
                    <span class="s2">if </span><span class="s1">(workUnitStore !== undefined &amp;&amp; existingEntry !== undefined) {</span>
                        <span class="s2">if </span><span class="s1">(existingEntry.revalidate === </span><span class="s4">0 </span><span class="s1">|| existingEntry.expire &lt; _constants.DYNAMIC_EXPIRE) {</span>
                            <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                                <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                                    <span class="s3">// In a Dynamic I/O prerender, if the cache entry has</span>
                                    <span class="s3">// revalidate: 0 or if the expire time is under 5 minutes, then</span>
                                    <span class="s3">// we consider this cache entry dynamic as it's not worth</span>
                                    <span class="s3">// generating static pages for such data. It's better to leave a</span>
                                    <span class="s3">// PPR hole that can be filled in dynamically with a potentially</span>
                                    <span class="s3">// cached entry.</span>
                                    <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                                        <span class="s1">cacheSignal.endRead();</span>
                                    <span class="s1">}</span>
                                    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'dynamic &quot;use cache&quot;'</span><span class="s1">);</span>
                                <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                                    <span class="s1">{</span>
                                        <span class="s3">// In a runtime prerender, we have to make sure that APIs that would hang during a static prerender</span>
                                        <span class="s3">// are resolved with a delay, in the runtime stage.</span>
                                        <span class="s2">if </span><span class="s1">(workUnitStore.runtimeStagePromise) {</span>
                                            <span class="s2">await </span><span class="s1">workUnitStore.runtimeStagePromise;</span>
                                        <span class="s1">}</span>
                                        <span class="s2">break</span><span class="s1">;</span>
                                    <span class="s1">}</span>
                                <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                                    <span class="s2">break</span><span class="s1">;</span>
                                <span class="s2">default</span><span class="s1">:</span>
                                    <span class="s1">workUnitStore;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(existingEntry.stale &lt; _constants.RUNTIME_PREFETCH_DYNAMIC_STALE) {</span>
                            <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                                <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                                    <span class="s3">// In a runtime prerender, if the cache entry will become stale in less then 30 seconds,</span>
                                    <span class="s3">// we consider this cache entry dynamic as it's not worth prefetching.</span>
                                    <span class="s3">// It's better to leave a PPR hole that can be filled in dynamically</span>
                                    <span class="s3">// with a potentially cached entry.</span>
                                    <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                                        <span class="s1">cacheSignal.endRead();</span>
                                    <span class="s1">}</span>
                                    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'dynamic &quot;use cache&quot;'</span><span class="s1">);</span>
                                <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                                <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                                    <span class="s2">break</span><span class="s1">;</span>
                                <span class="s2">default</span><span class="s1">:</span>
                                    <span class="s1">workUnitStore;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">[streamA, streamB] = existingEntry.value.tee();</span>
                    <span class="s1">existingEntry.value = streamB;</span>
                    <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                        <span class="s3">// When we have a cacheSignal we need to block on reading the cache</span>
                        <span class="s3">// entry before ending the read.</span>
                        <span class="s1">stream = createTrackedReadableStream(streamA, cacheSignal);</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">stream = streamA;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                        <span class="s1">cacheSignal.endRead();</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
                        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                                <span class="s3">// If `allowEmptyStaticShell` is true, and thus a prefilled</span>
                                <span class="s3">// resume data cache was provided, then a cache miss means that</span>
                                <span class="s3">// params were part of the cache key. In this case, we can make</span>
                                <span class="s3">// this cache function a dynamic hole in the shell (or produce</span>
                                <span class="s3">// an empty shell if there's no parent suspense boundary).</span>
                                <span class="s3">// Currently, this also includes layouts and pages that don't</span>
                                <span class="s3">// read params, which will be improved when we implement</span>
                                <span class="s3">// NAR-136. Otherwise, we assume that if params are passed</span>
                                <span class="s3">// explicitly into a &quot;use cache&quot; function, that the params are</span>
                                <span class="s3">// also accessed. This allows us to abort early, and treat the</span>
                                <span class="s3">// function as dynamic, instead of waiting for the timeout to be</span>
                                <span class="s3">// reached. Compared to the instrumentation-based params bailout</span>
                                <span class="s3">// we do here, this also covers the case where params are</span>
                                <span class="s3">// transformed with an async function, before being passed into</span>
                                <span class="s3">// the &quot;use cache&quot; function, which escapes the instrumentation.</span>
                                <span class="s2">if </span><span class="s1">(workUnitStore.allowEmptyStaticShell) {</span>
                                    <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'dynamic &quot;use cache&quot;'</span><span class="s1">);</span>
                                <span class="s1">}</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s2">default</span><span class="s1">:</span>
                                <span class="s1">workUnitStore;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(stream === undefined) {</span>
                <span class="s2">const </span><span class="s1">cacheSignal = workUnitStore ? (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getCacheSignal)(workUnitStore) : </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                    <span class="s3">// Either the cache handler or the generation can be using I/O at this point.</span>
                    <span class="s3">// We need to track when they start and when they complete.</span>
                    <span class="s1">cacheSignal.beginRead();</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">lazyRefreshTags = workStore.refreshTagsByCacheKind.get(kind);</span>
                <span class="s2">if </span><span class="s1">(lazyRefreshTags &amp;&amp; !(</span><span class="s4">0</span><span class="s1">, _lazyresult.isResolvedLazyResult)(lazyRefreshTags)) {</span>
                    <span class="s2">await </span><span class="s1">lazyRefreshTags;</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">entry;</span>
                <span class="s3">// We ignore existing cache entries when force revalidating.</span>
                <span class="s2">if </span><span class="s1">(cacheHandler &amp;&amp; !shouldForceRevalidate(workStore, workUnitStore)) {</span>
                    <span class="s2">var </span><span class="s1">_workUnitStore_implicitTags;</span>
                    <span class="s1">entry = </span><span class="s2">await </span><span class="s1">cacheHandler.get(serializedCacheKey, (workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_workUnitStore_implicitTags = workUnitStore.implicitTags) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _workUnitStore_implicitTags.tags) ?? []);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(entry) {</span>
                    <span class="s2">var </span><span class="s1">_workUnitStore_implicitTags1;</span>
                    <span class="s2">const </span><span class="s1">implicitTags = (workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_workUnitStore_implicitTags1 = workUnitStore.implicitTags) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _workUnitStore_implicitTags1.tags) ?? [];</span>
                    <span class="s2">let </span><span class="s1">implicitTagsExpiration = </span><span class="s4">0</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(workUnitStore == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: workUnitStore.implicitTags) {</span>
                        <span class="s2">const </span><span class="s1">lazyExpiration = workUnitStore.implicitTags.expirationsByCacheKind.get(kind);</span>
                        <span class="s2">if </span><span class="s1">(lazyExpiration) {</span>
                            <span class="s2">const </span><span class="s1">expiration = (</span><span class="s4">0</span><span class="s1">, _lazyresult.isResolvedLazyResult)(lazyExpiration) ? lazyExpiration.value : </span><span class="s2">await </span><span class="s1">lazyExpiration;</span>
                            <span class="s3">// If a cache handler returns an expiration time of Infinity, it</span>
                            <span class="s3">// signals to Next.js that it handles checking cache entries for</span>
                            <span class="s3">// staleness based on the expiration of the implicit tags passed</span>
                            <span class="s3">// into the `get` method. In this case, we keep the default of 0,</span>
                            <span class="s3">// which means that the implicit tags are not considered expired.</span>
                            <span class="s2">if </span><span class="s1">(expiration &lt; Infinity) {</span>
                                <span class="s1">implicitTagsExpiration = expiration;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(shouldDiscardCacheEntry(entry, workStore, workUnitStore, implicitTags, implicitTagsExpiration)) {</span>
                        <span class="s1">debug == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s0">'discarding stale entry'</span><span class="s1">, serializedCacheKey);</span>
                        <span class="s1">entry = undefined;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">currentTime = performance.timeOrigin + performance.now();</span>
                <span class="s2">if </span><span class="s1">(workUnitStore !== undefined &amp;&amp; entry !== undefined &amp;&amp; (entry.revalidate === </span><span class="s4">0 </span><span class="s1">|| entry.expire &lt; _constants.DYNAMIC_EXPIRE)) {</span>
                    <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                            <span class="s3">// In a Dynamic I/O prerender, if the cache entry has revalidate:</span>
                            <span class="s3">// 0 or if the expire time is under 5 minutes, then we consider</span>
                            <span class="s3">// this cache entry dynamic as it's not worth generating static</span>
                            <span class="s3">// pages for such data. It's better to leave a PPR hole that can</span>
                            <span class="s3">// be filled in dynamically with a potentially cached entry.</span>
                            <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                                <span class="s1">cacheSignal.endRead();</span>
                            <span class="s1">}</span>
                            <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'dynamic &quot;use cache&quot;'</span><span class="s1">);</span>
                        <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                            <span class="s3">// In a runtime prerender, we have to make sure that APIs that would hang during a static prerender</span>
                            <span class="s3">// are resolved with a delay, in the runtime stage.</span>
                            <span class="s2">if </span><span class="s1">(workUnitStore.runtimeStagePromise) {</span>
                                <span class="s2">await </span><span class="s1">workUnitStore.runtimeStagePromise;</span>
                            <span class="s1">}</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                        <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">default</span><span class="s1">:</span>
                            <span class="s1">workUnitStore;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(entry === undefined || currentTime &gt; entry.timestamp + entry.expire * </span><span class="s4">1000 </span><span class="s1">|| workStore.isStaticGeneration &amp;&amp; currentTime &gt; entry.timestamp + entry.revalidate * </span><span class="s4">1000</span><span class="s1">) {</span>
                    <span class="s3">// Miss. Generate a new result.</span>
                    <span class="s3">// If the cache entry is stale and we're prerendering, we don't want to use the</span>
                    <span class="s3">// stale entry since it would unnecessarily need to shorten the lifetime of the</span>
                    <span class="s3">// prerender. We're not time constrained here so we can re-generated it now.</span>
                    <span class="s3">// We need to run this inside a clean AsyncLocalStorage snapshot so that the cache</span>
                    <span class="s3">// generation cannot read anything from the context we're currently executing which</span>
                    <span class="s3">// might include request specific things like cookies() inside a React.cache().</span>
                    <span class="s3">// Note: It is important that we await at least once before this because it lets us</span>
                    <span class="s3">// pop out of any stack specific contexts as well - aka &quot;Sync&quot; Local Storage.</span>
                    <span class="s2">if </span><span class="s1">(entry) {</span>
                        <span class="s2">if </span><span class="s1">(currentTime &gt; entry.timestamp + entry.expire * </span><span class="s4">1000</span><span class="s1">) {</span>
                            <span class="s1">debug == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s0">'entry is expired'</span><span class="s1">, serializedCacheKey);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(workStore.isStaticGeneration &amp;&amp; currentTime &gt; entry.timestamp + entry.revalidate * </span><span class="s4">1000</span><span class="s1">) {</span>
                            <span class="s1">debug == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s0">'static generation, entry is stale'</span><span class="s1">, serializedCacheKey);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">generateCacheEntry(workStore, cacheContext, clientReferenceManifest, encodedCacheKeyParts, fn, sharedErrorStack);</span>
                    <span class="s2">if </span><span class="s1">(result.type === </span><span class="s0">'prerender-dynamic'</span><span class="s1">) {</span>
                        <span class="s2">return </span><span class="s1">result.hangingPromise;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">{ stream: newStream, pendingCacheEntry } = result;</span>
                    <span class="s3">// When draft mode is enabled, we must not save the cache entry.</span>
                    <span class="s2">if </span><span class="s1">(!workStore.isDraftMode) {</span>
                        <span class="s2">let </span><span class="s1">savedCacheEntry;</span>
                        <span class="s2">if </span><span class="s1">(prerenderResumeDataCache) {</span>
                            <span class="s3">// Create a clone that goes into the cache scope memory cache.</span>
                            <span class="s2">const </span><span class="s1">split = clonePendingCacheEntry(pendingCacheEntry);</span>
                            <span class="s1">savedCacheEntry = getNthCacheEntry(split, </span><span class="s4">0</span><span class="s1">);</span>
                            <span class="s1">prerenderResumeDataCache.cache.set(serializedCacheKey, getNthCacheEntry(split, </span><span class="s4">1</span><span class="s1">));</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">savedCacheEntry = pendingCacheEntry;</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(cacheHandler) {</span>
                            <span class="s2">const </span><span class="s1">promise = cacheHandler.set(serializedCacheKey, savedCacheEntry);</span>
                            <span class="s1">workStore.pendingRevalidateWrites ??= [];</span>
                            <span class="s1">workStore.pendingRevalidateWrites.push(promise);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">stream = newStream;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s3">// If we have an entry at this point, this can't be a private cache</span>
                    <span class="s3">// entry.</span>
                    <span class="s2">if </span><span class="s1">(cacheContext.kind === </span><span class="s0">'private'</span><span class="s1">) {</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">`A private cache entry must not be retrieved from the cache handler.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E749&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s1">propagateCacheLifeAndTags(cacheContext, entry);</span>
                    <span class="s3">// We want to return this stream, even if it's stale.</span>
                    <span class="s1">stream = entry.value;</span>
                    <span class="s3">// If we have a cache scope, we need to clone the entry and set it on</span>
                    <span class="s3">// the inner cache scope.</span>
                    <span class="s2">if </span><span class="s1">(prerenderResumeDataCache) {</span>
                        <span class="s2">const </span><span class="s1">[entryLeft, entryRight] = cloneCacheEntry(entry);</span>
                        <span class="s2">if </span><span class="s1">(cacheSignal) {</span>
                            <span class="s1">stream = createTrackedReadableStream(entryLeft.value, cacheSignal);</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">stream = entryLeft.value;</span>
                        <span class="s1">}</span>
                        <span class="s1">prerenderResumeDataCache.cache.set(serializedCacheKey, Promise.resolve(entryRight));</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s3">// If we're not regenerating we need to signal that we've finished</span>
                        <span class="s3">// putting the entry into the cache scope at this point. Otherwise we do</span>
                        <span class="s3">// that inside generateCacheEntry.</span>
                        <span class="s1">cacheSignal == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: cacheSignal.endRead();</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(currentTime &gt; entry.timestamp + entry.revalidate * </span><span class="s4">1000</span><span class="s1">) {</span>
                        <span class="s3">// If this is stale, and we're not in a prerender (i.e. this is</span>
                        <span class="s3">// dynamic render), then we should warm up the cache with a fresh</span>
                        <span class="s3">// revalidated entry.</span>
                        <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">generateCacheEntry(workStore, </span><span class="s3">// This is not running within the context of this unit.</span>
                        <span class="s1">{</span>
                            <span class="s1">kind: cacheContext.kind,</span>
                            <span class="s1">outerWorkUnitStore: undefined</span>
                        <span class="s1">}, clientReferenceManifest, encodedCacheKeyParts, fn, sharedErrorStack);</span>
                        <span class="s2">if </span><span class="s1">(result.type === </span><span class="s0">'cached'</span><span class="s1">) {</span>
                            <span class="s2">const </span><span class="s1">{ stream: ignoredStream, pendingCacheEntry } = result;</span>
                            <span class="s2">let </span><span class="s1">savedCacheEntry;</span>
                            <span class="s2">if </span><span class="s1">(prerenderResumeDataCache) {</span>
                                <span class="s2">const </span><span class="s1">split = clonePendingCacheEntry(pendingCacheEntry);</span>
                                <span class="s1">savedCacheEntry = getNthCacheEntry(split, </span><span class="s4">0</span><span class="s1">);</span>
                                <span class="s1">prerenderResumeDataCache.cache.set(serializedCacheKey, getNthCacheEntry(split, </span><span class="s4">1</span><span class="s1">));</span>
                            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                <span class="s1">savedCacheEntry = pendingCacheEntry;</span>
                            <span class="s1">}</span>
                            <span class="s2">if </span><span class="s1">(cacheHandler) {</span>
                                <span class="s2">const </span><span class="s1">promise = cacheHandler.set(serializedCacheKey, savedCacheEntry);</span>
                                <span class="s1">workStore.pendingRevalidateWrites ??= [];</span>
                                <span class="s1">workStore.pendingRevalidateWrites.push(promise);</span>
                            <span class="s1">}</span>
                            <span class="s2">await </span><span class="s1">ignoredStream.cancel();</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// Logs are replayed even if it's a hit - to ensure we see them on the client eventually.</span>
            <span class="s3">// If we didn't then the client wouldn't see the logs if it was seeded from a prewarm that</span>
            <span class="s3">// never made it to the client. However, this also means that you see logs even when the</span>
            <span class="s3">// cached function isn't actually re-executed. We should instead ensure prewarms always</span>
            <span class="s3">// make it to the client. Another issue is that this will cause double logging in the</span>
            <span class="s3">// server terminal. Once while generating the cache entry and once when replaying it on</span>
            <span class="s3">// the server, which is required to pick it up for replaying again on the client.</span>
            <span class="s2">const </span><span class="s1">replayConsoleLogs = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">serverConsumerManifest = {</span>
                <span class="s3">// moduleLoading must be null because we don't want to trigger preloads of ClientReferences</span>
                <span class="s3">// to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted</span>
                <span class="s3">// which themselves will handle the preloading.</span>
                <span class="s1">moduleLoading: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">moduleMap: isEdgeRuntime ? clientReferenceManifest.edgeRscModuleMapping : clientReferenceManifest.rscModuleMapping,</span>
                <span class="s1">serverModuleMap: (</span><span class="s4">0</span><span class="s1">, _encryptionutils.getServerModuleMap)()</span>
            <span class="s1">};</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _client.createFromReadableStream)(stream, {</span>
                <span class="s1">findSourceMapURL,</span>
                <span class="s1">serverConsumerManifest,</span>
                <span class="s1">temporaryReferences,</span>
                <span class="s1">replayConsoleLogs,</span>
                <span class="s1">environmentName: </span><span class="s0">'Cache'</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}[name];</span>
    <span class="s2">return </span><span class="s1">_react.default.cache(cachedFn);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isPageComponent(args) {</span>
    <span class="s2">if </span><span class="s1">(args.length !== </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">[props, ref] = args;</span>
    <span class="s2">return </span><span class="s1">ref === undefined &amp;&amp; </span><span class="s3">// server components receive an undefined ref arg</span>
    <span class="s1">props !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">props === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; props.$$isPageComponent;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isLayoutComponent(args) {</span>
    <span class="s2">if </span><span class="s1">(args.length !== </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">[props, ref] = args;</span>
    <span class="s2">return </span><span class="s1">ref === undefined &amp;&amp; </span><span class="s3">// server components receive an undefined ref arg</span>
    <span class="s1">props !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">props === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; props.$$isLayoutComponent;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldForceRevalidate(workStore, workUnitStore) {</span>
    <span class="s2">if </span><span class="s1">(workStore.isOnDemandRevalidate || workStore.isDraftMode) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(workStore.dev &amp;&amp; workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">workUnitStore.headers.get(</span><span class="s0">'cache-control'</span><span class="s1">) === </span><span class="s0">'no-cache'</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">workUnitStore.forceRevalidate;</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldDiscardCacheEntry(entry, workStore, workUnitStore, implicitTags, implicitTagsExpiration) {</span>
    <span class="s3">// If the cache entry was created before any of the implicit tags were</span>
    <span class="s3">// revalidated last, we need to discard it.</span>
    <span class="s2">if </span><span class="s1">(entry.timestamp &lt;= implicitTagsExpiration) {</span>
        <span class="s1">debug == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s0">'entry was created at'</span><span class="s1">, entry.timestamp, </span><span class="s0">'before implicit tags were revalidated at'</span><span class="s1">, implicitTagsExpiration);</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// During prerendering, we ignore recently revalidated tags. In dev mode, we</span>
    <span class="s3">// can assume that the dynamic dev rendering will have discarded and recreated</span>
    <span class="s3">// the affected cache entries, and we don't want to discard those again during</span>
    <span class="s3">// the prerender validation. During build-time prerendering, there will never</span>
    <span class="s3">// be any pending revalidated tags.</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">// If the cache entry contains revalidated tags that the cache handler might</span>
    <span class="s3">// not know about yet, we need to discard it.</span>
    <span class="s2">if </span><span class="s1">(entry.tags.some((tag)=&gt;isRecentlyRevalidatedTag(tag, workStore))) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// Finally, if any of the implicit tags have been revalidated recently, we</span>
    <span class="s3">// also need to discard the cache entry.</span>
    <span class="s2">if </span><span class="s1">(implicitTags.some((tag)=&gt;isRecentlyRevalidatedTag(tag, workStore))) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isRecentlyRevalidatedTag(tag, workStore) {</span>
    <span class="s2">const </span><span class="s1">{ previouslyRevalidatedTags, pendingRevalidatedTags } = workStore;</span>
    <span class="s3">// Was the tag previously revalidated (e.g. by a redirecting server action)?</span>
    <span class="s2">if </span><span class="s1">(previouslyRevalidatedTags.includes(tag)) {</span>
        <span class="s1">debug == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s0">'tag'</span><span class="s1">, tag, </span><span class="s0">'was previously revalidated'</span><span class="s1">);</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// It could also have been revalidated by the currently running server action.</span>
    <span class="s3">// In this case the revalidation might not have been fully propagated by a</span>
    <span class="s3">// remote cache handler yet, so we read it from the pending tags in the work</span>
    <span class="s3">// store.</span>
    <span class="s2">if </span><span class="s1">(pendingRevalidatedTags == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: pendingRevalidatedTags.includes(tag)) {</span>
        <span class="s1">debug == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: debug(</span><span class="s0">'tag'</span><span class="s1">, tag, </span><span class="s0">'was just revalidated'</span><span class="s1">);</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=use-cache-wrapper.js.map</span></pre>
</body>
</html>