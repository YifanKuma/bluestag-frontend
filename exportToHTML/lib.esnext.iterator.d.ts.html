<html>
<head>
<title>lib.esnext.iterator.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lib.esnext.iterator.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/*! ***************************************************************************** 
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use 
this file except in compliance with the License. You may obtain a copy of the 
License at http://www.apache.org/licenses/LICENSE-2.0 
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED 
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions 
and limitations under the License. 
***************************************************************************** */</span>


<span class="s0">/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</span>

<span class="s0">/// &lt;reference lib=&quot;es2015.iterable&quot; /&gt;</span>

<span class="s0">// NOTE: This is specified as what is essentially an unreachable module. All actual global declarations can be found</span>
<span class="s0">//       in the `declare global` section, below. This is necessary as there is currently no way to declare an `abstract`</span>
<span class="s0">//       member without declaring a `class`, but declaring `class Iterator&lt;T&gt;` globally would conflict with TypeScript's</span>
<span class="s0">//       general purpose `Iterator&lt;T&gt;` interface.</span>
<span class="s2">export </span><span class="s1">{};</span>

<span class="s0">// Abstract type that allows us to mark `next` as `abstract`</span>
<span class="s1">declare abstract </span><span class="s2">class </span><span class="s1">Iterator&lt;T, TResult = undefined, TNext = unknown&gt; { </span><span class="s0">// eslint-disable-line @typescript-eslint/no-unsafe-declaration-merging</span>
    <span class="s1">abstract next(value?: TNext): IteratorResult&lt;T, TResult&gt;;</span>
<span class="s1">}</span>

<span class="s0">// Merge all members of `IteratorObject&lt;T&gt;` into `Iterator&lt;T&gt;`</span>
<span class="s2">interface </span><span class="s1">Iterator&lt;T, TResult, TNext&gt; </span><span class="s2">extends </span><span class="s1">globalThis.IteratorObject&lt;T, TResult, TNext&gt; {}</span>

<span class="s0">// Capture the `Iterator` constructor in a type we can use in the `extends` clause of `IteratorConstructor`.</span>
<span class="s1">type IteratorObjectConstructor = </span><span class="s2">typeof </span><span class="s1">Iterator;</span>

<span class="s1">declare global {</span>
    <span class="s0">// Global `IteratorObject&lt;T, TReturn, TNext&gt;` interface that can be augmented by polyfills</span>
    <span class="s2">interface </span><span class="s1">IteratorObject&lt;T, TReturn, TNext&gt; {</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns this iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">[Symbol.iterator](): IteratorObject&lt;T, TReturn, TNext&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates an iterator whose values are the result of applying the callback to the values from this iterator.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">callbackfn A function that accepts up to two arguments to be used to transform values from the underlying iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">map&lt;U&gt;(callbackfn: (value: T, index: number) =&gt; U): IteratorObject&lt;U, undefined, unknown&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates an iterator whose values are those from this iterator for which the provided predicate returns true.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate A function that accepts up to two arguments to be used to test values from the underlying iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">filter&lt;S </span><span class="s2">extends </span><span class="s1">T&gt;(predicate: (value: T, index: number) =&gt; value is S): IteratorObject&lt;S, undefined, unknown&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates an iterator whose values are those from this iterator for which the provided predicate returns true.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate A function that accepts up to two arguments to be used to test values from the underlying iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">filter(predicate: (value: T, index: number) =&gt; unknown): IteratorObject&lt;T, undefined, unknown&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates an iterator whose values are the values from this iterator, stopping once the provided limit is reached.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">limit The maximum number of values to yield.</span>
         <span class="s0">*/</span>
        <span class="s1">take(limit: number): IteratorObject&lt;T, undefined, unknown&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates an iterator whose values are the values from this iterator after skipping the provided count.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">count The number of values to drop.</span>
         <span class="s0">*/</span>
        <span class="s1">drop(count: number): IteratorObject&lt;T, undefined, unknown&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates an iterator whose values are the result of applying the callback to the values from this iterator and then flattening the resulting iterators or iterables.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">callback A function that accepts up to two arguments to be used to transform values from the underlying iterator into new iterators or iterables to be flattened into the result.</span>
         <span class="s0">*/</span>
        <span class="s1">flatMap&lt;U&gt;(callback: (value: T, index: number) =&gt; Iterator&lt;U, unknown, undefined&gt; | Iterable&lt;U, unknown, undefined&gt;): IteratorObject&lt;U, undefined, unknown&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* Calls the specified callback function for all the elements in this iterator. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">callbackfn A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the iterator.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a value from the iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number) =&gt; T): T;</span>
        <span class="s1">reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number) =&gt; T, initialValue: T): T;</span>

        <span class="s0">/**</span>
         <span class="s0">* Calls the specified callback function for all the elements in this iterator. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">callbackfn A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the iterator.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a value from the iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">reduce&lt;U&gt;(callbackfn: (previousValue: U, currentValue: T, currentIndex: number) =&gt; U, initialValue: U): U;</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates a new array from the values yielded by this iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">toArray(): T[];</span>

        <span class="s0">/**</span>
         <span class="s0">* Performs the specified action for each element in the iterator.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">callbackfn A function that accepts up to two arguments. forEach calls the callbackfn function one time for each element in the iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">forEach(callbackfn: (value: T, index: number) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Determines whether the specified callback function returns true for any element of this iterator.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate A function that accepts up to two arguments. The some method calls</span>
         <span class="s0">* the predicate function for each element in this iterator until the predicate returns a value</span>
         <span class="s0">* true, or until the end of the iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">some(predicate: (value: T, index: number) =&gt; unknown): boolean;</span>

        <span class="s0">/**</span>
         <span class="s0">* Determines whether all the members of this iterator satisfy the specified test.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate A function that accepts up to two arguments. The every method calls</span>
         <span class="s0">* the predicate function for each element in this iterator until the predicate returns</span>
         <span class="s0">* false, or until the end of this iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">every(predicate: (value: T, index: number) =&gt; unknown): boolean;</span>

        <span class="s0">/**</span>
         <span class="s0">* Returns the value of the first element in this iterator where predicate is true, and undefined</span>
         <span class="s0">* otherwise.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">predicate find calls predicate once for each element of this iterator, in</span>
         <span class="s0">* order, until it finds one where predicate returns true. If such an element is found, find</span>
         <span class="s0">* immediately returns that element value. Otherwise, find returns undefined.</span>
         <span class="s0">*/</span>
        <span class="s1">find&lt;S </span><span class="s2">extends </span><span class="s1">T&gt;(predicate: (value: T, index: number) =&gt; value is S): S | undefined;</span>
        <span class="s1">find(predicate: (value: T, index: number) =&gt; unknown): T | undefined;</span>

        <span class="s1">readonly [Symbol.toStringTag]: string;</span>
    <span class="s1">}</span>

    <span class="s0">// Global `IteratorConstructor` interface that can be augmented by polyfills</span>
    <span class="s2">interface </span><span class="s1">IteratorConstructor </span><span class="s2">extends </span><span class="s1">IteratorObjectConstructor {</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a native iterator from an iterator or iterable object.</span>
         <span class="s0">* Returns its input if the input already inherits from the built-in Iterator class.</span>
         <span class="s0">* </span><span class="s3">@param </span><span class="s0">value An iterator or iterable object to convert a native iterator.</span>
         <span class="s0">*/</span>
        <span class="s1">from&lt;T&gt;(value: Iterator&lt;T, unknown, undefined&gt; | Iterable&lt;T, unknown, undefined&gt;): IteratorObject&lt;T, undefined, unknown&gt;;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">Iterator: IteratorConstructor;</span>
<span class="s1">}</span>
</pre>
</body>
</html>