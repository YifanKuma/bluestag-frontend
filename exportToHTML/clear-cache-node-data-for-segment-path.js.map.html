<html>
<head>
<title>clear-cache-node-data-for-segment-path.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
clear-cache-node-data-for-segment-path.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/clear-cache-node-data-for-segment-path.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightSegmentPath } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { getNextFlightSegmentPath } from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This will clear the CacheNode data for a particular segment path. This will cause a lazy-fetch in layout router to fill in new data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function clearCacheNodeDataForSegmentPath(</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const isLastEntry = flightSegmentPath.length &lt;= 2</span><span class="s3">\n\n  </span><span class="s1">const [parallelRouteKey, segment] = flightSegmentPath</span><span class="s3">\n  </span><span class="s1">const cacheKey = createRouterCacheKey(segment)</span><span class="s3">\n\n  </span><span class="s1">const existingChildSegmentMap =</span><span class="s3">\n    </span><span class="s1">existingCache.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n\n  </span><span class="s1">let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n\n  </span><span class="s1">if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {</span><span class="s3">\n    </span><span class="s1">childSegmentMap = new Map(existingChildSegmentMap)</span><span class="s3">\n    </span><span class="s1">newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const existingChildCacheNode = existingChildSegmentMap?.get(cacheKey)</span><span class="s3">\n  </span><span class="s1">let childCacheNode = childSegmentMap.get(cacheKey)</span><span class="s3">\n\n  </span><span class="s1">// In case of last segment start off the fetch at this level and don't copy further down.</span><span class="s3">\n  </span><span class="s1">if (isLastEntry) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!childCacheNode ||</span><span class="s3">\n      </span><span class="s1">!childCacheNode.lazyData ||</span><span class="s3">\n      </span><span class="s1">childCacheNode === existingChildCacheNode</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">childSegmentMap.set(cacheKey, {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!childCacheNode || !existingChildCacheNode) {</span><span class="s3">\n    </span><span class="s1">// Start fetch in the place where the existing cache doesn't have the data yet.</span><span class="s3">\n    </span><span class="s1">if (!childCacheNode) {</span><span class="s3">\n      </span><span class="s1">childSegmentMap.set(cacheKey, {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (childCacheNode === existingChildCacheNode) {</span><span class="s3">\n    </span><span class="s1">childCacheNode = {</span><span class="s3">\n      </span><span class="s1">lazyData: childCacheNode.lazyData,</span><span class="s3">\n      </span><span class="s1">rsc: childCacheNode.rsc,</span><span class="s3">\n      </span><span class="s1">prefetchRsc: childCacheNode.prefetchRsc,</span><span class="s3">\n      </span><span class="s1">head: childCacheNode.head,</span><span class="s3">\n      </span><span class="s1">prefetchHead: childCacheNode.prefetchHead,</span><span class="s3">\n      </span><span class="s1">parallelRoutes: new Map(childCacheNode.parallelRoutes),</span><span class="s3">\n      </span><span class="s1">loading: childCacheNode.loading,</span><span class="s3">\n    </span><span class="s1">} as CacheNode</span><span class="s3">\n    </span><span class="s1">childSegmentMap.set(cacheKey, childCacheNode)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return clearCacheNodeDataForSegmentPath(</span><span class="s3">\n    </span><span class="s1">childCacheNode,</span><span class="s3">\n    </span><span class="s1">existingChildCacheNode,</span><span class="s3">\n    </span><span class="s1">getNextFlightSegmentPath(flightSegmentPath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;clearCacheNodeDataForSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;childSegmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;existingChildCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;childCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAQgBA;;;eAAAA;;;mCANyB;sCACJ;AAK9B,SAASA,iCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAEhD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IACpC,MAAMK,WAAWC,IAAAA,0CAAoB,EAACF;IAEtC,MAAMG,0BACJR,cAAcS,cAAc,CAACC,GAAG,CAACN;IAEnC,IAAIO,kBAAkBZ,SAASU,cAAc,CAACC,GAAG,CAACN;IAElD,IAAI,CAACO,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BT,SAASU,cAAc,CAACI,GAAG,CAACT,kBAAkBO;IAChD;IAEA,MAAMG,yBAAyBN,2CAAAA,wBAAyBE,GAAG,CAACJ;IAC5D,IAAIS,iBAAiBJ,gBAAgBD,GAAG,CAACJ;IAEzC,yFAAyF;IACzF,IAAIJ,aAAa;QACf,IACE,CAACa,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACAH,gBAAgBE,GAAG,CAACP,UAAU;gBAC5BU,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,SAAS;gBACTC,aAAa,CAAC;YAChB;QACF;QACA;IACF;IAEA,IAAI,CAACP,kBAAkB,CAACD,wBAAwB;QAC9C,+EAA+E;QAC/E,IAAI,CAACC,gBAAgB;YACnBJ,gBAAgBE,GAAG,CAACP,UAAU;gBAC5BU,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,SAAS;gBACTC,aAAa,CAAC;YAChB;QACF;QACA;IACF;IAEA,IAAIP,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCX,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDY,SAASN,eAAeM,OAAO;QACjC;QACAV,gBAAgBE,GAAG,CAACP,UAAUS;IAChC;IAEA,OAAOjB,iCACLiB,gBACAD,wBACAS,IAAAA,2CAAwB,EAACtB;AAE7B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>