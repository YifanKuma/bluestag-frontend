<html>
<head>
<title>handle-mutable.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
handle-mutable.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/handle-mutable.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { computeChangedPath } from './compute-changed-path'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Mutable,</span><span class="s3">\n  </span><span class="s1">ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">ReducerState,</span><span class="s3">\n</span><span class="s1">} from './router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">function isNotUndefined&lt;T&gt;(value: T): value is Exclude&lt;T, undefined&gt; {</span><span class="s3">\n  </span><span class="s1">return typeof value !== 'undefined'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function handleMutable(</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">mutable: Mutable</span><span class="s3">\n</span><span class="s1">): ReducerState {</span><span class="s3">\n  </span><span class="s1">// shouldScroll is true by default, can override to false.</span><span class="s3">\n  </span><span class="s1">const shouldScroll = mutable.shouldScroll ?? true</span><span class="s3">\n\n  </span><span class="s1">let nextUrl = state.nextUrl</span><span class="s3">\n\n  </span><span class="s1">if (isNotUndefined(mutable.patchedTree)) {</span><span class="s3">\n    </span><span class="s1">// If we received a patched tree, we need to compute the changed path.</span><span class="s3">\n    </span><span class="s1">const changedPath = computeChangedPath(state.tree, mutable.patchedTree)</span><span class="s3">\n    </span><span class="s1">if (changedPath) {</span><span class="s3">\n      </span><span class="s1">// If the tree changed, we need to update the nextUrl</span><span class="s3">\n      </span><span class="s1">nextUrl = changedPath</span><span class="s3">\n    </span><span class="s1">} else if (!nextUrl) {</span><span class="s3">\n      </span><span class="s1">// if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl</span><span class="s3">\n      </span><span class="s1">nextUrl = state.canonicalUrl</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// otherwise this will be a no-op and continue to use the existing nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// Set href.</span><span class="s3">\n    </span><span class="s1">canonicalUrl: isNotUndefined(mutable.canonicalUrl)</span><span class="s3">\n      </span><span class="s1">? mutable.canonicalUrl === state.canonicalUrl</span><span class="s3">\n        </span><span class="s1">? state.canonicalUrl</span><span class="s3">\n        </span><span class="s1">: mutable.canonicalUrl</span><span class="s3">\n      </span><span class="s1">: state.canonicalUrl,</span><span class="s3">\n    </span><span class="s1">pushRef: {</span><span class="s3">\n      </span><span class="s1">pendingPush: isNotUndefined(mutable.pendingPush)</span><span class="s3">\n        </span><span class="s1">? mutable.pendingPush</span><span class="s3">\n        </span><span class="s1">: state.pushRef.pendingPush,</span><span class="s3">\n      </span><span class="s1">mpaNavigation: isNotUndefined(mutable.mpaNavigation)</span><span class="s3">\n        </span><span class="s1">? mutable.mpaNavigation</span><span class="s3">\n        </span><span class="s1">: state.pushRef.mpaNavigation,</span><span class="s3">\n      </span><span class="s1">preserveCustomHistoryState: isNotUndefined(</span><span class="s3">\n        </span><span class="s1">mutable.preserveCustomHistoryState</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">? mutable.preserveCustomHistoryState</span><span class="s3">\n        </span><span class="s1">: state.pushRef.preserveCustomHistoryState,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// All navigation requires scroll and focus management to trigger.</span><span class="s3">\n    </span><span class="s1">focusAndScrollRef: {</span><span class="s3">\n      </span><span class="s1">apply: shouldScroll</span><span class="s3">\n        </span><span class="s1">? isNotUndefined(mutable?.scrollableSegments)</span><span class="s3">\n          </span><span class="s1">? true</span><span class="s3">\n          </span><span class="s1">: state.focusAndScrollRef.apply</span><span class="s3">\n        </span><span class="s1">: // If shouldScroll is false then we should not apply scroll and focus management.</span><span class="s3">\n          </span><span class="s1">false,</span><span class="s3">\n      </span><span class="s1">onlyHashChange: mutable.onlyHashChange || false,</span><span class="s3">\n      </span><span class="s1">hashFragment: shouldScroll</span><span class="s3">\n        </span><span class="s1">? // Empty hash should trigger default behavior of scrolling layout into view.</span><span class="s3">\n          </span><span class="s1">// #top is handled in layout-router.</span><span class="s3">\n          </span><span class="s1">mutable.hashFragment &amp;&amp; mutable.hashFragment !== ''</span><span class="s3">\n          </span><span class="s1">? // Remove leading # and decode hash to make non-latin hashes work.</span><span class="s3">\n            </span><span class="s1">decodeURIComponent(mutable.hashFragment.slice(1))</span><span class="s3">\n          </span><span class="s1">: state.focusAndScrollRef.hashFragment</span><span class="s3">\n        </span><span class="s1">: // If shouldScroll is false then we should not apply scroll and focus management.</span><span class="s3">\n          </span><span class="s1">null,</span><span class="s3">\n      </span><span class="s1">segmentPaths: shouldScroll</span><span class="s3">\n        </span><span class="s1">? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths</span><span class="s3">\n        </span><span class="s1">: // If shouldScroll is false then we should not apply scroll and focus management.</span><span class="s3">\n          </span><span class="s1">[],</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// Apply cache.</span><span class="s3">\n    </span><span class="s1">cache: mutable.cache ? mutable.cache : state.cache,</span><span class="s3">\n    </span><span class="s1">prefetchCache: mutable.prefetchCache</span><span class="s3">\n      </span><span class="s1">? mutable.prefetchCache</span><span class="s3">\n      </span><span class="s1">: state.prefetchCache,</span><span class="s3">\n    </span><span class="s1">// Apply patched router state.</span><span class="s3">\n    </span><span class="s1">tree: isNotUndefined(mutable.patchedTree)</span><span class="s3">\n      </span><span class="s1">? mutable.patchedTree</span><span class="s3">\n      </span><span class="s1">: state.tree,</span><span class="s3">\n    </span><span class="s1">nextUrl,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotUndefined&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;changedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;computeChangedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;mpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;focusAndScrollRef&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyHashChange&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAWgBA;;;eAAAA;;;oCAXmB;AAOnC,SAASC,eAAkBC,KAAQ;IACjC,OAAO,OAAOA,UAAU;AAC1B;AAEO,SAASF,cACdG,KAA2B,EAC3BC,OAAgB;QAGKA;IADrB,0DAA0D;IAC1D,MAAMC,eAAeD,CAAAA,wBAAAA,QAAQC,YAAY,YAApBD,wBAAwB;IAE7C,IAAIE,UAAUH,MAAMG,OAAO;IAE3B,IAAIL,eAAeG,QAAQG,WAAW,GAAG;QACvC,sEAAsE;QACtE,MAAMC,cAAcC,IAAAA,sCAAkB,EAACN,MAAMO,IAAI,EAAEN,QAAQG,WAAW;QACtE,IAAIC,aAAa;YACf,qDAAqD;YACrDF,UAAUE;QACZ,OAAO,IAAI,CAACF,SAAS;YACnB,6HAA6H;YAC7HA,UAAUH,MAAMQ,YAAY;QAC9B;IACA,0EAA0E;IAC5E;QAyCQP;IAvCR,OAAO;QACL,YAAY;QACZO,cAAcV,eAAeG,QAAQO,YAAY,IAC7CP,QAAQO,YAAY,KAAKR,MAAMQ,YAAY,GACzCR,MAAMQ,YAAY,GAClBP,QAAQO,YAAY,GACtBR,MAAMQ,YAAY;QACtBC,SAAS;YACPC,aAAaZ,eAAeG,QAAQS,WAAW,IAC3CT,QAAQS,WAAW,GACnBV,MAAMS,OAAO,CAACC,WAAW;YAC7BC,eAAeb,eAAeG,QAAQU,aAAa,IAC/CV,QAAQU,aAAa,GACrBX,MAAMS,OAAO,CAACE,aAAa;YAC/BC,4BAA4Bd,eAC1BG,QAAQW,0BAA0B,IAEhCX,QAAQW,0BAA0B,GAClCZ,MAAMS,OAAO,CAACG,0BAA0B;QAC9C;QACA,kEAAkE;QAClEC,mBAAmB;YACjBC,OAAOZ,eACHJ,eAAeG,2BAAAA,QAASc,kBAAkB,IACxC,OACAf,MAAMa,iBAAiB,CAACC,KAAK,GAE/B;YACJE,gBAAgBf,QAAQe,cAAc,IAAI;YAC1CC,cAAcf,eAEV,oCAAoC;YACpCD,QAAQgB,YAAY,IAAIhB,QAAQgB,YAAY,KAAK,KAE/CC,mBAAmBjB,QAAQgB,YAAY,CAACE,KAAK,CAAC,MAC9CnB,MAAMa,iBAAiB,CAACI,YAAY,GAEtC;YACJG,cAAclB,eACVD,CAAAA,8BAAAA,2BAAAA,QAASc,kBAAkB,YAA3Bd,8BAA+BD,MAAMa,iBAAiB,CAACO,YAAY,GAEnE,EAAE;QACR;QACA,eAAe;QACfC,OAAOpB,QAAQoB,KAAK,GAAGpB,QAAQoB,KAAK,GAAGrB,MAAMqB,KAAK;QAClDC,eAAerB,QAAQqB,aAAa,GAChCrB,QAAQqB,aAAa,GACrBtB,MAAMsB,aAAa;QACvB,8BAA8B;QAC9Bf,MAAMT,eAAeG,QAAQG,WAAW,IACpCH,QAAQG,WAAW,GACnBJ,MAAMO,IAAI;QACdJ;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>