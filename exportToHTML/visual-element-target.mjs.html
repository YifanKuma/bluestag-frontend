<html>
<head>
<title>visual-element-target.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
visual-element-target.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ getValueTransition, frame, positionalKeys } from </span><span class="s2">'motion-dom'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ setTarget } from </span><span class="s2">'../../render/utils/setters.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ addValueToWillChange } from </span><span class="s2">'../../value/use-will-change/add-will-change.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ getOptimisedAppearId } from </span><span class="s2">'../optimized-appear/get-appear-id.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ animateMotionValue } from </span><span class="s2">'./motion-value.mjs'</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Decide whether we should block this animation. Previously, we achieved this</span>
 <span class="s3">* just by checking whether the key was listed in protectedKeys, but this</span>
 <span class="s3">* posed problems if an animation was triggered by afterChildren and protectedKeys</span>
 <span class="s3">* had been set to true in the meantime.</span>
 <span class="s3">*/</span>
<span class="s0">function </span><span class="s1">shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {</span>
    <span class="s0">const </span><span class="s1">shouldBlock = protectedKeys.hasOwnProperty(key) &amp;&amp; needsAnimating[key] !== </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s1">needsAnimating[key] = </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s0">return </span><span class="s1">shouldBlock;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">animateTarget(visualElement, targetAndTransition, { delay = </span><span class="s4">0</span><span class="s1">, transitionOverride, type } = {}) {</span>
    <span class="s0">let </span><span class="s1">{ transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;</span>
    <span class="s0">if </span><span class="s1">(transitionOverride)</span>
        <span class="s1">transition = transitionOverride;</span>
    <span class="s0">const </span><span class="s1">animations = [];</span>
    <span class="s0">const </span><span class="s1">animationTypeState = type &amp;&amp;</span>
        <span class="s1">visualElement.animationState &amp;&amp;</span>
        <span class="s1">visualElement.animationState.getState()[type];</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">target) {</span>
        <span class="s0">const </span><span class="s1">value = visualElement.getValue(key, visualElement.latestValues[key] ?? </span><span class="s0">null</span><span class="s1">);</span>
        <span class="s0">const </span><span class="s1">valueTarget = target[key];</span>
        <span class="s0">if </span><span class="s1">(valueTarget === undefined ||</span>
            <span class="s1">(animationTypeState &amp;&amp;</span>
                <span class="s1">shouldBlockAnimation(animationTypeState, key))) {</span>
            <span class="s0">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">valueTransition = {</span>
            <span class="s1">delay,</span>
            <span class="s1">...getValueTransition(transition || {}, key),</span>
        <span class="s1">};</span>
        <span class="s3">/**</span>
         <span class="s3">* If the value is already at the defined target, skip the animation.</span>
         <span class="s3">*/</span>
        <span class="s0">const </span><span class="s1">currentValue = value.get();</span>
        <span class="s0">if </span><span class="s1">(currentValue !== undefined &amp;&amp;</span>
            <span class="s1">!value.isAnimating &amp;&amp;</span>
            <span class="s1">!Array.isArray(valueTarget) &amp;&amp;</span>
            <span class="s1">valueTarget === currentValue &amp;&amp;</span>
            <span class="s1">!valueTransition.velocity) {</span>
            <span class="s0">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If this is the first time a value is being animated, check</span>
         <span class="s3">* to see if we're handling off from an existing animation.</span>
         <span class="s3">*/</span>
        <span class="s0">let </span><span class="s1">isHandoff = </span><span class="s0">false</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(window.MotionHandoffAnimation) {</span>
            <span class="s0">const </span><span class="s1">appearId = getOptimisedAppearId(visualElement);</span>
            <span class="s0">if </span><span class="s1">(appearId) {</span>
                <span class="s0">const </span><span class="s1">startTime = window.MotionHandoffAnimation(appearId, key, frame);</span>
                <span class="s0">if </span><span class="s1">(startTime !== </span><span class="s0">null</span><span class="s1">) {</span>
                    <span class="s1">valueTransition.startTime = startTime;</span>
                    <span class="s1">isHandoff = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">addValueToWillChange(visualElement, key);</span>
        <span class="s1">value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion &amp;&amp; positionalKeys.has(key)</span>
            <span class="s1">? { type: </span><span class="s0">false </span><span class="s1">}</span>
            <span class="s1">: valueTransition, visualElement, isHandoff));</span>
        <span class="s0">const </span><span class="s1">animation = value.animation;</span>
        <span class="s0">if </span><span class="s1">(animation) {</span>
            <span class="s1">animations.push(animation);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(transitionEnd) {</span>
        <span class="s1">Promise.all(animations).then(() =&gt; {</span>
            <span class="s1">frame.update(() =&gt; {</span>
                <span class="s1">transitionEnd &amp;&amp; setTarget(visualElement, transitionEnd);</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">animations;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ animateTarget };</span>
</pre>
</body>
</html>