<html>
<head>
<title>index.js.flow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.js.flow</font>
</center></td></tr></table>
<pre><span class="s0">// @flow</span>

<span class="s1">type Exclude&lt;A, B&gt; = A;</span>
<span class="s0">// see https://gist.github.com/thecotne/6e5969f4aaf8f253985ed36b30ac9fe0</span>
<span class="s1">type $FlowGen$If&lt;X: boolean, Then, Else = empty&gt; = $Call&lt;</span>
  <span class="s1">((</span><span class="s2">true</span><span class="s1">, Then, Else) =&gt; Then) &amp; ((</span><span class="s2">false</span><span class="s1">, Then, Else) =&gt; Else),</span>
  <span class="s1">X,</span>
  <span class="s1">Then,</span>
  <span class="s1">Else</span>
<span class="s1">&gt;;</span>

<span class="s1">type $FlowGen$Assignable&lt;A, B&gt; = $Call&lt;</span>
  <span class="s1">((...r: [B]) =&gt; </span><span class="s2">true</span><span class="s1">) &amp; ((...r: [A]) =&gt; </span><span class="s2">false</span><span class="s1">),</span>
  <span class="s1">A</span>
<span class="s1">&gt;;</span>

<span class="s2">import </span><span class="s1">type {</span>
  <span class="s1">Angle,</span>
  <span class="s1">CssColor,</span>
  <span class="s1">Rule,</span>
  <span class="s1">CustomProperty,</span>
  <span class="s1">EnvironmentVariable,</span>
  <span class="s1">Function,</span>
  <span class="s1">Image,</span>
  <span class="s1">LengthValue,</span>
  <span class="s1">MediaQuery,</span>
  <span class="s1">Declaration,</span>
  <span class="s1">Ratio,</span>
  <span class="s1">Resolution,</span>
  <span class="s1">Selector,</span>
  <span class="s1">SupportsCondition,</span>
  <span class="s1">Time,</span>
  <span class="s1">Token,</span>
  <span class="s1">TokenOrValue,</span>
  <span class="s1">UnknownAtRule,</span>
  <span class="s1">Url,</span>
  <span class="s1">Variable,</span>
  <span class="s1">StyleRule,</span>
  <span class="s1">DeclarationBlock,</span>
  <span class="s1">ParsedComponent,</span>
  <span class="s1">Multiplier,</span>
  <span class="s1">StyleSheet,</span>
  <span class="s1">Location2,</span>
<span class="s1">} from </span><span class="s3">&quot;./ast.js.flow&quot;</span><span class="s1">;</span>
<span class="s2">import </span><span class="s1">{ Targets, Features } from </span><span class="s3">&quot;./targets.js.flow&quot;</span><span class="s1">;</span>
<span class="s1">declare </span><span class="s2">export </span><span class="s1">* from </span><span class="s3">&quot;./ast.js.flow&quot;</span><span class="s1">;</span>
<span class="s1">declare </span><span class="s2">export </span><span class="s1">{ Targets, Features };</span>
<span class="s2">export </span><span class="s1">type TransformOptions&lt;C: CustomAtRules&gt; = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* The filename being transformed. Used for error messages and source maps.</span>
   <span class="s0">*/</span>
  <span class="s1">filename: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* The source code to transform.</span>
   <span class="s0">*/</span>
  <span class="s1">code: Uint8Array,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to enable minification.</span>
   <span class="s0">*/</span>
  <span class="s1">minify?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to output a source map.</span>
   <span class="s0">*/</span>
  <span class="s1">sourceMap?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* An input source map to extend.</span>
   <span class="s0">*/</span>
  <span class="s1">inputSourceMap?: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* An optional project root path, used as the source root in the output source map.</span>
   <span class="s0">* Also used to generate relative paths for sources used in CSS module hashes.</span>
   <span class="s0">*/</span>
  <span class="s1">projectRoot?: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* The browser targets for the generated code.</span>
   <span class="s0">*/</span>
  <span class="s1">targets?: Targets,</span>

  <span class="s0">/**</span>
   <span class="s0">* Features that should always be compiled, even when supported by targets.</span>
   <span class="s0">*/</span>
  <span class="s1">include?: number,</span>

  <span class="s0">/**</span>
   <span class="s0">* Features that should never be compiled, even when unsupported by targets.</span>
   <span class="s0">*/</span>
  <span class="s1">exclude?: number,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to enable parsing various draft syntax.</span>
   <span class="s0">*/</span>
  <span class="s1">drafts?: Drafts,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to enable various non-standard syntax.</span>
   <span class="s0">*/</span>
  <span class="s1">nonStandard?: NonStandard,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to compile this file as a CSS module.</span>
   <span class="s0">*/</span>
  <span class="s1">cssModules?: boolean | CSSModulesConfig,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to analyze dependencies (e.g. string).</span>
   <span class="s0">* When enabled, string dependencies</span>
   <span class="s0">* are replaced with hashed placeholders that can be replaced with the final</span>
   <span class="s0">* urls later (after bundling). Dependencies are returned as part of the result.</span>
   <span class="s0">*/</span>
  <span class="s1">analyzeDependencies?: boolean | DependencyOptions,</span>

  <span class="s0">/**</span>
   <span class="s0">* Replaces user action pseudo classes with class names that can be applied from JavaScript.</span>
   <span class="s0">* This is useful for polyfills, for example.</span>
   <span class="s0">*/</span>
  <span class="s1">pseudoClasses?: PseudoClasses,</span>

  <span class="s0">/**</span>
   <span class="s0">* A list of class names, ids, and custom identifiers (e.g. @keyframes) that are known</span>
   <span class="s0">* to be unused. These will be removed during minification. Note that these are not</span>
   <span class="s0">* selectors but individual names (without any . or # prefixes).</span>
   <span class="s0">*/</span>
  <span class="s1">unusedSymbols?: string[],</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to ignore invalid rules and declarations rather than erroring.</span>
   <span class="s0">* When enabled, warnings are returned, and the invalid rule or declaration is</span>
   <span class="s0">* omitted from the output code.</span>
   <span class="s0">*/</span>
  <span class="s1">errorRecovery?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* An AST visitor object. This allows custom transforms or analysis to be implemented in JavaScript.</span>
   <span class="s0">* Multiple visitors can be composed into one using the string function.</span>
   <span class="s0">* For optimal performance, visitors should be as specific as possible about what types of values</span>
   <span class="s0">* they care about so that JavaScript has to be called as little as possible.</span>
   <span class="s0">*/</span>
  <span class="s1">visitor?: Visitor&lt;C&gt;,</span>

  <span class="s0">/**</span>
   <span class="s0">* Defines how to parse custom CSS at-rules. Each at-rule can have a prelude, defined using a CSS</span>
   <span class="s0">* [syntax string](https://drafts.css-houdini.org/css-properties-values-api/#syntax-strings), and</span>
   <span class="s0">* a block body. The body can be a declaration list, rule list, or style block as defined in the</span>
   <span class="s0">* [css spec](https://drafts.csswg.org/css-syntax/#declaration-rule-list).</span>
   <span class="s0">*/</span>
  <span class="s1">customAtRules?: C,</span>
<span class="s1">|};</span>
<span class="s1">declare type PropertyStart =</span>
  <span class="s1">| </span><span class="s3">&quot;-&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;_&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;a&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;b&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;c&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;d&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;e&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;f&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;g&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;h&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;i&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;j&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;k&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;l&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;m&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;n&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;o&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;p&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;q&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;r&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;s&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;t&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;u&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;v&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;w&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;x&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;y&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;z&quot;</span><span class="s1">;</span>
<span class="s2">export </span><span class="s1">type ReturnedDeclaration =</span>
  <span class="s1">| Declaration</span>
  <span class="s1">| {|</span>
      <span class="s0">/**</span>
       <span class="s0">* The property name.</span>
       <span class="s0">*/</span>
      <span class="s1">property: string,</span>

      <span class="s0">/**</span>
       <span class="s0">* The raw string value for the declaration.</span>
       <span class="s0">*/</span>
      <span class="s1">raw: string,</span>
    <span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type ReturnedMediaQuery =</span>
  <span class="s1">| MediaQuery</span>
  <span class="s1">| {|</span>
      <span class="s0">/**</span>
       <span class="s0">* The raw string value for the media query.</span>
       <span class="s0">*/</span>
      <span class="s1">raw: string,</span>
    <span class="s1">|};</span>
<span class="s1">declare type FindByType&lt;Union, Name&gt; = $FlowGen$If&lt;</span>
  <span class="s1">$FlowGen$Assignable&lt;</span>
    <span class="s1">Union,</span>
    <span class="s1">{|</span>
      <span class="s1">type: Name,</span>
    <span class="s1">|}</span>
  <span class="s1">&gt;,</span>
  <span class="s1">Union,</span>
  <span class="s1">empty</span>
<span class="s1">&gt;;</span>
<span class="s2">export </span><span class="s1">type ReturnedRule = Rule&lt;ReturnedDeclaration, ReturnedMediaQuery&gt;;</span>
<span class="s1">declare type RequiredValue&lt;Rule&gt; = $FlowGen$If&lt;</span>
  <span class="s1">$FlowGen$Assignable&lt;</span>
    <span class="s1">Rule,</span>
    <span class="s1">{|</span>
      <span class="s1">value: { [key: string]: any },</span>
    <span class="s1">|}</span>
  <span class="s1">&gt;,</span>
  <span class="s1">$FlowGen$If&lt;</span>
    <span class="s1">$FlowGen$Assignable&lt;$PropertyType&lt;Rule, </span><span class="s3">&quot;value&quot;</span><span class="s1">&gt;, StyleRule&gt;,</span>
    <span class="s1">{|</span>
      <span class="s1">...Rule,</span>
      <span class="s1">...{|</span>
        <span class="s1">value: {|</span>
          <span class="s1">...Required&lt;StyleRule&gt;,</span>
          <span class="s1">...{|</span>
            <span class="s1">declarations: Required&lt;DeclarationBlock&gt;,</span>
          <span class="s1">|},</span>
        <span class="s1">|},</span>
      <span class="s1">|},</span>
    <span class="s1">|},</span>
    <span class="s1">{|</span>
      <span class="s1">...Rule,</span>
      <span class="s1">...{|</span>
        <span class="s1">value: Required&lt;$PropertyType&lt;Rule, </span><span class="s3">&quot;value&quot;</span><span class="s1">&gt;&gt;,</span>
      <span class="s1">|},</span>
    <span class="s1">|}</span>
  <span class="s1">&gt;,</span>
  <span class="s1">Rule</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type RuleVisitor&lt;R = RequiredValue&lt;Rule&gt;&gt; = (</span>
  <span class="s1">rule: R</span>
<span class="s1">) =&gt; ReturnedRule | ReturnedRule[] | </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">declare type MappedRuleVisitors = $ObjMapi&lt;</span>
  <span class="s1">{ [k: Exclude&lt;$PropertyType&lt;Rule, </span><span class="s3">&quot;type&quot;</span><span class="s1">&gt;, </span><span class="s3">&quot;unknown&quot; </span><span class="s1">| </span><span class="s3">&quot;custom&quot;</span><span class="s1">&gt;]: any },</span>
  <span class="s1">&lt;Name&gt;(Name) =&gt; RuleVisitor&lt;RequiredValue&lt;FindByType&lt;Rule, Name&gt;&gt;&gt;</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type UnknownVisitors&lt;T&gt; = {</span>
  <span class="s1">[name: string]: RuleVisitor&lt;T&gt;,</span>
<span class="s1">};</span>
<span class="s1">declare type CustomVisitors&lt;T: CustomAtRules&gt; = $ObjMapi&lt;</span>
  <span class="s1">T,</span>
  <span class="s1">&lt;Name&gt;(Name) =&gt; RuleVisitor&lt;CustomAtRule&lt;Name, $ElementType&lt;T, Name&gt;&gt;&gt;</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type AnyCustomAtRule&lt;C: CustomAtRules&gt; = $ElementType&lt;</span>
  <span class="s1">$ObjMapi&lt;C, &lt;Key&gt;(Key) =&gt; CustomAtRule&lt;Key, $ElementType&lt;C, Key&gt;&gt;&gt;,</span>
  <span class="s1">$Keys&lt;C&gt;</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type RuleVisitors&lt;C: CustomAtRules&gt; = {|</span>
  <span class="s1">...MappedRuleVisitors,</span>
  <span class="s1">...{|</span>
    <span class="s1">unknown?:</span>
      <span class="s1">| UnknownVisitors&lt;UnknownAtRule&gt;</span>
      <span class="s1">| $Diff&lt;</span>
          <span class="s1">RuleVisitor&lt;UnknownAtRule&gt;,</span>
          <span class="s1">{ [key: $Keys&lt;CallableFunction&gt;]: any }</span>
        <span class="s1">&gt;,</span>
    <span class="s1">custom?:</span>
      <span class="s1">| CustomVisitors&lt;C&gt;</span>
      <span class="s1">| $Diff&lt;</span>
          <span class="s1">RuleVisitor&lt;AnyCustomAtRule&lt;C&gt;&gt;,</span>
          <span class="s1">{ [key: $Keys&lt;CallableFunction&gt;]: any }</span>
        <span class="s1">&gt;,</span>
  <span class="s1">|},</span>
<span class="s1">|};</span>
<span class="s1">declare type PreludeTypes = Exclude&lt;</span>
  <span class="s1">$PropertyType&lt;ParsedComponent, </span><span class="s3">&quot;type&quot;</span><span class="s1">&gt;,</span>
  <span class="s3">&quot;literal&quot; </span><span class="s1">| </span><span class="s3">&quot;repeated&quot; </span><span class="s1">| </span><span class="s3">&quot;token&quot;</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type SyntaxString = string | string;</span>
<span class="s1">declare type ComponentTypes = $ObjMapi&lt;</span>
  <span class="s1">{ [k: PreludeTypes]: any },</span>
  <span class="s1">&lt;Key&gt;(Key) =&gt; FindByType&lt;ParsedComponent, Key&gt;</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type Repetitions = $ObjMapi&lt;</span>
  <span class="s1">{ [k: PreludeTypes]: any },</span>
  <span class="s1">&lt;Key&gt;(Key) =&gt; {|</span>
    <span class="s1">type: </span><span class="s3">&quot;repeated&quot;</span><span class="s1">,</span>
    <span class="s1">value: {|</span>
      <span class="s1">components: FindByType&lt;ParsedComponent, Key&gt;[],</span>
      <span class="s1">multiplier: Multiplier,</span>
    <span class="s1">|},</span>
  <span class="s1">|}</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type MappedPrelude = {| ...ComponentTypes, ...Repetitions |};</span>
<span class="s1">declare type MappedBody&lt;P: $PropertyType&lt;CustomAtRuleDefinition, </span><span class="s3">&quot;body&quot;</span><span class="s1">&gt;&gt; =</span>
  <span class="s1">$FlowGen$If&lt;$FlowGen$Assignable&lt;P, </span><span class="s3">&quot;style-block&quot;</span><span class="s1">&gt;, </span><span class="s3">&quot;rule-list&quot;</span><span class="s1">, P&gt;;</span>
<span class="s1">declare type CustomAtRule&lt;N, R: CustomAtRuleDefinition&gt; = {|</span>
  <span class="s1">name: N,</span>
  <span class="s1">prelude: $FlowGen$If&lt;</span>
    <span class="s1">$FlowGen$Assignable&lt;$PropertyType&lt;R, </span><span class="s3">&quot;prelude&quot;</span><span class="s1">&gt;, $Keys&lt;MappedPrelude&gt;&gt;,</span>
    <span class="s1">$ElementType&lt;MappedPrelude, $PropertyType&lt;R, </span><span class="s3">&quot;prelude&quot;</span><span class="s1">&gt;&gt;,</span>
    <span class="s1">ParsedComponent</span>
  <span class="s1">&gt;,</span>
  <span class="s1">body: FindByType&lt;CustomAtRuleBody, MappedBody&lt;$PropertyType&lt;R, </span><span class="s3">&quot;body&quot;</span><span class="s1">&gt;&gt;&gt;,</span>
  <span class="s1">loc: Location2,</span>
<span class="s1">|};</span>
<span class="s1">declare type CustomAtRuleBody =</span>
  <span class="s1">| {|</span>
      <span class="s1">type: </span><span class="s3">&quot;declaration-list&quot;</span><span class="s1">,</span>
      <span class="s1">value: Required&lt;DeclarationBlock&gt;,</span>
    <span class="s1">|}</span>
  <span class="s1">| {|</span>
      <span class="s1">type: </span><span class="s3">&quot;rule-list&quot;</span><span class="s1">,</span>
      <span class="s1">value: RequiredValue&lt;Rule&gt;[],</span>
    <span class="s1">|};</span>
<span class="s1">declare type FindProperty&lt;Union, Name&gt; = $FlowGen$If&lt;</span>
  <span class="s1">$FlowGen$Assignable&lt;</span>
    <span class="s1">Union,</span>
    <span class="s1">{|</span>
      <span class="s1">property: Name,</span>
    <span class="s1">|}</span>
  <span class="s1">&gt;,</span>
  <span class="s1">Union,</span>
  <span class="s1">empty</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type DeclarationVisitor&lt;P = Declaration&gt; = (</span>
  <span class="s1">property: P</span>
<span class="s1">) =&gt; ReturnedDeclaration | ReturnedDeclaration[] | </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">declare type MappedDeclarationVisitors = $ObjMapi&lt;</span>
  <span class="s1">{</span>
    <span class="s1">[k: Exclude&lt;</span>
      <span class="s1">$PropertyType&lt;Declaration, </span><span class="s3">&quot;property&quot;</span><span class="s1">&gt;,</span>
      <span class="s3">&quot;unparsed&quot; </span><span class="s1">| </span><span class="s3">&quot;custom&quot;</span>
    <span class="s1">&gt;]: any,</span>
  <span class="s1">},</span>
  <span class="s1">&lt;Name&gt;(</span>
    <span class="s1">Name</span>
  <span class="s1">) =&gt; DeclarationVisitor&lt;</span>
    <span class="s1">FindProperty&lt;Declaration, Name&gt; | FindProperty&lt;Declaration, </span><span class="s3">&quot;unparsed&quot;</span><span class="s1">&gt;</span>
  <span class="s1">&gt;</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type CustomPropertyVisitors = {</span>
  <span class="s1">[name: string]: DeclarationVisitor&lt;CustomProperty&gt;,</span>
<span class="s1">};</span>
<span class="s1">declare type DeclarationVisitors = {|</span>
  <span class="s1">...MappedDeclarationVisitors,</span>
  <span class="s1">...{|</span>
    <span class="s1">custom?: CustomPropertyVisitors | DeclarationVisitor&lt;CustomProperty&gt;,</span>
  <span class="s1">|},</span>
<span class="s1">|};</span>
<span class="s1">declare type RawValue = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* A raw string value which will be parsed like CSS.</span>
   <span class="s0">*/</span>
  <span class="s1">raw: string,</span>
<span class="s1">|};</span>
<span class="s1">declare type TokenReturnValue = TokenOrValue | TokenOrValue[] | RawValue | </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">declare type TokenVisitor = (token: Token) =&gt; TokenReturnValue;</span>
<span class="s1">declare type VisitableTokenTypes =</span>
  <span class="s1">| </span><span class="s3">&quot;ident&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;at-keyword&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;hash&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;id-hash&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;string&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;number&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;percentage&quot;</span>
  <span class="s1">| </span><span class="s3">&quot;dimension&quot;</span><span class="s1">;</span>
<span class="s1">declare type TokenVisitors = $ObjMapi&lt;</span>
  <span class="s1">{ [k: VisitableTokenTypes]: any },</span>
  <span class="s1">&lt;Name&gt;(Name) =&gt; (token: FindByType&lt;Token, Name&gt;) =&gt; TokenReturnValue</span>
<span class="s1">&gt;;</span>
<span class="s1">declare type FunctionVisitor = (fn: Function) =&gt; TokenReturnValue;</span>
<span class="s1">declare type EnvironmentVariableVisitor = (</span>
  <span class="s1">env: EnvironmentVariable</span>
<span class="s1">) =&gt; TokenReturnValue;</span>
<span class="s1">declare type EnvironmentVariableVisitors = {</span>
  <span class="s1">[name: string]: EnvironmentVariableVisitor,</span>
<span class="s1">};</span>
<span class="s2">export </span><span class="s1">type Visitor&lt;C: CustomAtRules&gt; = {|</span>
  <span class="s1">StyleSheet?: (</span>
    <span class="s1">stylesheet: StyleSheet</span>
  <span class="s1">) =&gt; StyleSheet&lt;ReturnedDeclaration, ReturnedMediaQuery&gt; | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">StyleSheetExit?: (</span>
    <span class="s1">stylesheet: StyleSheet</span>
  <span class="s1">) =&gt; StyleSheet&lt;ReturnedDeclaration, ReturnedMediaQuery&gt; | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Rule?: RuleVisitor&lt;&gt; | RuleVisitors&lt;C&gt;,</span>
  <span class="s1">RuleExit?: RuleVisitor&lt;&gt; | RuleVisitors&lt;C&gt;,</span>
  <span class="s1">Declaration?: DeclarationVisitor&lt;&gt; | DeclarationVisitors,</span>
  <span class="s1">DeclarationExit?: DeclarationVisitor&lt;&gt; | DeclarationVisitors,</span>
  <span class="s1">Url?: (url: Url) =&gt; Url | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Color?: (color: CssColor) =&gt; CssColor | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Image?: (image: Image) =&gt; Image | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">ImageExit?: (image: Image) =&gt; Image | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Length?: (length: LengthValue) =&gt; LengthValue | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Angle?: (angle: Angle) =&gt; Angle | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Ratio?: (ratio: Ratio) =&gt; Ratio | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Resolution?: (resolution: Resolution) =&gt; Resolution | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Time?: (time: Time) =&gt; Time | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">CustomIdent?: (ident: string) =&gt; string | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">DashedIdent?: (ident: string) =&gt; string | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">MediaQuery?: (</span>
    <span class="s1">query: MediaQuery</span>
  <span class="s1">) =&gt; ReturnedMediaQuery | ReturnedMediaQuery[] | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">MediaQueryExit?: (</span>
    <span class="s1">query: MediaQuery</span>
  <span class="s1">) =&gt; ReturnedMediaQuery | ReturnedMediaQuery[] | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">SupportsCondition?: (condition: SupportsCondition) =&gt; SupportsCondition,</span>
  <span class="s1">SupportsConditionExit?: (condition: SupportsCondition) =&gt; SupportsCondition,</span>
  <span class="s1">Selector?: (selector: Selector) =&gt; Selector | Selector[] | </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">Token?: TokenVisitor | TokenVisitors,</span>
  <span class="s1">Function?:</span>
    <span class="s1">| FunctionVisitor</span>
    <span class="s1">| {</span>
        <span class="s1">[name: string]: FunctionVisitor,</span>
      <span class="s1">},</span>
  <span class="s1">FunctionExit?:</span>
    <span class="s1">| FunctionVisitor</span>
    <span class="s1">| {</span>
        <span class="s1">[name: string]: FunctionVisitor,</span>
      <span class="s1">},</span>
  <span class="s1">Variable?: (variable: Variable) =&gt; TokenReturnValue,</span>
  <span class="s1">VariableExit?: (variable: Variable) =&gt; TokenReturnValue,</span>
  <span class="s1">EnvironmentVariable?:</span>
    <span class="s1">| EnvironmentVariableVisitor</span>
    <span class="s1">| EnvironmentVariableVisitors,</span>
  <span class="s1">EnvironmentVariableExit?:</span>
    <span class="s1">| EnvironmentVariableVisitor</span>
    <span class="s1">| EnvironmentVariableVisitors,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type CustomAtRules = {|</span>
  <span class="s1">[name: string]: CustomAtRuleDefinition,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type CustomAtRuleDefinition = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* Defines the syntax for a custom at-rule prelude. The value should be a</span>
   <span class="s0">* CSS [syntax string](https://drafts.css-houdini.org/css-properties-values-api/#syntax-strings)</span>
   <span class="s0">* representing the types of values that are accepted. This property may be omitted or</span>
   <span class="s0">* set to null to indicate that no prelude is accepted.</span>
   <span class="s0">*/</span>
  <span class="s1">prelude?: SyntaxString | </span><span class="s2">null</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* Defines the type of body contained within the at-rule block.</span>
   <span class="s0">*   - declaration-list: A CSS declaration list, as in a style rule.</span>
   <span class="s0">*   - rule-list: A list of CSS rules, as supported within a non-nested</span>
   <span class="s0">*       at-rule such as string.</span>
   <span class="s0">*   - style-block: Both a declaration list and rule list, as accepted within</span>
   <span class="s0">*       a nested at-rule within a style rule (e.g. string inside a style rule</span>
   <span class="s0">*       with directly nested declarations).</span>
   <span class="s0">*/</span>
  <span class="s1">body?: </span><span class="s3">&quot;declaration-list&quot; </span><span class="s1">| </span><span class="s3">&quot;rule-list&quot; </span><span class="s1">| </span><span class="s3">&quot;style-block&quot; </span><span class="s1">| </span><span class="s2">null</span><span class="s1">,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type DependencyOptions = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* Whether to preserve string rules rather than removing them.</span>
   <span class="s0">*/</span>
  <span class="s1">preserveImports?: boolean,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type BundleOptions&lt;C: CustomAtRules&gt; = $Diff&lt;</span>
  <span class="s1">TransformOptions&lt;C&gt;,</span>
  <span class="s1">{| code: any |}</span>
<span class="s1">&gt;;</span>
<span class="s2">export </span><span class="s1">type BundleAsyncOptions&lt;C: CustomAtRules&gt; = {|</span>
  <span class="s1">...$Exact&lt;BundleOptions&lt;C&gt;&gt;,</span>

  <span class="s1">resolver?: Resolver,</span>
<span class="s1">|};</span>

<span class="s0">/**</span>
 <span class="s0">* Custom resolver to use when loading CSS files.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">type Resolver = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* Read the given file and return its contents as a string.</span>
   <span class="s0">*/</span>
  <span class="s1">read?: (file: string) =&gt; string | Promise&lt;string&gt;,</span>

  <span class="s0">/**</span>
   <span class="s0">* Resolve the given CSS import specifier from the provided originating file to a</span>
   <span class="s0">* path which gets passed to string.</span>
   <span class="s0">*/</span>
  <span class="s1">resolve?: (</span>
    <span class="s1">specifier: string,</span>
    <span class="s1">originatingFile: string</span>
  <span class="s1">) =&gt; string | Promise&lt;string&gt;,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type Drafts = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* Whether to enable @custom-media rules.</span>
   <span class="s0">*/</span>
  <span class="s1">customMedia?: boolean,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type NonStandard = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* Whether to enable the non-standard &gt;&gt;&gt; and /deep/ selector combinators used by Angular and Vue.</span>
   <span class="s0">*/</span>
  <span class="s1">deepSelectorCombinator?: boolean,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type PseudoClasses = {|</span>
  <span class="s1">hover?: string,</span>
  <span class="s1">active?: string,</span>
  <span class="s1">focus?: string,</span>
  <span class="s1">focusVisible?: string,</span>
  <span class="s1">focusWithin?: string,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type TransformResult = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* The transformed code.</span>
   <span class="s0">*/</span>
  <span class="s1">code: Uint8Array,</span>

  <span class="s0">/**</span>
   <span class="s0">* The generated source map, if enabled.</span>
   <span class="s0">*/</span>
  <span class="s1">map: Uint8Array | </span><span class="s2">void</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* CSS module exports, if enabled.</span>
   <span class="s0">*/</span>
  <span class="s1">exports: CSSModuleExports | </span><span class="s2">void</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* CSS module references, if string is enabled.</span>
   <span class="s0">*/</span>
  <span class="s1">references: CSSModuleReferences,</span>

  <span class="s0">/**</span>
   <span class="s0">* string dependencies, if enabled.</span>
   <span class="s0">*/</span>
  <span class="s1">dependencies: Dependency[] | </span><span class="s2">void</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* Warnings that occurred during compilation.</span>
   <span class="s0">*/</span>
  <span class="s1">warnings: Warning[],</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type Warning = {|</span>
  <span class="s1">message: string,</span>
  <span class="s1">type: string,</span>
  <span class="s1">value?: any,</span>
  <span class="s1">loc: ErrorLocation,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type CSSModulesConfig = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* The pattern to use when renaming class names and other identifiers. Default is string.</span>
   <span class="s0">*/</span>
  <span class="s1">pattern?: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to rename dashed identifiers, e.g. custom properties.</span>
   <span class="s0">*/</span>
  <span class="s1">dashedIdents?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to enable hashing for string.</span>
   <span class="s0">*/</span>
  <span class="s1">animation?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to enable hashing for CSS grid identifiers.</span>
   <span class="s0">*/</span>
  <span class="s1">grid?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to enable hashing for string names.</span>
   <span class="s0">*/</span>
  <span class="s1">container?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to enable hashing for custom identifiers.</span>
   <span class="s0">*/</span>
  <span class="s1">customIdents?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to require at least one class or id selector in each rule.</span>
   <span class="s0">*/</span>
  <span class="s1">pure?: boolean,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type CSSModuleExports = {</span>
  <span class="s0">/**</span>
   <span class="s0">* Maps exported (i.e. original) names to local names.</span>
   <span class="s0">*/</span>
  <span class="s1">[name: string]: CSSModuleExport,</span>
<span class="s1">};</span>
<span class="s2">export </span><span class="s1">type CSSModuleExport = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* The local (compiled) name for this export.</span>
   <span class="s0">*/</span>
  <span class="s1">name: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether the export is referenced in this file.</span>
   <span class="s0">*/</span>
  <span class="s1">isReferenced: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* Other names that are composed by this export.</span>
   <span class="s0">*/</span>
  <span class="s1">composes: CSSModuleReference[],</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type CSSModuleReferences = {</span>
  <span class="s0">/**</span>
   <span class="s0">* Maps placeholder names to references.</span>
   <span class="s0">*/</span>
  <span class="s1">[name: string]: DependencyCSSModuleReference,</span>
<span class="s1">};</span>
<span class="s2">export </span><span class="s1">type CSSModuleReference =</span>
  <span class="s1">| LocalCSSModuleReference</span>
  <span class="s1">| GlobalCSSModuleReference</span>
  <span class="s1">| DependencyCSSModuleReference;</span>
<span class="s2">export </span><span class="s1">type LocalCSSModuleReference = {|</span>
  <span class="s1">type: </span><span class="s3">&quot;local&quot;</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* The local (compiled) name for the reference.</span>
   <span class="s0">*/</span>
  <span class="s1">name: string,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type GlobalCSSModuleReference = {|</span>
  <span class="s1">type: </span><span class="s3">&quot;global&quot;</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* The referenced global name.</span>
   <span class="s0">*/</span>
  <span class="s1">name: string,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type DependencyCSSModuleReference = {|</span>
  <span class="s1">type: </span><span class="s3">&quot;dependency&quot;</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* The name to reference within the dependency.</span>
   <span class="s0">*/</span>
  <span class="s1">name: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* The dependency specifier for the referenced file.</span>
   <span class="s0">*/</span>
  <span class="s1">specifier: string,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type Dependency = ImportDependency | UrlDependency;</span>
<span class="s2">export </span><span class="s1">type ImportDependency = {|</span>
  <span class="s1">type: </span><span class="s3">&quot;import&quot;</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* The url of the string dependency.</span>
   <span class="s0">*/</span>
  <span class="s1">url: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* The media query for the string rule.</span>
   <span class="s0">*/</span>
  <span class="s1">media: string | </span><span class="s2">null</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* The string rule.</span>
   <span class="s0">*/</span>
  <span class="s1">supports: string | </span><span class="s2">null</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* The source location where the string rule was found.</span>
   <span class="s0">*/</span>
  <span class="s1">loc: SourceLocation,</span>

  <span class="s0">/**</span>
   <span class="s0">* The placeholder that the import was replaced with.</span>
   <span class="s0">*/</span>
  <span class="s1">placeholder: string,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type UrlDependency = {|</span>
  <span class="s1">type: </span><span class="s3">&quot;url&quot;</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* The url of the dependency.</span>
   <span class="s0">*/</span>
  <span class="s1">url: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* The source location where the string was found.</span>
   <span class="s0">*/</span>
  <span class="s1">loc: SourceLocation,</span>

  <span class="s0">/**</span>
   <span class="s0">* The placeholder that the url was replaced with.</span>
   <span class="s0">*/</span>
  <span class="s1">placeholder: string,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type SourceLocation = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* The file path in which the dependency exists.</span>
   <span class="s0">*/</span>
  <span class="s1">filePath: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* The start location of the dependency.</span>
   <span class="s0">*/</span>
  <span class="s1">start: Location,</span>

  <span class="s0">/**</span>
   <span class="s0">* The end location (inclusive) of the dependency.</span>
   <span class="s0">*/</span>
  <span class="s1">end: Location,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type Location = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* The line number (1-based).</span>
   <span class="s0">*/</span>
  <span class="s1">line: number,</span>

  <span class="s0">/**</span>
   <span class="s0">* The column number (0-based).</span>
   <span class="s0">*/</span>
  <span class="s1">column: number,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type ErrorLocation = {|</span>
  <span class="s1">...$Exact&lt;Location&gt;,</span>

  <span class="s1">filename: string,</span>
<span class="s1">|};</span>

<span class="s0">/**</span>
 <span class="s0">* Compiles a CSS file, including optionally minifying and lowering syntax to the given</span>
 <span class="s0">* targets. A source map may also be generated, but this is not enabled by default.</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">export function </span><span class="s1">transform&lt;C: CustomAtRules&gt;(</span>
  <span class="s1">options: TransformOptions&lt;C&gt;</span>
<span class="s1">): TransformResult;</span>
<span class="s2">export </span><span class="s1">type TransformAttributeOptions = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* The filename in which the style attribute appeared. Used for error messages and dependencies.</span>
   <span class="s0">*/</span>
  <span class="s1">filename?: string,</span>

  <span class="s0">/**</span>
   <span class="s0">* The source code to transform.</span>
   <span class="s0">*/</span>
  <span class="s1">code: Uint8Array,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to enable minification.</span>
   <span class="s0">*/</span>
  <span class="s1">minify?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* The browser targets for the generated code.</span>
   <span class="s0">*/</span>
  <span class="s1">targets?: Targets,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to analyze string dependencies.</span>
   <span class="s0">* When enabled, string dependencies are replaced with hashed placeholders</span>
   <span class="s0">* that can be replaced with the final urls later (after bundling).</span>
   <span class="s0">* Dependencies are returned as part of the result.</span>
   <span class="s0">*/</span>
  <span class="s1">analyzeDependencies?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* Whether to ignore invalid rules and declarations rather than erroring.</span>
   <span class="s0">* When enabled, warnings are returned, and the invalid rule or declaration is</span>
   <span class="s0">* omitted from the output code.</span>
   <span class="s0">*/</span>
  <span class="s1">errorRecovery?: boolean,</span>

  <span class="s0">/**</span>
   <span class="s0">* An AST visitor object. This allows custom transforms or analysis to be implemented in JavaScript.</span>
   <span class="s0">* Multiple visitors can be composed into one using the string function.</span>
   <span class="s0">* For optimal performance, visitors should be as specific as possible about what types of values</span>
   <span class="s0">* they care about so that JavaScript has to be called as little as possible.</span>
   <span class="s0">*/</span>
  <span class="s1">visitor?: Visitor&lt;empty&gt;,</span>
<span class="s1">|};</span>
<span class="s2">export </span><span class="s1">type TransformAttributeResult = {|</span>
  <span class="s0">/**</span>
   <span class="s0">* The transformed code.</span>
   <span class="s0">*/</span>
  <span class="s1">code: Uint8Array,</span>

  <span class="s0">/**</span>
   <span class="s0">* string dependencies, if enabled.</span>
   <span class="s0">*/</span>
  <span class="s1">dependencies: Dependency[] | </span><span class="s2">void</span><span class="s1">,</span>

  <span class="s0">/**</span>
   <span class="s0">* Warnings that occurred during compilation.</span>
   <span class="s0">*/</span>
  <span class="s1">warnings: Warning[],</span>
<span class="s1">|};</span>

<span class="s0">/**</span>
 <span class="s0">* Compiles a single CSS declaration list, such as an inline style attribute in HTML.</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">export function </span><span class="s1">transformStyleAttribute(</span>
  <span class="s1">options: TransformAttributeOptions</span>
<span class="s1">): TransformAttributeResult;</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a browserslist result into targets that can be passed to lightningcss.</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">browserslist the result of calling string</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">export function </span><span class="s1">browserslistToTargets(browserslist: string[]): Targets;</span>

<span class="s0">/**</span>
 <span class="s0">* Bundles a CSS file and its dependencies, inlining @import rules.</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">export function </span><span class="s1">bundle&lt;C: CustomAtRules&gt;(</span>
  <span class="s1">options: BundleOptions&lt;C&gt;</span>
<span class="s1">): TransformResult;</span>

<span class="s0">/**</span>
 <span class="s0">* Bundles a CSS file and its dependencies asynchronously, inlining @import rules.</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">export function </span><span class="s1">bundleAsync&lt;C: CustomAtRules&gt;(</span>
  <span class="s1">options: BundleAsyncOptions&lt;C&gt;</span>
<span class="s1">): Promise&lt;TransformResult&gt;;</span>

<span class="s0">/**</span>
 <span class="s0">* Composes multiple visitor objects into a single one.</span>
 <span class="s0">*/</span>
<span class="s1">declare </span><span class="s2">export function </span><span class="s1">composeVisitors&lt;C: CustomAtRules&gt;(</span>
  <span class="s1">visitors: Visitor&lt;C&gt;[]</span>
<span class="s1">): Visitor&lt;C&gt;;</span>
</pre>
</body>
</html>