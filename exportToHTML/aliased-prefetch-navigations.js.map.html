<html>
<head>
<title>aliased-prefetch-navigations.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
aliased-prefetch-navigations.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/aliased-prefetch-navigations.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">addSearchParamsIfPageSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import type { NormalizedFlightData } from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { createEmptyCacheNode } from '../app-router'</span><span class="s3">\n</span><span class="s1">import { applyRouterStatePatchToTree } from './apply-router-state-patch-to-tree'</span><span class="s3">\n</span><span class="s1">import { createHrefFromUrl } from './create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import { fillCacheWithNewSubTreeDataButOnlyLoading } from './fill-cache-with-new-subtree-data'</span><span class="s3">\n</span><span class="s1">import { handleMutable } from './handle-mutable'</span><span class="s3">\n</span><span class="s1">import { generateSegmentsFromPatch } from './reducers/navigate-reducer'</span><span class="s3">\n</span><span class="s1">import type { Mutable, ReadonlyReducerState } from './router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a stop-gap until per-segment caching is implemented. It leverages the `aliased` flag that is added</span><span class="s3">\n </span><span class="s1">* to prefetch entries when it's determined that the loading state from that entry should be used for this navigation.</span><span class="s3">\n </span><span class="s1">* This function takes the aliased entry and only applies the loading state to the updated cache node.</span><span class="s3">\n </span><span class="s1">* We should remove this once per-segment fetching is implemented as ideally the prefetch cache will contain a</span><span class="s3">\n </span><span class="s1">* more granular segment map and so the router will be able to simply re-use the loading segment for the new navigation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function handleAliasedPrefetchEntry(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">state: ReadonlyReducerState,</span><span class="s3">\n  </span><span class="s1">flightData: string | NormalizedFlightData[],</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">mutable: Mutable</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let currentTree = state.tree</span><span class="s3">\n  </span><span class="s1">let currentCache = state.cache</span><span class="s3">\n  </span><span class="s1">const href = createHrefFromUrl(url)</span><span class="s3">\n  </span><span class="s1">let applied</span><span class="s3">\n  </span><span class="s1">let scrollableSegments: FlightSegmentPath[] = []</span><span class="s3">\n\n  </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n    </span><span class="s1">// If the segment doesn't have a loading component, we don't need to do anything.</span><span class="s3">\n    </span><span class="s1">if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let treePatch = normalizedFlightData.tree</span><span class="s3">\n    </span><span class="s1">// Segments are keyed by searchParams (e.g. __PAGE__?{</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">bar</span><span class="s3">\&quot;</span><span class="s1">}). We might return a less specific, param-less entry,</span><span class="s3">\n    </span><span class="s1">// so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.</span><span class="s3">\n    </span><span class="s1">// We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set</span><span class="s3">\n    </span><span class="s1">treePatch = addSearchParamsToPageSegments(</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">Object.fromEntries(url.searchParams)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const { seedData, isRootRender, pathToSegment } = normalizedFlightData</span><span class="s3">\n    </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n    </span><span class="s1">const flightSegmentPathWithLeadingEmpty = ['', ...pathToSegment]</span><span class="s3">\n\n    </span><span class="s1">// Segments are keyed by searchParams (e.g. __PAGE__?{</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">bar</span><span class="s3">\&quot;</span><span class="s1">}). We might return a less specific, param-less entry,</span><span class="s3">\n    </span><span class="s1">// so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.</span><span class="s3">\n    </span><span class="s1">// We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set</span><span class="s3">\n    </span><span class="s1">treePatch = addSearchParamsToPageSegments(</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">Object.fromEntries(url.searchParams)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">let newTree = applyRouterStatePatchToTree(</span><span class="s3">\n      </span><span class="s1">flightSegmentPathWithLeadingEmpty,</span><span class="s3">\n      </span><span class="s1">currentTree,</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">href</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const newCache = createEmptyCacheNode()</span><span class="s3">\n\n    </span><span class="s1">// The prefetch cache entry was aliased -- this signals that we only fill in the cache with the</span><span class="s3">\n    </span><span class="s1">// loading state and not the actual parallel route seed data.</span><span class="s3">\n    </span><span class="s1">if (isRootRender &amp;&amp; seedData) {</span><span class="s3">\n      </span><span class="s1">// Fill in the cache with the new loading / rsc data</span><span class="s3">\n      </span><span class="s1">const rsc = seedData[1]</span><span class="s3">\n      </span><span class="s1">const loading = seedData[3]</span><span class="s3">\n      </span><span class="s1">newCache.loading = loading</span><span class="s3">\n      </span><span class="s1">newCache.rsc = rsc</span><span class="s3">\n\n      </span><span class="s1">// Construct a new tree and apply the aliased loading state for each parallel route</span><span class="s3">\n      </span><span class="s1">fillNewTreeWithOnlyLoadingSegments(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">newCache,</span><span class="s3">\n        </span><span class="s1">currentCache,</span><span class="s3">\n        </span><span class="s1">treePatch,</span><span class="s3">\n        </span><span class="s1">seedData</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Copy rsc for the root node of the cache.</span><span class="s3">\n      </span><span class="s1">newCache.rsc = currentCache.rsc</span><span class="s3">\n      </span><span class="s1">newCache.prefetchRsc = currentCache.prefetchRsc</span><span class="s3">\n      </span><span class="s1">newCache.loading = currentCache.loading</span><span class="s3">\n      </span><span class="s1">newCache.parallelRoutes = new Map(currentCache.parallelRoutes)</span><span class="s3">\n\n      </span><span class="s1">// copy the loading state only into the leaf node (the part that changed)</span><span class="s3">\n      </span><span class="s1">fillCacheWithNewSubTreeDataButOnlyLoading(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">newCache,</span><span class="s3">\n        </span><span class="s1">currentCache,</span><span class="s3">\n        </span><span class="s1">normalizedFlightData</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we don't have an updated tree, there's no reason to update the cache, as the tree</span><span class="s3">\n    </span><span class="s1">// dictates what cache nodes to render.</span><span class="s3">\n    </span><span class="s1">if (newTree) {</span><span class="s3">\n      </span><span class="s1">currentTree = newTree</span><span class="s3">\n      </span><span class="s1">currentCache = newCache</span><span class="s3">\n      </span><span class="s1">applied = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const subSegment of generateSegmentsFromPatch(treePatch)) {</span><span class="s3">\n      </span><span class="s1">const scrollableSegmentPath = [</span><span class="s3">\n        </span><span class="s1">...normalizedFlightData.pathToSegment,</span><span class="s3">\n        </span><span class="s1">...subSegment,</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">// Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">scrollableSegmentPath[scrollableSegmentPath.length - 1] !==</span><span class="s3">\n        </span><span class="s1">DEFAULT_SEGMENT_KEY</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">scrollableSegments.push(scrollableSegmentPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!applied) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">mutable.patchedTree = currentTree</span><span class="s3">\n  </span><span class="s1">mutable.cache = currentCache</span><span class="s3">\n  </span><span class="s1">mutable.canonicalUrl = href</span><span class="s3">\n  </span><span class="s1">mutable.hashFragment = url.hash</span><span class="s3">\n  </span><span class="s1">mutable.scrollableSegments = scrollableSegments</span><span class="s3">\n\n  </span><span class="s1">return handleMutable(state, mutable)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasLoadingComponentInSeedData(seedData: CacheNodeSeedData | null) {</span><span class="s3">\n  </span><span class="s1">if (!seedData) return false</span><span class="s3">\n\n  </span><span class="s1">const parallelRoutes = seedData[2]</span><span class="s3">\n  </span><span class="s1">const loading = seedData[3]</span><span class="s3">\n\n  </span><span class="s1">if (loading) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key in parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">if (hasLoadingComponentInSeedData(parallelRoutes[key])) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function fillNewTreeWithOnlyLoadingSegments(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">newCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">existingCache: CacheNode,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">cacheNodeSeedData: CacheNodeSeedData | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isLastSegment = Object.keys(routerState[1]).length === 0</span><span class="s3">\n  </span><span class="s1">if (isLastSegment) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key in routerState[1]) {</span><span class="s3">\n    </span><span class="s1">const parallelRouteState = routerState[1][key]</span><span class="s3">\n    </span><span class="s1">const segmentForParallelRoute = parallelRouteState[0]</span><span class="s3">\n    </span><span class="s1">const cacheKey = createRouterCacheKey(segmentForParallelRoute)</span><span class="s3">\n\n    </span><span class="s1">const parallelSeedData =</span><span class="s3">\n      </span><span class="s1">cacheNodeSeedData !== null &amp;&amp; cacheNodeSeedData[2][key] !== undefined</span><span class="s3">\n        </span><span class="s1">? cacheNodeSeedData[2][key]</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n\n    </span><span class="s1">let newCacheNode: CacheNode</span><span class="s3">\n    </span><span class="s1">if (parallelSeedData !== null) {</span><span class="s3">\n      </span><span class="s1">// New data was sent from the server.</span><span class="s3">\n      </span><span class="s1">const rsc = parallelSeedData[1]</span><span class="s3">\n      </span><span class="s1">const loading = parallelSeedData[3]</span><span class="s3">\n      </span><span class="s1">newCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">// copy the layout but null the page segment as that's not meant to be used</span><span class="s3">\n        </span><span class="s1">rsc: segmentForParallelRoute.includes(PAGE_SEGMENT_KEY) ? null : rsc,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading,</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// No data available for this node. This will trigger a lazy fetch</span><span class="s3">\n      </span><span class="s1">// during render.</span><span class="s3">\n      </span><span class="s1">newCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const existingParallelRoutes = newCache.parallelRoutes.get(key)</span><span class="s3">\n    </span><span class="s1">if (existingParallelRoutes) {</span><span class="s3">\n      </span><span class="s1">existingParallelRoutes.set(cacheKey, newCacheNode)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">fillNewTreeWithOnlyLoadingSegments(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">newCacheNode,</span><span class="s3">\n      </span><span class="s1">existingCache,</span><span class="s3">\n      </span><span class="s1">parallelRouteState,</span><span class="s3">\n      </span><span class="s1">parallelSeedData</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add search params to the page segments in the flight router state</span><span class="s3">\n </span><span class="s1">* Page segments that are associated with search params have a page segment key</span><span class="s3">\n </span><span class="s1">* followed by a query string. This function will add those params to the page segment.</span><span class="s3">\n </span><span class="s1">* This is useful if we return an aliased prefetch entry (ie, won't have search params)</span><span class="s3">\n </span><span class="s1">* but the canonical router URL has search params.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addSearchParamsToPageSegments(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">searchParams: Record&lt;string, string | string[] | undefined&gt;</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes, ...rest] = flightRouterState</span><span class="s3">\n\n  </span><span class="s1">// If it's a page segment, modify the segment by adding search params</span><span class="s3">\n  </span><span class="s1">if (segment.includes(PAGE_SEGMENT_KEY)) {</span><span class="s3">\n    </span><span class="s1">const newSegment = addSearchParamsIfPageSegment(segment, searchParams)</span><span class="s3">\n    </span><span class="s1">return [newSegment, parallelRoutes, ...rest]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Otherwise, recurse through the parallel routes and return a new tree</span><span class="s3">\n  </span><span class="s1">const updatedParallelRoutes: { [key: string]: FlightRouterState } = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [key, parallelRoute] of Object.entries(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">updatedParallelRoutes[key] = addSearchParamsToPageSegments(</span><span class="s3">\n      </span><span class="s1">parallelRoute,</span><span class="s3">\n      </span><span class="s1">searchParams</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return [segment, updatedParallelRoutes, ...rest]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;addSearchParamsToPageSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;handleAliasedPrefetchEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;mutable&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;currentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;applied&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoadingComponentInSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootRender&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPathWithLeadingEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;newTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;newCache&quot;</span><span class="s0">,</span><span class="s1">&quot;createEmptyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;fillNewTreeWithOnlyLoadingSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;fillCacheWithNewSubTreeDataButOnlyLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;subSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;generateSegmentsFromPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMutable&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCache&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteState&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentForParallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;existingParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;rest&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;addSearchParamsIfPageSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>