<html>
<head>
<title>gatherLogicalOperands.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gatherLogicalOperands.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || (</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">ownKeys = </span><span class="s2">function</span><span class="s1">(o) {</span>
        <span class="s1">ownKeys = Object.getOwnPropertyNames || </span><span class="s2">function </span><span class="s1">(o) {</span>
            <span class="s2">var </span><span class="s1">ar = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">o) </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;</span>
            <span class="s2">return </span><span class="s1">ar;</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">ownKeys(o);</span>
    <span class="s1">};</span>
    <span class="s2">return function </span><span class="s1">(mod) {</span>
        <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
        <span class="s2">var </span><span class="s1">result = {};</span>
        <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k = ownKeys(mod), i = </span><span class="s3">0</span><span class="s1">; i &lt; k.length; i++) </span><span class="s2">if </span><span class="s1">(k[i] !== </span><span class="s0">&quot;default&quot;</span><span class="s1">) __createBinding(result, mod, k[i]);</span>
        <span class="s1">__setModuleDefault(result, mod);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>
<span class="s1">})();</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.NullishComparisonType = exports.OperandValidity = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">exports.gatherLogicalOperands = gatherLogicalOperands;</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ts_api_utils_1 = require(</span><span class="s0">&quot;ts-api-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../../util&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">ComparisonValueType;</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(ComparisonValueType) {</span>
    <span class="s1">ComparisonValueType[</span><span class="s0">&quot;Null&quot;</span><span class="s1">] = </span><span class="s0">&quot;Null&quot;</span><span class="s1">;</span>
    <span class="s1">ComparisonValueType[</span><span class="s0">&quot;Undefined&quot;</span><span class="s1">] = </span><span class="s0">&quot;Undefined&quot;</span><span class="s1">;</span>
    <span class="s1">ComparisonValueType[</span><span class="s0">&quot;UndefinedStringLiteral&quot;</span><span class="s1">] = </span><span class="s0">&quot;UndefinedStringLiteral&quot;</span><span class="s1">;</span>
<span class="s1">})(ComparisonValueType || (ComparisonValueType = {}));</span>
<span class="s2">var </span><span class="s1">OperandValidity;</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(OperandValidity) {</span>
    <span class="s1">OperandValidity[</span><span class="s0">&quot;Valid&quot;</span><span class="s1">] = </span><span class="s0">&quot;Valid&quot;</span><span class="s1">;</span>
    <span class="s1">OperandValidity[</span><span class="s0">&quot;Invalid&quot;</span><span class="s1">] = </span><span class="s0">&quot;Invalid&quot;</span><span class="s1">;</span>
<span class="s1">})(OperandValidity || (exports.OperandValidity = OperandValidity = {}));</span>
<span class="s2">var </span><span class="s1">NullishComparisonType;</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(NullishComparisonType) {</span>
    <span class="s4">/** `x != null`, `x != undefined` */</span>
    <span class="s1">NullishComparisonType[</span><span class="s0">&quot;NotEqualNullOrUndefined&quot;</span><span class="s1">] = </span><span class="s0">&quot;NotEqualNullOrUndefined&quot;</span><span class="s1">;</span>
    <span class="s4">/** `x == null`, `x == undefined` */</span>
    <span class="s1">NullishComparisonType[</span><span class="s0">&quot;EqualNullOrUndefined&quot;</span><span class="s1">] = </span><span class="s0">&quot;EqualNullOrUndefined&quot;</span><span class="s1">;</span>
    <span class="s4">/** `x !== null` */</span>
    <span class="s1">NullishComparisonType[</span><span class="s0">&quot;NotStrictEqualNull&quot;</span><span class="s1">] = </span><span class="s0">&quot;NotStrictEqualNull&quot;</span><span class="s1">;</span>
    <span class="s4">/** `x === null` */</span>
    <span class="s1">NullishComparisonType[</span><span class="s0">&quot;StrictEqualNull&quot;</span><span class="s1">] = </span><span class="s0">&quot;StrictEqualNull&quot;</span><span class="s1">;</span>
    <span class="s4">/** `x !== undefined`, `typeof x !== 'undefined'` */</span>
    <span class="s1">NullishComparisonType[</span><span class="s0">&quot;NotStrictEqualUndefined&quot;</span><span class="s1">] = </span><span class="s0">&quot;NotStrictEqualUndefined&quot;</span><span class="s1">;</span>
    <span class="s4">/** `x === undefined`, `typeof x === 'undefined'` */</span>
    <span class="s1">NullishComparisonType[</span><span class="s0">&quot;StrictEqualUndefined&quot;</span><span class="s1">] = </span><span class="s0">&quot;StrictEqualUndefined&quot;</span><span class="s1">;</span>
    <span class="s4">/** `!x` */</span>
    <span class="s1">NullishComparisonType[</span><span class="s0">&quot;NotBoolean&quot;</span><span class="s1">] = </span><span class="s0">&quot;NotBoolean&quot;</span><span class="s1">;</span>
    <span class="s4">/** `x` */</span>
    <span class="s1">NullishComparisonType[</span><span class="s0">&quot;Boolean&quot;</span><span class="s1">] = </span><span class="s0">&quot;Boolean&quot;</span><span class="s1">;</span>
<span class="s1">})(NullishComparisonType || (exports.NullishComparisonType = NullishComparisonType = {}));</span>
<span class="s2">const </span><span class="s1">NULLISH_FLAGS = ts.TypeFlags.Null | ts.TypeFlags.Undefined;</span>
<span class="s2">function </span><span class="s1">isValidFalseBooleanCheckType(node, disallowFalseyLiteral, parserServices, options) {</span>
    <span class="s2">const </span><span class="s1">type = parserServices.getTypeAtLocation(node);</span>
    <span class="s2">const </span><span class="s1">types = (</span><span class="s3">0</span><span class="s1">, ts_api_utils_1.unionConstituents)(type);</span>
    <span class="s2">if </span><span class="s1">(disallowFalseyLiteral &amp;&amp;</span>
        <span class="s4">/* 
        ``` 
        declare const x: false | {a: string}; 
        x &amp;&amp; x.a; 
        !x || x.a; 
        ``` 
     
        We don't want to consider these two cases because the boolean expression 
        narrows out the non-nullish falsy cases - so converting the chain to `x?.a` 
        would introduce a build error 
        */ </span><span class="s1">(types.some(t =&gt; (</span><span class="s3">0</span><span class="s1">, ts_api_utils_1.isBooleanLiteralType)(t) &amp;&amp; t.intrinsicName === </span><span class="s0">'false'</span><span class="s1">) ||</span>
            <span class="s1">types.some(t =&gt; (</span><span class="s3">0</span><span class="s1">, ts_api_utils_1.isStringLiteralType)(t) &amp;&amp; t.value === </span><span class="s0">''</span><span class="s1">) ||</span>
            <span class="s1">types.some(t =&gt; (</span><span class="s3">0</span><span class="s1">, ts_api_utils_1.isNumberLiteralType)(t) &amp;&amp; t.value === </span><span class="s3">0</span><span class="s1">) ||</span>
            <span class="s1">types.some(t =&gt; (</span><span class="s3">0</span><span class="s1">, ts_api_utils_1.isBigIntLiteralType)(t) &amp;&amp; t.value.base10Value === </span><span class="s0">'0'</span><span class="s1">))) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">allowedFlags = NULLISH_FLAGS | ts.TypeFlags.Object;</span>
    <span class="s2">if </span><span class="s1">(options.checkAny === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">allowedFlags |= ts.TypeFlags.Any;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.checkUnknown === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">allowedFlags |= ts.TypeFlags.Unknown;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.checkString === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">allowedFlags |= ts.TypeFlags.StringLike;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.checkNumber === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">allowedFlags |= ts.TypeFlags.NumberLike;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.checkBoolean === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">allowedFlags |= ts.TypeFlags.BooleanLike;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.checkBigInt === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">allowedFlags |= ts.TypeFlags.BigIntLike;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">types.every(t =&gt; (</span><span class="s3">0</span><span class="s1">, util_1.isTypeFlagSet)(t, allowedFlags));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">gatherLogicalOperands(node, parserServices, sourceCode, options) {</span>
    <span class="s2">const </span><span class="s1">result = [];</span>
    <span class="s2">const </span><span class="s1">{ newlySeenLogicals, operands } = flattenLogicalOperands(node);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">operand of operands) {</span>
        <span class="s2">const </span><span class="s1">areMoreOperands = operand !== operands.at(-</span><span class="s3">1</span><span class="s1">);</span>
        <span class="s2">switch </span><span class="s1">(operand.type) {</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.BinaryExpression: {</span>
                <span class="s4">// check for &quot;yoda&quot; style logical: null != x</span>
                <span class="s2">const </span><span class="s1">{ comparedExpression, comparedValue, isYoda } = (() =&gt; {</span>
                    <span class="s4">// non-yoda checks are by far the most common, so check for them first</span>
                    <span class="s2">const </span><span class="s1">comparedValueRight = getComparisonValueType(operand.right);</span>
                    <span class="s2">if </span><span class="s1">(comparedValueRight) {</span>
                        <span class="s2">return </span><span class="s1">{</span>
                            <span class="s1">comparedExpression: operand.left,</span>
                            <span class="s1">comparedValue: comparedValueRight,</span>
                            <span class="s1">isYoda: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">comparedExpression: operand.right,</span>
                        <span class="s1">comparedValue: getComparisonValueType(operand.left),</span>
                        <span class="s1">isYoda: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">};</span>
                <span class="s1">})();</span>
                <span class="s2">if </span><span class="s1">(comparedValue === ComparisonValueType.UndefinedStringLiteral) {</span>
                    <span class="s2">if </span><span class="s1">(comparedExpression.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;</span>
                        <span class="s1">comparedExpression.operator === </span><span class="s0">'typeof'</span><span class="s1">) {</span>
                        <span class="s2">const </span><span class="s1">argument = comparedExpression.argument;</span>
                        <span class="s2">if </span><span class="s1">(argument.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                            <span class="s4">// typeof window === 'undefined'</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isReferenceToGlobalFunction)(argument.name, argument, sourceCode)) {</span>
                            <span class="s1">result.push({ type: OperandValidity.Invalid });</span>
                            <span class="s2">continue</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s4">// typeof x.y === 'undefined'</span>
                        <span class="s1">result.push({</span>
                            <span class="s1">comparedName: comparedExpression.argument,</span>
                            <span class="s1">comparisonType: operand.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">)</span>
                                <span class="s1">? NullishComparisonType.NotStrictEqualUndefined</span>
                                <span class="s1">: NullishComparisonType.StrictEqualUndefined,</span>
                            <span class="s1">isYoda,</span>
                            <span class="s1">node: operand,</span>
                            <span class="s1">type: OperandValidity.Valid,</span>
                        <span class="s1">});</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s4">// y === 'undefined'</span>
                    <span class="s1">result.push({ type: OperandValidity.Invalid });</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">switch </span><span class="s1">(operand.operator) {</span>
                    <span class="s2">case </span><span class="s0">'!='</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'=='</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">(comparedValue === ComparisonValueType.Null ||</span>
                            <span class="s1">comparedValue === ComparisonValueType.Undefined) {</span>
                            <span class="s4">// x == null, x == undefined</span>
                            <span class="s1">result.push({</span>
                                <span class="s1">comparedName: comparedExpression,</span>
                                <span class="s1">comparisonType: operand.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">)</span>
                                    <span class="s1">? NullishComparisonType.NotEqualNullOrUndefined</span>
                                    <span class="s1">: NullishComparisonType.EqualNullOrUndefined,</span>
                                <span class="s1">isYoda,</span>
                                <span class="s1">node: operand,</span>
                                <span class="s1">type: OperandValidity.Valid,</span>
                            <span class="s1">});</span>
                            <span class="s2">continue</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s4">// x == something :(</span>
                        <span class="s1">result.push({ type: OperandValidity.Invalid });</span>
                        <span class="s2">continue</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s0">'!=='</span><span class="s1">:</span>
                    <span class="s2">case </span><span class="s0">'==='</span><span class="s1">: {</span>
                        <span class="s2">const </span><span class="s1">comparedName = comparedExpression;</span>
                        <span class="s2">switch </span><span class="s1">(comparedValue) {</span>
                            <span class="s2">case </span><span class="s1">ComparisonValueType.Null:</span>
                                <span class="s1">result.push({</span>
                                    <span class="s1">comparedName,</span>
                                    <span class="s1">comparisonType: operand.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">)</span>
                                        <span class="s1">? NullishComparisonType.NotStrictEqualNull</span>
                                        <span class="s1">: NullishComparisonType.StrictEqualNull,</span>
                                    <span class="s1">isYoda,</span>
                                    <span class="s1">node: operand,</span>
                                    <span class="s1">type: OperandValidity.Valid,</span>
                                <span class="s1">});</span>
                                <span class="s2">continue</span><span class="s1">;</span>
                            <span class="s2">case </span><span class="s1">ComparisonValueType.Undefined:</span>
                                <span class="s1">result.push({</span>
                                    <span class="s1">comparedName,</span>
                                    <span class="s1">comparisonType: operand.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">)</span>
                                        <span class="s1">? NullishComparisonType.NotStrictEqualUndefined</span>
                                        <span class="s1">: NullishComparisonType.StrictEqualUndefined,</span>
                                    <span class="s1">isYoda,</span>
                                    <span class="s1">node: operand,</span>
                                    <span class="s1">type: OperandValidity.Valid,</span>
                                <span class="s1">});</span>
                                <span class="s2">continue</span><span class="s1">;</span>
                            <span class="s2">default</span><span class="s1">:</span>
                                <span class="s4">// x === something :(</span>
                                <span class="s1">result.push({ type: OperandValidity.Invalid });</span>
                                <span class="s2">continue</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">result.push({ type: OperandValidity.Invalid });</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.UnaryExpression:</span>
                <span class="s2">if </span><span class="s1">(operand.operator === </span><span class="s0">'!' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">(!areMoreOperands ||</span>
                        <span class="s1">isValidFalseBooleanCheckType(operand.argument, node.operator === </span><span class="s0">'||'</span><span class="s1">, parserServices, options))) {</span>
                    <span class="s1">result.push({</span>
                        <span class="s1">comparedName: operand.argument,</span>
                        <span class="s1">comparisonType: NullishComparisonType.NotBoolean,</span>
                        <span class="s1">isYoda: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">node: operand,</span>
                        <span class="s1">type: OperandValidity.Valid,</span>
                    <span class="s1">});</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">result.push({ type: OperandValidity.Invalid });</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.LogicalExpression:</span>
                <span class="s4">// explicitly ignore the mixed logical expression cases</span>
                <span class="s1">result.push({ type: OperandValidity.Invalid });</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(!areMoreOperands ||</span>
                    <span class="s1">isValidFalseBooleanCheckType(operand, node.operator === </span><span class="s0">'&amp;&amp;'</span><span class="s1">, parserServices, options)) {</span>
                    <span class="s1">result.push({</span>
                        <span class="s1">comparedName: operand,</span>
                        <span class="s1">comparisonType: NullishComparisonType.Boolean,</span>
                        <span class="s1">isYoda: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">node: operand,</span>
                        <span class="s1">type: OperandValidity.Valid,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">result.push({ type: OperandValidity.Invalid });</span>
                <span class="s1">}</span>
                <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">newlySeenLogicals,</span>
        <span class="s1">operands: result,</span>
    <span class="s1">};</span>
    <span class="s4">/* 
    The AST is always constructed such the first element is always the deepest element. 
    I.e. for this code: `foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz &amp;&amp; foo.bar.baz.buzz` 
    The AST will look like this: 
    { 
      left: { 
        left: { 
          left: foo 
          right: foo.bar 
        } 
        right: foo.bar.baz 
      } 
      right: foo.bar.baz.buzz 
    } 
   
    So given any logical expression, we can perform a depth-first traversal to get 
    the operands in order. 
   
    Note that this function purposely does not inspect mixed logical expressions 
    like `foo || foo.bar &amp;&amp; foo.bar.baz` - separate selector 
    */</span>
    <span class="s2">function </span><span class="s1">flattenLogicalOperands(node) {</span>
        <span class="s2">const </span><span class="s1">operands = [];</span>
        <span class="s2">const </span><span class="s1">newlySeenLogicals = </span><span class="s2">new </span><span class="s1">Set([node]);</span>
        <span class="s2">const </span><span class="s1">stack = [node.right, node.left];</span>
        <span class="s2">let </span><span class="s1">current;</span>
        <span class="s2">while </span><span class="s1">((current = stack.pop())) {</span>
            <span class="s2">if </span><span class="s1">(current.type === utils_1.AST_NODE_TYPES.LogicalExpression &amp;&amp;</span>
                <span class="s1">current.operator === node.operator) {</span>
                <span class="s1">newlySeenLogicals.add(current);</span>
                <span class="s1">stack.push(current.right);</span>
                <span class="s1">stack.push(current.left);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">operands.push(current);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">newlySeenLogicals,</span>
            <span class="s1">operands,</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">getComparisonValueType(node) {</span>
        <span class="s2">switch </span><span class="s1">(node.type) {</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Literal:</span>
                <span class="s4">// eslint-disable-next-line eqeqeq, @typescript-eslint/internal/eqeq-nullish -- intentional exact comparison against null</span>
                <span class="s2">if </span><span class="s1">(node.value === </span><span class="s2">null </span><span class="s1">&amp;&amp; node.raw === </span><span class="s0">'null'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">ComparisonValueType.Null;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.value === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">ComparisonValueType.UndefinedStringLiteral;</span>
                <span class="s1">}</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                <span class="s2">if </span><span class="s1">(node.name === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">ComparisonValueType.Undefined;</span>
                <span class="s1">}</span>
                <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>