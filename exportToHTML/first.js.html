<html>
<head>
<title>first.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #264eff;}
.s5 { color: #0037a6;}
.s6 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
first.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span><span class="s2">var </span><span class="s1">_contextCompat = require(</span><span class="s0">'eslint-module-utils/contextCompat'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_docsUrl = require(</span><span class="s0">'../docsUrl'</span><span class="s1">);</span><span class="s2">var </span><span class="s1">_docsUrl2 = _interopRequireDefault(_docsUrl);</span><span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s0">'default'</span><span class="s1">: obj };}</span>

<span class="s2">function </span><span class="s1">getImportValue(node) {</span>
  <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'ImportDeclaration' </span><span class="s1">?</span>
  <span class="s1">node.source.value :</span>
  <span class="s1">node.moduleReference.expression.value;</span>
<span class="s1">}</span>

<span class="s1">module.exports = {</span>
  <span class="s1">meta: {</span>
    <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
    <span class="s1">docs: {</span>
      <span class="s1">category: </span><span class="s0">'Style guide'</span><span class="s1">,</span>
      <span class="s1">description: </span><span class="s0">'Ensure all imports appear before other statements.'</span><span class="s1">,</span>
      <span class="s1">url: (</span><span class="s3">0</span><span class="s1">, _docsUrl2[</span><span class="s0">'default'</span><span class="s1">])(</span><span class="s0">'first'</span><span class="s1">) },</span>

    <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
    <span class="s1">schema: [</span>
    <span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
      <span class="s0">'enum'</span><span class="s1">: [</span><span class="s0">'absolute-first'</span><span class="s1">, </span><span class="s0">'disable-absolute-first'</span><span class="s1">] }] },</span>




  <span class="s1">create: </span><span class="s2">function </span><span class="s1">() {</span><span class="s2">function </span><span class="s1">create(context) {</span>
      <span class="s2">function </span><span class="s1">isPossibleDirective(node) {</span>
        <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">'ExpressionStatement' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">node.expression.type === </span><span class="s0">'Literal' </span><span class="s1">&amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">node.expression.value === </span><span class="s0">'string'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">Program: </span><span class="s2">function </span><span class="s1">() {</span><span class="s2">function </span><span class="s1">Program(n) {</span>
            <span class="s2">var </span><span class="s1">body = n.body;</span>
            <span class="s2">if </span><span class="s1">(!body) {</span>
              <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">var </span><span class="s1">absoluteFirst = context.options[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'absolute-first'</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">message = </span><span class="s0">'Import in body of module; reorder to top.'</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">sourceCode = (</span><span class="s3">0</span><span class="s1">, _contextCompat.getSourceCode)(context);</span>
            <span class="s2">var </span><span class="s1">originSourceCode = sourceCode.getText();</span>
            <span class="s2">var </span><span class="s1">nonImportCount = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">anyExpressions = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">anyRelative = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">lastLegalImp = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">errorInfos = [];</span>
            <span class="s2">var </span><span class="s1">shouldSort = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">lastSortNodesIndex = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">body.forEach(</span><span class="s2">function </span><span class="s1">(node, index) {</span>
              <span class="s2">if </span><span class="s1">(!anyExpressions &amp;&amp; isPossibleDirective(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s1">anyExpressions = </span><span class="s2">true</span><span class="s1">;</span>

              <span class="s2">if </span><span class="s1">(node.type === </span><span class="s0">'ImportDeclaration' </span><span class="s1">|| node.type === </span><span class="s0">'TSImportEqualsDeclaration'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(absoluteFirst) {</span>
                  <span class="s2">if </span><span class="s1">(</span><span class="s4">/^\./</span><span class="s1">.test(getImportValue(node))) {</span>
                    <span class="s1">anyRelative = </span><span class="s2">true</span><span class="s1">;</span>
                  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(anyRelative) {</span>
                    <span class="s1">context.report({</span>
                      <span class="s1">node: node.type === </span><span class="s0">'ImportDeclaration' </span><span class="s1">? node.source : node.moduleReference,</span>
                      <span class="s1">message: </span><span class="s0">'Absolute imports should come before relative imports.' </span><span class="s1">});</span>

                  <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(nonImportCount &gt; </span><span class="s3">0</span><span class="s1">) {</span><span class="s2">var </span><span class="s1">_iteratorNormalCompletion = </span><span class="s2">true</span><span class="s1">;</span><span class="s2">var </span><span class="s1">_didIteratorError = </span><span class="s2">false</span><span class="s1">;</span><span class="s2">var </span><span class="s1">_iteratorError = undefined;</span><span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_iterator = (</span><span class="s3">0</span><span class="s1">, _contextCompat.getDeclaredVariables)(context, node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = </span><span class="s2">true</span><span class="s1">) {</span><span class="s2">var </span><span class="s1">variable = _step.value;</span>
                      <span class="s2">if </span><span class="s1">(!shouldSort) {</span><span class="s2">break</span><span class="s1">;}</span>
                      <span class="s2">var </span><span class="s1">references = variable.references;</span>
                      <span class="s2">if </span><span class="s1">(references.length) {</span><span class="s2">var </span><span class="s1">_iteratorNormalCompletion2 = </span><span class="s2">true</span><span class="s1">;</span><span class="s2">var </span><span class="s1">_didIteratorError2 = </span><span class="s2">false</span><span class="s1">;</span><span class="s2">var </span><span class="s1">_iteratorError2 = undefined;</span><span class="s2">try </span><span class="s1">{</span>
                          <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_iterator2 = references[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = </span><span class="s2">true</span><span class="s1">) {</span><span class="s2">var </span><span class="s1">reference = _step2.value;</span>
                            <span class="s2">if </span><span class="s1">(reference.identifier.range[</span><span class="s3">0</span><span class="s1">] &lt; node.range[</span><span class="s3">1</span><span class="s1">]) {</span>
                              <span class="s1">shouldSort = </span><span class="s2">false</span><span class="s1">;</span>
                              <span class="s2">break</span><span class="s1">;</span>
                            <span class="s1">}</span>
                          <span class="s1">}} </span><span class="s2">catch </span><span class="s1">(err) {_didIteratorError2 = </span><span class="s2">true</span><span class="s1">;_iteratorError2 = err;} </span><span class="s2">finally </span><span class="s1">{</span><span class="s2">try </span><span class="s1">{</span><span class="s2">if </span><span class="s1">(!_iteratorNormalCompletion2 &amp;&amp; _iterator2[</span><span class="s0">'return'</span><span class="s1">]) {_iterator2[</span><span class="s0">'return'</span><span class="s1">]();}} </span><span class="s2">finally </span><span class="s1">{</span><span class="s2">if </span><span class="s1">(_didIteratorError2) {</span><span class="s2">throw </span><span class="s1">_iteratorError2;}}}</span>
                      <span class="s1">}</span>
                    <span class="s1">}} </span><span class="s2">catch </span><span class="s1">(err) {_didIteratorError = </span><span class="s2">true</span><span class="s1">;_iteratorError = err;} </span><span class="s2">finally </span><span class="s1">{</span><span class="s2">try </span><span class="s1">{</span><span class="s2">if </span><span class="s1">(!_iteratorNormalCompletion &amp;&amp; _iterator[</span><span class="s0">'return'</span><span class="s1">]) {_iterator[</span><span class="s0">'return'</span><span class="s1">]();}} </span><span class="s2">finally </span><span class="s1">{</span><span class="s2">if </span><span class="s1">(_didIteratorError) {</span><span class="s2">throw </span><span class="s1">_iteratorError;}}}</span>
                  <span class="s1">shouldSort &amp;&amp; (lastSortNodesIndex = errorInfos.length);</span>
                  <span class="s1">errorInfos.push({</span>
                    <span class="s1">node: node,</span>
                    <span class="s1">range: [body[index - </span><span class="s3">1</span><span class="s1">].range[</span><span class="s3">1</span><span class="s1">], node.range[</span><span class="s3">1</span><span class="s1">]] });</span>

                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                  <span class="s1">lastLegalImp = node;</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">nonImportCount++;</span>
              <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(!errorInfos.length) {</span><span class="s2">return</span><span class="s1">;}</span>
            <span class="s1">errorInfos.forEach(</span><span class="s2">function </span><span class="s1">(errorInfo, index) {</span>
              <span class="s2">var </span><span class="s1">node = errorInfo.node;</span>
              <span class="s2">var </span><span class="s1">infos = {</span>
                <span class="s1">node: node,</span>
                <span class="s1">message: message };</span>

              <span class="s2">if </span><span class="s1">(index &lt; lastSortNodesIndex) {</span>
                <span class="s1">infos.fix = </span><span class="s2">function </span><span class="s1">(fixer) {</span>
                  <span class="s2">return </span><span class="s1">fixer.insertTextAfter(node, </span><span class="s0">''</span><span class="s1">);</span>
                <span class="s1">};</span>
              <span class="s1">} </span><span class="s2">else if </span><span class="s1">(index === lastSortNodesIndex) {</span>
                <span class="s2">var </span><span class="s1">sortNodes = errorInfos.slice(</span><span class="s3">0</span><span class="s1">, lastSortNodesIndex + </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">infos.fix = </span><span class="s2">function </span><span class="s1">(fixer) {</span>
                  <span class="s2">var </span><span class="s1">removeFixers = sortNodes.map(</span><span class="s2">function </span><span class="s1">(_errorInfo) {</span>
                    <span class="s2">return </span><span class="s1">fixer.removeRange(_errorInfo.range);</span>
                  <span class="s1">});</span>
                  <span class="s2">var </span><span class="s1">range = [</span><span class="s3">0</span><span class="s1">, removeFixers[removeFixers.length - </span><span class="s3">1</span><span class="s1">].range[</span><span class="s3">1</span><span class="s1">]];</span>
                  <span class="s2">var </span><span class="s1">insertSourceCode = sortNodes.map(</span><span class="s2">function </span><span class="s1">(_errorInfo) {</span>
                    <span class="s2">var </span><span class="s1">nodeSourceCode = String.prototype.slice.apply(</span>
                    <span class="s1">originSourceCode, _errorInfo.range);</span>

                    <span class="s2">if </span><span class="s1">(</span><span class="s4">/\S/</span><span class="s1">.test(nodeSourceCode[</span><span class="s3">0</span><span class="s1">])) {</span>
                      <span class="s2">return </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ String(nodeSourceCode);</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">nodeSourceCode;</span>
                  <span class="s1">}).join(</span><span class="s0">''</span><span class="s1">);</span>
                  <span class="s2">var </span><span class="s1">insertFixer = </span><span class="s2">null</span><span class="s1">;</span>
                  <span class="s2">var </span><span class="s1">replaceSourceCode = </span><span class="s0">''</span><span class="s1">;</span>
                  <span class="s2">if </span><span class="s1">(!lastLegalImp) {</span>
                    <span class="s1">insertSourceCode = insertSourceCode.trim() + insertSourceCode.match(</span><span class="s4">/^(\s+)/</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">];</span>
                  <span class="s1">}</span>
                  <span class="s1">insertFixer = lastLegalImp ?</span>
                  <span class="s1">fixer.insertTextAfter(lastLegalImp, insertSourceCode) :</span>
                  <span class="s1">fixer.insertTextBefore(body[</span><span class="s3">0</span><span class="s1">], insertSourceCode);</span>

                  <span class="s2">var </span><span class="s1">fixers = [insertFixer].concat(removeFixers);</span>
                  <span class="s1">fixers.forEach(</span><span class="s2">function </span><span class="s1">(computedFixer, i) {</span>
                    <span class="s1">replaceSourceCode += originSourceCode.slice(</span>
                    <span class="s1">fixers[i - </span><span class="s3">1</span><span class="s1">] ? fixers[i - </span><span class="s3">1</span><span class="s1">].range[</span><span class="s3">1</span><span class="s1">] : </span><span class="s3">0</span><span class="s1">, computedFixer.range[</span><span class="s3">0</span><span class="s1">]) +</span>
                    <span class="s1">computedFixer.text;</span>
                  <span class="s1">});</span>

                  <span class="s2">return </span><span class="s1">fixer.replaceTextRange(range, replaceSourceCode);</span>
                <span class="s1">};</span>
              <span class="s1">}</span>
              <span class="s1">context.report(infos);</span>
            <span class="s1">});</span>
          <span class="s1">}</span><span class="s2">return </span><span class="s1">Program;}() };</span>

    <span class="s1">}</span><span class="s2">return </span><span class="s1">create;}() };</span>
<span class="s6">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9maXJzdC5qcyJdLCJuYW1lcyI6WyJnZXRJbXBvcnRWYWx1ZSIsIm5vZGUiLCJ0eXBlIiwic291cmNlIiwidmFsdWUiLCJtb2R1bGVSZWZlcmVuY2UiLCJleHByZXNzaW9uIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1ldGEiLCJkb2NzIiwiY2F0ZWdvcnkiLCJkZXNjcmlwdGlvbiIsInVybCIsImZpeGFibGUiLCJzY2hlbWEiLCJjcmVhdGUiLCJjb250ZXh0IiwiaXNQb3NzaWJsZURpcmVjdGl2ZSIsIlByb2dyYW0iLCJuIiwiYm9keSIsImFic29sdXRlRmlyc3QiLCJvcHRpb25zIiwibWVzc2FnZSIsInNvdXJjZUNvZGUiLCJvcmlnaW5Tb3VyY2VDb2RlIiwiZ2V0VGV4dCIsIm5vbkltcG9ydENvdW50IiwiYW55RXhwcmVzc2lvbnMiLCJhbnlSZWxhdGl2ZSIsImxhc3RMZWdhbEltcCIsImVycm9ySW5mb3MiLCJzaG91bGRTb3J0IiwibGFzdFNvcnROb2Rlc0luZGV4IiwiZm9yRWFjaCIsImluZGV4IiwidGVzdCIsInJlcG9ydCIsInZhcmlhYmxlIiwicmVmZXJlbmNlcyIsImxlbmd0aCIsInJlZmVyZW5jZSIsImlkZW50aWZpZXIiLCJyYW5nZSIsInB1c2giLCJlcnJvckluZm8iLCJpbmZvcyIsImZpeCIsImZpeGVyIiwiaW5zZXJ0VGV4dEFmdGVyIiwic29ydE5vZGVzIiwic2xpY2UiLCJyZW1vdmVGaXhlcnMiLCJtYXAiLCJfZXJyb3JJbmZvIiwicmVtb3ZlUmFuZ2UiLCJpbnNlcnRTb3VyY2VDb2RlIiwibm9kZVNvdXJjZUNvZGUiLCJTdHJpbmciLCJwcm90b3R5cGUiLCJhcHBseSIsImpvaW4iLCJpbnNlcnRGaXhlciIsInJlcGxhY2VTb3VyY2VDb2RlIiwidHJpbSIsIm1hdGNoIiwiaW5zZXJ0VGV4dEJlZm9yZSIsImZpeGVycyIsImNvbmNhdCIsImNvbXB1dGVkRml4ZXIiLCJpIiwidGV4dCIsInJlcGxhY2VUZXh0UmFuZ2UiXSwibWFwcGluZ3MiOiJhQUFBOztBQUVBLHFDOztBQUVBLFNBQVNBLGNBQVQsQ0FBd0JDLElBQXhCLEVBQThCO0FBQzVCLFNBQU9BLEtBQUtDLElBQUwsS0FBYyxtQkFBZDtBQUNIRCxPQUFLRSxNQUFMLENBQVlDLEtBRFQ7QUFFSEgsT0FBS0ksZUFBTCxDQUFxQkMsVUFBckIsQ0FBZ0NGLEtBRnBDO0FBR0Q7O0FBRURHLE9BQU9DLE9BQVAsR0FBaUI7QUFDZkMsUUFBTTtBQUNKUCxVQUFNLFlBREY7QUFFSlEsVUFBTTtBQUNKQyxnQkFBVSxhQUROO0FBRUpDLG1CQUFhLG9EQUZUO0FBR0pDLFdBQUssMEJBQVEsT0FBUixDQUhELEVBRkY7O0FBT0pDLGFBQVMsTUFQTDtBQVFKQyxZQUFRO0FBQ047QUFDRWIsWUFBTSxRQURSO0FBRUUsY0FBTSxDQUFDLGdCQUFELEVBQW1CLHdCQUFuQixDQUZSLEVBRE0sQ0FSSixFQURTOzs7OztBQWlCZmMsUUFqQmUsK0JBaUJSQyxPQWpCUSxFQWlCQztBQUNkLGVBQVNDLG1CQUFULENBQTZCakIsSUFBN0IsRUFBbUM7QUFDakMsZUFBT0EsS0FBS0MsSUFBTCxLQUFjLHFCQUFkO0FBQ0ZELGFBQUtLLFVBQUwsQ0FBZ0JKLElBQWhCLEtBQXlCLFNBRHZCO0FBRUYsZUFBT0QsS0FBS0ssVUFBTCxDQUFnQkYsS0FBdkIsS0FBaUMsUUFGdEM7QUFHRDs7QUFFRCxhQUFPO0FBQ0xlLGVBREssZ0NBQ0dDLENBREgsRUFDTTtBQUNULGdCQUFNQyxPQUFPRCxFQUFFQyxJQUFmO0FBQ0EsZ0JBQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQ1Q7QUFDRDtBQUNELGdCQUFNQyxnQkFBZ0JMLFFBQVFNLE9BQVIsQ0FBZ0IsQ0FBaEIsTUFBdUIsZ0JBQTdDO0FBQ0EsZ0JBQU1DLFVBQVUsMkNBQWhCO0FBQ0EsZ0JBQU1DLGFBQWEsa0NBQWNSLE9BQWQsQ0FBbkI7QUFDQSxnQkFBTVMsbUJBQW1CRCxXQUFXRSxPQUFYLEVBQXpCO0FBQ0EsZ0JBQUlDLGlCQUFpQixDQUFyQjtBQUNBLGdCQUFJQyxpQkFBaUIsS0FBckI7QUFDQSxnQkFBSUMsY0FBYyxLQUFsQjtBQUNBLGdCQUFJQyxlQUFlLElBQW5CO0FBQ0EsZ0JBQU1DLGFBQWEsRUFBbkI7QUFDQSxnQkFBSUMsYUFBYSxJQUFqQjtBQUNBLGdCQUFJQyxxQkFBcUIsQ0FBekI7QUFDQWIsaUJBQUtjLE9BQUwsQ0FBYSxVQUFVbEMsSUFBVixFQUFnQm1DLEtBQWhCLEVBQXVCO0FBQ2xDLGtCQUFJLENBQUNQLGNBQUQsSUFBbUJYLG9CQUFvQmpCLElBQXBCLENBQXZCLEVBQWtEO0FBQ2hEO0FBQ0Q7O0FBRUQ0QiwrQkFBaUIsSUFBakI7O0FBRUEsa0JBQUk1QixLQUFLQyxJQUFMLEtBQWMsbUJBQWQsSUFBcUNELEtBQUtDLElBQUwsS0FBYywyQkFBdkQsRUFBb0Y7QUFDbEYsb0JBQUlvQixhQUFKLEVBQW1CO0FBQ2pCLHNCQUFLLEtBQUQsQ0FBUWUsSUFBUixDQUFhckMsZUFBZUMsSUFBZixDQUFiLENBQUosRUFBd0M7QUFDdEM2QixrQ0FBYyxJQUFkO0FBQ0QsbUJBRkQsTUFFTyxJQUFJQSxXQUFKLEVBQWlCO0FBQ3RCYiw0QkFBUXFCLE1BQVIsQ0FBZTtBQUNickMsNEJBQU1BLEtBQUtDLElBQUwsS0FBYyxtQkFBZCxHQUFvQ0QsS0FBS0UsTUFBekMsR0FBa0RGLEtBQUtJLGVBRGhEO0FBRWJtQiwrQkFBUyx1REFGSSxFQUFmOztBQUlEO0FBQ0Y7QUFDRCxvQkFBSUksaUJBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLHlDQUF1Qix5Q0FBcUJYLE9BQXJCLEVBQThCaEIsSUFBOUIsQ0FBdkIsOEhBQTRELEtBQWpEc0MsUUFBaUQ7QUFDMUQsMEJBQUksQ0FBQ04sVUFBTCxFQUFpQixDQUFFLE1BQVE7QUFDM0IsMEJBQU1PLGFBQWFELFNBQVNDLFVBQTVCO0FBQ0EsMEJBQUlBLFdBQVdDLE1BQWYsRUFBdUI7QUFDckIsZ0RBQXdCRCxVQUF4QixtSUFBb0MsS0FBekJFLFNBQXlCO0FBQ2xDLGdDQUFJQSxVQUFVQyxVQUFWLENBQXFCQyxLQUFyQixDQUEyQixDQUEzQixJQUFnQzNDLEtBQUsyQyxLQUFMLENBQVcsQ0FBWCxDQUFwQyxFQUFtRDtBQUNqRFgsMkNBQWEsS0FBYjtBQUNBO0FBQ0Q7QUFDRiwyQkFOb0I7QUFPdEI7QUFDRixxQkFacUI7QUFhdEJBLGlDQUFlQyxxQkFBcUJGLFdBQVdTLE1BQS9DO0FBQ0FULDZCQUFXYSxJQUFYLENBQWdCO0FBQ2Q1Qyw4QkFEYztBQUVkMkMsMkJBQU8sQ0FBQ3ZCLEtBQUtlLFFBQVEsQ0FBYixFQUFnQlEsS0FBaEIsQ0FBc0IsQ0FBdEIsQ0FBRCxFQUEyQjNDLEtBQUsyQyxLQUFMLENBQVcsQ0FBWCxDQUEzQixDQUZPLEVBQWhCOztBQUlELGlCQWxCRCxNQWtCTztBQUNMYixpQ0FBZTlCLElBQWY7QUFDRDtBQUNGLGVBaENELE1BZ0NPO0FBQ0wyQjtBQUNEO0FBQ0YsYUExQ0Q7QUEyQ0EsZ0JBQUksQ0FBQ0ksV0FBV1MsTUFBaEIsRUFBd0IsQ0FBRSxPQUFTO0FBQ25DVCx1QkFBV0csT0FBWCxDQUFtQixVQUFVVyxTQUFWLEVBQXFCVixLQUFyQixFQUE0QjtBQUM3QyxrQkFBTW5DLE9BQU82QyxVQUFVN0MsSUFBdkI7QUFDQSxrQkFBTThDLFFBQVE7QUFDWjlDLDBCQURZO0FBRVp1QixnQ0FGWSxFQUFkOztBQUlBLGtCQUFJWSxRQUFRRixrQkFBWixFQUFnQztBQUM5QmEsc0JBQU1DLEdBQU4sR0FBWSxVQUFVQyxLQUFWLEVBQWlCO0FBQzNCLHlCQUFPQSxNQUFNQyxlQUFOLENBQXNCakQsSUFBdEIsRUFBNEIsRUFBNUIsQ0FBUDtBQUNELGlCQUZEO0FBR0QsZUFKRCxNQUlPLElBQUltQyxVQUFVRixrQkFBZCxFQUFrQztBQUN2QyxvQkFBTWlCLFlBQVluQixXQUFXb0IsS0FBWCxDQUFpQixDQUFqQixFQUFvQmxCLHFCQUFxQixDQUF6QyxDQUFsQjtBQUNBYSxzQkFBTUMsR0FBTixHQUFZLFVBQVVDLEtBQVYsRUFBaUI7QUFDM0Isc0JBQU1JLGVBQWVGLFVBQVVHLEdBQVYsQ0FBYyxVQUFVQyxVQUFWLEVBQXNCO0FBQ3ZELDJCQUFPTixNQUFNTyxXQUFOLENBQWtCRCxXQUFXWCxLQUE3QixDQUFQO0FBQ0QsbUJBRm9CLENBQXJCO0FBR0Esc0JBQU1BLFFBQVEsQ0FBQyxDQUFELEVBQUlTLGFBQWFBLGFBQWFaLE1BQWIsR0FBc0IsQ0FBbkMsRUFBc0NHLEtBQXRDLENBQTRDLENBQTVDLENBQUosQ0FBZDtBQUNBLHNCQUFJYSxtQkFBbUJOLFVBQVVHLEdBQVYsQ0FBYyxVQUFVQyxVQUFWLEVBQXNCO0FBQ3pELHdCQUFNRyxpQkFBaUJDLE9BQU9DLFNBQVAsQ0FBaUJSLEtBQWpCLENBQXVCUyxLQUF2QjtBQUNyQm5DLG9DQURxQixFQUNINkIsV0FBV1gsS0FEUixDQUF2Qjs7QUFHQSx3QkFBSyxJQUFELENBQU9QLElBQVAsQ0FBWXFCLGVBQWUsQ0FBZixDQUFaLENBQUosRUFBb0M7QUFDbEMsMkNBQVlBLGNBQVo7QUFDRDtBQUNELDJCQUFPQSxjQUFQO0FBQ0QsbUJBUnNCLEVBUXBCSSxJQVJvQixDQVFmLEVBUmUsQ0FBdkI7QUFTQSxzQkFBSUMsY0FBYyxJQUFsQjtBQUNBLHNCQUFJQyxvQkFBb0IsRUFBeEI7QUFDQSxzQkFBSSxDQUFDakMsWUFBTCxFQUFtQjtBQUNqQjBCLHVDQUFtQkEsaUJBQWlCUSxJQUFqQixLQUEwQlIsaUJBQWlCUyxLQUFqQixDQUF1QixRQUF2QixFQUFpQyxDQUFqQyxDQUE3QztBQUNEO0FBQ0RILGdDQUFjaEM7QUFDVmtCLHdCQUFNQyxlQUFOLENBQXNCbkIsWUFBdEIsRUFBb0MwQixnQkFBcEMsQ0FEVTtBQUVWUix3QkFBTWtCLGdCQUFOLENBQXVCOUMsS0FBSyxDQUFMLENBQXZCLEVBQWdDb0MsZ0JBQWhDLENBRko7O0FBSUEsc0JBQU1XLFNBQVMsQ0FBQ0wsV0FBRCxFQUFjTSxNQUFkLENBQXFCaEIsWUFBckIsQ0FBZjtBQUNBZSx5QkFBT2pDLE9BQVAsQ0FBZSxVQUFDbUMsYUFBRCxFQUFnQkMsQ0FBaEIsRUFBc0I7QUFDbkNQLHlDQUFxQnRDLGlCQUFpQjBCLEtBQWpCO0FBQ25CZ0IsMkJBQU9HLElBQUksQ0FBWCxJQUFnQkgsT0FBT0csSUFBSSxDQUFYLEVBQWMzQixLQUFkLENBQW9CLENBQXBCLENBQWhCLEdBQXlDLENBRHRCLEVBQ3lCMEIsY0FBYzFCLEtBQWQsQ0FBb0IsQ0FBcEIsQ0FEekI7QUFFakIwQixrQ0FBY0UsSUFGbEI7QUFHRCxtQkFKRDs7QUFNQSx5QkFBT3ZCLE1BQU13QixnQkFBTixDQUF1QjdCLEtBQXZCLEVBQThCb0IsaUJBQTlCLENBQVA7QUFDRCxpQkEvQkQ7QUFnQ0Q7QUFDRC9DLHNCQUFRcUIsTUFBUixDQUFlUyxLQUFmO0FBQ0QsYUE5Q0Q7QUErQ0QsV0E1R0ksb0JBQVA7O0FBOEdELEtBdEljLG1CQUFqQiIsImZpbGUiOiJmaXJzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldERlY2xhcmVkVmFyaWFibGVzLCBnZXRTb3VyY2VDb2RlIH0gZnJvbSAnZXNsaW50LW1vZHVsZS11dGlscy9jb250ZXh0Q29tcGF0JztcblxuaW1wb3J0IGRvY3NVcmwgZnJvbSAnLi4vZG9jc1VybCc7XG5cbmZ1bmN0aW9uIGdldEltcG9ydFZhbHVlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ0ltcG9ydERlY2xhcmF0aW9uJ1xuICAgID8gbm9kZS5zb3VyY2UudmFsdWVcbiAgICA6IG5vZGUubW9kdWxlUmVmZXJlbmNlLmV4cHJlc3Npb24udmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtZXRhOiB7XG4gICAgdHlwZTogJ3N1Z2dlc3Rpb24nLFxuICAgIGRvY3M6IHtcbiAgICAgIGNhdGVnb3J5OiAnU3R5bGUgZ3VpZGUnLFxuICAgICAgZGVzY3JpcHRpb246ICdFbnN1cmUgYWxsIGltcG9ydHMgYXBwZWFyIGJlZm9yZSBvdGhlciBzdGF0ZW1lbnRzLicsXG4gICAgICB1cmw6IGRvY3NVcmwoJ2ZpcnN0JyksXG4gICAgfSxcbiAgICBmaXhhYmxlOiAnY29kZScsXG4gICAgc2NoZW1hOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBlbnVtOiBbJ2Fic29sdXRlLWZpcnN0JywgJ2Rpc2FibGUtYWJzb2x1dGUtZmlyc3QnXSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfSxcblxuICBjcmVhdGUoY29udGV4dCkge1xuICAgIGZ1bmN0aW9uIGlzUG9zc2libGVEaXJlY3RpdmUobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnXG4gICAgICAgICYmIG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSAnTGl0ZXJhbCdcbiAgICAgICAgJiYgdHlwZW9mIG5vZGUuZXhwcmVzc2lvbi52YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIFByb2dyYW0obikge1xuICAgICAgICBjb25zdCBib2R5ID0gbi5ib2R5O1xuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJzb2x1dGVGaXJzdCA9IGNvbnRleHQub3B0aW9uc1swXSA9PT0gJ2Fic29sdXRlLWZpcnN0JztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbXBvcnQgaW4gYm9keSBvZiBtb2R1bGU7IHJlb3JkZXIgdG8gdG9wLic7XG4gICAgICAgIGNvbnN0IHNvdXJjZUNvZGUgPSBnZXRTb3VyY2VDb2RlKGNvbnRleHQpO1xuICAgICAgICBjb25zdCBvcmlnaW5Tb3VyY2VDb2RlID0gc291cmNlQ29kZS5nZXRUZXh0KCk7XG4gICAgICAgIGxldCBub25JbXBvcnRDb3VudCA9IDA7XG4gICAgICAgIGxldCBhbnlFeHByZXNzaW9ucyA9IGZhbHNlO1xuICAgICAgICBsZXQgYW55UmVsYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGxhc3RMZWdhbEltcCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGVycm9ySW5mb3MgPSBbXTtcbiAgICAgICAgbGV0IHNob3VsZFNvcnQgPSB0cnVlO1xuICAgICAgICBsZXQgbGFzdFNvcnROb2Rlc0luZGV4ID0gMDtcbiAgICAgICAgYm9keS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpbmRleCkge1xuICAgICAgICAgIGlmICghYW55RXhwcmVzc2lvbnMgJiYgaXNQb3NzaWJsZURpcmVjdGl2ZShub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFueUV4cHJlc3Npb25zID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdJbXBvcnREZWNsYXJhdGlvbicgfHwgbm9kZS50eXBlID09PSAnVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChhYnNvbHV0ZUZpcnN0KSB7XG4gICAgICAgICAgICAgIGlmICgoL15cXC4vKS50ZXN0KGdldEltcG9ydFZhbHVlKG5vZGUpKSkge1xuICAgICAgICAgICAgICAgIGFueVJlbGF0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbnlSZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUudHlwZSA9PT0gJ0ltcG9ydERlY2xhcmF0aW9uJyA/IG5vZGUuc291cmNlIDogbm9kZS5tb2R1bGVSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQWJzb2x1dGUgaW1wb3J0cyBzaG91bGQgY29tZSBiZWZvcmUgcmVsYXRpdmUgaW1wb3J0cy4nLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9uSW1wb3J0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgZ2V0RGVjbGFyZWRWYXJpYWJsZXMoY29udGV4dCwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFNvcnQpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gdmFyaWFibGUucmVmZXJlbmNlcztcbiAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVmZXJlbmNlIG9mIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZS5pZGVudGlmaWVyLnJhbmdlWzBdIDwgbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzaG91bGRTb3J0ICYmIChsYXN0U29ydE5vZGVzSW5kZXggPSBlcnJvckluZm9zLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGVycm9ySW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICByYW5nZTogW2JvZHlbaW5kZXggLSAxXS5yYW5nZVsxXSwgbm9kZS5yYW5nZVsxXV0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdExlZ2FsSW1wID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9uSW1wb3J0Q291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWVycm9ySW5mb3MubGVuZ3RoKSB7IHJldHVybjsgfVxuICAgICAgICBlcnJvckluZm9zLmZvckVhY2goZnVuY3Rpb24gKGVycm9ySW5mbywgaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gZXJyb3JJbmZvLm5vZGU7XG4gICAgICAgICAgY29uc3QgaW5mb3MgPSB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpbmRleCA8IGxhc3RTb3J0Tm9kZXNJbmRleCkge1xuICAgICAgICAgICAgaW5mb3MuZml4ID0gZnVuY3Rpb24gKGZpeGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaXhlci5pbnNlcnRUZXh0QWZ0ZXIobm9kZSwgJycpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsYXN0U29ydE5vZGVzSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvcnROb2RlcyA9IGVycm9ySW5mb3Muc2xpY2UoMCwgbGFzdFNvcnROb2Rlc0luZGV4ICsgMSk7XG4gICAgICAgICAgICBpbmZvcy5maXggPSBmdW5jdGlvbiAoZml4ZXIpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlRml4ZXJzID0gc29ydE5vZGVzLm1hcChmdW5jdGlvbiAoX2Vycm9ySW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXhlci5yZW1vdmVSYW5nZShfZXJyb3JJbmZvLnJhbmdlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gWzAsIHJlbW92ZUZpeGVyc1tyZW1vdmVGaXhlcnMubGVuZ3RoIC0gMV0ucmFuZ2VbMV1dO1xuICAgICAgICAgICAgICBsZXQgaW5zZXJ0U291cmNlQ29kZSA9IHNvcnROb2Rlcy5tYXAoZnVuY3Rpb24gKF9lcnJvckluZm8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlU291cmNlQ29kZSA9IFN0cmluZy5wcm90b3R5cGUuc2xpY2UuYXBwbHkoXG4gICAgICAgICAgICAgICAgICBvcmlnaW5Tb3VyY2VDb2RlLCBfZXJyb3JJbmZvLnJhbmdlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCgvXFxTLykudGVzdChub2RlU291cmNlQ29kZVswXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgXFxuJHtub2RlU291cmNlQ29kZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVNvdXJjZUNvZGU7XG4gICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgICBsZXQgaW5zZXJ0Rml4ZXIgPSBudWxsO1xuICAgICAgICAgICAgICBsZXQgcmVwbGFjZVNvdXJjZUNvZGUgPSAnJztcbiAgICAgICAgICAgICAgaWYgKCFsYXN0TGVnYWxJbXApIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRTb3VyY2VDb2RlID0gaW5zZXJ0U291cmNlQ29kZS50cmltKCkgKyBpbnNlcnRTb3VyY2VDb2RlLm1hdGNoKC9eKFxccyspLylbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5zZXJ0Rml4ZXIgPSBsYXN0TGVnYWxJbXBcbiAgICAgICAgICAgICAgICA/IGZpeGVyLmluc2VydFRleHRBZnRlcihsYXN0TGVnYWxJbXAsIGluc2VydFNvdXJjZUNvZGUpXG4gICAgICAgICAgICAgICAgOiBmaXhlci5pbnNlcnRUZXh0QmVmb3JlKGJvZHlbMF0sIGluc2VydFNvdXJjZUNvZGUpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGZpeGVycyA9IFtpbnNlcnRGaXhlcl0uY29uY2F0KHJlbW92ZUZpeGVycyk7XG4gICAgICAgICAgICAgIGZpeGVycy5mb3JFYWNoKChjb21wdXRlZEZpeGVyLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZVNvdXJjZUNvZGUgKz0gb3JpZ2luU291cmNlQ29kZS5zbGljZShcbiAgICAgICAgICAgICAgICAgIGZpeGVyc1tpIC0gMV0gPyBmaXhlcnNbaSAtIDFdLnJhbmdlWzFdIDogMCwgY29tcHV0ZWRGaXhlci5yYW5nZVswXSxcbiAgICAgICAgICAgICAgICApICsgY29tcHV0ZWRGaXhlci50ZXh0O1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICByZXR1cm4gZml4ZXIucmVwbGFjZVRleHRSYW5nZShyYW5nZSwgcmVwbGFjZVNvdXJjZUNvZGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5yZXBvcnQoaW5mb3MpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG4iXX0=</span></pre>
</body>
</html>