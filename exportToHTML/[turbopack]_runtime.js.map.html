<html>
<head>
<title>[turbopack]_runtime.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
[turbopack]_runtime.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span>
  <span class="s1">&quot;version&quot;</span><span class="s0">: </span><span class="s2">3</span><span class="s0">,</span>
  <span class="s1">&quot;sources&quot;</span><span class="s0">: [],</span>
  <span class="s1">&quot;sections&quot;</span><span class="s0">: [</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/shared/runtime-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This file contains runtime types and functions that are shared between all</span><span class="s3">\n </span><span class="s1">* TurboPack ECMAScript runtimes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It will be prepended to the runtime code of each runtime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">./runtime-types.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">type EsmNamespaceObject = Record&lt;string, any&gt;</span><span class="s3">\n\n</span><span class="s1">// @ts-ignore Defined in `dev-base.ts`</span><span class="s3">\n</span><span class="s1">declare function getOrInstantiateModuleFromParent&lt;M&gt;(</span><span class="s3">\n  </span><span class="s1">id: ModuleId,</span><span class="s3">\n  </span><span class="s1">sourceModule: M</span><span class="s3">\n</span><span class="s1">): M</span><span class="s3">\n\n</span><span class="s1">const REEXPORTED_OBJECTS = new WeakMap&lt;Module, ReexportedObjects&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Constructs the `__turbopack_context__` object for a module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Context(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">module: Module,</span><span class="s3">\n  </span><span class="s1">exports: Exports</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.m = module</span><span class="s3">\n  </span><span class="s1">// We need to store this here instead of accessing it from the module object to:</span><span class="s3">\n  </span><span class="s1">// 1. Make it available to factories directly, since we rewrite `this` to</span><span class="s3">\n  </span><span class="s1">//    `__turbopack_context__.e` in CJS modules.</span><span class="s3">\n  </span><span class="s1">// 2. Support async modules which rewrite `module.exports` to a promise, so we</span><span class="s3">\n  </span><span class="s1">//    can still access the original exports object from functions like</span><span class="s3">\n  </span><span class="s1">//    `esmExport`</span><span class="s3">\n  </span><span class="s1">// Ideally we could find a new approach for async modules and drop this property altogether.</span><span class="s3">\n  </span><span class="s1">this.e = exports</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const contextPrototype = Context.prototype as TurbopackBaseContext&lt;Module&gt;</span><span class="s3">\n\n</span><span class="s1">type ModuleContextMap = Record&lt;ModuleId, ModuleContextEntry&gt;</span><span class="s3">\n\n</span><span class="s1">interface ModuleContextEntry {</span><span class="s3">\n  </span><span class="s1">id: () =&gt; ModuleId</span><span class="s3">\n  </span><span class="s1">module: () =&gt; any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ModuleContext {</span><span class="s3">\n  </span><span class="s1">// require call</span><span class="s3">\n  </span><span class="s1">(moduleId: ModuleId): Exports | EsmNamespaceObject</span><span class="s3">\n\n  </span><span class="s1">// async import call</span><span class="s3">\n  </span><span class="s1">import(moduleId: ModuleId): Promise&lt;Exports | EsmNamespaceObject&gt;</span><span class="s3">\n\n  </span><span class="s1">keys(): ModuleId[]</span><span class="s3">\n\n  </span><span class="s1">resolve(moduleId: ModuleId): ModuleId</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetOrInstantiateModuleFromParent&lt;M extends Module&gt; = (</span><span class="s3">\n  </span><span class="s1">moduleId: M['id'],</span><span class="s3">\n  </span><span class="s1">parentModule: M</span><span class="s3">\n</span><span class="s1">) =&gt; M</span><span class="s3">\n\n</span><span class="s1">declare function getOrInstantiateRuntimeModule(</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n</span><span class="s1">): Module</span><span class="s3">\n\n</span><span class="s1">const hasOwnProperty = Object.prototype.hasOwnProperty</span><span class="s3">\n</span><span class="s1">const toStringTag = typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag</span><span class="s3">\n\n</span><span class="s1">function defineProp(</span><span class="s3">\n  </span><span class="s1">obj: any,</span><span class="s3">\n  </span><span class="s1">name: PropertyKey,</span><span class="s3">\n  </span><span class="s1">options: PropertyDescriptor &amp; ThisType&lt;any&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getOverwrittenModule(</span><span class="s3">\n  </span><span class="s1">moduleCache: ModuleCache&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">let module = moduleCache[id]</span><span class="s3">\n  </span><span class="s1">if (!module) {</span><span class="s3">\n    </span><span class="s1">// This is invoked when a module is merged into another module, thus it wasn't invoked via</span><span class="s3">\n    </span><span class="s1">// instantiateModule and the cache entry wasn't created yet.</span><span class="s3">\n    </span><span class="s1">module = createModuleObject(id)</span><span class="s3">\n    </span><span class="s1">moduleCache[id] = module</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return module</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates the module object. Only done here to ensure all module objects have the same shape.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createModuleObject(id: ModuleId): Module {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">exports: {},</span><span class="s3">\n    </span><span class="s1">error: undefined,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">namespaceObject: undefined,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds the getters to the exports object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function esm(</span><span class="s3">\n  </span><span class="s1">exports: Exports,</span><span class="s3">\n  </span><span class="s1">getters: Array&lt;string | (() =&gt; unknown) | ((v: unknown) =&gt; void)&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">defineProp(exports, '__esModule', { value: true })</span><span class="s3">\n  </span><span class="s1">if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n  </span><span class="s1">while (i &lt; getters.length) {</span><span class="s3">\n    </span><span class="s1">const propName = getters[i++] as string</span><span class="s3">\n    </span><span class="s1">// TODO(luke.sandberg): we could support raw values here, but would need a discriminator beyond 'not a function'</span><span class="s3">\n    </span><span class="s1">const getter = getters[i++] as () =&gt; unknown</span><span class="s3">\n    </span><span class="s1">if (typeof getters[i] === 'function') {</span><span class="s3">\n      </span><span class="s1">// a setter</span><span class="s3">\n      </span><span class="s1">defineProp(exports, propName, {</span><span class="s3">\n        </span><span class="s1">get: getter,</span><span class="s3">\n        </span><span class="s1">set: getters[i++] as (v: unknown) =&gt; void,</span><span class="s3">\n        </span><span class="s1">enumerable: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">defineProp(exports, propName, { get: getter, enumerable: true })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">Object.seal(exports)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Makes the module an ESM with exports</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function esmExport(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">getters: Array&lt;string | (() =&gt; unknown) | ((v: unknown) =&gt; void)&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let module: Module</span><span class="s3">\n  </span><span class="s1">let exports: Module['exports']</span><span class="s3">\n  </span><span class="s1">if (id != null) {</span><span class="s3">\n    </span><span class="s1">module = getOverwrittenModule(this.c, id)</span><span class="s3">\n    </span><span class="s1">exports = module.exports</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">module = this.m</span><span class="s3">\n    </span><span class="s1">exports = this.e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">module.namespaceObject = exports</span><span class="s3">\n  </span><span class="s1">esm(exports, getters)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.s = esmExport</span><span class="s3">\n\n</span><span class="s1">type ReexportedObjects = Record&lt;PropertyKey, unknown&gt;[]</span><span class="s3">\n</span><span class="s1">function ensureDynamicExports(</span><span class="s3">\n  </span><span class="s1">module: Module,</span><span class="s3">\n  </span><span class="s1">exports: Exports</span><span class="s3">\n</span><span class="s1">): ReexportedObjects {</span><span class="s3">\n  </span><span class="s1">let reexportedObjects: ReexportedObjects | undefined =</span><span class="s3">\n    </span><span class="s1">REEXPORTED_OBJECTS.get(module)</span><span class="s3">\n\n  </span><span class="s1">if (!reexportedObjects) {</span><span class="s3">\n    </span><span class="s1">REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))</span><span class="s3">\n    </span><span class="s1">module.exports = module.namespaceObject = new Proxy(exports, {</span><span class="s3">\n      </span><span class="s1">get(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">hasOwnProperty.call(target, prop) ||</span><span class="s3">\n          </span><span class="s1">prop === 'default' ||</span><span class="s3">\n          </span><span class="s1">prop === '__esModule'</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">return Reflect.get(target, prop)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const obj of reexportedObjects!) {</span><span class="s3">\n          </span><span class="s1">const value = Reflect.get(obj, prop)</span><span class="s3">\n          </span><span class="s1">if (value !== undefined) return value</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">ownKeys(target) {</span><span class="s3">\n        </span><span class="s1">const keys = Reflect.ownKeys(target)</span><span class="s3">\n        </span><span class="s1">for (const obj of reexportedObjects!) {</span><span class="s3">\n          </span><span class="s1">for (const key of Reflect.ownKeys(obj)) {</span><span class="s3">\n            </span><span class="s1">if (key !== 'default' &amp;&amp; !keys.includes(key)) keys.push(key)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return keys</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return reexportedObjects</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Dynamically exports properties from an object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function dynamicExport(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">object: Record&lt;string, any&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let module: Module</span><span class="s3">\n  </span><span class="s1">let exports: Module['exports']</span><span class="s3">\n  </span><span class="s1">if (id != null) {</span><span class="s3">\n    </span><span class="s1">module = getOverwrittenModule(this.c, id)</span><span class="s3">\n    </span><span class="s1">exports = module.exports</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">module = this.m</span><span class="s3">\n    </span><span class="s1">exports = this.e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const reexportedObjects = ensureDynamicExports(module, exports)</span><span class="s3">\n\n  </span><span class="s1">if (typeof object === 'object' &amp;&amp; object !== null) {</span><span class="s3">\n    </span><span class="s1">reexportedObjects.push(object)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.j = dynamicExport</span><span class="s3">\n\n</span><span class="s1">function exportValue(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">value: any,</span><span class="s3">\n  </span><span class="s1">id: ModuleId | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let module: Module</span><span class="s3">\n  </span><span class="s1">if (id != null) {</span><span class="s3">\n    </span><span class="s1">module = getOverwrittenModule(this.c, id)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">module = this.m</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">module.exports = value</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.v = exportValue</span><span class="s3">\n\n</span><span class="s1">function exportNamespace(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">namespace: any,</span><span class="s3">\n  </span><span class="s1">id: ModuleId | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let module: Module</span><span class="s3">\n  </span><span class="s1">if (id != null) {</span><span class="s3">\n    </span><span class="s1">module = getOverwrittenModule(this.c, id)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">module = this.m</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">module.exports = module.namespaceObject = namespace</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.n = exportNamespace</span><span class="s3">\n\n</span><span class="s1">function createGetter(obj: Record&lt;string | symbol, any&gt;, key: string | symbol) {</span><span class="s3">\n  </span><span class="s1">return () =&gt; obj[key]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @returns prototype of the object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getProto: (obj: any) =&gt; any = Object.getPrototypeOf</span><span class="s3">\n  </span><span class="s1">? (obj) =&gt; Object.getPrototypeOf(obj)</span><span class="s3">\n  </span><span class="s1">: (obj) =&gt; obj.__proto__</span><span class="s3">\n\n</span><span class="s1">/** Prototypes that are not expanded for exports */</span><span class="s3">\n</span><span class="s1">const LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param raw</span><span class="s3">\n </span><span class="s1">* @param ns</span><span class="s3">\n </span><span class="s1">* @param allowExportDefault</span><span class="s3">\n </span><span class="s1">*   * `false`: will have the raw module as default export</span><span class="s3">\n </span><span class="s1">*   * `true`: will have the default property as default export</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function interopEsm(</span><span class="s3">\n  </span><span class="s1">raw: Exports,</span><span class="s3">\n  </span><span class="s1">ns: EsmNamespaceObject,</span><span class="s3">\n  </span><span class="s1">allowExportDefault?: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const getters: Array&lt;string | (() =&gt; unknown) | ((v: unknown) =&gt; void)&gt; = []</span><span class="s3">\n  </span><span class="s1">// The index of the `default` export if any</span><span class="s3">\n  </span><span class="s1">let defaultLocation = -1</span><span class="s3">\n  </span><span class="s1">for (</span><span class="s3">\n    </span><span class="s1">let current = raw;</span><span class="s3">\n    </span><span class="s1">(typeof current === 'object' || typeof current === 'function') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!LEAF_PROTOTYPES.includes(current);</span><span class="s3">\n    </span><span class="s1">current = getProto(current)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.getOwnPropertyNames(current)) {</span><span class="s3">\n      </span><span class="s1">getters.push(key, createGetter(raw, key))</span><span class="s3">\n      </span><span class="s1">if (defaultLocation === -1 &amp;&amp; key === 'default') {</span><span class="s3">\n        </span><span class="s1">defaultLocation = getters.length - 1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// this is not really correct</span><span class="s3">\n  </span><span class="s1">// we should set the `default` getter if the imported module is a `.cjs file`</span><span class="s3">\n  </span><span class="s1">if (!(allowExportDefault &amp;&amp; defaultLocation &gt;= 0)) {</span><span class="s3">\n    </span><span class="s1">// Replace the binding with one for the namespace itself in order to preserve iteration order.</span><span class="s3">\n    </span><span class="s1">if (defaultLocation &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">getters[defaultLocation] = () =&gt; raw</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">getters.push('default', () =&gt; raw)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">esm(ns, getters)</span><span class="s3">\n  </span><span class="s1">return ns</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createNS(raw: Module['exports']): EsmNamespaceObject {</span><span class="s3">\n  </span><span class="s1">if (typeof raw === 'function') {</span><span class="s3">\n    </span><span class="s1">return function (this: any, ...args: any[]) {</span><span class="s3">\n      </span><span class="s1">return raw.apply(this, args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return Object.create(null)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function esmImport(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId</span><span class="s3">\n</span><span class="s1">): Exclude&lt;Module['namespaceObject'], undefined&gt; {</span><span class="s3">\n  </span><span class="s1">const module = getOrInstantiateModuleFromParent(id, this.m)</span><span class="s3">\n\n  </span><span class="s1">// any ES module has to have `module.namespaceObject` defined.</span><span class="s3">\n  </span><span class="s1">if (module.namespaceObject) return module.namespaceObject</span><span class="s3">\n\n  </span><span class="s1">// only ESM can be an async module, so we don't need to worry about exports being a promise here.</span><span class="s3">\n  </span><span class="s1">const raw = module.exports</span><span class="s3">\n  </span><span class="s1">return (module.namespaceObject = interopEsm(</span><span class="s3">\n    </span><span class="s1">raw,</span><span class="s3">\n    </span><span class="s1">createNS(raw),</span><span class="s3">\n    </span><span class="s1">raw &amp;&amp; (raw as any).__esModule</span><span class="s3">\n  </span><span class="s1">))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.i = esmImport</span><span class="s3">\n\n</span><span class="s1">function asyncLoader(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n</span><span class="s1">): Promise&lt;Exports&gt; {</span><span class="s3">\n  </span><span class="s1">const loader = this.r(moduleId) as (</span><span class="s3">\n    </span><span class="s1">importFunction: EsmImport</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;Exports&gt;</span><span class="s3">\n  </span><span class="s1">return loader(this.i.bind(this))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.A = asyncLoader</span><span class="s3">\n\n</span><span class="s1">// Add a simple runtime require so that environments without one can still pass</span><span class="s3">\n</span><span class="s1">// `typeof require` CommonJS checks so that exports are correctly registered.</span><span class="s3">\n</span><span class="s1">const runtimeRequire =</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">typeof require === 'function'</span><span class="s3">\n    </span><span class="s1">? // @ts-ignore</span><span class="s3">\n      </span><span class="s1">require</span><span class="s3">\n    </span><span class="s1">: function require() {</span><span class="s3">\n        </span><span class="s1">throw new Error('Unexpected use of runtime require')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.t = runtimeRequire</span><span class="s3">\n\n</span><span class="s1">function commonJsRequire(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId</span><span class="s3">\n</span><span class="s1">): Exports {</span><span class="s3">\n  </span><span class="s1">return getOrInstantiateModuleFromParent(id, this.m).exports</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.r = commonJsRequire</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* `require.context` and require/import expression runtime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function moduleContext(map: ModuleContextMap): ModuleContext {</span><span class="s3">\n  </span><span class="s1">function moduleContext(id: ModuleId): Exports {</span><span class="s3">\n    </span><span class="s1">if (hasOwnProperty.call(map, id)) {</span><span class="s3">\n      </span><span class="s1">return map[id].module()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const e = new Error(`Cannot find module '${id}'`)</span><span class="s3">\n    </span><span class="s1">;(e as any).code = 'MODULE_NOT_FOUND'</span><span class="s3">\n    </span><span class="s1">throw e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">moduleContext.keys = (): ModuleId[] =&gt; {</span><span class="s3">\n    </span><span class="s1">return Object.keys(map)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">moduleContext.resolve = (id: ModuleId): ModuleId =&gt; {</span><span class="s3">\n    </span><span class="s1">if (hasOwnProperty.call(map, id)) {</span><span class="s3">\n      </span><span class="s1">return map[id].id()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const e = new Error(`Cannot find module '${id}'`)</span><span class="s3">\n    </span><span class="s1">;(e as any).code = 'MODULE_NOT_FOUND'</span><span class="s3">\n    </span><span class="s1">throw e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">moduleContext.import = async (id: ModuleId) =&gt; {</span><span class="s3">\n    </span><span class="s1">return await (moduleContext(id) as Promise&lt;Exports&gt;)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return moduleContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.f = moduleContext</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the path of a chunk defined by its data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getChunkPath(chunkData: ChunkData): ChunkPath {</span><span class="s3">\n  </span><span class="s1">return typeof chunkData === 'string' ? chunkData : chunkData.path</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isPromise&lt;T = any&gt;(maybePromise: any): maybePromise is Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">maybePromise != null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof maybePromise === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'then' in maybePromise &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof maybePromise.then === 'function'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isAsyncModuleExt&lt;T extends {}&gt;(obj: T): obj is AsyncModuleExt &amp; T {</span><span class="s3">\n  </span><span class="s1">return turbopackQueues in obj</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPromise&lt;T&gt;() {</span><span class="s3">\n  </span><span class="s1">let resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">let reject: (reason?: any) =&gt; void</span><span class="s3">\n\n  </span><span class="s1">const promise = new Promise&lt;T&gt;((res, rej) =&gt; {</span><span class="s3">\n    </span><span class="s1">reject = rej</span><span class="s3">\n    </span><span class="s1">resolve = res</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">promise,</span><span class="s3">\n    </span><span class="s1">resolve: resolve!,</span><span class="s3">\n    </span><span class="s1">reject: reject!,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.</span><span class="s3">\n</span><span class="s1">// The CompressedModuleFactories format is</span><span class="s3">\n</span><span class="s1">// - 1 or more module ids</span><span class="s3">\n</span><span class="s1">// - a module factory function</span><span class="s3">\n</span><span class="s1">// So walking this is a little complex but the flat structure is also fast to</span><span class="s3">\n</span><span class="s1">// traverse, we can use `typeof` operators to distinguish the two cases.</span><span class="s3">\n</span><span class="s1">function installCompressedModuleFactories(</span><span class="s3">\n  </span><span class="s1">chunkModules: CompressedModuleFactories,</span><span class="s3">\n  </span><span class="s1">offset: number,</span><span class="s3">\n  </span><span class="s1">moduleFactories: ModuleFactories,</span><span class="s3">\n  </span><span class="s1">newModuleId?: (id: ModuleId) =&gt; void</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let i = offset</span><span class="s3">\n  </span><span class="s1">while (i &lt; chunkModules.length) {</span><span class="s3">\n    </span><span class="s1">let moduleId = chunkModules[i] as ModuleId</span><span class="s3">\n    </span><span class="s1">let end = i + 1</span><span class="s3">\n    </span><span class="s1">// Find our factory function</span><span class="s3">\n    </span><span class="s1">while (</span><span class="s3">\n      </span><span class="s1">end &lt; chunkModules.length &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof chunkModules[end] !== 'function'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">end++</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end === chunkModules.length) {</span><span class="s3">\n      </span><span class="s1">throw new Error('malformed chunk format, expected a factory function')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Each chunk item has a 'primary id' and optional additional ids. If the primary id is already</span><span class="s3">\n    </span><span class="s1">// present we know all the additional ids are also present, so we don't need to check.</span><span class="s3">\n    </span><span class="s1">if (!moduleFactories.has(moduleId)) {</span><span class="s3">\n      </span><span class="s1">const moduleFactoryFn = chunkModules[end] as Function</span><span class="s3">\n      </span><span class="s1">applyModuleFactoryName(moduleFactoryFn)</span><span class="s3">\n      </span><span class="s1">newModuleId?.(moduleId)</span><span class="s3">\n      </span><span class="s1">for (; i &lt; end; i++) {</span><span class="s3">\n        </span><span class="s1">moduleId = chunkModules[i] as ModuleId</span><span class="s3">\n        </span><span class="s1">moduleFactories.set(moduleId, moduleFactoryFn)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// everything below is adapted from webpack</span><span class="s3">\n</span><span class="s1">// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13</span><span class="s3">\n\n</span><span class="s1">const turbopackQueues = Symbol('turbopack queues')</span><span class="s3">\n</span><span class="s1">const turbopackExports = Symbol('turbopack exports')</span><span class="s3">\n</span><span class="s1">const turbopackError = Symbol('turbopack error')</span><span class="s3">\n\n</span><span class="s1">const enum QueueStatus {</span><span class="s3">\n  </span><span class="s1">Unknown = -1,</span><span class="s3">\n  </span><span class="s1">Unresolved = 0,</span><span class="s3">\n  </span><span class="s1">Resolved = 1,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AsyncQueueFn = (() =&gt; void) &amp; { queueCount: number }</span><span class="s3">\n</span><span class="s1">type AsyncQueue = AsyncQueueFn[] &amp; {</span><span class="s3">\n  </span><span class="s1">status: QueueStatus</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveQueue(queue?: AsyncQueue) {</span><span class="s3">\n  </span><span class="s1">if (queue &amp;&amp; queue.status !== QueueStatus.Resolved) {</span><span class="s3">\n    </span><span class="s1">queue.status = QueueStatus.Resolved</span><span class="s3">\n    </span><span class="s1">queue.forEach((fn) =&gt; fn.queueCount--)</span><span class="s3">\n    </span><span class="s1">queue.forEach((fn) =&gt; (fn.queueCount-- ? fn.queueCount++ : fn()))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type Dep = Exports | AsyncModulePromise | Promise&lt;Exports&gt;</span><span class="s3">\n\n</span><span class="s1">type AsyncModuleExt = {</span><span class="s3">\n  </span><span class="s1">[turbopackQueues]: (fn: (queue: AsyncQueue) =&gt; void) =&gt; void</span><span class="s3">\n  </span><span class="s1">[turbopackExports]: Exports</span><span class="s3">\n  </span><span class="s1">[turbopackError]?: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AsyncModulePromise&lt;T = Exports&gt; = Promise&lt;T&gt; &amp; AsyncModuleExt</span><span class="s3">\n\n</span><span class="s1">function wrapDeps(deps: Dep[]): AsyncModuleExt[] {</span><span class="s3">\n  </span><span class="s1">return deps.map((dep): AsyncModuleExt =&gt; {</span><span class="s3">\n    </span><span class="s1">if (dep !== null &amp;&amp; typeof dep === 'object') {</span><span class="s3">\n      </span><span class="s1">if (isAsyncModuleExt(dep)) return dep</span><span class="s3">\n      </span><span class="s1">if (isPromise(dep)) {</span><span class="s3">\n        </span><span class="s1">const queue: AsyncQueue = Object.assign([], {</span><span class="s3">\n          </span><span class="s1">status: QueueStatus.Unresolved,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">const obj: AsyncModuleExt = {</span><span class="s3">\n          </span><span class="s1">[turbopackExports]: {},</span><span class="s3">\n          </span><span class="s1">[turbopackQueues]: (fn: (queue: AsyncQueue) =&gt; void) =&gt; fn(queue),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">dep.then(</span><span class="s3">\n          </span><span class="s1">(res) =&gt; {</span><span class="s3">\n            </span><span class="s1">obj[turbopackExports] = res</span><span class="s3">\n            </span><span class="s1">resolveQueue(queue)</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">(err) =&gt; {</span><span class="s3">\n            </span><span class="s1">obj[turbopackError] = err</span><span class="s3">\n            </span><span class="s1">resolveQueue(queue)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">return obj</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">[turbopackExports]: dep,</span><span class="s3">\n      </span><span class="s1">[turbopackQueues]: () =&gt; {},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function asyncModule(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">body: (</span><span class="s3">\n    </span><span class="s1">handleAsyncDependencies: (</span><span class="s3">\n      </span><span class="s1">deps: Dep[]</span><span class="s3">\n    </span><span class="s1">) =&gt; Exports[] | Promise&lt;() =&gt; Exports[]&gt;,</span><span class="s3">\n    </span><span class="s1">asyncResult: (err?: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">) =&gt; void,</span><span class="s3">\n  </span><span class="s1">hasAwait: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const module = this.m</span><span class="s3">\n  </span><span class="s1">const queue: AsyncQueue | undefined = hasAwait</span><span class="s3">\n    </span><span class="s1">? Object.assign([], { status: QueueStatus.Unknown })</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">const depQueues: Set&lt;AsyncQueue&gt; = new Set()</span><span class="s3">\n\n  </span><span class="s1">const { resolve, reject, promise: rawPromise } = createPromise&lt;Exports&gt;()</span><span class="s3">\n\n  </span><span class="s1">const promise: AsyncModulePromise = Object.assign(rawPromise, {</span><span class="s3">\n    </span><span class="s1">[turbopackExports]: module.exports,</span><span class="s3">\n    </span><span class="s1">[turbopackQueues]: (fn) =&gt; {</span><span class="s3">\n      </span><span class="s1">queue &amp;&amp; fn(queue)</span><span class="s3">\n      </span><span class="s1">depQueues.forEach(fn)</span><span class="s3">\n      </span><span class="s1">promise['catch'](() =&gt; {})</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">} satisfies AsyncModuleExt)</span><span class="s3">\n\n  </span><span class="s1">const attributes: PropertyDescriptor = {</span><span class="s3">\n    </span><span class="s1">get(): any {</span><span class="s3">\n      </span><span class="s1">return promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set(v: any) {</span><span class="s3">\n      </span><span class="s1">// Calling `esmExport` leads to this.</span><span class="s3">\n      </span><span class="s1">if (v !== promise) {</span><span class="s3">\n        </span><span class="s1">promise[turbopackExports] = v</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(module, 'exports', attributes)</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(module, 'namespaceObject', attributes)</span><span class="s3">\n\n  </span><span class="s1">function handleAsyncDependencies(deps: Dep[]) {</span><span class="s3">\n    </span><span class="s1">const currentDeps = wrapDeps(deps)</span><span class="s3">\n\n    </span><span class="s1">const getResult = () =&gt;</span><span class="s3">\n      </span><span class="s1">currentDeps.map((d) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (d[turbopackError]) throw d[turbopackError]</span><span class="s3">\n        </span><span class="s1">return d[turbopackExports]</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const { promise, resolve } = createPromise&lt;() =&gt; Exports[]&gt;()</span><span class="s3">\n\n    </span><span class="s1">const fn: AsyncQueueFn = Object.assign(() =&gt; resolve(getResult), {</span><span class="s3">\n      </span><span class="s1">queueCount: 0,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">function fnQueue(q: AsyncQueue) {</span><span class="s3">\n      </span><span class="s1">if (q !== queue &amp;&amp; !depQueues.has(q)) {</span><span class="s3">\n        </span><span class="s1">depQueues.add(q)</span><span class="s3">\n        </span><span class="s1">if (q &amp;&amp; q.status === QueueStatus.Unresolved) {</span><span class="s3">\n          </span><span class="s1">fn.queueCount++</span><span class="s3">\n          </span><span class="s1">q.push(fn)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">currentDeps.map((dep) =&gt; dep[turbopackQueues](fnQueue))</span><span class="s3">\n\n    </span><span class="s1">return fn.queueCount ? promise : getResult()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function asyncResult(err?: any) {</span><span class="s3">\n    </span><span class="s1">if (err) {</span><span class="s3">\n      </span><span class="s1">reject((promise[turbopackError] = err))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">resolve(promise[turbopackExports])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">resolveQueue(queue)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">body(handleAsyncDependencies, asyncResult)</span><span class="s3">\n\n  </span><span class="s1">if (queue &amp;&amp; queue.status === QueueStatus.Unknown) {</span><span class="s3">\n    </span><span class="s1">queue.status = QueueStatus.Unresolved</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.a = asyncModule</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A pseudo </span><span class="s3">\&quot;</span><span class="s1">fake</span><span class="s3">\&quot; </span><span class="s1">URL object to resolve to its relative path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this</span><span class="s3">\n </span><span class="s1">* runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid</span><span class="s3">\n </span><span class="s1">* hydration mismatch.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is based on webpack's existing implementation:</span><span class="s3">\n </span><span class="s1">* https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const relativeURL = function relativeURL(this: any, inputUrl: string) {</span><span class="s3">\n  </span><span class="s1">const realUrl = new URL(inputUrl, 'x:/')</span><span class="s3">\n  </span><span class="s1">const values: Record&lt;string, any&gt; = {}</span><span class="s3">\n  </span><span class="s1">for (const key in realUrl) values[key] = (realUrl as any)[key]</span><span class="s3">\n  </span><span class="s1">values.href = inputUrl</span><span class="s3">\n  </span><span class="s1">values.pathname = inputUrl.replace(/[?#].*/, '')</span><span class="s3">\n  </span><span class="s1">values.origin = values.protocol = ''</span><span class="s3">\n  </span><span class="s1">values.toString = values.toJSON = (..._args: Array&lt;any&gt;) =&gt; inputUrl</span><span class="s3">\n  </span><span class="s1">for (const key in values)</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(this, key, {</span><span class="s3">\n      </span><span class="s1">enumerable: true,</span><span class="s3">\n      </span><span class="s1">configurable: true,</span><span class="s3">\n      </span><span class="s1">value: values[key],</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">relativeURL.prototype = URL.prototype</span><span class="s3">\n</span><span class="s1">contextPrototype.U = relativeURL</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility function to ensure all variants of an enum are handled.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function invariant(never: never, computeMessage: (arg: any) =&gt; string): never {</span><span class="s3">\n  </span><span class="s1">throw new Error(`Invariant: ${computeMessage(never)}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A stub function to make `require` available but non-functional in ESM.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function requireStub(_moduleId: ModuleId): never {</span><span class="s3">\n  </span><span class="s1">throw new Error('dynamic usage of require is not supported')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.z = requireStub</span><span class="s3">\n\n</span><span class="s1">// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.</span><span class="s3">\n</span><span class="s1">contextPrototype.g = globalThis</span><span class="s3">\n\n</span><span class="s1">type ContextConstructor&lt;M&gt; = {</span><span class="s3">\n  </span><span class="s1">new (module: Module, exports: Exports): TurbopackBaseContext&lt;M&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyModuleFactoryName(factory: Function) {</span><span class="s3">\n  </span><span class="s1">// Give the module factory a nice name to improve stack traces.</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(factory, 'name', {</span><span class="s3">\n    </span><span class="s1">value: '__TURBOPACK__module__evaluation__',</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">470</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/shared-node/base-externals-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../shared/runtime-utils.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">/// A 'base' utilities to support runtime can have externals.</span><span class="s3">\n</span><span class="s1">/// Currently this is for node.js / edge runtime both.</span><span class="s3">\n</span><span class="s1">/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.</span><span class="s3">\n\n</span><span class="s1">async function externalImport(id: DependencySpecifier) {</span><span class="s3">\n  </span><span class="s1">let raw</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">raw = await import(id)</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">// TODO(alexkirsz) This can happen when a client-side module tries to load</span><span class="s3">\n    </span><span class="s1">// an external module we don't provide a shim for (e.g. querystring, url).</span><span class="s3">\n    </span><span class="s1">// For now, we fail semi-silently, but in the future this should be a</span><span class="s3">\n    </span><span class="s1">// compilation error.</span><span class="s3">\n    </span><span class="s1">throw new Error(`Failed to load external module ${id}: ${err}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (raw &amp;&amp; raw.__esModule &amp;&amp; raw.default &amp;&amp; 'default' in raw.default) {</span><span class="s3">\n    </span><span class="s1">return interopEsm(raw.default, createNS(raw), true)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return raw</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.y = externalImport</span><span class="s3">\n\n</span><span class="s1">function externalRequire(</span><span class="s3">\n  </span><span class="s1">id: ModuleId,</span><span class="s3">\n  </span><span class="s1">thunk: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">esm: boolean = false</span><span class="s3">\n</span><span class="s1">): Exports | EsmNamespaceObject {</span><span class="s3">\n  </span><span class="s1">let raw</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">raw = thunk()</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">// TODO(alexkirsz) This can happen when a client-side module tries to load</span><span class="s3">\n    </span><span class="s1">// an external module we don't provide a shim for (e.g. querystring, url).</span><span class="s3">\n    </span><span class="s1">// For now, we fail semi-silently, but in the future this should be a</span><span class="s3">\n    </span><span class="s1">// compilation error.</span><span class="s3">\n    </span><span class="s1">throw new Error(`Failed to load external module ${id}: ${err}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!esm || raw.__esModule) {</span><span class="s3">\n    </span><span class="s1">return raw</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return interopEsm(raw, createNS(raw), true)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">externalRequire.resolve = (</span><span class="s3">\n  </span><span class="s1">id: string,</span><span class="s3">\n  </span><span class="s1">options?: {</span><span class="s3">\n    </span><span class="s1">paths?: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">return require.resolve(id, options)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.x = externalRequire</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAuB;IACnD,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B;AACA,iBAAiB,CAAC,GAAG&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">511</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/shared-node/node-externals-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">declare var RUNTIME_PUBLIC_PATH: string</span><span class="s3">\n</span><span class="s1">declare var RELATIVE_ROOT_PATH: string</span><span class="s3">\n</span><span class="s1">declare var ASSET_PREFIX: string</span><span class="s3">\n\n</span><span class="s1">const path = require('path')</span><span class="s3">\n\n</span><span class="s1">const relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.')</span><span class="s3">\n</span><span class="s1">// Compute the relative path to the `distDir`.</span><span class="s3">\n</span><span class="s1">const relativePathToDistRoot = path.join(</span><span class="s3">\n  </span><span class="s1">relativePathToRuntimeRoot,</span><span class="s3">\n  </span><span class="s1">RELATIVE_ROOT_PATH</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot)</span><span class="s3">\n</span><span class="s1">// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.</span><span class="s3">\n</span><span class="s1">const ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns an absolute path to the given module path.</span><span class="s3">\n </span><span class="s1">* Module path should be relative, either path to a file or a directory.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This fn allows to calculate an absolute path for some global static values, such as</span><span class="s3">\n </span><span class="s1">* `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.</span><span class="s3">\n </span><span class="s1">* See ImportMetaBinding::code_generation for the usage.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolveAbsolutePath(modulePath?: string): string {</span><span class="s3">\n  </span><span class="s1">if (modulePath) {</span><span class="s3">\n    </span><span class="s1">return path.join(ABSOLUTE_ROOT, modulePath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ABSOLUTE_ROOT</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Context.prototype.P = resolveAbsolutePath</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,oDAAoD,GAMpD,MAAM,OAAO,QAAQ;AAErB,MAAM,4BAA4B,KAAK,QAAQ,CAAC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAM,yBAAyB,KAAK,IAAI,CACtC,2BACA;AAEF,MAAM,eAAe,KAAK,OAAO,CAAC,YAAY;AAC9C,mGAAmG;AACnG,MAAM,gBAAgB,KAAK,OAAO,CAAC,YAAY;AAE/C;;;;;;;CAOC,GACD,SAAS,oBAAoB,UAAmB;IAC9C,IAAI,YAAY;QACd,OAAO,KAAK,IAAI,CAAC,eAAe;IAClC;IACA,OAAO;AACT;AACA,QAAQ,SAAS,CAAC,CAAC,GAAG&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">532</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/shared-node/node-wasm-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../shared/runtime-utils.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">function readWebAssemblyAsResponse(path: string) {</span><span class="s3">\n  </span><span class="s1">const { createReadStream } = require('fs') as typeof import('fs')</span><span class="s3">\n  </span><span class="s1">const { Readable } = require('stream') as typeof import('stream')</span><span class="s3">\n\n  </span><span class="s1">const stream = createReadStream(path)</span><span class="s3">\n\n  </span><span class="s1">// @ts-ignore unfortunately there's a slight type mismatch with the stream.</span><span class="s3">\n  </span><span class="s1">return new Response(Readable.toWeb(stream), {</span><span class="s3">\n    </span><span class="s1">headers: {</span><span class="s3">\n      </span><span class="s1">'content-type': 'application/wasm',</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function compileWebAssemblyFromPath(</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n</span><span class="s1">): Promise&lt;WebAssembly.Module&gt; {</span><span class="s3">\n  </span><span class="s1">const response = readWebAssemblyAsResponse(path)</span><span class="s3">\n\n  </span><span class="s1">return await WebAssembly.compileStreaming(response)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function instantiateWebAssemblyFromPath(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">importsObj: WebAssembly.Imports</span><span class="s3">\n</span><span class="s1">): Promise&lt;Exports&gt; {</span><span class="s3">\n  </span><span class="s1">const response = readWebAssemblyAsResponse(path)</span><span class="s3">\n\n  </span><span class="s1">const { instance } = await WebAssembly.instantiateStreaming(</span><span class="s3">\n    </span><span class="s1">response,</span><span class="s3">\n    </span><span class="s1">importsObj</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return instance.exports</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,SAAS,0BAA0B,IAAY;IAC7C,MAAM,EAAE,gBAAgB,EAAE,GAAG,QAAQ;IACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;IAE7B,MAAM,SAAS,iBAAiB;IAEhC,2EAA2E;IAC3E,OAAO,IAAI,SAAS,SAAS,KAAK,CAAC,SAAS;QAC1C,SAAS;YACP,gBAAgB;QAClB;IACF;AACF;AAEA,eAAe,2BACb,IAAY;IAEZ,MAAM,WAAW,0BAA0B;IAE3C,OAAO,MAAM,YAAY,gBAAgB,CAAC;AAC5C;AAEA,eAAe,+BACb,IAAY,EACZ,UAA+B;IAE/B,MAAM,WAAW,0BAA0B;IAE3C,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,oBAAoB,CACzD,UACA;IAGF,OAAO,SAAS,OAAO;AACzB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">553</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/nodejs/runtime.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../shared/runtime-utils.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../shared-node/base-externals-utils.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../shared-node/node-externals-utils.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../shared-node/node-wasm-utils.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">enum SourceType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The module was instantiated because it was included in an evaluated chunk's</span><span class="s3">\n   </span><span class="s1">* runtime.</span><span class="s3">\n   </span><span class="s1">* SourceData is a ChunkPath.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Runtime = 0,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The module was instantiated because a parent module imported it.</span><span class="s3">\n   </span><span class="s1">* SourceData is a ModuleId.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Parent = 1,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SourceData = ChunkPath | ModuleId</span><span class="s3">\n\n</span><span class="s1">process.env.TURBOPACK = '1'</span><span class="s3">\n\n</span><span class="s1">interface TurbopackNodeBuildContext extends TurbopackBaseContext&lt;Module&gt; {</span><span class="s3">\n  </span><span class="s1">R: ResolvePathFromModule</span><span class="s3">\n  </span><span class="s1">x: ExternalRequire</span><span class="s3">\n  </span><span class="s1">y: ExternalImport</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const nodeContextPrototype = Context.prototype as TurbopackNodeBuildContext</span><span class="s3">\n\n</span><span class="s1">type ModuleFactory = (</span><span class="s3">\n  </span><span class="s1">this: Module['exports'],</span><span class="s3">\n  </span><span class="s1">context: TurbopackNodeBuildContext</span><span class="s3">\n</span><span class="s1">) =&gt; unknown</span><span class="s3">\n\n</span><span class="s1">const url = require('url') as typeof import('url')</span><span class="s3">\n\n</span><span class="s1">const moduleFactories: ModuleFactories = new Map()</span><span class="s3">\n</span><span class="s1">nodeContextPrototype.M = moduleFactories</span><span class="s3">\n</span><span class="s1">const moduleCache: ModuleCache&lt;Module&gt; = Object.create(null)</span><span class="s3">\n</span><span class="s1">nodeContextPrototype.c = moduleCache</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns an absolute path to the given module's id.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolvePathFromModule(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">moduleId: string</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const exported = this.r(moduleId)</span><span class="s3">\n  </span><span class="s1">const exportedPath = exported?.default ?? exported</span><span class="s3">\n  </span><span class="s1">if (typeof exportedPath !== 'string') {</span><span class="s3">\n    </span><span class="s1">return exported as any</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)</span><span class="s3">\n  </span><span class="s1">const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)</span><span class="s3">\n\n  </span><span class="s1">return url.pathToFileURL(resolved).href</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">nodeContextPrototype.R = resolvePathFromModule</span><span class="s3">\n\n</span><span class="s1">function loadRuntimeChunk(sourcePath: ChunkPath, chunkData: ChunkData): void {</span><span class="s3">\n  </span><span class="s1">if (typeof chunkData === 'string') {</span><span class="s3">\n    </span><span class="s1">loadRuntimeChunkPath(sourcePath, chunkData)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">loadRuntimeChunkPath(sourcePath, chunkData.path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const loadedChunks = new Set&lt;ChunkPath&gt;()</span><span class="s3">\n</span><span class="s1">const unsupportedLoadChunk = Promise.resolve(undefined)</span><span class="s3">\n</span><span class="s1">const loadedChunk: Promise&lt;void&gt; = Promise.resolve(undefined)</span><span class="s3">\n</span><span class="s1">const chunkCache = new Map&lt;ChunkPath, Promise&lt;void&gt;&gt;()</span><span class="s3">\n\n</span><span class="s1">function clearChunkCache() {</span><span class="s3">\n  </span><span class="s1">chunkCache.clear()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function loadRuntimeChunkPath(</span><span class="s3">\n  </span><span class="s1">sourcePath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">if (!isJs(chunkPath)) {</span><span class="s3">\n    </span><span class="s1">// We only support loading JS chunks in Node.js.</span><span class="s3">\n    </span><span class="s1">// This branch can be hit when trying to load a CSS chunk.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (loadedChunks.has(chunkPath)) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const resolved = path.resolve(RUNTIME_ROOT, chunkPath)</span><span class="s3">\n    </span><span class="s1">const chunkModules: CompressedModuleFactories = require(resolved)</span><span class="s3">\n    </span><span class="s1">installCompressedModuleFactories(chunkModules, 0, moduleFactories)</span><span class="s3">\n    </span><span class="s1">loadedChunks.add(chunkPath)</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">let errorMessage = `Failed to load chunk ${chunkPath}`</span><span class="s3">\n\n    </span><span class="s1">if (sourcePath) {</span><span class="s3">\n      </span><span class="s1">errorMessage += ` from runtime for chunk ${sourcePath}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">throw new Error(errorMessage, {</span><span class="s3">\n      </span><span class="s1">cause: e,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function loadChunkAsync(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">chunkData: ChunkData</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path</span><span class="s3">\n  </span><span class="s1">if (!isJs(chunkPath)) {</span><span class="s3">\n    </span><span class="s1">// We only support loading JS chunks in Node.js.</span><span class="s3">\n    </span><span class="s1">// This branch can be hit when trying to load a CSS chunk.</span><span class="s3">\n    </span><span class="s1">return unsupportedLoadChunk</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let entry = chunkCache.get(chunkPath)</span><span class="s3">\n  </span><span class="s1">if (entry === undefined) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// resolve to an absolute path to simplify `require` handling</span><span class="s3">\n      </span><span class="s1">const resolved = path.resolve(RUNTIME_ROOT, chunkPath)</span><span class="s3">\n      </span><span class="s1">// TODO: consider switching to `import()` to enable concurrent chunk loading and async file io</span><span class="s3">\n      </span><span class="s1">// However this is incompatible with hot reloading (since `import` doesn't use the require cache)</span><span class="s3">\n      </span><span class="s1">const chunkModules: CompressedModuleFactories = require(resolved)</span><span class="s3">\n      </span><span class="s1">installCompressedModuleFactories(chunkModules, 0, moduleFactories)</span><span class="s3">\n      </span><span class="s1">entry = loadedChunk</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n      </span><span class="s1">const errorMessage = `Failed to load chunk ${chunkPath} from module ${this.m.id}`</span><span class="s3">\n\n      </span><span class="s1">// Cache the failure promise, future requests will also get this same rejection</span><span class="s3">\n      </span><span class="s1">entry = Promise.reject(</span><span class="s3">\n        </span><span class="s1">new Error(errorMessage, {</span><span class="s3">\n          </span><span class="s1">cause: e,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">chunkCache.set(chunkPath, entry)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// TODO: Return an instrumented Promise that React can use instead of relying on referential equality.</span><span class="s3">\n  </span><span class="s1">return entry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.l = loadChunkAsync</span><span class="s3">\n\n</span><span class="s1">function loadChunkAsyncByUrl(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">chunkUrl: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath</span><span class="s3">\n  </span><span class="s1">return loadChunkAsync.call(this, path)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.L = loadChunkAsyncByUrl</span><span class="s3">\n\n</span><span class="s1">function loadWebAssembly(</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">_edgeModule: () =&gt; WebAssembly.Module,</span><span class="s3">\n  </span><span class="s1">imports: WebAssembly.Imports</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const resolved = path.resolve(RUNTIME_ROOT, chunkPath)</span><span class="s3">\n\n  </span><span class="s1">return instantiateWebAssemblyFromPath(resolved, imports)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.w = loadWebAssembly</span><span class="s3">\n\n</span><span class="s1">function loadWebAssemblyModule(</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">_edgeModule: () =&gt; WebAssembly.Module</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const resolved = path.resolve(RUNTIME_ROOT, chunkPath)</span><span class="s3">\n\n  </span><span class="s1">return compileWebAssemblyFromPath(resolved)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.u = loadWebAssemblyModule</span><span class="s3">\n\n</span><span class="s1">function getWorkerBlobURL(_chunks: ChunkPath[]): string {</span><span class="s3">\n  </span><span class="s1">throw new Error('Worker blobs are not implemented yet for Node.js')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">nodeContextPrototype.b = getWorkerBlobURL</span><span class="s3">\n\n</span><span class="s1">function instantiateModule(</span><span class="s3">\n  </span><span class="s1">id: ModuleId,</span><span class="s3">\n  </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n  </span><span class="s1">sourceData: SourceData</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">const moduleFactory = moduleFactories.get(id)</span><span class="s3">\n  </span><span class="s1">if (typeof moduleFactory !== 'function') {</span><span class="s3">\n    </span><span class="s1">// This can happen if modules incorrectly handle HMR disposes/updates,</span><span class="s3">\n    </span><span class="s1">// e.g. when they keep a `setTimeout` around which still executes old code</span><span class="s3">\n    </span><span class="s1">// and contains e.g. a `require(</span><span class="s3">\&quot;</span><span class="s1">something</span><span class="s3">\&quot;</span><span class="s1">)` call.</span><span class="s3">\n    </span><span class="s1">let instantiationReason: string</span><span class="s3">\n    </span><span class="s1">switch (sourceType) {</span><span class="s3">\n      </span><span class="s1">case SourceType.Runtime:</span><span class="s3">\n        </span><span class="s1">instantiationReason = `as a runtime entry of chunk ${sourceData}`</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case SourceType.Parent:</span><span class="s3">\n        </span><span class="s1">instantiationReason = `because it was required from module ${sourceData}`</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">invariant(</span><span class="s3">\n          </span><span class="s1">sourceType,</span><span class="s3">\n          </span><span class="s1">(sourceType) =&gt; `Unknown source type: ${sourceType}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Module ${id} was instantiated ${instantiationReason}, but the module factory is not available.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const module: Module = createModuleObject(id)</span><span class="s3">\n  </span><span class="s1">const exports = module.exports</span><span class="s3">\n  </span><span class="s1">moduleCache[id] = module</span><span class="s3">\n\n  </span><span class="s1">const context = new (Context as any as ContextConstructor&lt;Module&gt;)(</span><span class="s3">\n    </span><span class="s1">module,</span><span class="s3">\n    </span><span class="s1">exports</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">// NOTE(alexkirsz) This can fail when the module encounters a runtime error.</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">moduleFactory(context, module, exports)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">module.error = error as any</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">module.loaded = true</span><span class="s3">\n  </span><span class="s1">if (module.namespaceObject &amp;&amp; module.exports !== module.namespaceObject) {</span><span class="s3">\n    </span><span class="s1">// in case of a circular dependency: cjs1 -&gt; esm2 -&gt; cjs1</span><span class="s3">\n    </span><span class="s1">interopEsm(module.exports, module.namespaceObject)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return module</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Retrieves a module from the cache, or instantiate it if it is not cached.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// @ts-ignore</span><span class="s3">\n</span><span class="s1">function getOrInstantiateModuleFromParent(</span><span class="s3">\n  </span><span class="s1">id: ModuleId,</span><span class="s3">\n  </span><span class="s1">sourceModule: Module</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">const module = moduleCache[id]</span><span class="s3">\n\n  </span><span class="s1">if (module) {</span><span class="s3">\n    </span><span class="s1">if (module.error) {</span><span class="s3">\n      </span><span class="s1">throw module.error</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return module</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return instantiateModule(id, SourceType.Parent, sourceModule.id)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Instantiates a runtime module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function instantiateRuntimeModule(</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">return instantiateModule(moduleId, SourceType.Runtime, chunkPath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// @ts-ignore TypeScript doesn't separate this module space from the browser runtime</span><span class="s3">\n</span><span class="s1">function getOrInstantiateRuntimeModule(</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">const module = moduleCache[moduleId]</span><span class="s3">\n  </span><span class="s1">if (module) {</span><span class="s3">\n    </span><span class="s1">if (module.error) {</span><span class="s3">\n      </span><span class="s1">throw module.error</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return module</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return instantiateRuntimeModule(chunkPath, moduleId)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const regexJsUrl = /</span><span class="s3">\\</span><span class="s1">.js(?:</span><span class="s3">\\</span><span class="s1">?[^#]*)?(?:#.*)?$/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {</span><span class="s3">\n  </span><span class="s1">return regexJsUrl.test(chunkUrlOrPath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = (sourcePath: ChunkPath) =&gt; ({</span><span class="s3">\n  </span><span class="s1">m: (id: ModuleId) =&gt; getOrInstantiateRuntimeModule(sourcePath, id),</span><span class="s3">\n  </span><span class="s1">c: (chunkData: ChunkData) =&gt; loadRuntimeChunk(sourcePath, chunkData),</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}}]</span>
<span class="s0">}</span></pre>
</body>
</html>