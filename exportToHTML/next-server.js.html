<html>
<head>
<title>next-server.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-server.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;default&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">NextNodeServer;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; __export(require(</span><span class="s0">&quot;./base-server&quot;</span><span class="s1">));</span>
<span class="s1">require(</span><span class="s0">&quot;./node-environment&quot;</span><span class="s1">);</span>
<span class="s1">require(</span><span class="s0">&quot;./require-hook&quot;</span><span class="s1">);</span>
<span class="s1">require(</span><span class="s0">&quot;./node-polyfill-crypto&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../shared/lib/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fs = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_path = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routematcher = require(</span><span class="s0">&quot;../shared/lib/router/utils/route-matcher&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_requestmeta = require(</span><span class="s0">&quot;./request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_findpagesdir = require(</span><span class="s0">&quot;../lib/find-pages-dir&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_node = require(</span><span class="s0">&quot;./base-http/node&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_sendpayload = require(</span><span class="s0">&quot;./send-payload&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parseurl = require(</span><span class="s0">&quot;../shared/lib/router/utils/parse-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../build/output/log&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_baseserver = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(_export_star(require(</span><span class="s0">&quot;./base-server&quot;</span><span class="s1">), exports));</span>
<span class="s2">const </span><span class="s1">_require = require(</span><span class="s0">&quot;./require&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_denormalizepagepath = require(</span><span class="s0">&quot;../shared/lib/page-path/denormalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepagepath = require(</span><span class="s0">&quot;../shared/lib/page-path/normalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_loadcomponents = require(</span><span class="s0">&quot;./load-components&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_iserror = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../lib/is-error&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;./web/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_middlewareroutematcher = require(</span><span class="s0">&quot;../shared/lib/router/utils/middleware-route-matcher&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_env = require(</span><span class="s0">&quot;@next/env&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_querystring = require(</span><span class="s0">&quot;../shared/lib/router/utils/querystring&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removetrailingslash = require(</span><span class="s0">&quot;../shared/lib/router/utils/remove-trailing-slash&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getnextpathnameinfo = require(</span><span class="s0">&quot;../shared/lib/router/utils/get-next-pathname-info&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_bodystreams = require(</span><span class="s0">&quot;./body-streams&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apiutils = require(</span><span class="s0">&quot;./api-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_responsecache = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;./response-cache&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_incrementalcache = require(</span><span class="s0">&quot;./lib/incremental-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_setuphttpagentenv = require(</span><span class="s0">&quot;./setup-http-agent-env&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pagesapiroutematch = require(</span><span class="s0">&quot;./route-matches/pages-api-route-match&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_tracer = require(</span><span class="s0">&quot;./lib/trace/tracer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;./lib/trace/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nodefsmethods = require(</span><span class="s0">&quot;./lib/node-fs-methods&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routeregex = require(</span><span class="s0">&quot;../shared/lib/router/utils/route-regex&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pipereadable = require(</span><span class="s0">&quot;./pipe-readable&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_mockrequest = require(</span><span class="s0">&quot;./lib/mock-request&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterheaders = require(</span><span class="s0">&quot;../client/components/app-router-headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nextrequest = require(</span><span class="s0">&quot;./web/spec-extension/adapters/next-request&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_loadmanifestexternal = require(</span><span class="s0">&quot;./load-manifest.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_modulerender = require(</span><span class="s0">&quot;./route-modules/app-page/module.render&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_modulerender1 = require(</span><span class="s0">&quot;./route-modules/pages/module.render&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_interopdefault = require(</span><span class="s0">&quot;../lib/interop-default&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_formatdynamicimportpath = require(</span><span class="s0">&quot;../lib/format-dynamic-import-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_generateinterceptionroutesrewrites = require(</span><span class="s0">&quot;../lib/generate-interception-routes-rewrites&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routekind = require(</span><span class="s0">&quot;./route-kind&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_awaiter = require(</span><span class="s0">&quot;./after/awaiter&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_asynccallbackset = require(</span><span class="s0">&quot;./lib/async-callback-set&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_handlers = require(</span><span class="s0">&quot;./use-cache/handlers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_staticenv = require(</span><span class="s0">&quot;../lib/static-env&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ispostpone = require(</span><span class="s0">&quot;./lib/router-utils/is-postpone&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nodemoduleloader = require(</span><span class="s0">&quot;./lib/module-loader/node-module-loader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nofallbackerrorexternal = require(</span><span class="s0">&quot;../shared/lib/no-fallback-error.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_instrumentationglobalsexternal = require(</span><span class="s0">&quot;./lib/router-utils/instrumentation-globals.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerservercontext = require(</span><span class="s0">&quot;./lib/router-utils/router-server-context&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_export_star(from, to) {</span>
    <span class="s1">Object.keys(from).forEach(</span><span class="s2">function</span><span class="s1">(k) {</span>
        <span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; !Object.prototype.hasOwnProperty.call(to, k)) {</span>
            <span class="s1">Object.defineProperty(to, k, {</span>
                <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
                    <span class="s2">return </span><span class="s1">from[k];</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">from;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s4">// For module that can be both CJS or ESM</span>
<span class="s2">const </span><span class="s1">dynamicImportEsmDefault = process.env.NEXT_MINIMAL ? (id)=&gt;</span><span class="s2">import</span><span class="s1">(</span><span class="s4">/* webpackIgnore: true */ </span><span class="s1">id).then((mod)=&gt;mod.default || mod) : (id)=&gt;</span><span class="s2">import</span><span class="s1">(id).then((mod)=&gt;mod.default || mod);</span>
<span class="s2">const </span><span class="s1">MiddlewareMatcherCache = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s2">function </span><span class="s1">getMiddlewareMatcher(info) {</span>
    <span class="s2">const </span><span class="s1">stored = MiddlewareMatcherCache.get(info);</span>
    <span class="s2">if </span><span class="s1">(stored) {</span>
        <span class="s2">return </span><span class="s1">stored;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!Array.isArray(info.matchers)) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invariant: invalid matchers for middleware </span><span class="s1">${JSON.stringify(info)}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E257&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">matcher = (</span><span class="s3">0</span><span class="s1">, _middlewareroutematcher.getMiddlewareRouteMatcher)(info.matchers);</span>
    <span class="s1">MiddlewareMatcherCache.set(info, matcher);</span>
    <span class="s2">return </span><span class="s1">matcher;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">installProcessErrorHandlers(shouldRemoveUncaughtErrorAndRejectionListeners) {</span>
    <span class="s4">// The conventional wisdom of Node.js and other runtimes is to treat</span>
    <span class="s4">// unhandled errors as fatal and exit the process.</span>
    <span class="s4">//</span>
    <span class="s4">// But Next.js is not a generic JS runtime â€” it's a specialized runtime for</span>
    <span class="s4">// React Server Components.</span>
    <span class="s4">//</span>
    <span class="s4">// Many unhandled rejections are due to the late-awaiting pattern for</span>
    <span class="s4">// prefetching data. In Next.js it's OK to call an async function without</span>
    <span class="s4">// immediately awaiting it, to start the request as soon as possible</span>
    <span class="s4">// without blocking unncessarily on the result. These can end up</span>
    <span class="s4">// triggering an &quot;unhandledRejection&quot; if it later turns out that the</span>
    <span class="s4">// data is not needed to render the page. Example:</span>
    <span class="s4">//</span>
    <span class="s4">//     const promise = fetchData()</span>
    <span class="s4">//     const shouldShow = await checkCondition()</span>
    <span class="s4">//     if (shouldShow) {</span>
    <span class="s4">//       return &lt;Component promise={promise} /&gt;</span>
    <span class="s4">//     }</span>
    <span class="s4">//</span>
    <span class="s4">// In this example, `fetchData` is called immediately to start the request</span>
    <span class="s4">// as soon as possible, but if `shouldShow` is false, then it will be</span>
    <span class="s4">// discarded without unwrapping its result. If it errors, it will trigger</span>
    <span class="s4">// an &quot;unhandledRejection&quot; event.</span>
    <span class="s4">//</span>
    <span class="s4">// Ideally, we would suppress these rejections completely without warning,</span>
    <span class="s4">// because we don't consider them real errors. (TODO: Currently we do warn.)</span>
    <span class="s4">//</span>
    <span class="s4">// But regardless of whether we do or don't warn, we definitely shouldn't</span>
    <span class="s4">// crash the entire process.</span>
    <span class="s4">//</span>
    <span class="s4">// Even a &quot;legit&quot; unhandled error unrelated to prefetching shouldn't</span>
    <span class="s4">// prevent the rest of the page from rendering.</span>
    <span class="s4">//</span>
    <span class="s4">// So, we're going to intentionally override the default error handling</span>
    <span class="s4">// behavior of the outer JS runtime to be more forgiving</span>
    <span class="s4">// Remove any existing &quot;unhandledRejection&quot; and &quot;uncaughtException&quot; handlers.</span>
    <span class="s4">// This is gated behind an experimental flag until we've considered the impact</span>
    <span class="s4">// in various deployment environments. It's possible this may always need to</span>
    <span class="s4">// be configurable.</span>
    <span class="s2">if </span><span class="s1">(shouldRemoveUncaughtErrorAndRejectionListeners) {</span>
        <span class="s1">process.removeAllListeners(</span><span class="s0">'uncaughtException'</span><span class="s1">);</span>
        <span class="s1">process.removeAllListeners(</span><span class="s0">'unhandledRejection'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">// Install a new handler to prevent the process from crashing.</span>
    <span class="s1">process.on(</span><span class="s0">'unhandledRejection'</span><span class="s1">, (reason)=&gt;{</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _ispostpone.isPostpone)(reason)) {</span>
            <span class="s4">// React postpones that are unhandled might end up logged here but they're</span>
            <span class="s4">// not really errors. They're just part of rendering.</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// Immediately log the error.</span>
        <span class="s4">// TODO: Ideally, if we knew that this error was triggered by application</span>
        <span class="s4">// code, we would suppress it entirely without logging. We can't reliably</span>
        <span class="s4">// detect all of these, but when cacheComponents is enabled, we could suppress</span>
        <span class="s4">// at least some of them by waiting to log the error until after all in-</span>
        <span class="s4">// progress renders have completed. Then, only log errors for which there</span>
        <span class="s4">// was not a corresponding &quot;rejectionHandled&quot; event.</span>
        <span class="s1">console.error(reason);</span>
    <span class="s1">});</span>
    <span class="s1">process.on(</span><span class="s0">'rejectionHandled'</span><span class="s1">, ()=&gt;{</span>
    <span class="s4">// TODO: See note in the unhandledRejection handler above. In the future,</span>
    <span class="s4">// we may use the &quot;rejectionHandled&quot; event to de-queue an error from</span>
    <span class="s4">// being logged.</span>
    <span class="s1">});</span>
    <span class="s4">// Unhandled exceptions are errors triggered by non-async functions, so this</span>
    <span class="s4">// is unrelated to the late-awaiting pattern. However, for similar reasons,</span>
    <span class="s4">// we still shouldn't crash the process. Just log it.</span>
    <span class="s1">process.on(</span><span class="s0">'uncaughtException'</span><span class="s1">, (reason)=&gt;{</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _ispostpone.isPostpone)(reason)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">console.error(reason);</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">NextNodeServer </span><span class="s2">extends </span><span class="s1">_baseserver.default {</span>
    <span class="s1">constructor(options){</span>
        <span class="s2">var </span><span class="s1">_options_conf_experimental_sri, _options_conf_experimental, _options_conf_experimental1;</span>
        <span class="s4">// Initialize super class</span>
        <span class="s2">super</span><span class="s1">(options), </span><span class="s2">this</span><span class="s1">.cleanupListeners = </span><span class="s2">new </span><span class="s1">_asynccallbackset.AsyncCallbackSet(), </span><span class="s2">this</span><span class="s1">.handleNextImageRequest = async (req, res, parsedUrl)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(!parsedUrl.pathname || !parsedUrl.pathname.startsWith(</span><span class="s0">'/_next/image'</span><span class="s1">)) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Ignore if its a middleware request</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'middlewareInvoke'</span><span class="s1">)) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.minimalMode || </span><span class="s2">this</span><span class="s1">.nextConfig.output === </span><span class="s0">'export' </span><span class="s1">|| process.env.NEXT_MINIMAL) {</span>
                <span class="s1">res.statusCode = </span><span class="s3">400</span><span class="s1">;</span>
                <span class="s1">res.body(</span><span class="s0">'Bad Request'</span><span class="s1">).send();</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s4">// the `else` branch is needed for tree-shaking</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">{ ImageOptimizerCache } = require(</span><span class="s0">'./image-optimizer'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">imageOptimizerCache = </span><span class="s2">new </span><span class="s1">ImageOptimizerCache({</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">nextConfig: </span><span class="s2">this</span><span class="s1">.nextConfig</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">{ sendResponse, ImageError } = require(</span><span class="s0">'./image-optimizer'</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.imageResponseCache) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant image optimizer cache was not initialized'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E160&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">imagesConfig = </span><span class="s2">this</span><span class="s1">.nextConfig.images;</span>
                <span class="s2">if </span><span class="s1">(imagesConfig.loader !== </span><span class="s0">'default' </span><span class="s1">|| imagesConfig.unoptimized) {</span>
                    <span class="s2">await this</span><span class="s1">.render404(req, res);</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">paramsResult = ImageOptimizerCache.validateParams(req.originalRequest, parsedUrl.query, </span><span class="s2">this</span><span class="s1">.nextConfig, !!</span><span class="s2">this</span><span class="s1">.renderOpts.dev);</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s0">'errorMessage' </span><span class="s2">in </span><span class="s1">paramsResult) {</span>
                    <span class="s1">res.statusCode = </span><span class="s3">400</span><span class="s1">;</span>
                    <span class="s1">res.body(paramsResult.errorMessage).send();</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">cacheKey = ImageOptimizerCache.getCacheKey(paramsResult);</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">var </span><span class="s1">_cacheEntry_value, _cacheEntry_cacheControl;</span>
                    <span class="s2">const </span><span class="s1">{ getExtension } = require(</span><span class="s0">'./serve-static'</span><span class="s1">);</span>
                    <span class="s2">const </span><span class="s1">cacheEntry = </span><span class="s2">await this</span><span class="s1">.imageResponseCache.get(cacheKey, async ({ previousCacheEntry })=&gt;{</span>
                        <span class="s2">const </span><span class="s1">{ buffer, contentType, maxAge, upstreamEtag, etag } = </span><span class="s2">await this</span><span class="s1">.imageOptimizer(req, res, paramsResult, previousCacheEntry);</span>
                        <span class="s2">return </span><span class="s1">{</span>
                            <span class="s1">value: {</span>
                                <span class="s1">kind: _responsecache.CachedRouteKind.IMAGE,</span>
                                <span class="s1">buffer,</span>
                                <span class="s1">etag,</span>
                                <span class="s1">extension: getExtension(contentType),</span>
                                <span class="s1">upstreamEtag</span>
                            <span class="s1">},</span>
                            <span class="s1">cacheControl: {</span>
                                <span class="s1">revalidate: maxAge,</span>
                                <span class="s1">expire: undefined</span>
                            <span class="s1">}</span>
                        <span class="s1">};</span>
                    <span class="s1">}, {</span>
                        <span class="s1">routeKind: _routekind.RouteKind.IMAGE,</span>
                        <span class="s1">incrementalCache: imageOptimizerCache,</span>
                        <span class="s1">isFallback: </span><span class="s2">false</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">((cacheEntry == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_cacheEntry_value = cacheEntry.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _cacheEntry_value.kind) !== _responsecache.CachedRouteKind.IMAGE) {</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant did not get entry from image response cache'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E518&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s1">sendResponse(req.originalRequest, res.originalResponse, paramsResult.href, cacheEntry.value.extension, cacheEntry.value.buffer, cacheEntry.value.etag, paramsResult.isStatic, cacheEntry.isMiss ? </span><span class="s0">'MISS' </span><span class="s1">: cacheEntry.isStale ? </span><span class="s0">'STALE' </span><span class="s1">: </span><span class="s0">'HIT'</span><span class="s1">, imagesConfig, ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _cacheEntry_cacheControl.revalidate) || </span><span class="s3">0</span><span class="s1">, Boolean(</span><span class="s2">this</span><span class="s1">.renderOpts.dev));</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                    <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">ImageError) {</span>
                        <span class="s1">res.statusCode = err.statusCode;</span>
                        <span class="s1">res.body(err.message).send();</span>
                        <span class="s2">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}, </span><span class="s2">this</span><span class="s1">.handleCatchallRenderRequest = async (req, res, parsedUrl)=&gt;{</span>
            <span class="s2">let </span><span class="s1">{ pathname, query } = parsedUrl;</span>
            <span class="s2">if </span><span class="s1">(!pathname) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: pathname is undefined'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E409&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// When in minimal mode we do not bubble the fallback as the</span>
            <span class="s4">// router-server is not present to handle the error</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'bubbleNoFallback'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.minimalMode ? undefined : </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s4">// This is needed to expose render404 and nextConfig</span>
            <span class="s4">// for environments without router-server</span>
            <span class="s2">if </span><span class="s1">(!_routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol]) {</span>
                <span class="s1">_routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol] = {};</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">relativeProjectDir = (</span><span class="s3">0</span><span class="s1">, _path.relative)(process.cwd(), </span><span class="s2">this</span><span class="s1">.dir);</span>
            <span class="s2">const </span><span class="s1">existingServerContext = _routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol][relativeProjectDir];</span>
            <span class="s2">if </span><span class="s1">(!existingServerContext) {</span>
                <span class="s1">_routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol][relativeProjectDir] = {</span>
                    <span class="s1">render404: </span><span class="s2">this</span><span class="s1">.render404.bind(</span><span class="s2">this</span><span class="s1">)</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s1">_routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol][relativeProjectDir].nextConfig = </span><span class="s2">this</span><span class="s1">.nextConfig;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">var </span><span class="s1">_this_i18nProvider;</span>
                <span class="s4">// next.js core assumes page path without trailing slash</span>
                <span class="s1">pathname = (</span><span class="s3">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(pathname);</span>
                <span class="s2">const </span><span class="s1">options = {</span>
                    <span class="s1">i18n: (_this_i18nProvider = </span><span class="s2">this</span><span class="s1">.i18nProvider) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_i18nProvider.fromRequest(req, pathname)</span>
                <span class="s1">};</span>
                <span class="s2">const </span><span class="s1">match = </span><span class="s2">await this</span><span class="s1">.matchers.match(pathname, options);</span>
                <span class="s4">// If we don't have a match, try to render it anyways.</span>
                <span class="s2">if </span><span class="s1">(!match) {</span>
                    <span class="s2">await this</span><span class="s1">.render(req, res, pathname, query, parsedUrl, </span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// Add the match to the request so we don't have to re-run the matcher</span>
                <span class="s4">// for the same request.</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'match'</span><span class="s1">, match);</span>
                <span class="s4">// TODO-APP: move this to a route handler</span>
                <span class="s2">const </span><span class="s1">edgeFunctionsPages = </span><span class="s2">this</span><span class="s1">.getEdgeFunctionsPages();</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">edgeFunctionsPage of edgeFunctionsPages){</span>
                    <span class="s4">// If the page doesn't match the edge function page, skip it.</span>
                    <span class="s2">if </span><span class="s1">(edgeFunctionsPage !== match.definition.page) </span><span class="s2">continue</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.nextConfig.output === </span><span class="s0">'export'</span><span class="s1">) {</span>
                        <span class="s2">await this</span><span class="s1">.render404(req, res, parsedUrl);</span>
                        <span class="s2">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">delete </span><span class="s1">query[_approuterheaders.NEXT_RSC_UNION_QUERY];</span>
                    <span class="s4">// If we handled the request, we can return early.</span>
                    <span class="s4">// For api routes edge runtime</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">handled = </span><span class="s2">await this</span><span class="s1">.runEdgeFunction({</span>
                            <span class="s1">req,</span>
                            <span class="s1">res,</span>
                            <span class="s1">query,</span>
                            <span class="s1">params: match.params,</span>
                            <span class="s1">page: match.definition.page,</span>
                            <span class="s1">match,</span>
                            <span class="s1">appPaths: </span><span class="s2">null</span>
                        <span class="s1">});</span>
                        <span class="s2">if </span><span class="s1">(handled) </span><span class="s2">return true</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(apiError) {</span>
                        <span class="s2">await this</span><span class="s1">.instrumentationOnRequestError(apiError, req, {</span>
                            <span class="s1">routePath: match.definition.page,</span>
                            <span class="s1">routerKind: </span><span class="s0">'Pages Router'</span><span class="s1">,</span>
                            <span class="s1">routeType: </span><span class="s0">'route'</span><span class="s1">,</span>
                            <span class="s4">// Edge runtime does not support ISR</span>
                            <span class="s1">revalidateReason: undefined</span>
                        <span class="s1">});</span>
                        <span class="s2">throw </span><span class="s1">apiError;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">// If the route was detected as being a Pages API route, then handle</span>
                <span class="s4">// it.</span>
                <span class="s4">// TODO: move this behavior into a route handler.</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _pagesapiroutematch.isPagesAPIRouteMatch)(match)) {</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.nextConfig.output === </span><span class="s0">'export'</span><span class="s1">) {</span>
                        <span class="s2">await this</span><span class="s1">.render404(req, res, parsedUrl);</span>
                        <span class="s2">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">handled = </span><span class="s2">await this</span><span class="s1">.handleApiRequest(req, res, query, match);</span>
                    <span class="s2">if </span><span class="s1">(handled) </span><span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">await this</span><span class="s1">.render(req, res, pathname, query, parsedUrl, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_nofallbackerrorexternal.NoFallbackError) {</span>
                    <span class="s2">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderOpts.dev) {</span>
                        <span class="s2">const </span><span class="s1">{ formatServerError } = require(</span><span class="s0">'../lib/format-server-error'</span><span class="s1">);</span>
                        <span class="s1">formatServerError(err);</span>
                        <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(err);</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">this</span><span class="s1">.logError(err);</span>
                    <span class="s1">}</span>
                    <span class="s1">res.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
                    <span class="s2">await this</span><span class="s1">.renderError(err, req, res, pathname, query);</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{}</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">}, </span><span class="s2">this</span><span class="s1">.handleCatchallMiddlewareRequest = async (req, res, parsed)=&gt;{</span>
            <span class="s2">const </span><span class="s1">isMiddlewareInvoke = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'middlewareInvoke'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(!isMiddlewareInvoke) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">handleFinished = ()=&gt;{</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'middlewareInvoke'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">res.body(</span><span class="s0">''</span><span class="s1">).send();</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">middleware = </span><span class="s2">await this</span><span class="s1">.getMiddleware();</span>
            <span class="s2">if </span><span class="s1">(!middleware) {</span>
                <span class="s2">return </span><span class="s1">handleFinished();</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">initUrl = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'initURL'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">parsedUrl = (</span><span class="s3">0</span><span class="s1">, _parseurl.parseUrl)(initUrl);</span>
            <span class="s2">const </span><span class="s1">pathnameInfo = (</span><span class="s3">0</span><span class="s1">, _getnextpathnameinfo.getNextPathnameInfo)(parsedUrl.pathname, {</span>
                <span class="s1">nextConfig: </span><span class="s2">this</span><span class="s1">.nextConfig,</span>
                <span class="s1">i18nProvider: </span><span class="s2">this</span><span class="s1">.i18nProvider</span>
            <span class="s1">});</span>
            <span class="s1">parsedUrl.pathname = pathnameInfo.pathname;</span>
            <span class="s2">const </span><span class="s1">normalizedPathname = (</span><span class="s3">0</span><span class="s1">, _removetrailingslash.removeTrailingSlash)(parsed.pathname || </span><span class="s0">''</span><span class="s1">);</span>
            <span class="s2">let </span><span class="s1">maybeDecodedPathname = normalizedPathname;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">maybeDecodedPathname = decodeURIComponent(normalizedPathname);</span>
            <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
            <span class="s4">/* non-fatal we can't decode so can't match it */ </span><span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!(middleware.match(normalizedPathname, req, parsedUrl.query) || middleware.match(maybeDecodedPathname, req, parsedUrl.query))) {</span>
                <span class="s2">return </span><span class="s1">handleFinished();</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">result;</span>
            <span class="s2">let </span><span class="s1">bubblingResult = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">await this</span><span class="s1">.ensureMiddleware(req.url);</span>
                <span class="s1">result = </span><span class="s2">await this</span><span class="s1">.runMiddleware({</span>
                    <span class="s1">request: req,</span>
                    <span class="s1">response: res,</span>
                    <span class="s1">parsedUrl: parsedUrl,</span>
                    <span class="s1">parsed: parsed</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s0">'response' </span><span class="s2">in </span><span class="s1">result) {</span>
                    <span class="s2">if </span><span class="s1">(isMiddlewareInvoke) {</span>
                        <span class="s1">bubblingResult = </span><span class="s2">true</span><span class="s1">;</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_tracer.BubbledError(</span><span class="s2">true</span><span class="s1">, result), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries((</span><span class="s3">0</span><span class="s1">, _utils1.toNodeOutgoingHttpHeaders)(result.response.headers))){</span>
                        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">'content-encoding' </span><span class="s1">&amp;&amp; value !== undefined) {</span>
                            <span class="s1">res.setHeader(key, value);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">res.statusCode = result.response.status;</span>
                    <span class="s2">const </span><span class="s1">{ originalResponse } = res;</span>
                    <span class="s2">if </span><span class="s1">(result.response.body) {</span>
                        <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _pipereadable.pipeToNodeResponse)(result.response.body, originalResponse);</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">originalResponse.end();</span>
                    <span class="s1">}</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">if </span><span class="s1">(bubblingResult) {</span>
                    <span class="s2">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _iserror.default)(err) &amp;&amp; err.code === </span><span class="s0">'ENOENT'</span><span class="s1">) {</span>
                    <span class="s2">await this</span><span class="s1">.render404(req, res, parsed);</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">_utils.DecodeError) {</span>
                    <span class="s1">res.statusCode = </span><span class="s3">400</span><span class="s1">;</span>
                    <span class="s2">await this</span><span class="s1">.renderError(err, req, res, parsed.pathname || </span><span class="s0">''</span><span class="s1">);</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">error = (</span><span class="s3">0</span><span class="s1">, _iserror.getProperError)(err);</span>
                <span class="s1">console.error(error);</span>
                <span class="s1">res.statusCode = </span><span class="s3">500</span><span class="s1">;</span>
                <span class="s2">await this</span><span class="s1">.renderError(error, req, res, parsed.pathname || </span><span class="s0">''</span><span class="s1">);</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">result.finished;</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">isDev = options.dev ?? </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.isDev = isDev;</span>
        <span class="s2">this</span><span class="s1">.sriEnabled = Boolean((_options_conf_experimental = options.conf.experimental) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_options_conf_experimental_sri = _options_conf_experimental.sri) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _options_conf_experimental_sri.algorithm);</span>
        <span class="s4">/**</span>
     <span class="s4">* This sets environment variable to be used at the time of SSR by head.tsx.</span>
     <span class="s4">* Using this from process.env allows targeting SSR by calling</span>
     <span class="s4">* `process.env.__NEXT_OPTIMIZE_CSS`.</span>
     <span class="s4">*/ </span><span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderOpts.optimizeCss) {</span>
            <span class="s1">process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(</span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderOpts.nextScriptWorkers) {</span>
            <span class="s1">process.env.__NEXT_SCRIPT_WORKERS = JSON.stringify(</span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">process.env.NEXT_DEPLOYMENT_ID = </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.useSkewCookie ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.nextConfig.deploymentId || </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.minimalMode) {</span>
            <span class="s2">this</span><span class="s1">.imageResponseCache = </span><span class="s2">new </span><span class="s1">_responsecache.default(</span><span class="s2">this</span><span class="s1">.minimalMode);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ appDocumentPreloading } = </span><span class="s2">this</span><span class="s1">.nextConfig.experimental;</span>
        <span class="s2">const </span><span class="s1">isDefaultEnabled = </span><span class="s2">typeof </span><span class="s1">appDocumentPreloading === </span><span class="s0">'undefined'</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!options.dev &amp;&amp; (appDocumentPreloading === </span><span class="s2">true </span><span class="s1">|| !(</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; isDefaultEnabled))) {</span>
            <span class="s4">// pre-warm _document and _app as these will be</span>
            <span class="s4">// needed for most requests</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadcomponents.loadComponents)({</span>
                <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                <span class="s1">page: </span><span class="s0">'/_document'</span><span class="s1">,</span>
                <span class="s1">isAppPath: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">isDev: </span><span class="s2">this</span><span class="s1">.isDev,</span>
                <span class="s1">sriEnabled: </span><span class="s2">this</span><span class="s1">.sriEnabled</span>
            <span class="s1">}).catch(()=&gt;{});</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadcomponents.loadComponents)({</span>
                <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                <span class="s1">page: </span><span class="s0">'/_app'</span><span class="s1">,</span>
                <span class="s1">isAppPath: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">isDev: </span><span class="s2">this</span><span class="s1">.isDev,</span>
                <span class="s1">sriEnabled: </span><span class="s2">this</span><span class="s1">.sriEnabled</span>
            <span class="s1">}).catch(()=&gt;{});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!options.dev &amp;&amp; !</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.preloadEntriesOnStart) {</span>
            <span class="s2">this</span><span class="s1">.unstable_preloadEntries();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!options.dev) {</span>
            <span class="s2">const </span><span class="s1">{ dynamicRoutes = [] } = </span><span class="s2">this</span><span class="s1">.getRoutesManifest() ?? {};</span>
            <span class="s2">this</span><span class="s1">.dynamicRoutes = dynamicRoutes.map((r)=&gt;{</span>
                <span class="s4">// TODO: can we just re-use the regex from the manifest?</span>
                <span class="s2">const </span><span class="s1">regex = (</span><span class="s3">0</span><span class="s1">, _routeregex.getRouteRegex)(r.page);</span>
                <span class="s2">const </span><span class="s1">match = (</span><span class="s3">0</span><span class="s1">, _routematcher.getRouteMatcher)(regex);</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">match,</span>
                    <span class="s1">page: r.page,</span>
                    <span class="s1">re: regex.re</span>
                <span class="s1">};</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">// ensure options are set when loadConfig isn't called</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _setuphttpagentenv.setHttpClientAndAgentOptions)(</span><span class="s2">this</span><span class="s1">.nextConfig);</span>
        <span class="s4">// Intercept fetch and other testmode apis.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.serverOptions.experimentalTestProxy) {</span>
            <span class="s1">process.env.NEXT_PRIVATE_TEST_PROXY = </span><span class="s0">'true'</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">{ interceptTestApis } = </span><span class="s4">// eslint-disable-next-line @next/internal/typechecked-require -- experimental/testmode is not built ins next/dist/esm</span>
            <span class="s1">require(</span><span class="s0">'next/dist/experimental/testmode/server'</span><span class="s1">);</span>
            <span class="s1">interceptTestApis();</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.middlewareManifestPath = (</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.serverDistDir, _constants.MIDDLEWARE_MANIFEST);</span>
        <span class="s4">// This is just optimization to fire prepare as soon as possible. It will be</span>
        <span class="s4">// properly awaited later. We add the catch here to ensure that it does not</span>
        <span class="s4">// cause a unhandled promise rejection. The promise rejection will be</span>
        <span class="s4">// handled later on via the `await` when the request handler is called.</span>
        <span class="s2">if </span><span class="s1">(!options.dev) {</span>
            <span class="s2">this</span><span class="s1">.prepare().catch((err)=&gt;{</span>
                <span class="s1">console.error(</span><span class="s0">'Failed to prepare server'</span><span class="s1">, err);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">// when using compile mode static env isn't inlined so we</span>
        <span class="s4">// need to populate in normal runtime env</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderOpts.isExperimentalCompile) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _staticenv.populateStaticEnv)(</span><span class="s2">this</span><span class="s1">.nextConfig);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">shouldRemoveUncaughtErrorAndRejectionListeners = Boolean((_options_conf_experimental1 = options.conf.experimental) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _options_conf_experimental1.removeUncaughtErrorAndRejectionListeners);</span>
        <span class="s1">installProcessErrorHandlers(shouldRemoveUncaughtErrorAndRejectionListeners);</span>
    <span class="s1">}</span>
    <span class="s1">async unstable_preloadEntries() {</span>
        <span class="s4">// Ensure prepare process will be finished before preloading entries.</span>
        <span class="s2">await this</span><span class="s1">.prepare();</span>
        <span class="s2">const </span><span class="s1">appPathsManifest = </span><span class="s2">this</span><span class="s1">.getAppPathsManifest();</span>
        <span class="s2">const </span><span class="s1">pagesManifest = </span><span class="s2">this</span><span class="s1">.getPagesManifest();</span>
        <span class="s2">await this</span><span class="s1">.loadCustomCacheHandlers();</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">page of Object.keys(pagesManifest || {})){</span>
            <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadcomponents.loadComponents)({</span>
                <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                <span class="s1">page,</span>
                <span class="s1">isAppPath: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">isDev: </span><span class="s2">this</span><span class="s1">.isDev,</span>
                <span class="s1">sriEnabled: </span><span class="s2">this</span><span class="s1">.sriEnabled</span>
            <span class="s1">}).catch(()=&gt;{});</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">page of Object.keys(appPathsManifest || {})){</span>
            <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadcomponents.loadComponents)({</span>
                <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                <span class="s1">page,</span>
                <span class="s1">isAppPath: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">isDev: </span><span class="s2">this</span><span class="s1">.isDev,</span>
                <span class="s1">sriEnabled: </span><span class="s2">this</span><span class="s1">.sriEnabled</span>
            <span class="s1">}).then(async ({ ComponentMod })=&gt;{</span>
                <span class="s4">// we need to ensure fetch is patched before we require the page,</span>
                <span class="s4">// otherwise if the fetch is patched by user code, we will be patching it</span>
                <span class="s4">// too late and there won't be any caching behaviors</span>
                <span class="s1">ComponentMod.patchFetch();</span>
                <span class="s2">const </span><span class="s1">webpackRequire = ComponentMod.__next_app__.require;</span>
                <span class="s2">if </span><span class="s1">(webpackRequire == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: webpackRequire.m) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">id of Object.keys(webpackRequire.m)){</span>
                        <span class="s2">await </span><span class="s1">webpackRequire(id);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}).catch(()=&gt;{});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async handleUpgrade() {</span>
    <span class="s4">// The web server does not support web sockets, it's only used for HMR in</span>
    <span class="s4">// development.</span>
    <span class="s1">}</span>
    <span class="s1">async loadInstrumentationModule() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.serverOptions.dev) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.instrumentation = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _instrumentationglobalsexternal.getInstrumentationModule)(</span><span class="s2">this</span><span class="s1">.dir, </span><span class="s2">this</span><span class="s1">.nextConfig.distDir);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">if </span><span class="s1">(err.code !== </span><span class="s0">'MODULE_NOT_FOUND'</span><span class="s1">) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'An error occurred while loading the instrumentation hook'</span><span class="s1">, {</span>
                        <span class="s1">cause: err</span>
                    <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E92&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.instrumentation;</span>
    <span class="s1">}</span>
    <span class="s1">async prepareImpl() {</span>
        <span class="s2">await super</span><span class="s1">.prepareImpl();</span>
        <span class="s2">await this</span><span class="s1">.runInstrumentationHookIfAvailable();</span>
    <span class="s1">}</span>
    <span class="s1">async runInstrumentationHookIfAvailable() {</span>
        <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _instrumentationglobalsexternal.ensureInstrumentationRegistered)(</span><span class="s2">this</span><span class="s1">.dir, </span><span class="s2">this</span><span class="s1">.nextConfig.distDir);</span>
    <span class="s1">}</span>
    <span class="s1">loadEnvConfig({ dev, forceReload, silent }) {</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _env.loadEnvConfig)(</span><span class="s2">this</span><span class="s1">.dir, dev, silent ? {</span>
            <span class="s1">info: ()=&gt;{},</span>
            <span class="s1">error: ()=&gt;{}</span>
        <span class="s1">} : _log, forceReload);</span>
    <span class="s1">}</span>
    <span class="s1">async loadCustomCacheHandlers() {</span>
        <span class="s2">const </span><span class="s1">{ cacheHandlers } = </span><span class="s2">this</span><span class="s1">.nextConfig.experimental;</span>
        <span class="s2">if </span><span class="s1">(!cacheHandlers) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s4">// If we've already initialized the cache handlers interface, don't do it</span>
        <span class="s4">// again.</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _handlers.initializeCacheHandlers)()) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[kind, handler] of Object.entries(cacheHandlers)){</span>
            <span class="s2">if </span><span class="s1">(!handler) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlers.setCacheHandler)(kind, (</span><span class="s3">0</span><span class="s1">, _interopdefault.interopDefault)(</span><span class="s2">await </span><span class="s1">dynamicImportEsmDefault((</span><span class="s3">0</span><span class="s1">, _formatdynamicimportpath.formatDynamicImportPath)(</span><span class="s2">this</span><span class="s1">.distDir, handler))));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async getIncrementalCache({ requestHeaders }) {</span>
        <span class="s2">const </span><span class="s1">dev = !!</span><span class="s2">this</span><span class="s1">.renderOpts.dev;</span>
        <span class="s2">let </span><span class="s1">CacheHandler;</span>
        <span class="s2">const </span><span class="s1">{ cacheHandler } = </span><span class="s2">this</span><span class="s1">.nextConfig;</span>
        <span class="s2">if </span><span class="s1">(cacheHandler) {</span>
            <span class="s1">CacheHandler = (</span><span class="s3">0</span><span class="s1">, _interopdefault.interopDefault)(</span><span class="s2">await </span><span class="s1">dynamicImportEsmDefault((</span><span class="s3">0</span><span class="s1">, _formatdynamicimportpath.formatDynamicImportPath)(</span><span class="s2">this</span><span class="s1">.distDir, cacheHandler)));</span>
        <span class="s1">}</span>
        <span class="s2">await this</span><span class="s1">.loadCustomCacheHandlers();</span>
        <span class="s4">// incremental-cache is request specific</span>
        <span class="s4">// although can have shared caches in module scope</span>
        <span class="s4">// per-cache handler</span>
        <span class="s2">return new </span><span class="s1">_incrementalcache.IncrementalCache({</span>
            <span class="s1">fs: </span><span class="s2">this</span><span class="s1">.getCacheFilesystem(),</span>
            <span class="s1">dev,</span>
            <span class="s1">requestHeaders,</span>
            <span class="s1">allowedRevalidateHeaderKeys: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.allowedRevalidateHeaderKeys,</span>
            <span class="s1">minimalMode: </span><span class="s2">this</span><span class="s1">.minimalMode,</span>
            <span class="s1">serverDistDir: </span><span class="s2">this</span><span class="s1">.serverDistDir,</span>
            <span class="s1">fetchCacheKeyPrefix: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.fetchCacheKeyPrefix,</span>
            <span class="s1">maxMemoryCacheSize: </span><span class="s2">this</span><span class="s1">.nextConfig.cacheMaxMemorySize,</span>
            <span class="s1">flushToDisk: !</span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.isrFlushToDisk,</span>
            <span class="s1">getPrerenderManifest: ()=&gt;</span><span class="s2">this</span><span class="s1">.getPrerenderManifest(),</span>
            <span class="s1">CurCacheHandler: CacheHandler</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">getResponseCache() {</span>
        <span class="s2">return new </span><span class="s1">_responsecache.default(</span><span class="s2">this</span><span class="s1">.minimalMode);</span>
    <span class="s1">}</span>
    <span class="s1">getPublicDir() {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.dir, _constants.CLIENT_PUBLIC_FILES_PATH);</span>
    <span class="s1">}</span>
    <span class="s1">getHasStaticDir() {</span>
        <span class="s2">return </span><span class="s1">_fs.default.existsSync((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.dir, </span><span class="s0">'static'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s1">getPagesManifest() {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadmanifestexternal.loadManifest)((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.serverDistDir, _constants.PAGES_MANIFEST));</span>
    <span class="s1">}</span>
    <span class="s1">getAppPathsManifest() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.enabledDirectories.app) </span><span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadmanifestexternal.loadManifest)((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.serverDistDir, _constants.APP_PATHS_MANIFEST));</span>
    <span class="s1">}</span>
    <span class="s1">getinterceptionRoutePatterns() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.enabledDirectories.app) </span><span class="s2">return </span><span class="s1">[];</span>
        <span class="s2">const </span><span class="s1">routesManifest = </span><span class="s2">this</span><span class="s1">.getRoutesManifest();</span>
        <span class="s2">return </span><span class="s1">(routesManifest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: routesManifest.rewrites.beforeFiles.filter(_generateinterceptionroutesrewrites.isInterceptionRouteRewrite).map((rewrite)=&gt;</span><span class="s2">new </span><span class="s1">RegExp(rewrite.regex))) ?? [];</span>
    <span class="s1">}</span>
    <span class="s1">async hasPage(pathname) {</span>
        <span class="s2">var </span><span class="s1">_this_nextConfig_i18n;</span>
        <span class="s2">return </span><span class="s1">!!(</span><span class="s3">0</span><span class="s1">, _require.getMaybePagePath)(pathname, </span><span class="s2">this</span><span class="s1">.distDir, (_this_nextConfig_i18n = </span><span class="s2">this</span><span class="s1">.nextConfig.i18n) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this_nextConfig_i18n.locales, </span><span class="s2">this</span><span class="s1">.enabledDirectories.app);</span>
    <span class="s1">}</span>
    <span class="s1">getBuildId() {</span>
        <span class="s2">const </span><span class="s1">buildIdFile = (</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, _constants.BUILD_ID_FILE);</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s1">_fs.default.readFileSync(buildIdFile, </span><span class="s0">'utf8'</span><span class="s1">).trim();</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s2">if </span><span class="s1">(err.code === </span><span class="s0">'ENOENT'</span><span class="s1">) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Could not find a production build in the '</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.distDir}</span><span class="s0">' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E427&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getEnabledDirectories(dev) {</span>
        <span class="s2">const </span><span class="s1">dir = dev ? </span><span class="s2">this</span><span class="s1">.dir : </span><span class="s2">this</span><span class="s1">.serverDistDir;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">app: (</span><span class="s3">0</span><span class="s1">, _findpagesdir.findDir)(dir, </span><span class="s0">'app'</span><span class="s1">) ? </span><span class="s2">true </span><span class="s1">: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">pages: (</span><span class="s3">0</span><span class="s1">, _findpagesdir.findDir)(dir, </span><span class="s0">'pages'</span><span class="s1">) ? </span><span class="s2">true </span><span class="s1">: </span><span class="s2">false</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">sendRenderResult(req, res, options) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _sendpayload.sendRenderResult)({</span>
            <span class="s1">req: req.originalRequest,</span>
            <span class="s1">res: res.originalResponse,</span>
            <span class="s1">result: options.result,</span>
            <span class="s1">generateEtags: options.generateEtags,</span>
            <span class="s1">poweredByHeader: options.poweredByHeader,</span>
            <span class="s1">cacheControl: options.cacheControl</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async runApi(req, res, query, match) {</span>
        <span class="s2">const </span><span class="s1">edgeFunctionsPages = </span><span class="s2">this</span><span class="s1">.getEdgeFunctionsPages();</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">edgeFunctionsPage of edgeFunctionsPages){</span>
            <span class="s2">if </span><span class="s1">(edgeFunctionsPage === match.definition.pathname) {</span>
                <span class="s2">const </span><span class="s1">handledAsEdgeFunction = </span><span class="s2">await this</span><span class="s1">.runEdgeFunction({</span>
                    <span class="s1">req,</span>
                    <span class="s1">res,</span>
                    <span class="s1">query,</span>
                    <span class="s1">params: match.params,</span>
                    <span class="s1">page: match.definition.pathname,</span>
                    <span class="s1">appPaths: </span><span class="s2">null</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(handledAsEdgeFunction) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// The module supports minimal mode, load the minimal module.</span>
        <span class="s4">// Restore original URL as the handler handles it's own parsing</span>
        <span class="s2">const </span><span class="s1">parsedInitUrl = (</span><span class="s3">0</span><span class="s1">, _parseurl.parseUrl)((</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'initURL'</span><span class="s1">) || req.url);</span>
        <span class="s1">req.url = </span><span class="s0">`</span><span class="s1">${parsedInitUrl.pathname}${parsedInitUrl.search || </span><span class="s0">''</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">loader = </span><span class="s2">new </span><span class="s1">_nodemoduleloader.NodeModuleLoader();</span>
        <span class="s2">const </span><span class="s1">module = </span><span class="s2">await </span><span class="s1">loader.load(match.definition.filename);</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req.originalRequest, </span><span class="s0">'relativeProjectDir'</span><span class="s1">, (</span><span class="s3">0</span><span class="s1">, _path.relative)(process.cwd(), </span><span class="s2">this</span><span class="s1">.dir));</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req.originalRequest, </span><span class="s0">'distDir'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.distDir);</span>
        <span class="s2">await </span><span class="s1">module.handler(req.originalRequest, res.originalResponse, {</span>
            <span class="s1">waitUntil: </span><span class="s2">this</span><span class="s1">.getWaitUntil()</span>
        <span class="s1">});</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async renderHTML(req, res, pathname, query, renderOpts) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.NextNodeServerSpan.renderHTML, async ()=&gt;</span><span class="s2">this</span><span class="s1">.renderHTMLImpl(req, res, pathname, query, renderOpts));</span>
    <span class="s1">}</span>
    <span class="s1">async renderHTMLImpl(req, res, pathname, query, renderOpts) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_MINIMAL) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: renderHTML should not be called in minimal mode'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E472&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s4">// the `else` branch is needed for tree-shaking</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// Due to the way we pass data by mutating `renderOpts`, we can't extend the</span>
            <span class="s4">// object here but only updating its `nextFontManifest` field.</span>
            <span class="s4">// https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952</span>
            <span class="s1">renderOpts.nextFontManifest = </span><span class="s2">this</span><span class="s1">.nextFontManifest;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.enabledDirectories.app &amp;&amp; renderOpts.isAppPath) {</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _modulerender.lazyRenderAppPage)(req, res, pathname, query, </span><span class="s4">// This code path does not service revalidations for unknown param</span>
                <span class="s4">// shells. As a result, we don't need to pass in the unknown params.</span>
                <span class="s2">null</span><span class="s1">, renderOpts, </span><span class="s2">this</span><span class="s1">.getServerComponentsHmrCache(), </span><span class="s2">false</span><span class="s1">, {</span>
                    <span class="s1">buildId: </span><span class="s2">this</span><span class="s1">.buildId</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// TODO: re-enable this once we've refactored to use implicit matches</span>
            <span class="s4">// throw new Error('Invariant: render should have used routeModule')</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _modulerender1.lazyRenderPagesPage)(req.originalRequest, res.originalResponse, pathname, query, renderOpts, {</span>
                <span class="s1">buildId: </span><span class="s2">this</span><span class="s1">.buildId,</span>
                <span class="s1">deploymentId: </span><span class="s2">this</span><span class="s1">.nextConfig.deploymentId,</span>
                <span class="s1">customServer: </span><span class="s2">this</span><span class="s1">.serverOptions.customServer || undefined</span>
            <span class="s1">}, {</span>
                <span class="s1">isFallback: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">isDraftMode: renderOpts.isDraftMode,</span>
                <span class="s1">developmentNotFoundSourcePage: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'developmentNotFoundSourcePage'</span><span class="s1">)</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async imageOptimizer(req, res, paramsResult, previousCacheEntry) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_MINIMAL) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant: imageOptimizer should not be called in minimal mode'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E506&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">{ imageOptimizer, fetchExternalImage, fetchInternalImage } = require(</span><span class="s0">'./image-optimizer'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">handleInternalReq = async (newReq, newRes)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(newReq.url === req.url) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invariant attempted to optimize _next/image itself`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E496&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.routerServerHandler) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invariant missing routerServerHandler`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E317&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">await this</span><span class="s1">.routerServerHandler(newReq, newRes);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">{ isAbsolute, href } = paramsResult;</span>
            <span class="s2">const </span><span class="s1">imageUpstream = isAbsolute ? </span><span class="s2">await </span><span class="s1">fetchExternalImage(href) : </span><span class="s2">await </span><span class="s1">fetchInternalImage(href, req.originalRequest, res.originalResponse, handleInternalReq);</span>
            <span class="s2">return </span><span class="s1">imageOptimizer(imageUpstream, paramsResult, </span><span class="s2">this</span><span class="s1">.nextConfig, {</span>
                <span class="s1">isDev: </span><span class="s2">this</span><span class="s1">.renderOpts.dev,</span>
                <span class="s1">previousCacheEntry</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getPagePath(pathname, locales) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _require.getPagePath)(pathname, </span><span class="s2">this</span><span class="s1">.distDir, locales, </span><span class="s2">this</span><span class="s1">.enabledDirectories.app);</span>
    <span class="s1">}</span>
    <span class="s1">async renderPageComponent(ctx, bubbleNoFallback) {</span>
        <span class="s2">const </span><span class="s1">edgeFunctionsPages = </span><span class="s2">this</span><span class="s1">.getEdgeFunctionsPages() || [];</span>
        <span class="s2">if </span><span class="s1">(edgeFunctionsPages.length) {</span>
            <span class="s2">const </span><span class="s1">appPaths = </span><span class="s2">this</span><span class="s1">.getOriginalAppPaths(ctx.pathname);</span>
            <span class="s2">const </span><span class="s1">isAppPath = Array.isArray(appPaths);</span>
            <span class="s2">let </span><span class="s1">page = ctx.pathname;</span>
            <span class="s2">if </span><span class="s1">(isAppPath) {</span>
                <span class="s4">// When it's an array, we need to pass all parallel routes to the loader.</span>
                <span class="s1">page = appPaths[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">edgeFunctionsPage of edgeFunctionsPages){</span>
                <span class="s2">if </span><span class="s1">(edgeFunctionsPage === page) {</span>
                    <span class="s2">await this</span><span class="s1">.runEdgeFunction({</span>
                        <span class="s1">req: ctx.req,</span>
                        <span class="s1">res: ctx.res,</span>
                        <span class="s1">query: ctx.query,</span>
                        <span class="s1">params: ctx.renderOpts.params,</span>
                        <span class="s1">page,</span>
                        <span class="s1">appPaths</span>
                    <span class="s1">});</span>
                    <span class="s2">return null</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return super</span><span class="s1">.renderPageComponent(ctx, bubbleNoFallback);</span>
    <span class="s1">}</span>
    <span class="s1">async findPageComponents({ locale, page, query, params, isAppPath, url }) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.NextNodeServerSpan.findPageComponents, {</span>
            <span class="s1">spanName: </span><span class="s0">'resolve page components'</span><span class="s1">,</span>
            <span class="s1">attributes: {</span>
                <span class="s0">'next.route'</span><span class="s1">: isAppPath ? (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(page) : page</span>
            <span class="s1">}</span>
        <span class="s1">}, ()=&gt;</span><span class="s2">this</span><span class="s1">.findPageComponentsImpl({</span>
                <span class="s1">locale,</span>
                <span class="s1">page,</span>
                <span class="s1">query,</span>
                <span class="s1">params,</span>
                <span class="s1">isAppPath,</span>
                <span class="s1">url</span>
            <span class="s1">}));</span>
    <span class="s1">}</span>
    <span class="s1">async findPageComponentsImpl({ locale, page, query, params, isAppPath, url: _url }) {</span>
        <span class="s2">const </span><span class="s1">pagePaths = [</span>
            <span class="s1">page</span>
        <span class="s1">];</span>
        <span class="s2">if </span><span class="s1">(query.amp) {</span>
            <span class="s4">// try serving a static AMP version first</span>
            <span class="s1">pagePaths.unshift((isAppPath ? (</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)(page) : (</span><span class="s3">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(page)) + </span><span class="s0">'.amp'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(locale) {</span>
            <span class="s1">pagePaths.unshift(...pagePaths.map((path)=&gt;</span><span class="s0">`/</span><span class="s1">${locale}${path === </span><span class="s0">'/' </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: path}</span><span class="s0">`</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pagePath of pagePaths){</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">components = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadcomponents.loadComponents)({</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">page: pagePath,</span>
                    <span class="s1">isAppPath,</span>
                    <span class="s1">isDev: </span><span class="s2">this</span><span class="s1">.isDev,</span>
                    <span class="s1">sriEnabled: </span><span class="s2">this</span><span class="s1">.sriEnabled</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(locale &amp;&amp; </span><span class="s2">typeof </span><span class="s1">components.Component === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; !pagePath.startsWith(</span><span class="s0">`/</span><span class="s1">${locale}</span><span class="s0">/`</span><span class="s1">) &amp;&amp; pagePath !== </span><span class="s0">`/</span><span class="s1">${locale}</span><span class="s0">`</span><span class="s1">) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">components,</span>
                    <span class="s1">query: {</span>
                        <span class="s1">...!</span><span class="s2">this</span><span class="s1">.renderOpts.isExperimentalCompile &amp;&amp; components.getStaticProps ? {</span>
                            <span class="s1">amp: query.amp</span>
                        <span class="s1">} : query,</span>
                        <span class="s4">// For appDir params is excluded.</span>
                        <span class="s1">...(isAppPath ? {} : params) || {}</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s4">// we should only not throw if we failed to find the page</span>
                <span class="s4">// in the pages-manifest</span>
                <span class="s2">if </span><span class="s1">(!(err </span><span class="s2">instanceof </span><span class="s1">_utils.PageNotFoundError)) {</span>
                    <span class="s2">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">getNextFontManifest() {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _loadmanifestexternal.loadManifest)((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, </span><span class="s0">'server'</span><span class="s1">, _constants.NEXT_FONT_MANIFEST + </span><span class="s0">'.json'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s4">// Used in development only, overloaded in next-dev-server</span>
    <span class="s1">logErrorWithOriginalStack(_err, _type) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: logErrorWithOriginalStack can only be called on the development server'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E6&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">// Used in development only, overloaded in next-dev-server</span>
    <span class="s1">async ensurePage(_opts) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: ensurePage can only be called on the development server'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E291&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Resolves `API` request, in development builds on demand</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">req http request</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">res http response</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">pathname path of request</span>
   <span class="s4">*/ </span><span class="s1">async handleApiRequest(req, res, query, match) {</span>
        <span class="s2">return this</span><span class="s1">.runApi(req, res, query, match);</span>
    <span class="s1">}</span>
    <span class="s1">getCacheFilesystem() {</span>
        <span class="s2">return </span><span class="s1">_nodefsmethods.nodeFs;</span>
    <span class="s1">}</span>
    <span class="s1">normalizeReq(req) {</span>
        <span class="s2">return </span><span class="s1">!(req </span><span class="s2">instanceof </span><span class="s1">_node.NodeNextRequest) ? </span><span class="s2">new </span><span class="s1">_node.NodeNextRequest(req) : req;</span>
    <span class="s1">}</span>
    <span class="s1">normalizeRes(res) {</span>
        <span class="s2">return </span><span class="s1">!(res </span><span class="s2">instanceof </span><span class="s1">_node.NodeNextResponse) ? </span><span class="s2">new </span><span class="s1">_node.NodeNextResponse(res) : res;</span>
    <span class="s1">}</span>
    <span class="s1">getRequestHandler() {</span>
        <span class="s2">const </span><span class="s1">handler = </span><span class="s2">this</span><span class="s1">.makeRequestHandler();</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.serverOptions.experimentalTestProxy) {</span>
            <span class="s2">const </span><span class="s1">{ wrapRequestHandlerNode } = </span><span class="s4">// eslint-disable-next-line @next/internal/typechecked-require -- experimental/testmode is not built ins next/dist/esm</span>
            <span class="s1">require(</span><span class="s0">'next/dist/experimental/testmode/server'</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">wrapRequestHandlerNode(handler);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">handler;</span>
    <span class="s1">}</span>
    <span class="s1">makeRequestHandler() {</span>
        <span class="s4">// This is just optimization to fire prepare as soon as possible. It will be</span>
        <span class="s4">// properly awaited later. We add the catch here to ensure that it does not</span>
        <span class="s4">// cause an unhandled promise rejection. The promise rejection will be</span>
        <span class="s4">// handled later on via the `await` when the request handler is called.</span>
        <span class="s2">this</span><span class="s1">.prepare().catch((err)=&gt;{</span>
            <span class="s1">console.error(</span><span class="s0">'Failed to prepare server'</span><span class="s1">, err);</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">handler = </span><span class="s2">super</span><span class="s1">.getRequestHandler();</span>
        <span class="s2">return </span><span class="s1">(req, res, parsedUrl)=&gt;handler(</span><span class="s2">this</span><span class="s1">.normalizeReq(req), </span><span class="s2">this</span><span class="s1">.normalizeRes(res), parsedUrl);</span>
    <span class="s1">}</span>
    <span class="s1">async revalidate({ urlPath, revalidateHeaders, opts }) {</span>
        <span class="s2">const </span><span class="s1">mocked = (</span><span class="s3">0</span><span class="s1">, _mockrequest.createRequestResponseMocks)({</span>
            <span class="s1">url: urlPath,</span>
            <span class="s1">headers: revalidateHeaders</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">handler = </span><span class="s2">this</span><span class="s1">.getRequestHandler();</span>
        <span class="s2">await </span><span class="s1">handler(</span><span class="s2">new </span><span class="s1">_node.NodeNextRequest(mocked.req), </span><span class="s2">new </span><span class="s1">_node.NodeNextResponse(mocked.res));</span>
        <span class="s2">await </span><span class="s1">mocked.res.hasStreamed;</span>
        <span class="s2">if </span><span class="s1">(mocked.res.getHeader(</span><span class="s0">'x-nextjs-cache'</span><span class="s1">) !== </span><span class="s0">'REVALIDATED' </span><span class="s1">&amp;&amp; mocked.res.statusCode !== </span><span class="s3">200 </span><span class="s1">&amp;&amp; !(mocked.res.statusCode === </span><span class="s3">404 </span><span class="s1">&amp;&amp; opts.unstable_onlyGenerated)) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invalid response </span><span class="s1">${mocked.res.statusCode}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E175&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async render(req, res, pathname, query, parsedUrl, internal = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">return super</span><span class="s1">.render(</span><span class="s2">this</span><span class="s1">.normalizeReq(req), </span><span class="s2">this</span><span class="s1">.normalizeRes(res), pathname, query, parsedUrl, internal);</span>
    <span class="s1">}</span>
    <span class="s1">async renderToHTML(req, res, pathname, query) {</span>
        <span class="s2">return super</span><span class="s1">.renderToHTML(</span><span class="s2">this</span><span class="s1">.normalizeReq(req), </span><span class="s2">this</span><span class="s1">.normalizeRes(res), pathname, query);</span>
    <span class="s1">}</span>
    <span class="s1">async renderErrorToResponseImpl(ctx, err) {</span>
        <span class="s2">const </span><span class="s1">{ req, res, query } = ctx;</span>
        <span class="s2">const </span><span class="s1">is404 = res.statusCode === </span><span class="s3">404</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(is404 &amp;&amp; </span><span class="s2">this</span><span class="s1">.enabledDirectories.app) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderOpts.dev) {</span>
                <span class="s2">await this</span><span class="s1">.ensurePage({</span>
                    <span class="s1">page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span>
                    <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">url: req.url</span>
                <span class="s1">}).catch(()=&gt;{});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.getEdgeFunctionsPages().includes(_constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY)) {</span>
                <span class="s2">await this</span><span class="s1">.runEdgeFunction({</span>
                    <span class="s1">req,</span>
                    <span class="s1">res,</span>
                    <span class="s1">query: query || {},</span>
                    <span class="s1">params: {},</span>
                    <span class="s1">page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,</span>
                    <span class="s1">appPaths: </span><span class="s2">null</span>
                <span class="s1">});</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return super</span><span class="s1">.renderErrorToResponseImpl(ctx, err);</span>
    <span class="s1">}</span>
    <span class="s1">async renderError(err, req, res, pathname, query, setHeaders) {</span>
        <span class="s2">return super</span><span class="s1">.renderError(err, </span><span class="s2">this</span><span class="s1">.normalizeReq(req), </span><span class="s2">this</span><span class="s1">.normalizeRes(res), pathname, query, setHeaders);</span>
    <span class="s1">}</span>
    <span class="s1">async renderErrorToHTML(err, req, res, pathname, query) {</span>
        <span class="s2">return super</span><span class="s1">.renderErrorToHTML(err, </span><span class="s2">this</span><span class="s1">.normalizeReq(req), </span><span class="s2">this</span><span class="s1">.normalizeRes(res), pathname, query);</span>
    <span class="s1">}</span>
    <span class="s1">async render404(req, res, parsedUrl, setHeaders) {</span>
        <span class="s2">return super</span><span class="s1">.render404(</span><span class="s2">this</span><span class="s1">.normalizeReq(req), </span><span class="s2">this</span><span class="s1">.normalizeRes(res), parsedUrl, setHeaders);</span>
    <span class="s1">}</span>
    <span class="s1">getMiddlewareManifest() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.minimalMode) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">manifest = require(</span><span class="s2">this</span><span class="s1">.middlewareManifestPath);</span>
            <span class="s2">return </span><span class="s1">manifest;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/** Returns the middleware routing item if there is one. */ </span><span class="s1">async getMiddleware() {</span>
        <span class="s2">var </span><span class="s1">_manifest_middleware;</span>
        <span class="s2">const </span><span class="s1">manifest = </span><span class="s2">this</span><span class="s1">.getMiddlewareManifest();</span>
        <span class="s2">const </span><span class="s1">middleware = manifest == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_manifest_middleware = manifest.middleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _manifest_middleware[</span><span class="s0">'/'</span><span class="s1">];</span>
        <span class="s2">if </span><span class="s1">(!middleware) {</span>
            <span class="s2">const </span><span class="s1">middlewareModule = </span><span class="s2">await this</span><span class="s1">.loadNodeMiddleware();</span>
            <span class="s2">if </span><span class="s1">(middlewareModule) {</span>
                <span class="s2">var </span><span class="s1">_middlewareModule_config;</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">match: (</span><span class="s3">0</span><span class="s1">, _middlewareroutematcher.getMiddlewareRouteMatcher)(((_middlewareModule_config = middlewareModule.config) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _middlewareModule_config.matchers) || [</span>
                        <span class="s1">{</span>
                            <span class="s1">regexp: </span><span class="s0">'.*'</span><span class="s1">,</span>
                            <span class="s1">originalSource: </span><span class="s0">'/:path*'</span>
                        <span class="s1">}</span>
                    <span class="s1">]),</span>
                    <span class="s1">page: </span><span class="s0">'/'</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">match: getMiddlewareMatcher(middleware),</span>
            <span class="s1">page: </span><span class="s0">'/'</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">getEdgeFunctionsPages() {</span>
        <span class="s2">const </span><span class="s1">manifest = </span><span class="s2">this</span><span class="s1">.getMiddlewareManifest();</span>
        <span class="s2">if </span><span class="s1">(!manifest) {</span>
            <span class="s2">return </span><span class="s1">[];</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">Object.keys(manifest.functions);</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Get information for the edge function located in the provided page</span>
   <span class="s4">* folder. If the edge function info can't be found it will throw</span>
   <span class="s4">* an error.</span>
   <span class="s4">*/ </span><span class="s1">getEdgeFunctionInfo(params) {</span>
        <span class="s2">const </span><span class="s1">manifest = </span><span class="s2">this</span><span class="s1">.getMiddlewareManifest();</span>
        <span class="s2">if </span><span class="s1">(!manifest) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">foundPage;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">foundPage = (</span><span class="s3">0</span><span class="s1">, _denormalizepagepath.denormalizePagePath)((</span><span class="s3">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(params.page));</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">pageInfo = params.middleware ? manifest.middleware[foundPage] : manifest.functions[foundPage];</span>
        <span class="s2">if </span><span class="s1">(!pageInfo) {</span>
            <span class="s2">if </span><span class="s1">(!params.middleware) {</span>
                <span class="s2">throw new </span><span class="s1">_utils.PageNotFoundError(foundPage);</span>
            <span class="s1">}</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">name: pageInfo.name,</span>
            <span class="s1">paths: pageInfo.files.map((file)=&gt;(</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, file)),</span>
            <span class="s1">wasm: (pageInfo.wasm ?? []).map((binding)=&gt;({</span>
                    <span class="s1">...binding,</span>
                    <span class="s1">filePath: (</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, binding.filePath)</span>
                <span class="s1">})),</span>
            <span class="s1">assets: pageInfo.assets &amp;&amp; pageInfo.assets.map((binding)=&gt;{</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">...binding,</span>
                    <span class="s1">filePath: (</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, binding.filePath)</span>
                <span class="s1">};</span>
            <span class="s1">}),</span>
            <span class="s1">env: pageInfo.env</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">async loadNodeMiddleware() {</span>
        <span class="s2">if </span><span class="s1">(!process.env.NEXT_MINIMAL) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">var </span><span class="s1">_functionsConfig_functions;</span>
                <span class="s2">const </span><span class="s1">functionsConfig = </span><span class="s2">this</span><span class="s1">.renderOpts.dev ? {} : require((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, </span><span class="s0">'server'</span><span class="s1">, _constants.FUNCTIONS_CONFIG_MANIFEST));</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderOpts.dev || (functionsConfig == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_functionsConfig_functions = functionsConfig.functions) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _functionsConfig_functions[</span><span class="s0">'/_middleware'</span><span class="s1">])) {</span>
                    <span class="s4">// if used with top level await, this will be a promise</span>
                    <span class="s2">return </span><span class="s1">require((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'middleware.js'</span><span class="s1">));</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _iserror.default)(err) &amp;&amp; err.code !== </span><span class="s0">'ENOENT' </span><span class="s1">&amp;&amp; err.code !== </span><span class="s0">'MODULE_NOT_FOUND'</span><span class="s1">) {</span>
                    <span class="s2">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Checks if a middleware exists. This method is useful for the development</span>
   <span class="s4">* server where we need to check the filesystem. Here we just check the</span>
   <span class="s4">* middleware manifest.</span>
   <span class="s4">*/ </span><span class="s1">async hasMiddleware(pathname) {</span>
        <span class="s2">const </span><span class="s1">info = </span><span class="s2">this</span><span class="s1">.getEdgeFunctionInfo({</span>
            <span class="s1">page: pathname,</span>
            <span class="s1">middleware: </span><span class="s2">true</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">nodeMiddleware = </span><span class="s2">await this</span><span class="s1">.loadNodeMiddleware();</span>
        <span class="s2">if </span><span class="s1">(!info &amp;&amp; nodeMiddleware) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">Boolean(info &amp;&amp; info.paths.length &gt; </span><span class="s3">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* A placeholder for a function to be defined in the development server.</span>
   <span class="s4">* It will make sure that the root middleware or an edge function has been compiled</span>
   <span class="s4">* so that we can run it.</span>
   <span class="s4">*/ </span><span class="s1">async ensureMiddleware(_url) {}</span>
    <span class="s1">async ensureEdgeFunction(_params) {}</span>
    <span class="s4">/**</span>
   <span class="s4">* This method gets all middleware matchers and execute them when the request</span>
   <span class="s4">* matches. It will make sure that each middleware exists and is compiled and</span>
   <span class="s4">* ready to be invoked. The development server will decorate it to add warns</span>
   <span class="s4">* and errors with rich traces.</span>
   <span class="s4">*/ </span><span class="s1">async runMiddleware(params) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_MINIMAL) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant: runMiddleware should not be called in minimal mode'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E276&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">// Middleware is skipped for on-demand revalidate requests</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _apiutils.checkIsOnDemandRevalidate)(params.request, </span><span class="s2">this</span><span class="s1">.renderOpts.previewProps).isOnDemandRevalidate) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">response: </span><span class="s2">new </span><span class="s1">Response(</span><span class="s2">null</span><span class="s1">, {</span>
                    <span class="s1">headers: {</span>
                        <span class="s0">'x-middleware-next'</span><span class="s1">: </span><span class="s0">'1'</span>
                    <span class="s1">}</span>
                <span class="s1">})</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">url;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.nextConfig.skipMiddlewareUrlNormalize) {</span>
            <span class="s1">url = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.request, </span><span class="s0">'initURL'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// For middleware to &quot;fetch&quot; we must always provide an absolute URL</span>
            <span class="s2">const </span><span class="s1">query = (</span><span class="s3">0</span><span class="s1">, _querystring.urlQueryToSearchParams)(params.parsed.query).toString();</span>
            <span class="s2">const </span><span class="s1">locale = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.request, </span><span class="s0">'locale'</span><span class="s1">);</span>
            <span class="s1">url = </span><span class="s0">`</span><span class="s1">${(</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.request, </span><span class="s0">'initProtocol'</span><span class="s1">)}</span><span class="s0">://</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.fetchHostname || </span><span class="s0">'localhost'</span><span class="s1">}</span><span class="s0">:</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.port}${locale ? </span><span class="s0">`/</span><span class="s1">${locale}</span><span class="s0">` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${params.parsed.pathname}${query ? </span><span class="s0">`?</span><span class="s1">${query}</span><span class="s0">` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!url.startsWith(</span><span class="s0">'http'</span><span class="s1">)) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'To use middleware you must provide a `hostname` and `port` to the Next.js Server'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E35&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">page = {};</span>
        <span class="s2">const </span><span class="s1">middleware = </span><span class="s2">await this</span><span class="s1">.getMiddleware();</span>
        <span class="s2">if </span><span class="s1">(!middleware) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">finished: </span><span class="s2">false</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">await this</span><span class="s1">.hasMiddleware(middleware.page)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">finished: </span><span class="s2">false</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">await this</span><span class="s1">.ensureMiddleware(params.request.url);</span>
        <span class="s2">const </span><span class="s1">middlewareInfo = </span><span class="s2">this</span><span class="s1">.getEdgeFunctionInfo({</span>
            <span class="s1">page: middleware.page,</span>
            <span class="s1">middleware: </span><span class="s2">true</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">method = (params.request.method || </span><span class="s0">'GET'</span><span class="s1">).toUpperCase();</span>
        <span class="s2">const </span><span class="s1">requestData = {</span>
            <span class="s1">headers: params.request.headers,</span>
            <span class="s1">method,</span>
            <span class="s1">nextConfig: {</span>
                <span class="s1">basePath: </span><span class="s2">this</span><span class="s1">.nextConfig.basePath,</span>
                <span class="s1">i18n: </span><span class="s2">this</span><span class="s1">.nextConfig.i18n,</span>
                <span class="s1">trailingSlash: </span><span class="s2">this</span><span class="s1">.nextConfig.trailingSlash,</span>
                <span class="s1">experimental: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental</span>
            <span class="s1">},</span>
            <span class="s1">url: url,</span>
            <span class="s1">page,</span>
            <span class="s1">body: method !== </span><span class="s0">'GET' </span><span class="s1">&amp;&amp; method !== </span><span class="s0">'HEAD' </span><span class="s1">? (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.request, </span><span class="s0">'clonableBody'</span><span class="s1">) : undefined,</span>
            <span class="s1">signal: (</span><span class="s3">0</span><span class="s1">, _nextrequest.signalFromNodeResponse)(params.response.originalResponse),</span>
            <span class="s1">waitUntil: </span><span class="s2">this</span><span class="s1">.getWaitUntil()</span>
        <span class="s1">};</span>
        <span class="s2">let </span><span class="s1">result;</span>
        <span class="s4">// if no middleware info check for Node.js middleware</span>
        <span class="s4">// this is not in the middleware-manifest as that historically</span>
        <span class="s4">// has only included edge-functions, we need to do a breaking</span>
        <span class="s4">// version bump for that manifest to write this info there if</span>
        <span class="s4">// we decide we want to</span>
        <span class="s2">if </span><span class="s1">(!middlewareInfo) {</span>
            <span class="s2">let </span><span class="s1">middlewareModule;</span>
            <span class="s1">middlewareModule = </span><span class="s2">await this</span><span class="s1">.loadNodeMiddleware();</span>
            <span class="s2">if </span><span class="s1">(!middlewareModule) {</span>
                <span class="s2">throw new </span><span class="s1">_utils.MiddlewareNotFoundError();</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">adapterFn = middlewareModule.default || middlewareModule;</span>
            <span class="s2">const </span><span class="s1">hasRequestBody = ![</span>
                <span class="s0">'HEAD'</span><span class="s1">,</span>
                <span class="s0">'GET'</span>
            <span class="s1">].includes(params.request.method) &amp;&amp; Boolean(requestData.body);</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">result = </span><span class="s2">await </span><span class="s1">adapterFn({</span>
                    <span class="s1">handler: middlewareModule.middleware || middlewareModule,</span>
                    <span class="s1">request: {</span>
                        <span class="s1">...requestData,</span>
                        <span class="s1">body: hasRequestBody ? requestData.body.cloneBodyStream() : undefined</span>
                    <span class="s1">},</span>
                    <span class="s1">page: </span><span class="s0">'middleware'</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(hasRequestBody) {</span>
                    <span class="s1">requestData.body.finalize();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">{ run } = require(</span><span class="s0">'./web/sandbox'</span><span class="s1">);</span>
            <span class="s1">result = </span><span class="s2">await </span><span class="s1">run({</span>
                <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                <span class="s1">name: middlewareInfo.name,</span>
                <span class="s1">paths: middlewareInfo.paths,</span>
                <span class="s1">edgeFunctionEntry: middlewareInfo,</span>
                <span class="s1">request: requestData,</span>
                <span class="s1">useCache: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">onWarning: params.onWarning</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.renderOpts.dev) {</span>
            <span class="s1">result.waitUntil.catch((error)=&gt;{</span>
                <span class="s1">console.error(</span><span class="s0">`Uncaught: middleware waitUntil errored`</span><span class="s1">, error);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!result) {</span>
            <span class="s2">this</span><span class="s1">.render404(params.request, params.response, params.parsed);</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">finished: </span><span class="s2">true</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s4">// Split compound (comma-separated) set-cookie headers</span>
        <span class="s2">if </span><span class="s1">(result.response.headers.has(</span><span class="s0">'set-cookie'</span><span class="s1">)) {</span>
            <span class="s2">const </span><span class="s1">cookies = result.response.headers.getSetCookie().flatMap((maybeCompoundCookie)=&gt;(</span><span class="s3">0</span><span class="s1">, _utils1.splitCookiesString)(maybeCompoundCookie));</span>
            <span class="s4">// Clear existing header(s)</span>
            <span class="s1">result.response.headers.delete(</span><span class="s0">'set-cookie'</span><span class="s1">);</span>
            <span class="s4">// Append each cookie individually.</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">cookie of cookies){</span>
                <span class="s1">result.response.headers.append(</span><span class="s0">'set-cookie'</span><span class="s1">, cookie);</span>
            <span class="s1">}</span>
            <span class="s4">// Add cookies to request meta.</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(params.request, </span><span class="s0">'middlewareCookie'</span><span class="s1">, cookies);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">getPrerenderManifest() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._cachedPreviewManifest) {</span>
            <span class="s2">return this</span><span class="s1">._cachedPreviewManifest;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">._cachedPreviewManifest = (</span><span class="s3">0</span><span class="s1">, _loadmanifestexternal.loadManifest)((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, _constants.PRERENDER_MANIFEST));</span>
        <span class="s2">return this</span><span class="s1">._cachedPreviewManifest;</span>
    <span class="s1">}</span>
    <span class="s1">getRoutesManifest() {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants1.NextNodeServerSpan.getRoutesManifest, ()=&gt;(</span><span class="s3">0</span><span class="s1">, _loadmanifestexternal.loadManifest)((</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, _constants.ROUTES_MANIFEST)));</span>
    <span class="s1">}</span>
    <span class="s1">attachRequestMeta(req, parsedUrl, isUpgradeReq) {</span>
        <span class="s2">var </span><span class="s1">_req_headers_xforwardedproto;</span>
        <span class="s4">// Injected in base-server.ts</span>
        <span class="s2">const </span><span class="s1">protocol = ((_req_headers_xforwardedproto = req.headers[</span><span class="s0">'x-forwarded-proto'</span><span class="s1">]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _req_headers_xforwardedproto.includes(</span><span class="s0">'https'</span><span class="s1">)) ? </span><span class="s0">'https' </span><span class="s1">: </span><span class="s0">'http'</span><span class="s1">;</span>
        <span class="s4">// When there are hostname and port we build an absolute URL</span>
        <span class="s2">const </span><span class="s1">initUrl = </span><span class="s2">this</span><span class="s1">.fetchHostname &amp;&amp; </span><span class="s2">this</span><span class="s1">.port ? </span><span class="s0">`</span><span class="s1">${protocol}</span><span class="s0">://</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.fetchHostname}</span><span class="s0">:</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.port}${req.url}</span><span class="s0">` </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.trustHostHeader ? </span><span class="s0">`https://</span><span class="s1">${req.headers.host || </span><span class="s0">'localhost'</span><span class="s1">}${req.url}</span><span class="s0">` </span><span class="s1">: req.url;</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'initURL'</span><span class="s1">, initUrl);</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'initQuery'</span><span class="s1">, {</span>
            <span class="s1">...parsedUrl.query</span>
        <span class="s1">});</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'initProtocol'</span><span class="s1">, protocol);</span>
        <span class="s2">if </span><span class="s1">(!isUpgradeReq) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'clonableBody'</span><span class="s1">, (</span><span class="s3">0</span><span class="s1">, _bodystreams.getCloneableBody)(req.originalRequest));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async runEdgeFunction(params) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NEXT_MINIMAL) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Middleware is not supported in minimal mode. Please remove the `NEXT_MINIMAL` environment variable.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E58&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">edgeInfo;</span>
        <span class="s2">const </span><span class="s1">{ query, page, match } = params;</span>
        <span class="s2">if </span><span class="s1">(!match) </span><span class="s2">await this</span><span class="s1">.ensureEdgeFunction({</span>
            <span class="s1">page,</span>
            <span class="s1">appPaths: params.appPaths,</span>
            <span class="s1">url: params.req.url</span>
        <span class="s1">});</span>
        <span class="s1">edgeInfo = </span><span class="s2">this</span><span class="s1">.getEdgeFunctionInfo({</span>
            <span class="s1">page,</span>
            <span class="s1">middleware: </span><span class="s2">false</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(!edgeInfo) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// For edge to &quot;fetch&quot; we must always provide an absolute URL</span>
        <span class="s2">const </span><span class="s1">isNextDataRequest = (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.req, </span><span class="s0">'isNextDataReq'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">initialUrl = </span><span class="s2">new </span><span class="s1">URL((</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.req, </span><span class="s0">'initURL'</span><span class="s1">) || </span><span class="s0">'/'</span><span class="s1">, </span><span class="s0">'http://n'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">queryString = (</span><span class="s3">0</span><span class="s1">, _querystring.urlQueryToSearchParams)({</span>
            <span class="s1">...Object.fromEntries(initialUrl.searchParams),</span>
            <span class="s1">...query,</span>
            <span class="s1">...params.params</span>
        <span class="s1">}).toString();</span>
        <span class="s2">if </span><span class="s1">(isNextDataRequest) {</span>
            <span class="s1">params.req.headers[</span><span class="s0">'x-nextjs-data'</span><span class="s1">] = </span><span class="s0">'1'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">initialUrl.search = queryString;</span>
        <span class="s2">const </span><span class="s1">url = initialUrl.toString();</span>
        <span class="s2">if </span><span class="s1">(!url.startsWith(</span><span class="s0">'http'</span><span class="s1">)) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'To use middleware you must provide a `hostname` and `port` to the Next.js Server'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E35&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ run } = require(</span><span class="s0">'./web/sandbox'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">run({</span>
            <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
            <span class="s1">name: edgeInfo.name,</span>
            <span class="s1">paths: edgeInfo.paths,</span>
            <span class="s1">edgeFunctionEntry: edgeInfo,</span>
            <span class="s1">request: {</span>
                <span class="s1">headers: params.req.headers,</span>
                <span class="s1">method: params.req.method,</span>
                <span class="s1">nextConfig: {</span>
                    <span class="s1">basePath: </span><span class="s2">this</span><span class="s1">.nextConfig.basePath,</span>
                    <span class="s1">i18n: </span><span class="s2">this</span><span class="s1">.nextConfig.i18n,</span>
                    <span class="s1">trailingSlash: </span><span class="s2">this</span><span class="s1">.nextConfig.trailingSlash</span>
                <span class="s1">},</span>
                <span class="s1">url,</span>
                <span class="s1">page: {</span>
                    <span class="s1">name: params.page,</span>
                    <span class="s1">...params.params &amp;&amp; {</span>
                        <span class="s1">params: params.params</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s1">body: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.req, </span><span class="s0">'clonableBody'</span><span class="s1">),</span>
                <span class="s1">signal: (</span><span class="s3">0</span><span class="s1">, _nextrequest.signalFromNodeResponse)(params.res.originalResponse),</span>
                <span class="s1">waitUntil: </span><span class="s2">this</span><span class="s1">.getWaitUntil()</span>
            <span class="s1">},</span>
            <span class="s1">useCache: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">onError: params.onError,</span>
            <span class="s1">onWarning: params.onWarning,</span>
            <span class="s1">incrementalCache: globalThis.__incrementalCache || (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.req, </span><span class="s0">'incrementalCache'</span><span class="s1">),</span>
            <span class="s1">serverComponentsHmrCache: (</span><span class="s3">0</span><span class="s1">, _requestmeta.getRequestMeta)(params.req, </span><span class="s0">'serverComponentsHmrCache'</span><span class="s1">)</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(result.fetchMetrics) {</span>
            <span class="s1">params.req.fetchMetrics = result.fetchMetrics;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!params.res.statusCode || params.res.statusCode &lt; </span><span class="s3">400</span><span class="s1">) {</span>
            <span class="s1">params.res.statusCode = result.response.status;</span>
            <span class="s1">params.res.statusMessage = result.response.statusText;</span>
        <span class="s1">}</span>
        <span class="s4">// TODO: (wyattjoh) investigate improving this</span>
        <span class="s1">result.response.headers.forEach((value, key)=&gt;{</span>
            <span class="s4">// The append handling is special cased for `set-cookie`.</span>
            <span class="s2">if </span><span class="s1">(key.toLowerCase() === </span><span class="s0">'set-cookie'</span><span class="s1">) {</span>
                <span class="s4">// TODO: (wyattjoh) replace with native response iteration when we can upgrade undici</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">cookie of (</span><span class="s3">0</span><span class="s1">, _utils1.splitCookiesString)(value)){</span>
                    <span class="s1">params.res.appendHeader(key, cookie);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">params.res.appendHeader(key, value);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">{ originalResponse } = params.res;</span>
        <span class="s2">if </span><span class="s1">(result.response.body) {</span>
            <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _pipereadable.pipeToNodeResponse)(result.response.body, originalResponse);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">originalResponse.end();</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">get serverDistDir() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._serverDistDir) {</span>
            <span class="s2">return this</span><span class="s1">._serverDistDir;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">serverDistDir = (</span><span class="s3">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, _constants.SERVER_DIRECTORY);</span>
        <span class="s2">this</span><span class="s1">._serverDistDir = serverDistDir;</span>
        <span class="s2">return </span><span class="s1">serverDistDir;</span>
    <span class="s1">}</span>
    <span class="s1">async getFallbackErrorComponents(_url) {</span>
        <span class="s4">// Not implemented for production use cases, this is implemented on the</span>
        <span class="s4">// development server.</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async instrumentationOnRequestError(...args) {</span>
        <span class="s2">await super</span><span class="s1">.instrumentationOnRequestError(...args);</span>
        <span class="s4">// For Node.js runtime production logs, in dev it will be overridden by next-dev-server</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.renderOpts.dev) {</span>
            <span class="s2">this</span><span class="s1">.logError(args[</span><span class="s3">0</span><span class="s1">]);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">onServerClose(listener) {</span>
        <span class="s2">this</span><span class="s1">.cleanupListeners.add(listener);</span>
    <span class="s1">}</span>
    <span class="s1">async close() {</span>
        <span class="s2">await this</span><span class="s1">.cleanupListeners.runAll();</span>
    <span class="s1">}</span>
    <span class="s1">getInternalWaitUntil() {</span>
        <span class="s2">this</span><span class="s1">.internalWaitUntil ??= </span><span class="s2">this</span><span class="s1">.createInternalWaitUntil();</span>
        <span class="s2">return this</span><span class="s1">.internalWaitUntil;</span>
    <span class="s1">}</span>
    <span class="s1">createInternalWaitUntil() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.minimalMode) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createInternalWaitUntil should never be called in minimal mode'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E540&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">awaiter = </span><span class="s2">new </span><span class="s1">_awaiter.AwaiterOnce({</span>
            <span class="s1">onError: console.error</span>
        <span class="s1">});</span>
        <span class="s4">// TODO(after): warn if the process exits before these are awaited</span>
        <span class="s2">this</span><span class="s1">.onServerClose(()=&gt;awaiter.awaiting());</span>
        <span class="s2">return </span><span class="s1">awaiter.waitUntil;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=next-server.js.map</span></pre>
</body>
</html>