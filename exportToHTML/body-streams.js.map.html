<html>
<head>
<title>body-streams.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
body-streams.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/body-streams.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { Readable } from 'stream'</span><span class="s3">\n</span><span class="s1">import { PassThrough } from 'stream'</span><span class="s3">\n\n</span><span class="s1">export function requestToBodyStream(</span><span class="s3">\n  </span><span class="s1">context: { ReadableStream: typeof ReadableStream },</span><span class="s3">\n  </span><span class="s1">KUint8Array: typeof Uint8Array,</span><span class="s3">\n  </span><span class="s1">stream: Readable</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return new context.ReadableStream({</span><span class="s3">\n    </span><span class="s1">start: async (controller) =&gt; {</span><span class="s3">\n      </span><span class="s1">for await (const chunk of stream) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(new KUint8Array(chunk))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function replaceRequestBody&lt;T extends IncomingMessage&gt;(</span><span class="s3">\n  </span><span class="s1">base: T,</span><span class="s3">\n  </span><span class="s1">stream: Readable</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">for (const key in stream) {</span><span class="s3">\n    </span><span class="s1">let v = stream[key as keyof Readable] as any</span><span class="s3">\n    </span><span class="s1">if (typeof v === 'function') {</span><span class="s3">\n      </span><span class="s1">v = v.bind(base)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">base[key as keyof T] = v</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return base</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CloneableBody {</span><span class="s3">\n  </span><span class="s1">finalize(): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">cloneBodyStream(): Readable</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getCloneableBody&lt;T extends IncomingMessage&gt;(</span><span class="s3">\n  </span><span class="s1">readable: T</span><span class="s3">\n</span><span class="s1">): CloneableBody {</span><span class="s3">\n  </span><span class="s1">let buffered: Readable | null = null</span><span class="s3">\n\n  </span><span class="s1">const endPromise = new Promise&lt;void | { error?: unknown }&gt;(</span><span class="s3">\n    </span><span class="s1">(resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">readable.on('end', resolve)</span><span class="s3">\n      </span><span class="s1">readable.on('error', reject)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">).catch((error) =&gt; {</span><span class="s3">\n    </span><span class="s1">return { error }</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Replaces the original request body if necessary.</span><span class="s3">\n     </span><span class="s1">* This is done because once we read the body from the original request,</span><span class="s3">\n     </span><span class="s1">* we can't read it again.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async finalize(): Promise&lt;void&gt; {</span><span class="s3">\n      </span><span class="s1">if (buffered) {</span><span class="s3">\n        </span><span class="s1">const res = await endPromise</span><span class="s3">\n\n        </span><span class="s1">if (res &amp;&amp; typeof res === 'object' &amp;&amp; res.error) {</span><span class="s3">\n          </span><span class="s1">throw res.error</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">replaceRequestBody(readable, buffered)</span><span class="s3">\n        </span><span class="s1">buffered = readable</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clones the body stream</span><span class="s3">\n     </span><span class="s1">* to pass into a middleware</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cloneBodyStream() {</span><span class="s3">\n      </span><span class="s1">const input = buffered ?? readable</span><span class="s3">\n      </span><span class="s1">const p1 = new PassThrough()</span><span class="s3">\n      </span><span class="s1">const p2 = new PassThrough()</span><span class="s3">\n      </span><span class="s1">input.on('data', (chunk) =&gt; {</span><span class="s3">\n        </span><span class="s1">p1.push(chunk)</span><span class="s3">\n        </span><span class="s1">p2.push(chunk)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">input.on('end', () =&gt; {</span><span class="s3">\n        </span><span class="s1">p1.push(null)</span><span class="s3">\n        </span><span class="s1">p2.push(null)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">buffered = p2</span><span class="s3">\n      </span><span class="s1">return p1</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getCloneableBody&quot;</span><span class="s0">,</span><span class="s1">&quot;requestToBodyStream&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;KUint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceRequestBody&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;buffered&quot;</span><span class="s0">,</span><span class="s1">&quot;endPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;finalize&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneBodyStream&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;p1&quot;</span><span class="s0">,</span><span class="s1">&quot;PassThrough&quot;</span><span class="s0">,</span><span class="s1">&quot;p2&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;IAuCgBA,gBAAgB;eAAhBA;;IAnCAC,mBAAmB;eAAnBA;;;wBAFY;AAErB,SAASA,oBACdC,OAAkD,EAClDC,WAA8B,EAC9BC,MAAgB;IAEhB,OAAO,IAAIF,QAAQG,cAAc,CAAC;QAChCC,OAAO,OAAOC;YACZ,WAAW,MAAMC,SAASJ,OAAQ;gBAChCG,WAAWE,OAAO,CAAC,IAAIN,YAAYK;YACrC;YACAD,WAAWG,KAAK;QAClB;IACF;AACF;AAEA,SAASC,mBACPC,IAAO,EACPR,MAAgB;IAEhB,IAAK,MAAMS,OAAOT,OAAQ;QACxB,IAAIU,IAAIV,MAAM,CAACS,IAAsB;QACrC,IAAI,OAAOC,MAAM,YAAY;YAC3BA,IAAIA,EAAEC,IAAI,CAACH;QACb;QACAA,IAAI,CAACC,IAAe,GAAGC;IACzB;IAEA,OAAOF;AACT;AAOO,SAASZ,iBACdgB,QAAW;IAEX,IAAIC,WAA4B;IAEhC,MAAMC,aAAa,IAAIC,QACrB,CAACC,SAASC;QACRL,SAASM,EAAE,CAAC,OAAOF;QACnBJ,SAASM,EAAE,CAAC,SAASD;IACvB,GACAE,KAAK,CAAC,CAACC;QACP,OAAO;YAAEA;QAAM;IACjB;IAEA,OAAO;QACL;;;;KAIC,GACD,MAAMC;YACJ,IAAIR,UAAU;gBACZ,MAAMS,MAAM,MAAMR;gBAElB,IAAIQ,OAAO,OAAOA,QAAQ,YAAYA,IAAIF,KAAK,EAAE;oBAC/C,MAAME,IAAIF,KAAK;gBACjB;gBACAb,mBAAmBK,UAAUC;gBAC7BA,WAAWD;YACb;QACF;QACA;;;KAGC,GACDW;YACE,MAAMC,QAAQX,YAAYD;YAC1B,MAAMa,KAAK,IAAIC,mBAAW;YAC1B,MAAMC,KAAK,IAAID,mBAAW;YAC1BF,MAAMN,EAAE,CAAC,QAAQ,CAACd;gBAChBqB,GAAGG,IAAI,CAACxB;gBACRuB,GAAGC,IAAI,CAACxB;YACV;YACAoB,MAAMN,EAAE,CAAC,OAAO;gBACdO,GAAGG,IAAI,CAAC;gBACRD,GAAGC,IAAI,CAAC;YACV;YACAf,WAAWc;YACX,OAAOF;QACT;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>