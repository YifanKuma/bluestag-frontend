<html>
<head>
<title>create-component-tree.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create-component-tree.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/create-component-tree.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNodeSeedData, PreloadCallbacks } from './types'</span><span class="s3">\n</span><span class="s1">import React from 'react'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isClientReference,</span><span class="s3">\n  </span><span class="s1">isUseCacheFunction,</span><span class="s3">\n</span><span class="s1">} from '../../lib/client-and-server-references'</span><span class="s3">\n</span><span class="s1">import { getLayoutOrPageModule } from '../lib/app-dir-module'</span><span class="s3">\n</span><span class="s1">import type { LoaderTree } from '../lib/app-dir-module'</span><span class="s3">\n</span><span class="s1">import { interopDefault } from './interop-default'</span><span class="s3">\n</span><span class="s1">import { parseLoaderTree } from './parse-loader-tree'</span><span class="s3">\n</span><span class="s1">import type { AppRenderContext, GetDynamicParamFromSegment } from './app-render'</span><span class="s3">\n</span><span class="s1">import { createComponentStylesAndScripts } from './create-component-styles-and-scripts'</span><span class="s3">\n</span><span class="s1">import { getLayerAssets } from './get-layer-assets'</span><span class="s3">\n</span><span class="s1">import { hasLoadingComponentInTree } from './has-loading-component-in-tree'</span><span class="s3">\n</span><span class="s1">import { validateRevalidate } from '../lib/patch-fetch'</span><span class="s3">\n</span><span class="s1">import { PARALLEL_ROUTE_DEFAULT_PATH } from '../../client/components/builtin/default'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NextNodeServerSpan } from '../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'</span><span class="s3">\n</span><span class="s1">import type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../request/params'</span><span class="s3">\n</span><span class="s1">import { workUnitAsyncStorage } from './work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { OUTLET_BOUNDARY_NAME } from '../../lib/framework/boundary-constants'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">UseCacheLayoutComponentProps,</span><span class="s3">\n  </span><span class="s1">UseCachePageComponentProps,</span><span class="s3">\n</span><span class="s1">} from '../use-cache/use-cache-wrapper'</span><span class="s3">\n</span><span class="s1">import { DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">BOUNDARY_PREFIX,</span><span class="s3">\n  </span><span class="s1">BOUNDARY_SUFFIX,</span><span class="s3">\n  </span><span class="s1">BUILTIN_PREFIX,</span><span class="s3">\n  </span><span class="s1">getConventionPathByType,</span><span class="s3">\n  </span><span class="s1">isNextjsBuiltinFilePath,</span><span class="s3">\n</span><span class="s1">} from './segment-explorer-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use the provided loader tree to create the React Component tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createComponentTree(props: {</span><span class="s3">\n  </span><span class="s1">loaderTree: LoaderTree</span><span class="s3">\n  </span><span class="s1">parentParams: Params</span><span class="s3">\n  </span><span class="s1">rootLayoutIncluded: boolean</span><span class="s3">\n  </span><span class="s1">injectedCSS: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">injectedJS: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">injectedFontPreloadTags: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getMetadataReady: () =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">getViewportReady: () =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext</span><span class="s3">\n  </span><span class="s1">missingSlots?: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">preloadCallbacks: PreloadCallbacks</span><span class="s3">\n  </span><span class="s1">authInterrupts: boolean</span><span class="s3">\n  </span><span class="s1">StreamingMetadataOutlet: React.ComponentType | null</span><span class="s3">\n</span><span class="s1">}): Promise&lt;CacheNodeSeedData&gt; {</span><span class="s3">\n  </span><span class="s1">return getTracer().trace(</span><span class="s3">\n    </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">spanName: 'build component tree',</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">() =&gt; createComponentTreeInternal(props, true)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function errorMissingDefaultExport(</span><span class="s3">\n  </span><span class="s1">pagePath: string,</span><span class="s3">\n  </span><span class="s1">convention: string</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">const normalizedPagePath = pagePath === '/' ? '' : pagePath</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">`The default export is not a React Component in </span><span class="s3">\&quot;</span><span class="s1">${normalizedPagePath}/${convention}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const cacheNodeKey = 'c'</span><span class="s3">\n\n</span><span class="s1">async function createComponentTreeInternal(</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">loaderTree: tree,</span><span class="s3">\n    </span><span class="s1">parentParams,</span><span class="s3">\n    </span><span class="s1">rootLayoutIncluded,</span><span class="s3">\n    </span><span class="s1">injectedCSS,</span><span class="s3">\n    </span><span class="s1">injectedJS,</span><span class="s3">\n    </span><span class="s1">injectedFontPreloadTags,</span><span class="s3">\n    </span><span class="s1">getViewportReady,</span><span class="s3">\n    </span><span class="s1">getMetadataReady,</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">missingSlots,</span><span class="s3">\n    </span><span class="s1">preloadCallbacks,</span><span class="s3">\n    </span><span class="s1">authInterrupts,</span><span class="s3">\n    </span><span class="s1">StreamingMetadataOutlet,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">loaderTree: LoaderTree</span><span class="s3">\n    </span><span class="s1">parentParams: Params</span><span class="s3">\n    </span><span class="s1">rootLayoutIncluded: boolean</span><span class="s3">\n    </span><span class="s1">injectedCSS: Set&lt;string&gt;</span><span class="s3">\n    </span><span class="s1">injectedJS: Set&lt;string&gt;</span><span class="s3">\n    </span><span class="s1">injectedFontPreloadTags: Set&lt;string&gt;</span><span class="s3">\n    </span><span class="s1">getViewportReady: () =&gt; Promise&lt;void&gt;</span><span class="s3">\n    </span><span class="s1">getMetadataReady: () =&gt; Promise&lt;void&gt;</span><span class="s3">\n    </span><span class="s1">ctx: AppRenderContext</span><span class="s3">\n    </span><span class="s1">missingSlots?: Set&lt;string&gt;</span><span class="s3">\n    </span><span class="s1">preloadCallbacks: PreloadCallbacks</span><span class="s3">\n    </span><span class="s1">authInterrupts: boolean</span><span class="s3">\n    </span><span class="s1">StreamingMetadataOutlet: React.ComponentType | null</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">isRoot: boolean</span><span class="s3">\n</span><span class="s1">): Promise&lt;CacheNodeSeedData&gt; {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">renderOpts: { nextConfigOutput, experimental },</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">componentMod: {</span><span class="s3">\n      </span><span class="s1">SegmentViewNode,</span><span class="s3">\n      </span><span class="s1">HTTPAccessFallbackBoundary,</span><span class="s3">\n      </span><span class="s1">LayoutRouter,</span><span class="s3">\n      </span><span class="s1">RenderFromTemplateContext,</span><span class="s3">\n      </span><span class="s1">OutletBoundary,</span><span class="s3">\n      </span><span class="s1">ClientPageRoot,</span><span class="s3">\n      </span><span class="s1">ClientSegmentRoot,</span><span class="s3">\n      </span><span class="s1">createServerSearchParamsForServerPage,</span><span class="s3">\n      </span><span class="s1">createPrerenderSearchParamsForClientPage,</span><span class="s3">\n      </span><span class="s1">createServerParamsForServerSegment,</span><span class="s3">\n      </span><span class="s1">createPrerenderParamsForClientSegment,</span><span class="s3">\n      </span><span class="s1">serverHooks: { DynamicServerError },</span><span class="s3">\n      </span><span class="s1">Postpone,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">pagePath,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">isPrefetch,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n\n  </span><span class="s1">const { page, conventionPath, segment, modules, parallelRoutes } =</span><span class="s3">\n    </span><span class="s1">parseLoaderTree(tree)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">layout,</span><span class="s3">\n    </span><span class="s1">template,</span><span class="s3">\n    </span><span class="s1">error,</span><span class="s3">\n    </span><span class="s1">loading,</span><span class="s3">\n    </span><span class="s1">'not-found': notFound,</span><span class="s3">\n    </span><span class="s1">forbidden,</span><span class="s3">\n    </span><span class="s1">unauthorized,</span><span class="s3">\n  </span><span class="s1">} = modules</span><span class="s3">\n\n  </span><span class="s1">const injectedCSSWithCurrentLayout = new Set(injectedCSS)</span><span class="s3">\n  </span><span class="s1">const injectedJSWithCurrentLayout = new Set(injectedJS)</span><span class="s3">\n  </span><span class="s1">const injectedFontPreloadTagsWithCurrentLayout = new Set(</span><span class="s3">\n    </span><span class="s1">injectedFontPreloadTags</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const layerAssets = getLayerAssets({</span><span class="s3">\n    </span><span class="s1">preloadCallbacks,</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">layoutOrPagePath: conventionPath,</span><span class="s3">\n    </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n    </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n    </span><span class="s1">injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const [Template, templateStyles, templateScripts] = template</span><span class="s3">\n    </span><span class="s1">? await createComponentStylesAndScripts({</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">filePath: template[1],</span><span class="s3">\n        </span><span class="s1">getComponent: template[0],</span><span class="s3">\n        </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n        </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">: [React.Fragment]</span><span class="s3">\n\n  </span><span class="s1">const [ErrorComponent, errorStyles, errorScripts] = error</span><span class="s3">\n    </span><span class="s1">? await createComponentStylesAndScripts({</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">filePath: error[1],</span><span class="s3">\n        </span><span class="s1">getComponent: error[0],</span><span class="s3">\n        </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n        </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n\n  </span><span class="s1">const [Loading, loadingStyles, loadingScripts] = loading</span><span class="s3">\n    </span><span class="s1">? await createComponentStylesAndScripts({</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">filePath: loading[1],</span><span class="s3">\n        </span><span class="s1">getComponent: loading[0],</span><span class="s3">\n        </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n        </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n\n  </span><span class="s1">const isLayout = typeof layout !== 'undefined'</span><span class="s3">\n  </span><span class="s1">const isPage = typeof page !== 'undefined'</span><span class="s3">\n  </span><span class="s1">const { mod: layoutOrPageMod, modType } = await getTracer().trace(</span><span class="s3">\n    </span><span class="s1">NextNodeServerSpan.getLayoutOrPageModule,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">hideSpan: !(isLayout || isPage),</span><span class="s3">\n      </span><span class="s1">spanName: 'resolve segment modules',</span><span class="s3">\n      </span><span class="s1">attributes: {</span><span class="s3">\n        </span><span class="s1">'next.segment': segment,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">() =&gt; getLayoutOrPageModule(tree)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Checks if the current segment is a root layout.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const rootLayoutAtThisLevel = isLayout &amp;&amp; !rootLayoutIncluded</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Checks if the current segment or any level above it has a root layout.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const rootLayoutIncludedAtThisLevelOrAbove =</span><span class="s3">\n    </span><span class="s1">rootLayoutIncluded || rootLayoutAtThisLevel</span><span class="s3">\n\n  </span><span class="s1">const [NotFound, notFoundStyles] = notFound</span><span class="s3">\n    </span><span class="s1">? await createComponentStylesAndScripts({</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">filePath: notFound[1],</span><span class="s3">\n        </span><span class="s1">getComponent: notFound[0],</span><span class="s3">\n        </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n        </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n\n  </span><span class="s1">const [Forbidden, forbiddenStyles] =</span><span class="s3">\n    </span><span class="s1">authInterrupts &amp;&amp; forbidden</span><span class="s3">\n      </span><span class="s1">? await createComponentStylesAndScripts({</span><span class="s3">\n          </span><span class="s1">ctx,</span><span class="s3">\n          </span><span class="s1">filePath: forbidden[1],</span><span class="s3">\n          </span><span class="s1">getComponent: forbidden[0],</span><span class="s3">\n          </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n          </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">: []</span><span class="s3">\n\n  </span><span class="s1">const [Unauthorized, unauthorizedStyles] =</span><span class="s3">\n    </span><span class="s1">authInterrupts &amp;&amp; unauthorized</span><span class="s3">\n      </span><span class="s1">? await createComponentStylesAndScripts({</span><span class="s3">\n          </span><span class="s1">ctx,</span><span class="s3">\n          </span><span class="s1">filePath: unauthorized[1],</span><span class="s3">\n          </span><span class="s1">getComponent: unauthorized[0],</span><span class="s3">\n          </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n          </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">: []</span><span class="s3">\n\n  </span><span class="s1">let dynamic = layoutOrPageMod?.dynamic</span><span class="s3">\n\n  </span><span class="s1">if (nextConfigOutput === 'export') {</span><span class="s3">\n    </span><span class="s1">if (!dynamic || dynamic === 'auto') {</span><span class="s3">\n      </span><span class="s1">dynamic = 'error'</span><span class="s3">\n    </span><span class="s1">} else if (dynamic === 'force-dynamic') {</span><span class="s3">\n      </span><span class="s1">// force-dynamic is always incompatible with 'export'. We must interrupt the build</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n        </span><span class="s1">`Page with </span><span class="s3">\\</span><span class="s1">`dynamic = </span><span class="s3">\&quot;</span><span class="s1">force-dynamic</span><span class="s3">\&quot;\\</span><span class="s1">` couldn't be exported. </span><span class="s3">\\</span><span class="s1">`output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;\\</span><span class="s1">` requires all pages be renderable statically because there is no runtime server to dynamically render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof dynamic === 'string') {</span><span class="s3">\n    </span><span class="s1">// the nested most config wins so we only force-static</span><span class="s3">\n    </span><span class="s1">// if it's configured above any parent that configured</span><span class="s3">\n    </span><span class="s1">// otherwise</span><span class="s3">\n    </span><span class="s1">if (dynamic === 'error') {</span><span class="s3">\n      </span><span class="s1">workStore.dynamicShouldError = true</span><span class="s3">\n    </span><span class="s1">} else if (dynamic === 'force-dynamic') {</span><span class="s3">\n      </span><span class="s1">workStore.forceDynamic = true</span><span class="s3">\n\n      </span><span class="s1">// TODO: (PPR) remove this bailout once PPR is the default</span><span class="s3">\n      </span><span class="s1">if (workStore.isStaticGeneration &amp;&amp; !experimental.isRoutePPREnabled) {</span><span class="s3">\n        </span><span class="s1">// If the postpone API isn't available, we can't postpone the render and</span><span class="s3">\n        </span><span class="s1">// therefore we can't use the dynamic API.</span><span class="s3">\n        </span><span class="s1">const err = new DynamicServerError(</span><span class="s3">\n          </span><span class="s1">`Page with </span><span class="s3">\\</span><span class="s1">`dynamic = </span><span class="s3">\&quot;</span><span class="s1">force-dynamic</span><span class="s3">\&quot;\\</span><span class="s1">` won't be rendered statically.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">workStore.dynamicUsageDescription = err.message</span><span class="s3">\n        </span><span class="s1">workStore.dynamicUsageStack = err.stack</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">workStore.dynamicShouldError = false</span><span class="s3">\n      </span><span class="s1">workStore.forceStatic = dynamic === 'force-static'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof layoutOrPageMod?.fetchCache === 'string') {</span><span class="s3">\n    </span><span class="s1">workStore.fetchCache = layoutOrPageMod?.fetchCache</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof layoutOrPageMod?.revalidate !== 'undefined') {</span><span class="s3">\n    </span><span class="s1">validateRevalidate(layoutOrPageMod?.revalidate, workStore.route)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof layoutOrPageMod?.revalidate === 'number') {</span><span class="s3">\n    </span><span class="s1">const defaultRevalidate = layoutOrPageMod.revalidate as number</span><span class="s3">\n\n    </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n    </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n      </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n        </span><span class="s1">case 'prerender':</span><span class="s3">\n        </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n          </span><span class="s1">if (workUnitStore.revalidate &gt; defaultRevalidate) {</span><span class="s3">\n            </span><span class="s1">workUnitStore.revalidate = defaultRevalidate</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">case 'request':</span><span class="s3">\n          </span><span class="s1">// A request store doesn't have a revalidate property.</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">// createComponentTree is not called for these stores:</span><span class="s3">\n        </span><span class="s1">case 'cache':</span><span class="s3">\n        </span><span class="s1">case 'private-cache':</span><span class="s3">\n        </span><span class="s1">case 'prerender-client':</span><span class="s3">\n        </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!workStore.forceStatic &amp;&amp;</span><span class="s3">\n      </span><span class="s1">workStore.isStaticGeneration &amp;&amp;</span><span class="s3">\n      </span><span class="s1">defaultRevalidate === 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// If the postpone API isn't available, we can't postpone the render and</span><span class="s3">\n      </span><span class="s1">// therefore we can't use the dynamic API.</span><span class="s3">\n      </span><span class="s1">!experimental.isRoutePPREnabled</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const dynamicUsageDescription = `revalidate: 0 configured ${segment}`</span><span class="s3">\n      </span><span class="s1">workStore.dynamicUsageDescription = dynamicUsageDescription</span><span class="s3">\n\n      </span><span class="s1">throw new DynamicServerError(dynamicUsageDescription)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const isStaticGeneration = workStore.isStaticGeneration</span><span class="s3">\n\n  </span><span class="s1">// Assume the segment we're rendering contains only partial data if PPR is</span><span class="s3">\n  </span><span class="s1">// enabled and this is a statically generated response. This is used by the</span><span class="s3">\n  </span><span class="s1">// client Segment Cache after a prefetch to determine if it can skip the</span><span class="s3">\n  </span><span class="s1">// second request to fill in the dynamic data.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// It's OK for this to be `true` when the data is actually fully static, but</span><span class="s3">\n  </span><span class="s1">// it's not OK for this to be `false` when the data possibly contains holes.</span><span class="s3">\n  </span><span class="s1">// Although the value here is overly pessimistic, for prefetches, it will be</span><span class="s3">\n  </span><span class="s1">// replaced by a more specific value when the data is later processed into</span><span class="s3">\n  </span><span class="s1">// per-segment responses (see collect-segment-data.tsx)</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// For dynamic requests, this must always be `false` because dynamic responses</span><span class="s3">\n  </span><span class="s1">// are never partial.</span><span class="s3">\n  </span><span class="s1">const isPossiblyPartialResponse =</span><span class="s3">\n    </span><span class="s1">isStaticGeneration &amp;&amp; experimental.isRoutePPREnabled === true</span><span class="s3">\n\n  </span><span class="s1">const LayoutOrPage: React.ComponentType&lt;any&gt; | undefined = layoutOrPageMod</span><span class="s3">\n    </span><span class="s1">? interopDefault(layoutOrPageMod)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The React Component to render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let MaybeComponent = LayoutOrPage</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">const { isValidElementType } =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/react-is') as typeof import('next/dist/compiled/react-is')</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">typeof MaybeComponent !== 'undefined' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isValidElementType(MaybeComponent)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">errorMissingDefaultExport(pagePath, modType ?? 'page')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">typeof ErrorComponent !== 'undefined' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isValidElementType(ErrorComponent)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">errorMissingDefaultExport(pagePath, 'error')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof Loading !== 'undefined' &amp;&amp; !isValidElementType(Loading)) {</span><span class="s3">\n      </span><span class="s1">errorMissingDefaultExport(pagePath, 'loading')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof NotFound !== 'undefined' &amp;&amp; !isValidElementType(NotFound)) {</span><span class="s3">\n      </span><span class="s1">errorMissingDefaultExport(pagePath, 'not-found')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof Forbidden !== 'undefined' &amp;&amp; !isValidElementType(Forbidden)) {</span><span class="s3">\n      </span><span class="s1">errorMissingDefaultExport(pagePath, 'forbidden')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">typeof Unauthorized !== 'undefined' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isValidElementType(Unauthorized)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">errorMissingDefaultExport(pagePath, 'unauthorized')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handle dynamic segment params.</span><span class="s3">\n  </span><span class="s1">const segmentParam = getDynamicParamFromSegment(segment)</span><span class="s3">\n\n  </span><span class="s1">// Create object holding the parent params and current params</span><span class="s3">\n  </span><span class="s1">let currentParams: Params = parentParams</span><span class="s3">\n  </span><span class="s1">if (segmentParam &amp;&amp; segmentParam.value !== null) {</span><span class="s3">\n    </span><span class="s1">currentParams = {</span><span class="s3">\n      </span><span class="s1">...parentParams,</span><span class="s3">\n      </span><span class="s1">[segmentParam.param]: segmentParam.value,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Resolve the segment param</span><span class="s3">\n  </span><span class="s1">const actualSegment = segmentParam ? segmentParam.treeSegment : segment</span><span class="s3">\n  </span><span class="s1">const isSegmentViewEnabled =</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV === 'development' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">ctx.renderOpts.devtoolSegmentExplorer</span><span class="s3">\n  </span><span class="s1">const dir =</span><span class="s3">\n    </span><span class="s1">(process.env.NEXT_RUNTIME === 'edge'</span><span class="s3">\n      </span><span class="s1">? process.env.__NEXT_EDGE_PROJECT_DIR</span><span class="s3">\n      </span><span class="s1">: ctx.renderOpts.dir) || ''</span><span class="s3">\n\n  </span><span class="s1">// Use the same condition to render metadataOutlet as metadata</span><span class="s3">\n  </span><span class="s1">const metadataOutlet = StreamingMetadataOutlet ? (</span><span class="s3">\n    </span><span class="s1">&lt;StreamingMetadataOutlet /&gt;</span><span class="s3">\n  </span><span class="s1">) : (</span><span class="s3">\n    </span><span class="s1">&lt;MetadataOutlet ready={getMetadataReady} /&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const [notFoundElement, notFoundFilePath] =</span><span class="s3">\n    </span><span class="s1">await createBoundaryConventionElement({</span><span class="s3">\n      </span><span class="s1">ctx,</span><span class="s3">\n      </span><span class="s1">conventionName: 'not-found',</span><span class="s3">\n      </span><span class="s1">Component: NotFound,</span><span class="s3">\n      </span><span class="s1">styles: notFoundStyles,</span><span class="s3">\n      </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const [forbiddenElement] = await createBoundaryConventionElement({</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">conventionName: 'forbidden',</span><span class="s3">\n    </span><span class="s1">Component: Forbidden,</span><span class="s3">\n    </span><span class="s1">styles: forbiddenStyles,</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const [unauthorizedElement] = await createBoundaryConventionElement({</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">conventionName: 'unauthorized',</span><span class="s3">\n    </span><span class="s1">Component: Unauthorized,</span><span class="s3">\n    </span><span class="s1">styles: unauthorizedStyles,</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// TODO: Combine this `map` traversal with the loop below that turns the array</span><span class="s3">\n  </span><span class="s1">// into an object.</span><span class="s3">\n  </span><span class="s1">const parallelRouteMap = await Promise.all(</span><span class="s3">\n    </span><span class="s1">Object.keys(parallelRoutes).map(</span><span class="s3">\n      </span><span class="s1">async (</span><span class="s3">\n        </span><span class="s1">parallelRouteKey</span><span class="s3">\n      </span><span class="s1">): Promise&lt;[string, React.ReactNode, CacheNodeSeedData | null]&gt; =&gt; {</span><span class="s3">\n        </span><span class="s1">const isChildrenRouteKey = parallelRouteKey === 'children'</span><span class="s3">\n        </span><span class="s1">const parallelRoute = parallelRoutes[parallelRouteKey]</span><span class="s3">\n\n        </span><span class="s1">const notFoundComponent = isChildrenRouteKey</span><span class="s3">\n          </span><span class="s1">? notFoundElement</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n        </span><span class="s1">const forbiddenComponent = isChildrenRouteKey</span><span class="s3">\n          </span><span class="s1">? forbiddenElement</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n        </span><span class="s1">const unauthorizedComponent = isChildrenRouteKey</span><span class="s3">\n          </span><span class="s1">? unauthorizedElement</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n        </span><span class="s1">// if we're prefetching and that there's a Loading component, we bail out</span><span class="s3">\n        </span><span class="s1">// otherwise we keep rendering for the prefetch.</span><span class="s3">\n        </span><span class="s1">// We also want to bail out if there's no Loading component in the tree.</span><span class="s3">\n        </span><span class="s1">let childCacheNodeSeedData: CacheNodeSeedData | null = null</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">// Before PPR, the way instant navigations work in Next.js is we</span><span class="s3">\n          </span><span class="s1">// prefetch everything up to the first route segment that defines a</span><span class="s3">\n          </span><span class="s1">// loading.tsx boundary. (We do the same if there's no loading</span><span class="s3">\n          </span><span class="s1">// boundary in the entire tree, because we don't want to prefetch too</span><span class="s3">\n          </span><span class="s1">// much) The rest of the tree is deferred until the actual navigation.</span><span class="s3">\n          </span><span class="s1">// It does not take into account whether the data is dynamic — even if</span><span class="s3">\n          </span><span class="s1">// the tree is completely static, it will still defer everything</span><span class="s3">\n          </span><span class="s1">// inside the loading boundary.</span><span class="s3">\n          </span><span class="s1">//</span><span class="s3">\n          </span><span class="s1">// This behavior predates PPR and is only relevant if the</span><span class="s3">\n          </span><span class="s1">// PPR flag is not enabled.</span><span class="s3">\n          </span><span class="s1">isPrefetch &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(Loading || !hasLoadingComponentInTree(parallelRoute)) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// The approach with PPR is different — loading.tsx behaves like a</span><span class="s3">\n          </span><span class="s1">// regular Suspense boundary and has no special behavior.</span><span class="s3">\n          </span><span class="s1">//</span><span class="s3">\n          </span><span class="s1">// With PPR, we prefetch as deeply as possible, and only defer when</span><span class="s3">\n          </span><span class="s1">// dynamic data is accessed. If so, we only defer the nearest parent</span><span class="s3">\n          </span><span class="s1">// Suspense boundary of the dynamic data access, regardless of whether</span><span class="s3">\n          </span><span class="s1">// the boundary is defined by loading.tsx or a normal &lt;Suspense&gt;</span><span class="s3">\n          </span><span class="s1">// component in userspace.</span><span class="s3">\n          </span><span class="s1">//</span><span class="s3">\n          </span><span class="s1">// NOTE: In practice this usually means we'll end up prefetching more</span><span class="s3">\n          </span><span class="s1">// than we were before PPR, which may or may not be considered a</span><span class="s3">\n          </span><span class="s1">// performance regression by some apps. The plan is to address this</span><span class="s3">\n          </span><span class="s1">// before General Availability of PPR by introducing granular</span><span class="s3">\n          </span><span class="s1">// per-segment fetching, so we can reuse as much of the tree as</span><span class="s3">\n          </span><span class="s1">// possible during both prefetches and dynamic navigations. But during</span><span class="s3">\n          </span><span class="s1">// the beta period, we should be clear about this trade off in our</span><span class="s3">\n          </span><span class="s1">// communications.</span><span class="s3">\n          </span><span class="s1">!experimental.isRoutePPREnabled</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// Don't prefetch this child. This will trigger a lazy fetch by the</span><span class="s3">\n          </span><span class="s1">// client router.</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// Create the child component</span><span class="s3">\n\n          </span><span class="s1">if (process.env.NODE_ENV === 'development' &amp;&amp; missingSlots) {</span><span class="s3">\n            </span><span class="s1">// When we detect the default fallback (which triggers a 404), we collect the missing slots</span><span class="s3">\n            </span><span class="s1">// to provide more helpful debug information during development mode.</span><span class="s3">\n            </span><span class="s1">const parsedTree = parseLoaderTree(parallelRoute)</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">parsedTree.conventionPath?.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">missingSlots.add(parallelRouteKey)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const seedData = await createComponentTreeInternal(</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">loaderTree: parallelRoute,</span><span class="s3">\n              </span><span class="s1">parentParams: currentParams,</span><span class="s3">\n              </span><span class="s1">rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,</span><span class="s3">\n              </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n              </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n              </span><span class="s1">injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,</span><span class="s3">\n              </span><span class="s1">// `getMetadataReady` and `getViewportReady` are used to conditionally throw. In the case of parallel routes we will have more than one page</span><span class="s3">\n              </span><span class="s1">// but we only want to throw on the first one.</span><span class="s3">\n              </span><span class="s1">getMetadataReady: isChildrenRouteKey</span><span class="s3">\n                </span><span class="s1">? getMetadataReady</span><span class="s3">\n                </span><span class="s1">: () =&gt; Promise.resolve(),</span><span class="s3">\n              </span><span class="s1">getViewportReady: isChildrenRouteKey</span><span class="s3">\n                </span><span class="s1">? getViewportReady</span><span class="s3">\n                </span><span class="s1">: () =&gt; Promise.resolve(),</span><span class="s3">\n              </span><span class="s1">ctx,</span><span class="s3">\n              </span><span class="s1">missingSlots,</span><span class="s3">\n              </span><span class="s1">preloadCallbacks,</span><span class="s3">\n              </span><span class="s1">authInterrupts,</span><span class="s3">\n              </span><span class="s1">// `StreamingMetadataOutlet` is used to conditionally throw. In the case of parallel routes we will have more than one page</span><span class="s3">\n              </span><span class="s1">// but we only want to throw on the first one.</span><span class="s3">\n              </span><span class="s1">StreamingMetadataOutlet: isChildrenRouteKey</span><span class="s3">\n                </span><span class="s1">? StreamingMetadataOutlet</span><span class="s3">\n                </span><span class="s1">: null,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">false</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">childCacheNodeSeedData = seedData</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const templateNode = (</span><span class="s3">\n          </span><span class="s1">&lt;Template&gt;</span><span class="s3">\n            </span><span class="s1">&lt;RenderFromTemplateContext /&gt;</span><span class="s3">\n          </span><span class="s1">&lt;/Template&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">const templateFilePath = getConventionPathByType(tree, dir, 'template')</span><span class="s3">\n        </span><span class="s1">const errorFilePath = getConventionPathByType(tree, dir, 'error')</span><span class="s3">\n        </span><span class="s1">const loadingFilePath = getConventionPathByType(tree, dir, 'loading')</span><span class="s3">\n        </span><span class="s1">const globalErrorFilePath = isRoot</span><span class="s3">\n          </span><span class="s1">? getConventionPathByType(tree, dir, 'global-error')</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n        </span><span class="s1">const wrappedErrorStyles =</span><span class="s3">\n          </span><span class="s1">isSegmentViewEnabled &amp;&amp; errorFilePath ? (</span><span class="s3">\n            </span><span class="s1">&lt;SegmentViewNode type=</span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot; </span><span class="s1">pagePath={errorFilePath}&gt;</span><span class="s3">\n              </span><span class="s1">{errorStyles}</span><span class="s3">\n            </span><span class="s1">&lt;/SegmentViewNode&gt;</span><span class="s3">\n          </span><span class="s1">) : (</span><span class="s3">\n            </span><span class="s1">errorStyles</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// Add a suffix to avoid conflict with the segment view node representing rendered file.</span><span class="s3">\n        </span><span class="s1">// existence: not-found.tsx@boundary</span><span class="s3">\n        </span><span class="s1">// rendered: not-found.tsx</span><span class="s3">\n        </span><span class="s1">const fileNameSuffix = BOUNDARY_SUFFIX</span><span class="s3">\n        </span><span class="s1">const segmentViewBoundaries = isSegmentViewEnabled ? (</span><span class="s3">\n          </span><span class="s1">&lt;&gt;</span><span class="s3">\n            </span><span class="s1">{notFoundFilePath &amp;&amp; (</span><span class="s3">\n              </span><span class="s1">&lt;SegmentViewNode</span><span class="s3">\n                </span><span class="s1">type={`${BOUNDARY_PREFIX}not-found`}</span><span class="s3">\n                </span><span class="s1">pagePath={notFoundFilePath + fileNameSuffix}</span><span class="s3">\n              </span><span class="s1">/&gt;</span><span class="s3">\n            </span><span class="s1">)}</span><span class="s3">\n            </span><span class="s1">{loadingFilePath &amp;&amp; (</span><span class="s3">\n              </span><span class="s1">&lt;SegmentViewNode</span><span class="s3">\n                </span><span class="s1">type={`${BOUNDARY_PREFIX}loading`}</span><span class="s3">\n                </span><span class="s1">pagePath={loadingFilePath + fileNameSuffix}</span><span class="s3">\n              </span><span class="s1">/&gt;</span><span class="s3">\n            </span><span class="s1">)}</span><span class="s3">\n            </span><span class="s1">{errorFilePath &amp;&amp; (</span><span class="s3">\n              </span><span class="s1">&lt;SegmentViewNode</span><span class="s3">\n                </span><span class="s1">type={`${BOUNDARY_PREFIX}error`}</span><span class="s3">\n                </span><span class="s1">pagePath={errorFilePath + fileNameSuffix}</span><span class="s3">\n              </span><span class="s1">/&gt;</span><span class="s3">\n            </span><span class="s1">)}</span><span class="s3">\n            </span><span class="s1">{/* Only show global-error when it's the builtin one */}</span><span class="s3">\n            </span><span class="s1">{globalErrorFilePath &amp;&amp; (</span><span class="s3">\n              </span><span class="s1">&lt;SegmentViewNode</span><span class="s3">\n                </span><span class="s1">type={`${BOUNDARY_PREFIX}global-error`}</span><span class="s3">\n                </span><span class="s1">pagePath={</span><span class="s3">\n                  </span><span class="s1">isNextjsBuiltinFilePath(globalErrorFilePath)</span><span class="s3">\n                    </span><span class="s1">? `${BUILTIN_PREFIX}global-error.js${fileNameSuffix}`</span><span class="s3">\n                    </span><span class="s1">: globalErrorFilePath</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">/&gt;</span><span class="s3">\n            </span><span class="s1">)}</span><span class="s3">\n            </span><span class="s1">{/* do not surface forbidden and unauthorized boundaries yet as they're unstable */}</span><span class="s3">\n          </span><span class="s1">&lt;/&gt;</span><span class="s3">\n        </span><span class="s1">) : null</span><span class="s3">\n\n        </span><span class="s1">return [</span><span class="s3">\n          </span><span class="s1">parallelRouteKey,</span><span class="s3">\n          </span><span class="s1">&lt;LayoutRouter</span><span class="s3">\n            </span><span class="s1">parallelRouterKey={parallelRouteKey}</span><span class="s3">\n            </span><span class="s1">// TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.</span><span class="s3">\n            </span><span class="s1">error={ErrorComponent}</span><span class="s3">\n            </span><span class="s1">errorStyles={wrappedErrorStyles}</span><span class="s3">\n            </span><span class="s1">errorScripts={errorScripts}</span><span class="s3">\n            </span><span class="s1">template={</span><span class="s3">\n              </span><span class="s1">// Only render SegmentViewNode when there's an actual template</span><span class="s3">\n              </span><span class="s1">isSegmentViewEnabled &amp;&amp; templateFilePath ? (</span><span class="s3">\n                </span><span class="s1">&lt;SegmentViewNode type=</span><span class="s3">\&quot;</span><span class="s1">template</span><span class="s3">\&quot; </span><span class="s1">pagePath={templateFilePath}&gt;</span><span class="s3">\n                  </span><span class="s1">{templateNode}</span><span class="s3">\n                </span><span class="s1">&lt;/SegmentViewNode&gt;</span><span class="s3">\n              </span><span class="s1">) : (</span><span class="s3">\n                </span><span class="s1">templateNode</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">templateStyles={templateStyles}</span><span class="s3">\n            </span><span class="s1">templateScripts={templateScripts}</span><span class="s3">\n            </span><span class="s1">notFound={notFoundComponent}</span><span class="s3">\n            </span><span class="s1">forbidden={forbiddenComponent}</span><span class="s3">\n            </span><span class="s1">unauthorized={unauthorizedComponent}</span><span class="s3">\n            </span><span class="s1">{...(isSegmentViewEnabled &amp;&amp; { segmentViewBoundaries })}</span><span class="s3">\n          </span><span class="s1">/&gt;,</span><span class="s3">\n          </span><span class="s1">childCacheNodeSeedData,</span><span class="s3">\n        </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Convert the parallel route map into an object after all promises have been resolved.</span><span class="s3">\n  </span><span class="s1">let parallelRouteProps: { [key: string]: React.ReactNode } = {}</span><span class="s3">\n  </span><span class="s1">let parallelRouteCacheNodeSeedData: {</span><span class="s3">\n    </span><span class="s1">[key: string]: CacheNodeSeedData | null</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n  </span><span class="s1">for (const parallelRoute of parallelRouteMap) {</span><span class="s3">\n    </span><span class="s1">const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute</span><span class="s3">\n    </span><span class="s1">parallelRouteProps[parallelRouteKey] = parallelRouteProp</span><span class="s3">\n    </span><span class="s1">parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let loadingElement = Loading ? &lt;Loading key=</span><span class="s3">\&quot;</span><span class="s1">l</span><span class="s3">\&quot; </span><span class="s1">/&gt; : null</span><span class="s3">\n  </span><span class="s1">const loadingFilePath = getConventionPathByType(tree, dir, 'loading')</span><span class="s3">\n  </span><span class="s1">if (isSegmentViewEnabled &amp;&amp; loadingElement) {</span><span class="s3">\n    </span><span class="s1">if (loadingFilePath) {</span><span class="s3">\n      </span><span class="s1">loadingElement = (</span><span class="s3">\n        </span><span class="s1">&lt;SegmentViewNode</span><span class="s3">\n          </span><span class="s1">key={cacheNodeKey + '-loading'}</span><span class="s3">\n          </span><span class="s1">type=</span><span class="s3">\&quot;</span><span class="s1">loading</span><span class="s3">\&quot;\n          </span><span class="s1">pagePath={loadingFilePath}</span><span class="s3">\n        </span><span class="s1">&gt;</span><span class="s3">\n          </span><span class="s1">{loadingElement}</span><span class="s3">\n        </span><span class="s1">&lt;/SegmentViewNode&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const loadingData: LoadingModuleData = loadingElement</span><span class="s3">\n    </span><span class="s1">? [loadingElement, loadingStyles, loadingScripts]</span><span class="s3">\n    </span><span class="s1">: null</span><span class="s3">\n\n  </span><span class="s1">// When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component</span><span class="s3">\n  </span><span class="s1">if (!MaybeComponent) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">actualSegment,</span><span class="s3">\n      </span><span class="s1">&lt;React.Fragment key={cacheNodeKey}&gt;</span><span class="s3">\n        </span><span class="s1">{layerAssets}</span><span class="s3">\n        </span><span class="s1">{parallelRouteProps.children}</span><span class="s3">\n      </span><span class="s1">&lt;/React.Fragment&gt;,</span><span class="s3">\n      </span><span class="s1">parallelRouteCacheNodeSeedData,</span><span class="s3">\n      </span><span class="s1">loadingData,</span><span class="s3">\n      </span><span class="s1">isPossiblyPartialResponse,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const Component = MaybeComponent</span><span class="s3">\n  </span><span class="s1">// If force-dynamic is used and the current render supports postponing, we</span><span class="s3">\n  </span><span class="s1">// replace it with a node that will postpone the render. This ensures that the</span><span class="s3">\n  </span><span class="s1">// postpone is invoked during the react render phase and not during the next</span><span class="s3">\n  </span><span class="s1">// render phase.</span><span class="s3">\n  </span><span class="s1">// @TODO this does not actually do what it seems like it would or should do. The idea is that</span><span class="s3">\n  </span><span class="s1">// if we are rendering in a force-dynamic mode and we can postpone we should only make the segments</span><span class="s3">\n  </span><span class="s1">// that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However</span><span class="s3">\n  </span><span class="s1">// because this comes after the children traversal and the static generation store is mutated every segment</span><span class="s3">\n  </span><span class="s1">// along the parent path of a force-dynamic segment will hit this condition effectively making the entire</span><span class="s3">\n  </span><span class="s1">// render force-dynamic. We should refactor this function so that we can correctly track which segments</span><span class="s3">\n  </span><span class="s1">// need to be dynamic</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">workStore.isStaticGeneration &amp;&amp;</span><span class="s3">\n    </span><span class="s1">workStore.forceDynamic &amp;&amp;</span><span class="s3">\n    </span><span class="s1">experimental.isRoutePPREnabled</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">actualSegment,</span><span class="s3">\n      </span><span class="s1">&lt;React.Fragment key={cacheNodeKey}&gt;</span><span class="s3">\n        </span><span class="s1">&lt;Postpone</span><span class="s3">\n          </span><span class="s1">reason='dynamic = </span><span class="s3">\&quot;</span><span class="s1">force-dynamic</span><span class="s3">\&quot; </span><span class="s1">was used'</span><span class="s3">\n          </span><span class="s1">route={workStore.route}</span><span class="s3">\n        </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">{layerAssets}</span><span class="s3">\n      </span><span class="s1">&lt;/React.Fragment&gt;,</span><span class="s3">\n      </span><span class="s1">parallelRouteCacheNodeSeedData,</span><span class="s3">\n      </span><span class="s1">loadingData,</span><span class="s3">\n      </span><span class="s1">true,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const isClientComponent = isClientReference(layoutOrPageMod)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV === 'development' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'params' in parallelRouteProps</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// @TODO consider making this an error and running the check in build as well</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot; </span><span class="s1">is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isPage) {</span><span class="s3">\n    </span><span class="s1">const PageComponent = Component</span><span class="s3">\n\n    </span><span class="s1">// Assign searchParams to props if this is a page</span><span class="s3">\n    </span><span class="s1">let pageElement: React.ReactNode</span><span class="s3">\n    </span><span class="s1">if (isClientComponent) {</span><span class="s3">\n      </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n        </span><span class="s1">const promiseOfParams =</span><span class="s3">\n          </span><span class="s1">createPrerenderParamsForClientSegment(currentParams)</span><span class="s3">\n        </span><span class="s1">const promiseOfSearchParams =</span><span class="s3">\n          </span><span class="s1">createPrerenderSearchParamsForClientPage(workStore)</span><span class="s3">\n        </span><span class="s1">pageElement = (</span><span class="s3">\n          </span><span class="s1">&lt;ClientPageRoot</span><span class="s3">\n            </span><span class="s1">Component={PageComponent}</span><span class="s3">\n            </span><span class="s1">searchParams={query}</span><span class="s3">\n            </span><span class="s1">params={currentParams}</span><span class="s3">\n            </span><span class="s1">promises={[promiseOfSearchParams, promiseOfParams]}</span><span class="s3">\n          </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pageElement = (</span><span class="s3">\n          </span><span class="s1">&lt;ClientPageRoot</span><span class="s3">\n            </span><span class="s1">Component={PageComponent}</span><span class="s3">\n            </span><span class="s1">searchParams={query}</span><span class="s3">\n            </span><span class="s1">params={currentParams}</span><span class="s3">\n          </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// If we are passing params to a server component Page we need to track</span><span class="s3">\n      </span><span class="s1">// their usage in case the current render mode tracks dynamic API usage.</span><span class="s3">\n      </span><span class="s1">const params = createServerParamsForServerSegment(</span><span class="s3">\n        </span><span class="s1">currentParams,</span><span class="s3">\n        </span><span class="s1">workStore</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// If we are passing searchParams to a server component Page we need to</span><span class="s3">\n      </span><span class="s1">// track their usage in case the current render mode tracks dynamic API</span><span class="s3">\n      </span><span class="s1">// usage.</span><span class="s3">\n      </span><span class="s1">let searchParams = createServerSearchParamsForServerPage(query, workStore)</span><span class="s3">\n\n      </span><span class="s1">if (isUseCacheFunction(PageComponent)) {</span><span class="s3">\n        </span><span class="s1">const UseCachePageComponent: React.ComponentType&lt;UseCachePageComponentProps&gt; =</span><span class="s3">\n          </span><span class="s1">PageComponent</span><span class="s3">\n\n        </span><span class="s1">pageElement = (</span><span class="s3">\n          </span><span class="s1">&lt;UseCachePageComponent</span><span class="s3">\n            </span><span class="s1">params={params}</span><span class="s3">\n            </span><span class="s1">searchParams={searchParams}</span><span class="s3">\n            </span><span class="s1">$$isPageComponent</span><span class="s3">\n          </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pageElement = (</span><span class="s3">\n          </span><span class="s1">&lt;PageComponent params={params} searchParams={searchParams} /&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const isDefaultSegment = segment === DEFAULT_SEGMENT_KEY</span><span class="s3">\n    </span><span class="s1">const pageFilePath =</span><span class="s3">\n      </span><span class="s1">getConventionPathByType(tree, dir, 'page') ??</span><span class="s3">\n      </span><span class="s1">getConventionPathByType(tree, dir, 'defaultPage')</span><span class="s3">\n    </span><span class="s1">const segmentType = isDefaultSegment ? 'default' : 'page'</span><span class="s3">\n    </span><span class="s1">const wrappedPageElement =</span><span class="s3">\n      </span><span class="s1">isSegmentViewEnabled &amp;&amp; pageFilePath ? (</span><span class="s3">\n        </span><span class="s1">&lt;SegmentViewNode</span><span class="s3">\n          </span><span class="s1">key={cacheNodeKey + '-' + segmentType}</span><span class="s3">\n          </span><span class="s1">type={segmentType}</span><span class="s3">\n          </span><span class="s1">pagePath={pageFilePath}</span><span class="s3">\n        </span><span class="s1">&gt;</span><span class="s3">\n          </span><span class="s1">{pageElement}</span><span class="s3">\n        </span><span class="s1">&lt;/SegmentViewNode&gt;</span><span class="s3">\n      </span><span class="s1">) : (</span><span class="s3">\n        </span><span class="s1">pageElement</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">actualSegment,</span><span class="s3">\n      </span><span class="s1">&lt;React.Fragment key={cacheNodeKey}&gt;</span><span class="s3">\n        </span><span class="s1">{wrappedPageElement}</span><span class="s3">\n        </span><span class="s1">{layerAssets}</span><span class="s3">\n        </span><span class="s1">&lt;OutletBoundary&gt;</span><span class="s3">\n          </span><span class="s1">&lt;MetadataOutlet ready={getViewportReady} /&gt;</span><span class="s3">\n          </span><span class="s1">{metadataOutlet}</span><span class="s3">\n        </span><span class="s1">&lt;/OutletBoundary&gt;</span><span class="s3">\n      </span><span class="s1">&lt;/React.Fragment&gt;,</span><span class="s3">\n      </span><span class="s1">parallelRouteCacheNodeSeedData,</span><span class="s3">\n      </span><span class="s1">loadingData,</span><span class="s3">\n      </span><span class="s1">isPossiblyPartialResponse,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const SegmentComponent = Component</span><span class="s3">\n    </span><span class="s1">const isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot =</span><span class="s3">\n      </span><span class="s1">rootLayoutAtThisLevel &amp;&amp;</span><span class="s3">\n      </span><span class="s1">'children' in parallelRoutes &amp;&amp;</span><span class="s3">\n      </span><span class="s1">Object.keys(parallelRoutes).length &gt; 1</span><span class="s3">\n\n    </span><span class="s1">let segmentNode: React.ReactNode</span><span class="s3">\n\n    </span><span class="s1">if (isClientComponent) {</span><span class="s3">\n      </span><span class="s1">let clientSegment: React.ReactNode</span><span class="s3">\n\n      </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n        </span><span class="s1">const promiseOfParams =</span><span class="s3">\n          </span><span class="s1">createPrerenderParamsForClientSegment(currentParams)</span><span class="s3">\n\n        </span><span class="s1">clientSegment = (</span><span class="s3">\n          </span><span class="s1">&lt;ClientSegmentRoot</span><span class="s3">\n            </span><span class="s1">Component={SegmentComponent}</span><span class="s3">\n            </span><span class="s1">slots={parallelRouteProps}</span><span class="s3">\n            </span><span class="s1">params={currentParams}</span><span class="s3">\n            </span><span class="s1">promise={promiseOfParams}</span><span class="s3">\n          </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">clientSegment = (</span><span class="s3">\n          </span><span class="s1">&lt;ClientSegmentRoot</span><span class="s3">\n            </span><span class="s1">Component={SegmentComponent}</span><span class="s3">\n            </span><span class="s1">slots={parallelRouteProps}</span><span class="s3">\n            </span><span class="s1">params={currentParams}</span><span class="s3">\n          </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {</span><span class="s3">\n        </span><span class="s1">let notfoundClientSegment: React.ReactNode</span><span class="s3">\n        </span><span class="s1">let forbiddenClientSegment: React.ReactNode</span><span class="s3">\n        </span><span class="s1">let unauthorizedClientSegment: React.ReactNode</span><span class="s3">\n        </span><span class="s1">// TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.</span><span class="s3">\n        </span><span class="s1">// This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,</span><span class="s3">\n        </span><span class="s1">// but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.</span><span class="s3">\n        </span><span class="s1">// We should instead look into handling the fallback behavior differently in development mode so that it doesn't</span><span class="s3">\n        </span><span class="s1">// rely on the `NotFound` behavior.</span><span class="s3">\n        </span><span class="s1">notfoundClientSegment = createErrorBoundaryClientSegmentRoot({</span><span class="s3">\n          </span><span class="s1">ErrorBoundaryComponent: NotFound,</span><span class="s3">\n          </span><span class="s1">errorElement: notFoundElement,</span><span class="s3">\n          </span><span class="s1">ClientSegmentRoot,</span><span class="s3">\n          </span><span class="s1">layerAssets,</span><span class="s3">\n          </span><span class="s1">SegmentComponent,</span><span class="s3">\n          </span><span class="s1">currentParams,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">forbiddenClientSegment = createErrorBoundaryClientSegmentRoot({</span><span class="s3">\n          </span><span class="s1">ErrorBoundaryComponent: Forbidden,</span><span class="s3">\n          </span><span class="s1">errorElement: forbiddenElement,</span><span class="s3">\n          </span><span class="s1">ClientSegmentRoot,</span><span class="s3">\n          </span><span class="s1">layerAssets,</span><span class="s3">\n          </span><span class="s1">SegmentComponent,</span><span class="s3">\n          </span><span class="s1">currentParams,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">unauthorizedClientSegment = createErrorBoundaryClientSegmentRoot({</span><span class="s3">\n          </span><span class="s1">ErrorBoundaryComponent: Unauthorized,</span><span class="s3">\n          </span><span class="s1">errorElement: unauthorizedElement,</span><span class="s3">\n          </span><span class="s1">ClientSegmentRoot,</span><span class="s3">\n          </span><span class="s1">layerAssets,</span><span class="s3">\n          </span><span class="s1">SegmentComponent,</span><span class="s3">\n          </span><span class="s1">currentParams,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">notfoundClientSegment ||</span><span class="s3">\n          </span><span class="s1">forbiddenClientSegment ||</span><span class="s3">\n          </span><span class="s1">unauthorizedClientSegment</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">segmentNode = (</span><span class="s3">\n            </span><span class="s1">&lt;HTTPAccessFallbackBoundary</span><span class="s3">\n              </span><span class="s1">key={cacheNodeKey}</span><span class="s3">\n              </span><span class="s1">notFound={notfoundClientSegment}</span><span class="s3">\n              </span><span class="s1">forbidden={forbiddenClientSegment}</span><span class="s3">\n              </span><span class="s1">unauthorized={unauthorizedClientSegment}</span><span class="s3">\n            </span><span class="s1">&gt;</span><span class="s3">\n              </span><span class="s1">{layerAssets}</span><span class="s3">\n              </span><span class="s1">{clientSegment}</span><span class="s3">\n            </span><span class="s1">&lt;/HTTPAccessFallbackBoundary&gt;</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">segmentNode = (</span><span class="s3">\n            </span><span class="s1">&lt;React.Fragment key={cacheNodeKey}&gt;</span><span class="s3">\n              </span><span class="s1">{layerAssets}</span><span class="s3">\n              </span><span class="s1">{clientSegment}</span><span class="s3">\n            </span><span class="s1">&lt;/React.Fragment&gt;</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">segmentNode = (</span><span class="s3">\n          </span><span class="s1">&lt;React.Fragment key={cacheNodeKey}&gt;</span><span class="s3">\n            </span><span class="s1">{layerAssets}</span><span class="s3">\n            </span><span class="s1">{clientSegment}</span><span class="s3">\n          </span><span class="s1">&lt;/React.Fragment&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const params = createServerParamsForServerSegment(</span><span class="s3">\n        </span><span class="s1">currentParams,</span><span class="s3">\n        </span><span class="s1">workStore</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">let serverSegment: React.ReactNode</span><span class="s3">\n\n      </span><span class="s1">if (isUseCacheFunction(SegmentComponent)) {</span><span class="s3">\n        </span><span class="s1">const UseCacheLayoutComponent: React.ComponentType&lt;UseCacheLayoutComponentProps&gt; =</span><span class="s3">\n          </span><span class="s1">SegmentComponent</span><span class="s3">\n\n        </span><span class="s1">serverSegment = (</span><span class="s3">\n          </span><span class="s1">&lt;UseCacheLayoutComponent</span><span class="s3">\n            </span><span class="s1">{...parallelRouteProps}</span><span class="s3">\n            </span><span class="s1">params={params}</span><span class="s3">\n            </span><span class="s1">$$isLayoutComponent</span><span class="s3">\n          </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">serverSegment = (</span><span class="s3">\n          </span><span class="s1">&lt;SegmentComponent {...parallelRouteProps} params={params} /&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {</span><span class="s3">\n        </span><span class="s1">// TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.</span><span class="s3">\n        </span><span class="s1">// This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,</span><span class="s3">\n        </span><span class="s1">// but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.</span><span class="s3">\n        </span><span class="s1">// We should instead look into handling the fallback behavior differently in development mode so that it doesn't</span><span class="s3">\n        </span><span class="s1">// rely on the `NotFound` behavior.</span><span class="s3">\n        </span><span class="s1">segmentNode = (</span><span class="s3">\n          </span><span class="s1">&lt;HTTPAccessFallbackBoundary</span><span class="s3">\n            </span><span class="s1">key={cacheNodeKey}</span><span class="s3">\n            </span><span class="s1">notFound={</span><span class="s3">\n              </span><span class="s1">notFoundElement ? (</span><span class="s3">\n                </span><span class="s1">&lt;&gt;</span><span class="s3">\n                  </span><span class="s1">{layerAssets}</span><span class="s3">\n                  </span><span class="s1">&lt;SegmentComponent params={params}&gt;</span><span class="s3">\n                    </span><span class="s1">{notFoundStyles}</span><span class="s3">\n                    </span><span class="s1">{notFoundElement}</span><span class="s3">\n                  </span><span class="s1">&lt;/SegmentComponent&gt;</span><span class="s3">\n                </span><span class="s1">&lt;/&gt;</span><span class="s3">\n              </span><span class="s1">) : undefined</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">&gt;</span><span class="s3">\n            </span><span class="s1">{layerAssets}</span><span class="s3">\n            </span><span class="s1">{serverSegment}</span><span class="s3">\n          </span><span class="s1">&lt;/HTTPAccessFallbackBoundary&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">segmentNode = (</span><span class="s3">\n          </span><span class="s1">&lt;React.Fragment key={cacheNodeKey}&gt;</span><span class="s3">\n            </span><span class="s1">{layerAssets}</span><span class="s3">\n            </span><span class="s1">{serverSegment}</span><span class="s3">\n          </span><span class="s1">&lt;/React.Fragment&gt;</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const layoutFilePath = getConventionPathByType(tree, dir, 'layout')</span><span class="s3">\n    </span><span class="s1">const wrappedSegmentNode =</span><span class="s3">\n      </span><span class="s1">isSegmentViewEnabled &amp;&amp; layoutFilePath ? (</span><span class="s3">\n        </span><span class="s1">&lt;SegmentViewNode key=</span><span class="s3">\&quot;</span><span class="s1">layout</span><span class="s3">\&quot; </span><span class="s1">type=</span><span class="s3">\&quot;</span><span class="s1">layout</span><span class="s3">\&quot; </span><span class="s1">pagePath={layoutFilePath}&gt;</span><span class="s3">\n          </span><span class="s1">{segmentNode}</span><span class="s3">\n        </span><span class="s1">&lt;/SegmentViewNode&gt;</span><span class="s3">\n      </span><span class="s1">) : (</span><span class="s3">\n        </span><span class="s1">segmentNode</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// For layouts we just render the component</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">actualSegment,</span><span class="s3">\n      </span><span class="s1">wrappedSegmentNode,</span><span class="s3">\n      </span><span class="s1">parallelRouteCacheNodeSeedData,</span><span class="s3">\n      </span><span class="s1">loadingData,</span><span class="s3">\n      </span><span class="s1">isPossiblyPartialResponse,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function MetadataOutlet({</span><span class="s3">\n  </span><span class="s1">ready,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">ready: () =&gt; Promise&lt;void&gt; &amp; { status?: string; value?: unknown }</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const r = ready()</span><span class="s3">\n  </span><span class="s1">// We can avoid a extra microtask by unwrapping the instrumented promise directly if available.</span><span class="s3">\n  </span><span class="s1">if (r.status === 'rejected') {</span><span class="s3">\n    </span><span class="s1">throw r.value</span><span class="s3">\n  </span><span class="s1">} else if (r.status !== 'fulfilled') {</span><span class="s3">\n    </span><span class="s1">await r</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">MetadataOutlet.displayName = OUTLET_BOUNDARY_NAME</span><span class="s3">\n\n</span><span class="s1">function createErrorBoundaryClientSegmentRoot({</span><span class="s3">\n  </span><span class="s1">ErrorBoundaryComponent,</span><span class="s3">\n  </span><span class="s1">errorElement,</span><span class="s3">\n  </span><span class="s1">ClientSegmentRoot,</span><span class="s3">\n  </span><span class="s1">layerAssets,</span><span class="s3">\n  </span><span class="s1">SegmentComponent,</span><span class="s3">\n  </span><span class="s1">currentParams,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">ErrorBoundaryComponent: React.ComponentType&lt;any&gt; | undefined</span><span class="s3">\n  </span><span class="s1">errorElement: React.ReactNode</span><span class="s3">\n  </span><span class="s1">ClientSegmentRoot: React.ComponentType&lt;any&gt;</span><span class="s3">\n  </span><span class="s1">layerAssets: React.ReactNode</span><span class="s3">\n  </span><span class="s1">SegmentComponent: React.ComponentType&lt;any&gt;</span><span class="s3">\n  </span><span class="s1">currentParams: Params</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">if (ErrorBoundaryComponent) {</span><span class="s3">\n    </span><span class="s1">const notFoundParallelRouteProps = {</span><span class="s3">\n      </span><span class="s1">children: errorElement,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">&lt;&gt;</span><span class="s3">\n        </span><span class="s1">{layerAssets}</span><span class="s3">\n        </span><span class="s1">&lt;ClientSegmentRoot</span><span class="s3">\n          </span><span class="s1">Component={SegmentComponent}</span><span class="s3">\n          </span><span class="s1">slots={notFoundParallelRouteProps}</span><span class="s3">\n          </span><span class="s1">params={currentParams}</span><span class="s3">\n        </span><span class="s1">/&gt;</span><span class="s3">\n      </span><span class="s1">&lt;/&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRootParams(</span><span class="s3">\n  </span><span class="s1">loaderTree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">getDynamicParamFromSegment: GetDynamicParamFromSegment</span><span class="s3">\n</span><span class="s1">): Params {</span><span class="s3">\n  </span><span class="s1">return getRootParamsImpl({}, loaderTree, getDynamicParamFromSegment)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getRootParamsImpl(</span><span class="s3">\n  </span><span class="s1">parentParams: Params,</span><span class="s3">\n  </span><span class="s1">loaderTree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">getDynamicParamFromSegment: GetDynamicParamFromSegment</span><span class="s3">\n</span><span class="s1">): Params {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">segment,</span><span class="s3">\n    </span><span class="s1">modules: { layout },</span><span class="s3">\n    </span><span class="s1">parallelRoutes,</span><span class="s3">\n  </span><span class="s1">} = parseLoaderTree(loaderTree)</span><span class="s3">\n\n  </span><span class="s1">const segmentParam = getDynamicParamFromSegment(segment)</span><span class="s3">\n\n  </span><span class="s1">let currentParams: Params = parentParams</span><span class="s3">\n  </span><span class="s1">if (segmentParam &amp;&amp; segmentParam.value !== null) {</span><span class="s3">\n    </span><span class="s1">currentParams = {</span><span class="s3">\n      </span><span class="s1">...parentParams,</span><span class="s3">\n      </span><span class="s1">[segmentParam.param]: segmentParam.value,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const isRootLayout = typeof layout !== 'undefined'</span><span class="s3">\n\n  </span><span class="s1">if (isRootLayout) {</span><span class="s3">\n    </span><span class="s1">return currentParams</span><span class="s3">\n  </span><span class="s1">} else if (!parallelRoutes.children) {</span><span class="s3">\n    </span><span class="s1">// This should really be an error but there are bugs in Turbopack that cause</span><span class="s3">\n    </span><span class="s1">// the _not-found LoaderTree to not have any layouts. For rootParams sake</span><span class="s3">\n    </span><span class="s1">// this is somewhat irrelevant when you are not customizing the 404 page.</span><span class="s3">\n    </span><span class="s1">// If you are customizing 404</span><span class="s3">\n    </span><span class="s1">// TODO update rootParams to make all params optional if `/app/not-found.tsx` is defined</span><span class="s3">\n    </span><span class="s1">return currentParams</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return getRootParamsImpl(</span><span class="s3">\n      </span><span class="s1">currentParams,</span><span class="s3">\n      </span><span class="s1">// We stop looking for root params as soon as we hit the first layout</span><span class="s3">\n      </span><span class="s1">// and it is not possible to use parallel route children above the root layout</span><span class="s3">\n      </span><span class="s1">// so every parallelRoutes object that this function can visit will necessarily</span><span class="s3">\n      </span><span class="s1">// have a single `children` prop and no others.</span><span class="s3">\n      </span><span class="s1">parallelRoutes.children,</span><span class="s3">\n      </span><span class="s1">getDynamicParamFromSegment</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function createBoundaryConventionElement({</span><span class="s3">\n  </span><span class="s1">ctx,</span><span class="s3">\n  </span><span class="s1">conventionName,</span><span class="s3">\n  </span><span class="s1">Component,</span><span class="s3">\n  </span><span class="s1">styles,</span><span class="s3">\n  </span><span class="s1">tree,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext</span><span class="s3">\n  </span><span class="s1">conventionName:</span><span class="s3">\n    </span><span class="s1">| 'not-found'</span><span class="s3">\n    </span><span class="s1">| 'error'</span><span class="s3">\n    </span><span class="s1">| 'loading'</span><span class="s3">\n    </span><span class="s1">| 'forbidden'</span><span class="s3">\n    </span><span class="s1">| 'unauthorized'</span><span class="s3">\n  </span><span class="s1">Component: React.ComponentType&lt;any&gt; | undefined</span><span class="s3">\n  </span><span class="s1">styles: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">tree: LoaderTree</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const isSegmentViewEnabled =</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV === 'development' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">ctx.renderOpts.devtoolSegmentExplorer</span><span class="s3">\n  </span><span class="s1">const dir =</span><span class="s3">\n    </span><span class="s1">(process.env.NEXT_RUNTIME === 'edge'</span><span class="s3">\n      </span><span class="s1">? process.env.__NEXT_EDGE_PROJECT_DIR</span><span class="s3">\n      </span><span class="s1">: ctx.renderOpts.dir) || ''</span><span class="s3">\n  </span><span class="s1">const { SegmentViewNode } = ctx.componentMod</span><span class="s3">\n  </span><span class="s1">const element = Component ? (</span><span class="s3">\n    </span><span class="s1">&lt;&gt;</span><span class="s3">\n      </span><span class="s1">&lt;Component /&gt;</span><span class="s3">\n      </span><span class="s1">{styles}</span><span class="s3">\n    </span><span class="s1">&lt;/&gt;</span><span class="s3">\n  </span><span class="s1">) : undefined</span><span class="s3">\n\n  </span><span class="s1">const pagePath = getConventionPathByType(tree, dir, conventionName)</span><span class="s3">\n\n  </span><span class="s1">const wrappedElement =</span><span class="s3">\n    </span><span class="s1">isSegmentViewEnabled &amp;&amp; element ? (</span><span class="s3">\n      </span><span class="s1">&lt;SegmentViewNode</span><span class="s3">\n        </span><span class="s1">key={cacheNodeKey + '-' + conventionName}</span><span class="s3">\n        </span><span class="s1">type={conventionName}</span><span class="s3">\n        </span><span class="s1">pagePath={pagePath!}</span><span class="s3">\n      </span><span class="s1">&gt;</span><span class="s3">\n        </span><span class="s1">{element}</span><span class="s3">\n      </span><span class="s1">&lt;/SegmentViewNode&gt;</span><span class="s3">\n    </span><span class="s1">) : (</span><span class="s3">\n      </span><span class="s1">element</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return [wrappedElement, pagePath] as const</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createComponentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;getRootParams&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;NextNodeServerSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;createComponentTreeInternal&quot;</span><span class="s0">,</span><span class="s1">&quot;errorMissingDefaultExport&quot;</span><span class="s0">,</span><span class="s1">&quot;pagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;convention&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;parentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;rootLayoutIncluded&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedCSS&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedJS&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedFontPreloadTags&quot;</span><span class="s0">,</span><span class="s1">&quot;getViewportReady&quot;</span><span class="s0">,</span><span class="s1">&quot;getMetadataReady&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;missingSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;preloadCallbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;authInterrupts&quot;</span><span class="s0">,</span><span class="s1">&quot;StreamingMetadataOutlet&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfigOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;componentMod&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentViewNode&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTPAccessFallbackBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;LayoutRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderFromTemplateContext&quot;</span><span class="s0">,</span><span class="s1">&quot;OutletBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;ClientPageRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;ClientSegmentRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerSearchParamsForServerPage&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrerenderSearchParamsForClientPage&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerParamsForServerSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrerenderParamsForClientSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;serverHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;DynamicServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;Postpone&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicParamFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;conventionPath&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;modules&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;parseLoaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;layout&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;forbidden&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorized&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedCSSWithCurrentLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedJSWithCurrentLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedFontPreloadTagsWithCurrentLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;layerAssets&quot;</span><span class="s0">,</span><span class="s1">&quot;getLayerAssets&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutOrPagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;Template&quot;</span><span class="s0">,</span><span class="s1">&quot;templateStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;templateScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;createComponentStylesAndScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;getComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;Fragment&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;errorStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;errorScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;Loading&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;isLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;isPage&quot;</span><span class="s0">,</span><span class="s1">&quot;mod&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutOrPageMod&quot;</span><span class="s0">,</span><span class="s1">&quot;modType&quot;</span><span class="s0">,</span><span class="s1">&quot;getLayoutOrPageModule&quot;</span><span class="s0">,</span><span class="s1">&quot;hideSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;rootLayoutAtThisLevel&quot;</span><span class="s0">,</span><span class="s1">&quot;rootLayoutIncludedAtThisLevelOrAbove&quot;</span><span class="s0">,</span><span class="s1">&quot;NotFound&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;Forbidden&quot;</span><span class="s0">,</span><span class="s1">&quot;forbiddenStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;Unauthorized&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorizedStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;StaticGenBailoutError&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicShouldError&quot;</span><span class="s0">,</span><span class="s1">&quot;forceDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicUsageDescription&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicUsageStack&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;forceStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;validateRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossiblyPartialResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;LayoutOrPage&quot;</span><span class="s0">,</span><span class="s1">&quot;interopDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;MaybeComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidElementType&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentParam&quot;</span><span class="s0">,</span><span class="s1">&quot;currentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;actualSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;treeSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;isSegmentViewEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;devtoolSegmentExplorer&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EDGE_PROJECT_DIR&quot;</span><span class="s0">,</span><span class="s1">&quot;metadataOutlet&quot;</span><span class="s0">,</span><span class="s1">&quot;MetadataOutlet&quot;</span><span class="s0">,</span><span class="s1">&quot;ready&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundElement&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;createBoundaryConventionElement&quot;</span><span class="s0">,</span><span class="s1">&quot;conventionName&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;styles&quot;</span><span class="s0">,</span><span class="s1">&quot;forbiddenElement&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorizedElement&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isChildrenRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;forbiddenComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorizedComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;childCacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoadingComponentInTree&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PARALLEL_ROUTE_DEFAULT_PATH&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;templateNode&quot;</span><span class="s0">,</span><span class="s1">&quot;templateFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;getConventionPathByType&quot;</span><span class="s0">,</span><span class="s1">&quot;errorFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;globalErrorFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;wrappedErrorStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;fileNameSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;BOUNDARY_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentViewBoundaries&quot;</span><span class="s0">,</span><span class="s1">&quot;BOUNDARY_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextjsBuiltinFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;BUILTIN_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouterKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteProps&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteCacheNodeSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteProp&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingElement&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingData&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;isClientComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;isClientReference&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;PageComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;pageElement&quot;</span><span class="s0">,</span><span class="s1">&quot;promiseOfParams&quot;</span><span class="s0">,</span><span class="s1">&quot;promiseOfSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;isUseCacheFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;UseCachePageComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;$$isPageComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;isDefaultSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;pageFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentType&quot;</span><span class="s0">,</span><span class="s1">&quot;wrappedPageElement&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentNode&quot;</span><span class="s0">,</span><span class="s1">&quot;clientSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;slots&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;notfoundClientSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;forbiddenClientSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorizedClientSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;createErrorBoundaryClientSegmentRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorBoundaryComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;errorElement&quot;</span><span class="s0">,</span><span class="s1">&quot;serverSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;UseCacheLayoutComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;$$isLayoutComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;wrappedSegmentNode&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;displayName&quot;</span><span class="s0">,</span><span class="s1">&quot;OUTLET_BOUNDARY_NAME&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundParallelRouteProps&quot;</span><span class="s0">,</span><span class="s1">&quot;getRootParamsImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;wrappedElement&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>