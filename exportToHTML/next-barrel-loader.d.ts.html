<html>
<head>
<title>next-barrel-loader.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-barrel-loader.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* ## Barrel Optimizations</span>
 <span class="s0">*</span>
 <span class="s0">* This loader is used to optimize the imports of &quot;barrel&quot; files that have many</span>
 <span class="s0">* re-exports. Currently, both Node.js and Webpack have to enter all of these</span>
 <span class="s0">* submodules even if we only need a few of them.</span>
 <span class="s0">*</span>
 <span class="s0">* For example, say a file `foo.js` with the following contents:</span>
 <span class="s0">*</span>
 <span class="s0">*   export { a } from './a'</span>
 <span class="s0">*   export { b } from './b'</span>
 <span class="s0">*   export { c } from './c'</span>
 <span class="s0">*   ...</span>
 <span class="s0">*</span>
 <span class="s0">* If the user imports `a` only, this loader will accept the `names` option to</span>
 <span class="s0">* be `['a']`. Then, it request the &quot;__barrel_transform__&quot; SWC transform to load</span>
 <span class="s0">* `foo.js` and receive the following output:</span>
 <span class="s0">*</span>
 <span class="s0">*   export const __next_private_export_map__ = '[[&quot;a&quot;,&quot;./a&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;./b&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;./c&quot;,&quot;c&quot;],...]'</span>
 <span class="s0">*</span>
 <span class="s0">*   format: '[&quot;&lt;imported identifier&gt;&quot;, &quot;&lt;import path&gt;&quot;, &quot;&lt;exported name&gt;&quot;]'</span>
 <span class="s0">*   e.g.: import { a as b } from './module-a' =&gt; '[&quot;b&quot;, &quot;./module-a&quot;, &quot;a&quot;]'</span>
 <span class="s0">*</span>
 <span class="s0">* The export map, generated by SWC, is a JSON that represents the exports of</span>
 <span class="s0">* that module, their original file, and their original name (since you can do</span>
 <span class="s0">* `export { a as b }`).</span>
 <span class="s0">*</span>
 <span class="s0">* Then, this loader can safely remove all the exports that are not needed and</span>
 <span class="s0">* re-export the ones from `names`:</span>
 <span class="s0">*</span>
 <span class="s0">*   export { a } from './a'</span>
 <span class="s0">*</span>
 <span class="s0">* That's the basic situation and also the happy path.</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">* ## Wildcard Exports</span>
 <span class="s0">*</span>
 <span class="s0">* For wildcard exports (e.g. `export * from './a'`), it becomes a bit more complicated.</span>
 <span class="s0">* Say `foo.js` with the following contents:</span>
 <span class="s0">*</span>
 <span class="s0">*   export * from './a'</span>
 <span class="s0">*   export * from './b'</span>
 <span class="s0">*   export * from './c'</span>
 <span class="s0">*   ...</span>
 <span class="s0">*</span>
 <span class="s0">* If the user imports `bar` from it, SWC can never know which files are going to be</span>
 <span class="s0">* exporting `bar`. So, we have to keep all the wildcard exports and do the same</span>
 <span class="s0">* process recursively. This loader will return the following output:</span>
 <span class="s0">*</span>
 <span class="s0">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./a'</span>
 <span class="s0">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./b'</span>
 <span class="s0">*   export * from '__barrel_optimize__?names=bar&amp;wildcard!=!./c'</span>
 <span class="s0">*   ...</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;!=!&quot; tells Webpack to use the same loader to process './a', './b', and './c'.</span>
 <span class="s0">* After the recursive process, the &quot;inner loaders&quot; will either return an empty string</span>
 <span class="s0">* or:</span>
 <span class="s0">*</span>
 <span class="s0">*   export * from './target'</span>
 <span class="s0">*</span>
 <span class="s0">* Where `target` is the file that exports `bar`.</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">* ## Non-Barrel Files</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is not a barrel, we can't apply any optimizations. That's because</span>
 <span class="s0">* we can't easily remove things from the file. For example, say `foo.js` with:</span>
 <span class="s0">*</span>
 <span class="s0">*   const v = 1</span>
 <span class="s0">*   export function b () {</span>
 <span class="s0">*     return v</span>
 <span class="s0">*   }</span>
 <span class="s0">*</span>
 <span class="s0">* If the user imports `b` only, we can't remove the `const v = 1` even though</span>
 <span class="s0">* the file is side-effect free. In these caes, this loader will simply re-export</span>
 <span class="s0">* `foo.js`:</span>
 <span class="s0">*</span>
 <span class="s0">*   export * from './foo'</span>
 <span class="s0">*</span>
 <span class="s0">* Besides these cases, this loader also carefully handles the module cache so</span>
 <span class="s0">* SWC won't analyze the same file twice, and no instance of the same file will</span>
 <span class="s0">* be accidentally created as different instances.</span>
 <span class="s0">*/</span>
<span class="s2">import </span><span class="s1">type webpack from </span><span class="s3">'webpack'</span><span class="s1">;</span>
<span class="s1">declare </span><span class="s2">const </span><span class="s1">NextBarrelLoader: (</span><span class="s2">this</span><span class="s1">: webpack.LoaderContext&lt;{</span>
    <span class="s1">names: string[];</span>
    <span class="s1">swcCacheDir: string;</span>
<span class="s1">}&gt;) =&gt; Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>
<span class="s2">export default </span><span class="s1">NextBarrelLoader;</span>
</pre>
</body>
</html>