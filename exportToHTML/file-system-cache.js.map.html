<html>
<head>
<title>file-system-cache.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
file-system-cache.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/lib/incremental-cache/file-system-cache.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { RouteMetadata } from '../../../export/routes/types'</span><span class="s3">\n</span><span class="s1">import type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from '.'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n\n</span><span class="s1">import type { LRUCache } from '../lru-cache'</span><span class="s3">\n</span><span class="s1">import path from '../../../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_DATA_SUFFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_META_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_PREFETCH_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENT_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SUFFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { isStale, tagsManifest } from './tags-manifest.external'</span><span class="s3">\n</span><span class="s1">import { MultiFileWriter } from '../../../lib/multi-file-writer'</span><span class="s3">\n</span><span class="s1">import { getMemoryCache } from './memory-cache.external'</span><span class="s3">\n\n</span><span class="s1">type FileSystemCacheContext = Omit&lt;</span><span class="s3">\n  </span><span class="s1">CacheHandlerContext,</span><span class="s3">\n  </span><span class="s1">'fs' | 'serverDistDir'</span><span class="s3">\n</span><span class="s1">&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">fs: CacheFs</span><span class="s3">\n  </span><span class="s1">serverDistDir: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class FileSystemCache implements CacheHandler {</span><span class="s3">\n  </span><span class="s1">private fs: FileSystemCacheContext['fs']</span><span class="s3">\n  </span><span class="s1">private flushToDisk?: FileSystemCacheContext['flushToDisk']</span><span class="s3">\n  </span><span class="s1">private serverDistDir: FileSystemCacheContext['serverDistDir']</span><span class="s3">\n  </span><span class="s1">private revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">private static debug: boolean = !!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private static memoryCache: LRUCache&lt;CacheHandlerValue&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(ctx: FileSystemCacheContext) {</span><span class="s3">\n    </span><span class="s1">this.fs = ctx.fs</span><span class="s3">\n    </span><span class="s1">this.flushToDisk = ctx.flushToDisk</span><span class="s3">\n    </span><span class="s1">this.serverDistDir = ctx.serverDistDir</span><span class="s3">\n    </span><span class="s1">this.revalidatedTags = ctx.revalidatedTags</span><span class="s3">\n\n    </span><span class="s1">if (ctx.maxMemoryCacheSize) {</span><span class="s3">\n      </span><span class="s1">if (!FileSystemCache.memoryCache) {</span><span class="s3">\n        </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n          </span><span class="s1">console.log('using memory store for fetch cache')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">FileSystemCache.memoryCache = getMemoryCache(ctx.maxMemoryCacheSize)</span><span class="s3">\n      </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('memory store already initialized')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('not using memory store for fetch cache')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;CacheHandler['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let [tags] = args</span><span class="s3">\n    </span><span class="s1">tags = typeof tags === 'string' ? [tags] : tags</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('revalidateTag', tags)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (tags.length === 0) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const tag of tags) {</span><span class="s3">\n      </span><span class="s1">if (!tagsManifest.has(tag)) {</span><span class="s3">\n        </span><span class="s1">tagsManifest.set(tag, Date.now())</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(...args: Parameters&lt;CacheHandler['get']&gt;) {</span><span class="s3">\n    </span><span class="s1">const [key, ctx] = args</span><span class="s3">\n    </span><span class="s1">const { kind } = ctx</span><span class="s3">\n\n    </span><span class="s1">let data = FileSystemCache.memoryCache?.get(key)</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, ctx.tags, kind, !!data)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, kind, !!data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// let's check the disk for seed data</span><span class="s3">\n    </span><span class="s1">if (!data &amp;&amp; process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (kind === IncrementalCacheKind.APP_ROUTE) {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}.body`,</span><span class="s3">\n            </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath)</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">const meta = JSON.parse(</span><span class="s3">\n            </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n              </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n              </span><span class="s1">'utf8'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">data = {</span><span class="s3">\n            </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n            </span><span class="s1">value: {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_ROUTE,</span><span class="s3">\n              </span><span class="s1">body: fileData,</span><span class="s3">\n              </span><span class="s1">headers: meta.headers,</span><span class="s3">\n              </span><span class="s1">status: meta.status,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">kind === IncrementalCacheKind.FETCH ? key : `${key}.html`,</span><span class="s3">\n            </span><span class="s1">kind</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath, 'utf8')</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n            </span><span class="s1">const { tags, fetchIdx, fetchUrl } = ctx</span><span class="s3">\n\n            </span><span class="s1">if (!this.flushToDisk) return null</span><span class="s3">\n\n            </span><span class="s1">const lastModified = mtime.getTime()</span><span class="s3">\n            </span><span class="s1">const parsedData: CachedFetchValue = JSON.parse(fileData)</span><span class="s3">\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified,</span><span class="s3">\n              </span><span class="s1">value: parsedData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (data.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n              </span><span class="s1">const storedTags = data.value?.tags</span><span class="s3">\n\n              </span><span class="s1">// update stored tags if a new one is being added</span><span class="s3">\n              </span><span class="s1">// TODO: remove this when we can send the tags</span><span class="s3">\n              </span><span class="s1">// via header on GET same as SET</span><span class="s3">\n              </span><span class="s1">if (!tags?.every((tag) =&gt; storedTags?.includes(tag))) {</span><span class="s3">\n                </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n                  </span><span class="s1">console.log('tags vs storedTags mismatch', tags, storedTags)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">await this.set(key, data.value, {</span><span class="s3">\n                  </span><span class="s1">fetchCache: true,</span><span class="s3">\n                  </span><span class="s1">tags,</span><span class="s3">\n                  </span><span class="s1">fetchIdx,</span><span class="s3">\n                  </span><span class="s1">fetchUrl,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.APP_PAGE) {</span><span class="s3">\n            </span><span class="s1">// We try to load the metadata file, but if it fails, we don't</span><span class="s3">\n            </span><span class="s1">// error. We also don't load it if this is a fallback.</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">meta = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} catch {}</span><span class="s3">\n\n            </span><span class="s1">let maybeSegmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n            </span><span class="s1">if (meta?.segmentPaths) {</span><span class="s3">\n              </span><span class="s1">// Collect all the segment data for this page.</span><span class="s3">\n              </span><span class="s1">// TODO: To optimize file system reads, we should consider creating</span><span class="s3">\n              </span><span class="s1">// separate cache entries for each segment, rather than storing them</span><span class="s3">\n              </span><span class="s1">// all on the page's entry. Though the behavior is</span><span class="s3">\n              </span><span class="s1">// identical regardless.</span><span class="s3">\n              </span><span class="s1">const segmentData: Map&lt;string, Buffer&gt; = new Map()</span><span class="s3">\n              </span><span class="s1">maybeSegmentData = segmentData</span><span class="s3">\n              </span><span class="s1">const segmentsDir = key + RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">meta.segmentPaths.map(async (segmentPath: string) =&gt; {</span><span class="s3">\n                  </span><span class="s1">const segmentDataFilePath = this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">segmentData.set(</span><span class="s3">\n                      </span><span class="s1">segmentPath,</span><span class="s3">\n                      </span><span class="s1">await this.fs.readFile(segmentDataFilePath)</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">} catch {</span><span class="s3">\n                    </span><span class="s1">// This shouldn't happen, but if for some reason we fail to</span><span class="s3">\n                    </span><span class="s1">// load a segment from the filesystem, treat it the same as if</span><span class="s3">\n                    </span><span class="s1">// the segment is dynamic and does not have a prefetch.</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">let rscData: Buffer | undefined</span><span class="s3">\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">rscData = await this.fs.readFile(</span><span class="s3">\n                </span><span class="s1">this.getFilePath(</span><span class="s3">\n                  </span><span class="s1">`${key}${ctx.isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,</span><span class="s3">\n                  </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">rscData,</span><span class="s3">\n                </span><span class="s1">postponed: meta?.postponed,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n                </span><span class="s1">segmentData: maybeSegmentData,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.PAGES) {</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">let pageData: string | object = {}</span><span class="s3">\n\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">pageData = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">`${key}${NEXT_DATA_SUFFIX}`,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.PAGES</span><span class="s3">\n                  </span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">pageData,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`Invariant: Unexpected route kind ${kind} in file system cache.`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (data) {</span><span class="s3">\n          </span><span class="s1">FileSystemCache.memoryCache?.set(key, data)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_PAGE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_ROUTE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">let cacheTags: undefined | string[]</span><span class="s3">\n      </span><span class="s1">const tagsHeader = data.value.headers?.[NEXT_CACHE_TAGS_HEADER]</span><span class="s3">\n\n      </span><span class="s1">if (typeof tagsHeader === 'string') {</span><span class="s3">\n        </span><span class="s1">cacheTags = tagsHeader.split(',')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheTags?.length) {</span><span class="s3">\n        </span><span class="s1">// we trigger a blocking validation if an ISR page</span><span class="s3">\n        </span><span class="s1">// had a tag revalidated, if we want to be a background</span><span class="s3">\n        </span><span class="s1">// revalidation instead we return data.lastModified = -1</span><span class="s3">\n        </span><span class="s1">if (isStale(cacheTags, data?.lastModified || Date.now())) {</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const combinedTags =</span><span class="s3">\n        </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n          </span><span class="s1">? [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n          </span><span class="s1">: []</span><span class="s3">\n\n      </span><span class="s1">const wasRevalidated = combinedTags.some((tag) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (this.revalidatedTags.includes(tag)) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return isStale([tag], data?.lastModified || Date.now())</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">// When revalidate tag is called we don't return</span><span class="s3">\n      </span><span class="s1">// stale data so it's updated right away</span><span class="s3">\n      </span><span class="s1">if (wasRevalidated) {</span><span class="s3">\n        </span><span class="s1">data = undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return data ?? null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">FileSystemCache.memoryCache?.set(key, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">lastModified: Date.now(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('set', key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.flushToDisk || !data) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new writer that will prepare to write all the files to disk</span><span class="s3">\n    </span><span class="s1">// after their containing directory is created.</span><span class="s3">\n    </span><span class="s1">const writer = new MultiFileWriter(this.fs)</span><span class="s3">\n\n    </span><span class="s1">if (data.kind === CachedRouteKind.APP_ROUTE) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.body`,</span><span class="s3">\n        </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(filePath, data.body)</span><span class="s3">\n\n      </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n        </span><span class="s1">headers: data.headers,</span><span class="s3">\n        </span><span class="s1">status: data.status,</span><span class="s3">\n        </span><span class="s1">postponed: undefined,</span><span class="s3">\n        </span><span class="s1">segmentPaths: undefined,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n        </span><span class="s1">JSON.stringify(meta, null, 2)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.PAGES ||</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const isAppPath = data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n      </span><span class="s1">const htmlPath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.html`,</span><span class="s3">\n        </span><span class="s1">isAppPath ? IncrementalCacheKind.APP_PAGE : IncrementalCacheKind.PAGES</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(htmlPath, data.html)</span><span class="s3">\n\n      </span><span class="s1">// Fallbacks don't generate a data file.</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; !ctx.isFallback) {</span><span class="s3">\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}${</span><span class="s3">\n              </span><span class="s1">isAppPath</span><span class="s3">\n                </span><span class="s1">? ctx.isRoutePPREnabled</span><span class="s3">\n                  </span><span class="s1">? RSC_PREFETCH_SUFFIX</span><span class="s3">\n                  </span><span class="s1">: RSC_SUFFIX</span><span class="s3">\n                </span><span class="s1">: NEXT_DATA_SUFFIX</span><span class="s3">\n            </span><span class="s1">}`,</span><span class="s3">\n            </span><span class="s1">isAppPath</span><span class="s3">\n              </span><span class="s1">? IncrementalCacheKind.APP_PAGE</span><span class="s3">\n              </span><span class="s1">: IncrementalCacheKind.PAGES</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">isAppPath ? data.rscData! : JSON.stringify(data.pageData)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (data?.kind === CachedRouteKind.APP_PAGE) {</span><span class="s3">\n        </span><span class="s1">let segmentPaths: string[] | undefined</span><span class="s3">\n        </span><span class="s1">if (data.segmentData) {</span><span class="s3">\n          </span><span class="s1">segmentPaths = []</span><span class="s3">\n          </span><span class="s1">const segmentsDir = htmlPath.replace(</span><span class="s3">\n            </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.html$/,</span><span class="s3">\n            </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">for (const [segmentPath, buffer] of data.segmentData) {</span><span class="s3">\n            </span><span class="s1">segmentPaths.push(segmentPath)</span><span class="s3">\n            </span><span class="s1">const segmentDataFilePath =</span><span class="s3">\n              </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX</span><span class="s3">\n            </span><span class="s1">writer.append(segmentDataFilePath, buffer)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n          </span><span class="s1">headers: data.headers,</span><span class="s3">\n          </span><span class="s1">status: data.status,</span><span class="s3">\n          </span><span class="s1">postponed: data.postponed,</span><span class="s3">\n          </span><span class="s1">segmentPaths,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">htmlPath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n          </span><span class="s1">JSON.stringify(meta)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(key, IncrementalCacheKind.FETCH)</span><span class="s3">\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath,</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">...data,</span><span class="s3">\n          </span><span class="s1">tags: ctx.fetchCache ? ctx.tags : [],</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Wait for all FS operations to complete.</span><span class="s3">\n    </span><span class="s1">await writer.wait()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private getFilePath(pathname: string, kind: IncrementalCacheKind): string {</span><span class="s3">\n    </span><span class="s1">switch (kind) {</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.FETCH:</span><span class="s3">\n        </span><span class="s1">// we store in .next/cache/fetch-cache so it can be persisted</span><span class="s3">\n        </span><span class="s1">// across deploys</span><span class="s3">\n        </span><span class="s1">return path.join(</span><span class="s3">\n          </span><span class="s1">this.serverDistDir,</span><span class="s3">\n          </span><span class="s1">'..',</span><span class="s3">\n          </span><span class="s1">'cache',</span><span class="s3">\n          </span><span class="s1">'fetch-cache',</span><span class="s3">\n          </span><span class="s1">pathname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.PAGES:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'pages', pathname)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_ROUTE:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'app', pathname)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new Error(`Unexpected file path kind: ${kind}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;FileSystemCache&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_DEBUG_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;flushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;serverDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;maxMemoryCacheSize&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;getMemoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;resetRequestCache&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateTag&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;FETCH&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;APP_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;getFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;fileData&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;mtime&quot;</span><span class="s0">,</span><span class="s1">&quot;stat&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_META_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;lastModified&quot;</span><span class="s0">,</span><span class="s1">&quot;getTime&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedRouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedData&quot;</span><span class="s0">,</span><span class="s1">&quot;storedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;APP_PAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentsDir&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENTS_DIR_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentDataFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENT_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;rscData&quot;</span><span class="s0">,</span><span class="s1">&quot;isFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_PREFETCH_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;pageData&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DATA_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheTags&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;isStale&quot;</span><span class="s0">,</span><span class="s1">&quot;combinedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;softTags&quot;</span><span class="s0">,</span><span class="s1">&quot;wasRevalidated&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;writer&quot;</span><span class="s0">,</span><span class="s1">&quot;MultiFileWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;wait&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;IMAGE&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>