<html>
<head>
<title>magic-string.cjs.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
magic-string.cjs.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">sourcemapCodec = require(</span><span class="s0">'@jridgewell/sourcemap-codec'</span><span class="s1">);</span>

<span class="s2">class </span><span class="s1">BitSet {</span>
	<span class="s1">constructor(arg) {</span>
		<span class="s2">this</span><span class="s1">.bits = arg </span><span class="s2">instanceof </span><span class="s1">BitSet ? arg.bits.slice() : [];</span>
	<span class="s1">}</span>

	<span class="s1">add(n) {</span>
		<span class="s2">this</span><span class="s1">.bits[n &gt;&gt; </span><span class="s3">5</span><span class="s1">] |= </span><span class="s3">1 </span><span class="s1">&lt;&lt; (n &amp; </span><span class="s3">31</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">has(n) {</span>
		<span class="s2">return </span><span class="s1">!!(</span><span class="s2">this</span><span class="s1">.bits[n &gt;&gt; </span><span class="s3">5</span><span class="s1">] &amp; (</span><span class="s3">1 </span><span class="s1">&lt;&lt; (n &amp; </span><span class="s3">31</span><span class="s1">)));</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Chunk {</span>
	<span class="s1">constructor(start, end, content) {</span>
		<span class="s2">this</span><span class="s1">.start = start;</span>
		<span class="s2">this</span><span class="s1">.end = end;</span>
		<span class="s2">this</span><span class="s1">.original = content;</span>

		<span class="s2">this</span><span class="s1">.intro = </span><span class="s0">''</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.outro = </span><span class="s0">''</span><span class="s1">;</span>

		<span class="s2">this</span><span class="s1">.content = content;</span>
		<span class="s2">this</span><span class="s1">.storeName = </span><span class="s2">false</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.edited = </span><span class="s2">false</span><span class="s1">;</span>

		<span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.previous = </span><span class="s2">null</span><span class="s1">;</span>
			<span class="s2">this</span><span class="s1">.next = </span><span class="s2">null</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">appendLeft(content) {</span>
		<span class="s2">this</span><span class="s1">.outro += content;</span>
	<span class="s1">}</span>

	<span class="s1">appendRight(content) {</span>
		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro + content;</span>
	<span class="s1">}</span>

	<span class="s1">clone() {</span>
		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">new </span><span class="s1">Chunk(</span><span class="s2">this</span><span class="s1">.start, </span><span class="s2">this</span><span class="s1">.end, </span><span class="s2">this</span><span class="s1">.original);</span>

		<span class="s1">chunk.intro = </span><span class="s2">this</span><span class="s1">.intro;</span>
		<span class="s1">chunk.outro = </span><span class="s2">this</span><span class="s1">.outro;</span>
		<span class="s1">chunk.content = </span><span class="s2">this</span><span class="s1">.content;</span>
		<span class="s1">chunk.storeName = </span><span class="s2">this</span><span class="s1">.storeName;</span>
		<span class="s1">chunk.edited = </span><span class="s2">this</span><span class="s1">.edited;</span>

		<span class="s2">return </span><span class="s1">chunk;</span>
	<span class="s1">}</span>

	<span class="s1">contains(index) {</span>
		<span class="s2">return this</span><span class="s1">.start &lt; index &amp;&amp; index &lt; </span><span class="s2">this</span><span class="s1">.end;</span>
	<span class="s1">}</span>

	<span class="s1">eachNext(fn) {</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">;</span>
		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">fn(chunk);</span>
			<span class="s1">chunk = chunk.next;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">eachPrevious(fn) {</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">;</span>
		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">fn(chunk);</span>
			<span class="s1">chunk = chunk.previous;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">edit(content, storeName, contentOnly) {</span>
		<span class="s2">this</span><span class="s1">.content = content;</span>
		<span class="s2">if </span><span class="s1">(!contentOnly) {</span>
			<span class="s2">this</span><span class="s1">.intro = </span><span class="s0">''</span><span class="s1">;</span>
			<span class="s2">this</span><span class="s1">.outro = </span><span class="s0">''</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">this</span><span class="s1">.storeName = storeName;</span>

		<span class="s2">this</span><span class="s1">.edited = </span><span class="s2">true</span><span class="s1">;</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">prependLeft(content) {</span>
		<span class="s2">this</span><span class="s1">.outro = content + </span><span class="s2">this</span><span class="s1">.outro;</span>
	<span class="s1">}</span>

	<span class="s1">prependRight(content) {</span>
		<span class="s2">this</span><span class="s1">.intro = content + </span><span class="s2">this</span><span class="s1">.intro;</span>
	<span class="s1">}</span>

	<span class="s1">reset() {</span>
		<span class="s2">this</span><span class="s1">.intro = </span><span class="s0">''</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.outro = </span><span class="s0">''</span><span class="s1">;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.edited) {</span>
			<span class="s2">this</span><span class="s1">.content = </span><span class="s2">this</span><span class="s1">.original;</span>
			<span class="s2">this</span><span class="s1">.storeName = </span><span class="s2">false</span><span class="s1">;</span>
			<span class="s2">this</span><span class="s1">.edited = </span><span class="s2">false</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">split(index) {</span>
		<span class="s2">const </span><span class="s1">sliceIndex = index - </span><span class="s2">this</span><span class="s1">.start;</span>

		<span class="s2">const </span><span class="s1">originalBefore = </span><span class="s2">this</span><span class="s1">.original.slice(</span><span class="s3">0</span><span class="s1">, sliceIndex);</span>
		<span class="s2">const </span><span class="s1">originalAfter = </span><span class="s2">this</span><span class="s1">.original.slice(sliceIndex);</span>

		<span class="s2">this</span><span class="s1">.original = originalBefore;</span>

		<span class="s2">const </span><span class="s1">newChunk = </span><span class="s2">new </span><span class="s1">Chunk(index, </span><span class="s2">this</span><span class="s1">.end, originalAfter);</span>
		<span class="s1">newChunk.outro = </span><span class="s2">this</span><span class="s1">.outro;</span>
		<span class="s2">this</span><span class="s1">.outro = </span><span class="s0">''</span><span class="s1">;</span>

		<span class="s2">this</span><span class="s1">.end = index;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.edited) {</span>
			<span class="s4">// after split we should save the edit content record into the correct chunk</span>
			<span class="s4">// to make sure sourcemap correct</span>
			<span class="s4">// For example:</span>
			<span class="s4">// '  test'.trim()</span>
			<span class="s4">//     split   -&gt; '  ' + 'test'</span>
			<span class="s4">//   ✔️ edit    -&gt; '' + 'test'</span>
			<span class="s4">//   ✖️ edit    -&gt; 'test' + ''</span>
			<span class="s4">// TODO is this block necessary?...</span>
			<span class="s1">newChunk.edit(</span><span class="s0">''</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
			<span class="s2">this</span><span class="s1">.content = </span><span class="s0">''</span><span class="s1">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.content = originalBefore;</span>
		<span class="s1">}</span>

		<span class="s1">newChunk.next = </span><span class="s2">this</span><span class="s1">.next;</span>
		<span class="s2">if </span><span class="s1">(newChunk.next) newChunk.next.previous = newChunk;</span>
		<span class="s1">newChunk.previous = </span><span class="s2">this</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.next = newChunk;</span>

		<span class="s2">return </span><span class="s1">newChunk;</span>
	<span class="s1">}</span>

	<span class="s1">toString() {</span>
		<span class="s2">return this</span><span class="s1">.intro + </span><span class="s2">this</span><span class="s1">.content + </span><span class="s2">this</span><span class="s1">.outro;</span>
	<span class="s1">}</span>

	<span class="s1">trimEnd(rx) {</span>
		<span class="s2">this</span><span class="s1">.outro = </span><span class="s2">this</span><span class="s1">.outro.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro.length) </span><span class="s2">return true</span><span class="s1">;</span>

		<span class="s2">const </span><span class="s1">trimmed = </span><span class="s2">this</span><span class="s1">.content.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>

		<span class="s2">if </span><span class="s1">(trimmed.length) {</span>
			<span class="s2">if </span><span class="s1">(trimmed !== </span><span class="s2">this</span><span class="s1">.content) {</span>
				<span class="s2">this</span><span class="s1">.split(</span><span class="s2">this</span><span class="s1">.start + trimmed.length).edit(</span><span class="s0">''</span><span class="s1">, undefined, </span><span class="s2">true</span><span class="s1">);</span>
				<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.edited) {</span>
					<span class="s4">// save the change, if it has been edited</span>
					<span class="s2">this</span><span class="s1">.edit(trimmed, </span><span class="s2">this</span><span class="s1">.storeName, </span><span class="s2">true</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">return true</span><span class="s1">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.edit(</span><span class="s0">''</span><span class="s1">, undefined, </span><span class="s2">true</span><span class="s1">);</span>

			<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length) </span><span class="s2">return true</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">trimStart(rx) {</span>
		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length) </span><span class="s2">return true</span><span class="s1">;</span>

		<span class="s2">const </span><span class="s1">trimmed = </span><span class="s2">this</span><span class="s1">.content.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>

		<span class="s2">if </span><span class="s1">(trimmed.length) {</span>
			<span class="s2">if </span><span class="s1">(trimmed !== </span><span class="s2">this</span><span class="s1">.content) {</span>
				<span class="s2">const </span><span class="s1">newChunk = </span><span class="s2">this</span><span class="s1">.split(</span><span class="s2">this</span><span class="s1">.end - trimmed.length);</span>
				<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.edited) {</span>
					<span class="s4">// save the change, if it has been edited</span>
					<span class="s1">newChunk.edit(trimmed, </span><span class="s2">this</span><span class="s1">.storeName, </span><span class="s2">true</span><span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s2">this</span><span class="s1">.edit(</span><span class="s0">''</span><span class="s1">, undefined, </span><span class="s2">true</span><span class="s1">);</span>
			<span class="s1">}</span>
			<span class="s2">return true</span><span class="s1">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.edit(</span><span class="s0">''</span><span class="s1">, undefined, </span><span class="s2">true</span><span class="s1">);</span>

			<span class="s2">this</span><span class="s1">.outro = </span><span class="s2">this</span><span class="s1">.outro.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro.length) </span><span class="s2">return true</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getBtoa() {</span>
	<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">globalThis !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">globalThis.btoa === </span><span class="s0">'function'</span><span class="s1">) {</span>
		<span class="s2">return </span><span class="s1">(str) =&gt; globalThis.btoa(unescape(encodeURIComponent(str)));</span>
	<span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Buffer === </span><span class="s0">'function'</span><span class="s1">) {</span>
		<span class="s2">return </span><span class="s1">(str) =&gt; Buffer.from(str, </span><span class="s0">'utf-8'</span><span class="s1">).toString(</span><span class="s0">'base64'</span><span class="s1">);</span>
	<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
		<span class="s2">return </span><span class="s1">() =&gt; {</span>
			<span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Unsupported environment: `window.btoa` or `Buffer` should be supported.'</span><span class="s1">);</span>
		<span class="s1">};</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">btoa = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">getBtoa();</span>

<span class="s2">class </span><span class="s1">SourceMap {</span>
	<span class="s1">constructor(properties) {</span>
		<span class="s2">this</span><span class="s1">.version = </span><span class="s3">3</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.file = properties.file;</span>
		<span class="s2">this</span><span class="s1">.sources = properties.sources;</span>
		<span class="s2">this</span><span class="s1">.sourcesContent = properties.sourcesContent;</span>
		<span class="s2">this</span><span class="s1">.names = properties.names;</span>
		<span class="s2">this</span><span class="s1">.mappings = sourcemapCodec.encode(properties.mappings);</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">properties.x_google_ignoreList !== </span><span class="s0">'undefined'</span><span class="s1">) {</span>
			<span class="s2">this</span><span class="s1">.x_google_ignoreList = properties.x_google_ignoreList;</span>
		<span class="s1">}</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">properties.debugId !== </span><span class="s0">'undefined'</span><span class="s1">) {</span>
			<span class="s2">this</span><span class="s1">.debugId = properties.debugId;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">toString() {</span>
		<span class="s2">return </span><span class="s1">JSON.stringify(</span><span class="s2">this</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">toUrl() {</span>
		<span class="s2">return </span><span class="s0">'data:application/json;charset=utf-8;base64,' </span><span class="s1">+ btoa(</span><span class="s2">this</span><span class="s1">.toString());</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">guessIndent(code) {</span>
	<span class="s2">const </span><span class="s1">lines = code.split(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>

	<span class="s2">const </span><span class="s1">tabbed = lines.filter((line) =&gt; </span><span class="s6">/^\t+/</span><span class="s1">.test(line));</span>
	<span class="s2">const </span><span class="s1">spaced = lines.filter((line) =&gt; </span><span class="s6">/^ {2,}/</span><span class="s1">.test(line));</span>

	<span class="s2">if </span><span class="s1">(tabbed.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp; spaced.length === </span><span class="s3">0</span><span class="s1">) {</span>
		<span class="s2">return null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s4">// More lines tabbed than spaced? Assume tabs, and</span>
	<span class="s4">// default to tabs in the case of a tie (or nothing</span>
	<span class="s4">// to go on)</span>
	<span class="s2">if </span><span class="s1">(tabbed.length &gt;= spaced.length) {</span>
		<span class="s2">return </span><span class="s0">'</span><span class="s5">\t</span><span class="s0">'</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s4">// Otherwise, we need to guess the multiple</span>
	<span class="s2">const </span><span class="s1">min = spaced.reduce((previous, current) =&gt; {</span>
		<span class="s2">const </span><span class="s1">numSpaces = </span><span class="s6">/^ +/</span><span class="s1">.exec(current)[</span><span class="s3">0</span><span class="s1">].length;</span>
		<span class="s2">return </span><span class="s1">Math.min(numSpaces, previous);</span>
	<span class="s1">}, Infinity);</span>

	<span class="s2">return new </span><span class="s1">Array(min + </span><span class="s3">1</span><span class="s1">).join(</span><span class="s0">' '</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getRelativePath(from, to) {</span>
	<span class="s2">const </span><span class="s1">fromParts = from.split(</span><span class="s6">/[/\\]/</span><span class="s1">);</span>
	<span class="s2">const </span><span class="s1">toParts = to.split(</span><span class="s6">/[/\\]/</span><span class="s1">);</span>

	<span class="s1">fromParts.pop(); </span><span class="s4">// get dirname</span>

	<span class="s2">while </span><span class="s1">(fromParts[</span><span class="s3">0</span><span class="s1">] === toParts[</span><span class="s3">0</span><span class="s1">]) {</span>
		<span class="s1">fromParts.shift();</span>
		<span class="s1">toParts.shift();</span>
	<span class="s1">}</span>

	<span class="s2">if </span><span class="s1">(fromParts.length) {</span>
		<span class="s2">let </span><span class="s1">i = fromParts.length;</span>
		<span class="s2">while </span><span class="s1">(i--) fromParts[i] = </span><span class="s0">'..'</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">fromParts.concat(toParts).join(</span><span class="s0">'/'</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">toString = Object.prototype.toString;</span>

<span class="s2">function </span><span class="s1">isObject(thing) {</span>
	<span class="s2">return </span><span class="s1">toString.call(thing) === </span><span class="s0">'[object Object]'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getLocator(source) {</span>
	<span class="s2">const </span><span class="s1">originalLines = source.split(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
	<span class="s2">const </span><span class="s1">lineOffsets = [];</span>

	<span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">, pos = </span><span class="s3">0</span><span class="s1">; i &lt; originalLines.length; i++) {</span>
		<span class="s1">lineOffsets.push(pos);</span>
		<span class="s1">pos += originalLines[i].length + </span><span class="s3">1</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">return function </span><span class="s1">locate(index) {</span>
		<span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">;</span>
		<span class="s2">let </span><span class="s1">j = lineOffsets.length;</span>
		<span class="s2">while </span><span class="s1">(i &lt; j) {</span>
			<span class="s2">const </span><span class="s1">m = (i + j) &gt;&gt; </span><span class="s3">1</span><span class="s1">;</span>
			<span class="s2">if </span><span class="s1">(index &lt; lineOffsets[m]) {</span>
				<span class="s1">j = m;</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">i = m + </span><span class="s3">1</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">const </span><span class="s1">line = i - </span><span class="s3">1</span><span class="s1">;</span>
		<span class="s2">const </span><span class="s1">column = index - lineOffsets[line];</span>
		<span class="s2">return </span><span class="s1">{ line, column };</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">wordRegex = </span><span class="s6">/\w/</span><span class="s1">;</span>

<span class="s2">class </span><span class="s1">Mappings {</span>
	<span class="s1">constructor(hires) {</span>
		<span class="s2">this</span><span class="s1">.hires = hires;</span>
		<span class="s2">this</span><span class="s1">.generatedCodeLine = </span><span class="s3">0</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.generatedCodeColumn = </span><span class="s3">0</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.raw = [];</span>
		<span class="s2">this</span><span class="s1">.rawSegments = </span><span class="s2">this</span><span class="s1">.raw[</span><span class="s2">this</span><span class="s1">.generatedCodeLine] = [];</span>
		<span class="s2">this</span><span class="s1">.pending = </span><span class="s2">null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">addEdit(sourceIndex, content, loc, nameIndex) {</span>
		<span class="s2">if </span><span class="s1">(content.length) {</span>
			<span class="s2">const </span><span class="s1">contentLengthMinusOne = content.length - </span><span class="s3">1</span><span class="s1">;</span>
			<span class="s2">let </span><span class="s1">contentLineEnd = content.indexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">, </span><span class="s3">0</span><span class="s1">);</span>
			<span class="s2">let </span><span class="s1">previousContentLineEnd = -</span><span class="s3">1</span><span class="s1">;</span>
			<span class="s4">// Loop through each line in the content and add a segment, but stop if the last line is empty,</span>
			<span class="s4">// else code afterwards would fill one line too many</span>
			<span class="s2">while </span><span class="s1">(contentLineEnd &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; contentLengthMinusOne &gt; contentLineEnd) {</span>
				<span class="s2">const </span><span class="s1">segment = [</span><span class="s2">this</span><span class="s1">.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span>
				<span class="s2">if </span><span class="s1">(nameIndex &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
					<span class="s1">segment.push(nameIndex);</span>
				<span class="s1">}</span>
				<span class="s2">this</span><span class="s1">.rawSegments.push(segment);</span>

				<span class="s2">this</span><span class="s1">.generatedCodeLine += </span><span class="s3">1</span><span class="s1">;</span>
				<span class="s2">this</span><span class="s1">.raw[</span><span class="s2">this</span><span class="s1">.generatedCodeLine] = </span><span class="s2">this</span><span class="s1">.rawSegments = [];</span>
				<span class="s2">this</span><span class="s1">.generatedCodeColumn = </span><span class="s3">0</span><span class="s1">;</span>

				<span class="s1">previousContentLineEnd = contentLineEnd;</span>
				<span class="s1">contentLineEnd = content.indexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">, contentLineEnd + </span><span class="s3">1</span><span class="s1">);</span>
			<span class="s1">}</span>

			<span class="s2">const </span><span class="s1">segment = [</span><span class="s2">this</span><span class="s1">.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span>
			<span class="s2">if </span><span class="s1">(nameIndex &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
				<span class="s1">segment.push(nameIndex);</span>
			<span class="s1">}</span>
			<span class="s2">this</span><span class="s1">.rawSegments.push(segment);</span>

			<span class="s2">this</span><span class="s1">.advance(content.slice(previousContentLineEnd + </span><span class="s3">1</span><span class="s1">));</span>
		<span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pending) {</span>
			<span class="s2">this</span><span class="s1">.rawSegments.push(</span><span class="s2">this</span><span class="s1">.pending);</span>
			<span class="s2">this</span><span class="s1">.advance(content);</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.pending = </span><span class="s2">null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {</span>
		<span class="s2">let </span><span class="s1">originalCharIndex = chunk.start;</span>
		<span class="s2">let </span><span class="s1">first = </span><span class="s2">true</span><span class="s1">;</span>
		<span class="s4">// when iterating each char, check if it's in a word boundary</span>
		<span class="s2">let </span><span class="s1">charInHiresBoundary = </span><span class="s2">false</span><span class="s1">;</span>

		<span class="s2">while </span><span class="s1">(originalCharIndex &lt; chunk.end) {</span>
			<span class="s2">if </span><span class="s1">(original[originalCharIndex] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">) {</span>
				<span class="s1">loc.line += </span><span class="s3">1</span><span class="s1">;</span>
				<span class="s1">loc.column = </span><span class="s3">0</span><span class="s1">;</span>
				<span class="s2">this</span><span class="s1">.generatedCodeLine += </span><span class="s3">1</span><span class="s1">;</span>
				<span class="s2">this</span><span class="s1">.raw[</span><span class="s2">this</span><span class="s1">.generatedCodeLine] = </span><span class="s2">this</span><span class="s1">.rawSegments = [];</span>
				<span class="s2">this</span><span class="s1">.generatedCodeColumn = </span><span class="s3">0</span><span class="s1">;</span>
				<span class="s1">first = </span><span class="s2">true</span><span class="s1">;</span>
				<span class="s1">charInHiresBoundary = </span><span class="s2">false</span><span class="s1">;</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hires || first || sourcemapLocations.has(originalCharIndex)) {</span>
					<span class="s2">const </span><span class="s1">segment = [</span><span class="s2">this</span><span class="s1">.generatedCodeColumn, sourceIndex, loc.line, loc.column];</span>

					<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hires === </span><span class="s0">'boundary'</span><span class="s1">) {</span>
						<span class="s4">// in hires &quot;boundary&quot;, group segments per word boundary than per char</span>
						<span class="s2">if </span><span class="s1">(wordRegex.test(original[originalCharIndex])) {</span>
							<span class="s4">// for first char in the boundary found, start the boundary by pushing a segment</span>
							<span class="s2">if </span><span class="s1">(!charInHiresBoundary) {</span>
								<span class="s2">this</span><span class="s1">.rawSegments.push(segment);</span>
								<span class="s1">charInHiresBoundary = </span><span class="s2">true</span><span class="s1">;</span>
							<span class="s1">}</span>
						<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
							<span class="s4">// for non-word char, end the boundary by pushing a segment</span>
							<span class="s2">this</span><span class="s1">.rawSegments.push(segment);</span>
							<span class="s1">charInHiresBoundary = </span><span class="s2">false</span><span class="s1">;</span>
						<span class="s1">}</span>
					<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
						<span class="s2">this</span><span class="s1">.rawSegments.push(segment);</span>
					<span class="s1">}</span>
				<span class="s1">}</span>

				<span class="s1">loc.column += </span><span class="s3">1</span><span class="s1">;</span>
				<span class="s2">this</span><span class="s1">.generatedCodeColumn += </span><span class="s3">1</span><span class="s1">;</span>
				<span class="s1">first = </span><span class="s2">false</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s1">originalCharIndex += </span><span class="s3">1</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.pending = </span><span class="s2">null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">advance(str) {</span>
		<span class="s2">if </span><span class="s1">(!str) </span><span class="s2">return</span><span class="s1">;</span>

		<span class="s2">const </span><span class="s1">lines = str.split(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>

		<span class="s2">if </span><span class="s1">(lines.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
			<span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; lines.length - </span><span class="s3">1</span><span class="s1">; i++) {</span>
				<span class="s2">this</span><span class="s1">.generatedCodeLine++;</span>
				<span class="s2">this</span><span class="s1">.raw[</span><span class="s2">this</span><span class="s1">.generatedCodeLine] = </span><span class="s2">this</span><span class="s1">.rawSegments = [];</span>
			<span class="s1">}</span>
			<span class="s2">this</span><span class="s1">.generatedCodeColumn = </span><span class="s3">0</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.generatedCodeColumn += lines[lines.length - </span><span class="s3">1</span><span class="s1">].length;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">n = </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>

<span class="s2">const </span><span class="s1">warned = {</span>
	<span class="s1">insertLeft: </span><span class="s2">false</span><span class="s1">,</span>
	<span class="s1">insertRight: </span><span class="s2">false</span><span class="s1">,</span>
	<span class="s1">storeName: </span><span class="s2">false</span><span class="s1">,</span>
<span class="s1">};</span>

<span class="s2">class </span><span class="s1">MagicString {</span>
	<span class="s1">constructor(string, options = {}) {</span>
		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">new </span><span class="s1">Chunk(</span><span class="s3">0</span><span class="s1">, string.length, string);</span>

		<span class="s1">Object.defineProperties(</span><span class="s2">this</span><span class="s1">, {</span>
			<span class="s1">original: { writable: </span><span class="s2">true</span><span class="s1">, value: string },</span>
			<span class="s1">outro: { writable: </span><span class="s2">true</span><span class="s1">, value: </span><span class="s0">'' </span><span class="s1">},</span>
			<span class="s1">intro: { writable: </span><span class="s2">true</span><span class="s1">, value: </span><span class="s0">'' </span><span class="s1">},</span>
			<span class="s1">firstChunk: { writable: </span><span class="s2">true</span><span class="s1">, value: chunk },</span>
			<span class="s1">lastChunk: { writable: </span><span class="s2">true</span><span class="s1">, value: chunk },</span>
			<span class="s1">lastSearchedChunk: { writable: </span><span class="s2">true</span><span class="s1">, value: chunk },</span>
			<span class="s1">byStart: { writable: </span><span class="s2">true</span><span class="s1">, value: {} },</span>
			<span class="s1">byEnd: { writable: </span><span class="s2">true</span><span class="s1">, value: {} },</span>
			<span class="s1">filename: { writable: </span><span class="s2">true</span><span class="s1">, value: options.filename },</span>
			<span class="s1">indentExclusionRanges: { writable: </span><span class="s2">true</span><span class="s1">, value: options.indentExclusionRanges },</span>
			<span class="s1">sourcemapLocations: { writable: </span><span class="s2">true</span><span class="s1">, value: </span><span class="s2">new </span><span class="s1">BitSet() },</span>
			<span class="s1">storedNames: { writable: </span><span class="s2">true</span><span class="s1">, value: {} },</span>
			<span class="s1">indentStr: { writable: </span><span class="s2">true</span><span class="s1">, value: undefined },</span>
			<span class="s1">ignoreList: { writable: </span><span class="s2">true</span><span class="s1">, value: options.ignoreList },</span>
			<span class="s1">offset: { writable: </span><span class="s2">true</span><span class="s1">, value: options.offset || </span><span class="s3">0 </span><span class="s1">},</span>
		<span class="s1">});</span>

		<span class="s2">this</span><span class="s1">.byStart[</span><span class="s3">0</span><span class="s1">] = chunk;</span>
		<span class="s2">this</span><span class="s1">.byEnd[string.length] = chunk;</span>
	<span class="s1">}</span>

	<span class="s1">addSourcemapLocation(char) {</span>
		<span class="s2">this</span><span class="s1">.sourcemapLocations.add(char);</span>
	<span class="s1">}</span>

	<span class="s1">append(content) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s0">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'outro content must be a string'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">.outro += content;</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">appendLeft(index, content) {</span>
		<span class="s1">index = index + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s0">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'inserted content must be a string'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">._split(index);</span>

		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byEnd[index];</span>

		<span class="s2">if </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.appendLeft(content);</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.intro += content;</span>
		<span class="s1">}</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">appendRight(index, content) {</span>
		<span class="s1">index = index + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s0">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'inserted content must be a string'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">._split(index);</span>

		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byStart[index];</span>

		<span class="s2">if </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.appendRight(content);</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.outro += content;</span>
		<span class="s1">}</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">clone() {</span>
		<span class="s2">const </span><span class="s1">cloned = </span><span class="s2">new </span><span class="s1">MagicString(</span><span class="s2">this</span><span class="s1">.original, { filename: </span><span class="s2">this</span><span class="s1">.filename, offset: </span><span class="s2">this</span><span class="s1">.offset });</span>

		<span class="s2">let </span><span class="s1">originalChunk = </span><span class="s2">this</span><span class="s1">.firstChunk;</span>
		<span class="s2">let </span><span class="s1">clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());</span>

		<span class="s2">while </span><span class="s1">(originalChunk) {</span>
			<span class="s1">cloned.byStart[clonedChunk.start] = clonedChunk;</span>
			<span class="s1">cloned.byEnd[clonedChunk.end] = clonedChunk;</span>

			<span class="s2">const </span><span class="s1">nextOriginalChunk = originalChunk.next;</span>
			<span class="s2">const </span><span class="s1">nextClonedChunk = nextOriginalChunk &amp;&amp; nextOriginalChunk.clone();</span>

			<span class="s2">if </span><span class="s1">(nextClonedChunk) {</span>
				<span class="s1">clonedChunk.next = nextClonedChunk;</span>
				<span class="s1">nextClonedChunk.previous = clonedChunk;</span>

				<span class="s1">clonedChunk = nextClonedChunk;</span>
			<span class="s1">}</span>

			<span class="s1">originalChunk = nextOriginalChunk;</span>
		<span class="s1">}</span>

		<span class="s1">cloned.lastChunk = clonedChunk;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.indentExclusionRanges) {</span>
			<span class="s1">cloned.indentExclusionRanges = </span><span class="s2">this</span><span class="s1">.indentExclusionRanges.slice();</span>
		<span class="s1">}</span>

		<span class="s1">cloned.sourcemapLocations = </span><span class="s2">new </span><span class="s1">BitSet(</span><span class="s2">this</span><span class="s1">.sourcemapLocations);</span>

		<span class="s1">cloned.intro = </span><span class="s2">this</span><span class="s1">.intro;</span>
		<span class="s1">cloned.outro = </span><span class="s2">this</span><span class="s1">.outro;</span>

		<span class="s2">return </span><span class="s1">cloned;</span>
	<span class="s1">}</span>

	<span class="s1">generateDecodedMap(options) {</span>
		<span class="s1">options = options || {};</span>

		<span class="s2">const </span><span class="s1">sourceIndex = </span><span class="s3">0</span><span class="s1">;</span>
		<span class="s2">const </span><span class="s1">names = Object.keys(</span><span class="s2">this</span><span class="s1">.storedNames);</span>
		<span class="s2">const </span><span class="s1">mappings = </span><span class="s2">new </span><span class="s1">Mappings(options.hires);</span>

		<span class="s2">const </span><span class="s1">locate = getLocator(</span><span class="s2">this</span><span class="s1">.original);</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro) {</span>
			<span class="s1">mappings.advance(</span><span class="s2">this</span><span class="s1">.intro);</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.firstChunk.eachNext((chunk) =&gt; {</span>
			<span class="s2">const </span><span class="s1">loc = locate(chunk.start);</span>

			<span class="s2">if </span><span class="s1">(chunk.intro.length) mappings.advance(chunk.intro);</span>

			<span class="s2">if </span><span class="s1">(chunk.edited) {</span>
				<span class="s1">mappings.addEdit(</span>
					<span class="s1">sourceIndex,</span>
					<span class="s1">chunk.content,</span>
					<span class="s1">loc,</span>
					<span class="s1">chunk.storeName ? names.indexOf(chunk.original) : -</span><span class="s3">1</span><span class="s1">,</span>
				<span class="s1">);</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">mappings.addUneditedChunk(sourceIndex, chunk, </span><span class="s2">this</span><span class="s1">.original, loc, </span><span class="s2">this</span><span class="s1">.sourcemapLocations);</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(chunk.outro.length) mappings.advance(chunk.outro);</span>
		<span class="s1">});</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro) {</span>
			<span class="s1">mappings.advance(</span><span class="s2">this</span><span class="s1">.outro);</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">{</span>
			<span class="s1">file: options.file ? options.file.split(</span><span class="s6">/[/\\]/</span><span class="s1">).pop() : undefined,</span>
			<span class="s1">sources: [</span>
				<span class="s1">options.source ? getRelativePath(options.file || </span><span class="s0">''</span><span class="s1">, options.source) : options.file || </span><span class="s0">''</span><span class="s1">,</span>
			<span class="s1">],</span>
			<span class="s1">sourcesContent: options.includeContent ? [</span><span class="s2">this</span><span class="s1">.original] : undefined,</span>
			<span class="s1">names,</span>
			<span class="s1">mappings: mappings.raw,</span>
			<span class="s1">x_google_ignoreList: </span><span class="s2">this</span><span class="s1">.ignoreList ? [sourceIndex] : undefined,</span>
		<span class="s1">};</span>
	<span class="s1">}</span>

	<span class="s1">generateMap(options) {</span>
		<span class="s2">return new </span><span class="s1">SourceMap(</span><span class="s2">this</span><span class="s1">.generateDecodedMap(options));</span>
	<span class="s1">}</span>

	<span class="s1">_ensureindentStr() {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.indentStr === undefined) {</span>
			<span class="s2">this</span><span class="s1">.indentStr = guessIndent(</span><span class="s2">this</span><span class="s1">.original);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">_getRawIndentString() {</span>
		<span class="s2">this</span><span class="s1">._ensureindentStr();</span>
		<span class="s2">return this</span><span class="s1">.indentStr;</span>
	<span class="s1">}</span>

	<span class="s1">getIndentString() {</span>
		<span class="s2">this</span><span class="s1">._ensureindentStr();</span>
		<span class="s2">return this</span><span class="s1">.indentStr === </span><span class="s2">null </span><span class="s1">? </span><span class="s0">'</span><span class="s5">\t</span><span class="s0">' </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.indentStr;</span>
	<span class="s1">}</span>

	<span class="s1">indent(indentStr, options) {</span>
		<span class="s2">const </span><span class="s1">pattern = </span><span class="s6">/^[^\r\n]/gm</span><span class="s1">;</span>

		<span class="s2">if </span><span class="s1">(isObject(indentStr)) {</span>
			<span class="s1">options = indentStr;</span>
			<span class="s1">indentStr = undefined;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(indentStr === undefined) {</span>
			<span class="s2">this</span><span class="s1">._ensureindentStr();</span>
			<span class="s1">indentStr = </span><span class="s2">this</span><span class="s1">.indentStr || </span><span class="s0">'</span><span class="s5">\t</span><span class="s0">'</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(indentStr === </span><span class="s0">''</span><span class="s1">) </span><span class="s2">return this</span><span class="s1">; </span><span class="s4">// noop</span>

		<span class="s1">options = options || {};</span>

		<span class="s4">// Process exclusion ranges</span>
		<span class="s2">const </span><span class="s1">isExcluded = {};</span>

		<span class="s2">if </span><span class="s1">(options.exclude) {</span>
			<span class="s2">const </span><span class="s1">exclusions =</span>
				<span class="s2">typeof </span><span class="s1">options.exclude[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'number' </span><span class="s1">? [options.exclude] : options.exclude;</span>
			<span class="s1">exclusions.forEach((exclusion) =&gt; {</span>
				<span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = exclusion[</span><span class="s3">0</span><span class="s1">]; i &lt; exclusion[</span><span class="s3">1</span><span class="s1">]; i += </span><span class="s3">1</span><span class="s1">) {</span>
					<span class="s1">isExcluded[i] = </span><span class="s2">true</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">});</span>
		<span class="s1">}</span>

		<span class="s2">let </span><span class="s1">shouldIndentNextCharacter = options.indentStart !== </span><span class="s2">false</span><span class="s1">;</span>
		<span class="s2">const </span><span class="s1">replacer = (match) =&gt; {</span>
			<span class="s2">if </span><span class="s1">(shouldIndentNextCharacter) </span><span class="s2">return </span><span class="s0">`</span><span class="s1">${indentStr}${match}</span><span class="s0">`</span><span class="s1">;</span>
			<span class="s1">shouldIndentNextCharacter = </span><span class="s2">true</span><span class="s1">;</span>
			<span class="s2">return </span><span class="s1">match;</span>
		<span class="s1">};</span>

		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(pattern, replacer);</span>

		<span class="s2">let </span><span class="s1">charIndex = </span><span class="s3">0</span><span class="s1">;</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk;</span>

		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s2">const </span><span class="s1">end = chunk.end;</span>

			<span class="s2">if </span><span class="s1">(chunk.edited) {</span>
				<span class="s2">if </span><span class="s1">(!isExcluded[charIndex]) {</span>
					<span class="s1">chunk.content = chunk.content.replace(pattern, replacer);</span>

					<span class="s2">if </span><span class="s1">(chunk.content.length) {</span>
						<span class="s1">shouldIndentNextCharacter = chunk.content[chunk.content.length - </span><span class="s3">1</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">charIndex = chunk.start;</span>

				<span class="s2">while </span><span class="s1">(charIndex &lt; end) {</span>
					<span class="s2">if </span><span class="s1">(!isExcluded[charIndex]) {</span>
						<span class="s2">const </span><span class="s1">char = </span><span class="s2">this</span><span class="s1">.original[charIndex];</span>

						<span class="s2">if </span><span class="s1">(char === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">) {</span>
							<span class="s1">shouldIndentNextCharacter = </span><span class="s2">true</span><span class="s1">;</span>
						<span class="s1">} </span><span class="s2">else if </span><span class="s1">(char !== </span><span class="s0">'</span><span class="s5">\r</span><span class="s0">' </span><span class="s1">&amp;&amp; shouldIndentNextCharacter) {</span>
							<span class="s1">shouldIndentNextCharacter = </span><span class="s2">false</span><span class="s1">;</span>

							<span class="s2">if </span><span class="s1">(charIndex === chunk.start) {</span>
								<span class="s1">chunk.prependRight(indentStr);</span>
							<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
								<span class="s2">this</span><span class="s1">._splitChunk(chunk, charIndex);</span>
								<span class="s1">chunk = chunk.next;</span>
								<span class="s1">chunk.prependRight(indentStr);</span>
							<span class="s1">}</span>
						<span class="s1">}</span>
					<span class="s1">}</span>

					<span class="s1">charIndex += </span><span class="s3">1</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s1">charIndex = chunk.end;</span>
			<span class="s1">chunk = chunk.next;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.outro = </span><span class="s2">this</span><span class="s1">.outro.replace(pattern, replacer);</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">insert() {</span>
		<span class="s2">throw new </span><span class="s1">Error(</span>
			<span class="s0">'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'</span><span class="s1">,</span>
		<span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">insertLeft(index, content) {</span>
		<span class="s2">if </span><span class="s1">(!warned.insertLeft) {</span>
			<span class="s1">console.warn(</span>
				<span class="s0">'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'</span><span class="s1">,</span>
			<span class="s1">);</span>
			<span class="s1">warned.insertLeft = </span><span class="s2">true</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">.appendLeft(index, content);</span>
	<span class="s1">}</span>

	<span class="s1">insertRight(index, content) {</span>
		<span class="s2">if </span><span class="s1">(!warned.insertRight) {</span>
			<span class="s1">console.warn(</span>
				<span class="s0">'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'</span><span class="s1">,</span>
			<span class="s1">);</span>
			<span class="s1">warned.insertRight = </span><span class="s2">true</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">.prependRight(index, content);</span>
	<span class="s1">}</span>

	<span class="s1">move(start, end, index) {</span>
		<span class="s1">start = start + </span><span class="s2">this</span><span class="s1">.offset;</span>
		<span class="s1">end = end + </span><span class="s2">this</span><span class="s1">.offset;</span>
		<span class="s1">index = index + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(index &gt;= start &amp;&amp; index &lt;= end) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Cannot move a selection inside itself'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">._split(start);</span>
		<span class="s2">this</span><span class="s1">._split(end);</span>
		<span class="s2">this</span><span class="s1">._split(index);</span>

		<span class="s2">const </span><span class="s1">first = </span><span class="s2">this</span><span class="s1">.byStart[start];</span>
		<span class="s2">const </span><span class="s1">last = </span><span class="s2">this</span><span class="s1">.byEnd[end];</span>

		<span class="s2">const </span><span class="s1">oldLeft = first.previous;</span>
		<span class="s2">const </span><span class="s1">oldRight = last.next;</span>

		<span class="s2">const </span><span class="s1">newRight = </span><span class="s2">this</span><span class="s1">.byStart[index];</span>
		<span class="s2">if </span><span class="s1">(!newRight &amp;&amp; last === </span><span class="s2">this</span><span class="s1">.lastChunk) </span><span class="s2">return this</span><span class="s1">;</span>
		<span class="s2">const </span><span class="s1">newLeft = newRight ? newRight.previous : </span><span class="s2">this</span><span class="s1">.lastChunk;</span>

		<span class="s2">if </span><span class="s1">(oldLeft) oldLeft.next = oldRight;</span>
		<span class="s2">if </span><span class="s1">(oldRight) oldRight.previous = oldLeft;</span>

		<span class="s2">if </span><span class="s1">(newLeft) newLeft.next = first;</span>
		<span class="s2">if </span><span class="s1">(newRight) newRight.previous = last;</span>

		<span class="s2">if </span><span class="s1">(!first.previous) </span><span class="s2">this</span><span class="s1">.firstChunk = last.next;</span>
		<span class="s2">if </span><span class="s1">(!last.next) {</span>
			<span class="s2">this</span><span class="s1">.lastChunk = first.previous;</span>
			<span class="s2">this</span><span class="s1">.lastChunk.next = </span><span class="s2">null</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s1">first.previous = newLeft;</span>
		<span class="s1">last.next = newRight || </span><span class="s2">null</span><span class="s1">;</span>

		<span class="s2">if </span><span class="s1">(!newLeft) </span><span class="s2">this</span><span class="s1">.firstChunk = first;</span>
		<span class="s2">if </span><span class="s1">(!newRight) </span><span class="s2">this</span><span class="s1">.lastChunk = last;</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">overwrite(start, end, content, options) {</span>
		<span class="s1">options = options || {};</span>
		<span class="s2">return this</span><span class="s1">.update(start, end, content, { ...options, overwrite: !options.contentOnly });</span>
	<span class="s1">}</span>

	<span class="s1">update(start, end, content, options) {</span>
		<span class="s1">start = start + </span><span class="s2">this</span><span class="s1">.offset;</span>
		<span class="s1">end = end + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s0">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'replacement content must be a string'</span><span class="s1">);</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.original.length !== </span><span class="s3">0</span><span class="s1">) {</span>
			<span class="s2">while </span><span class="s1">(start &lt; </span><span class="s3">0</span><span class="s1">) start += </span><span class="s2">this</span><span class="s1">.original.length;</span>
			<span class="s2">while </span><span class="s1">(end &lt; </span><span class="s3">0</span><span class="s1">) end += </span><span class="s2">this</span><span class="s1">.original.length;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(end &gt; </span><span class="s2">this</span><span class="s1">.original.length) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'end is out of bounds'</span><span class="s1">);</span>
		<span class="s2">if </span><span class="s1">(start === end)</span>
			<span class="s2">throw new </span><span class="s1">Error(</span>
				<span class="s0">'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'</span><span class="s1">,</span>
			<span class="s1">);</span>

		<span class="s2">this</span><span class="s1">._split(start);</span>
		<span class="s2">this</span><span class="s1">._split(end);</span>

		<span class="s2">if </span><span class="s1">(options === </span><span class="s2">true</span><span class="s1">) {</span>
			<span class="s2">if </span><span class="s1">(!warned.storeName) {</span>
				<span class="s1">console.warn(</span>
					<span class="s0">'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'</span><span class="s1">,</span>
				<span class="s1">);</span>
				<span class="s1">warned.storeName = </span><span class="s2">true</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s1">options = { storeName: </span><span class="s2">true </span><span class="s1">};</span>
		<span class="s1">}</span>
		<span class="s2">const </span><span class="s1">storeName = options !== undefined ? options.storeName : </span><span class="s2">false</span><span class="s1">;</span>
		<span class="s2">const </span><span class="s1">overwrite = options !== undefined ? options.overwrite : </span><span class="s2">false</span><span class="s1">;</span>

		<span class="s2">if </span><span class="s1">(storeName) {</span>
			<span class="s2">const </span><span class="s1">original = </span><span class="s2">this</span><span class="s1">.original.slice(start, end);</span>
			<span class="s1">Object.defineProperty(</span><span class="s2">this</span><span class="s1">.storedNames, original, {</span>
				<span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
				<span class="s1">value: </span><span class="s2">true</span><span class="s1">,</span>
				<span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
			<span class="s1">});</span>
		<span class="s1">}</span>

		<span class="s2">const </span><span class="s1">first = </span><span class="s2">this</span><span class="s1">.byStart[start];</span>
		<span class="s2">const </span><span class="s1">last = </span><span class="s2">this</span><span class="s1">.byEnd[end];</span>

		<span class="s2">if </span><span class="s1">(first) {</span>
			<span class="s2">let </span><span class="s1">chunk = first;</span>
			<span class="s2">while </span><span class="s1">(chunk !== last) {</span>
				<span class="s2">if </span><span class="s1">(chunk.next !== </span><span class="s2">this</span><span class="s1">.byStart[chunk.end]) {</span>
					<span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Cannot overwrite across a split point'</span><span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s1">chunk = chunk.next;</span>
				<span class="s1">chunk.edit(</span><span class="s0">''</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
			<span class="s1">}</span>

			<span class="s1">first.edit(content, storeName, !overwrite);</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s4">// must be inserting at the end</span>
			<span class="s2">const </span><span class="s1">newChunk = </span><span class="s2">new </span><span class="s1">Chunk(start, end, </span><span class="s0">''</span><span class="s1">).edit(content, storeName);</span>

			<span class="s4">// TODO last chunk in the array may not be the last chunk, if it's moved...</span>
			<span class="s1">last.next = newChunk;</span>
			<span class="s1">newChunk.previous = last;</span>
		<span class="s1">}</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">prepend(content) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s0">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'outro content must be a string'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">.intro = content + </span><span class="s2">this</span><span class="s1">.intro;</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">prependLeft(index, content) {</span>
		<span class="s1">index = index + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s0">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'inserted content must be a string'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">._split(index);</span>

		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byEnd[index];</span>

		<span class="s2">if </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.prependLeft(content);</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.intro = content + </span><span class="s2">this</span><span class="s1">.intro;</span>
		<span class="s1">}</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">prependRight(index, content) {</span>
		<span class="s1">index = index + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s0">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'inserted content must be a string'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">._split(index);</span>

		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byStart[index];</span>

		<span class="s2">if </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.prependRight(content);</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.outro = content + </span><span class="s2">this</span><span class="s1">.outro;</span>
		<span class="s1">}</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">remove(start, end) {</span>
		<span class="s1">start = start + </span><span class="s2">this</span><span class="s1">.offset;</span>
		<span class="s1">end = end + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.original.length !== </span><span class="s3">0</span><span class="s1">) {</span>
			<span class="s2">while </span><span class="s1">(start &lt; </span><span class="s3">0</span><span class="s1">) start += </span><span class="s2">this</span><span class="s1">.original.length;</span>
			<span class="s2">while </span><span class="s1">(end &lt; </span><span class="s3">0</span><span class="s1">) end += </span><span class="s2">this</span><span class="s1">.original.length;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(start === end) </span><span class="s2">return this</span><span class="s1">;</span>

		<span class="s2">if </span><span class="s1">(start &lt; </span><span class="s3">0 </span><span class="s1">|| end &gt; </span><span class="s2">this</span><span class="s1">.original.length) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Character is out of bounds'</span><span class="s1">);</span>
		<span class="s2">if </span><span class="s1">(start &gt; end) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'end must be greater than start'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">._split(start);</span>
		<span class="s2">this</span><span class="s1">._split(end);</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byStart[start];</span>

		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.intro = </span><span class="s0">''</span><span class="s1">;</span>
			<span class="s1">chunk.outro = </span><span class="s0">''</span><span class="s1">;</span>
			<span class="s1">chunk.edit(</span><span class="s0">''</span><span class="s1">);</span>

			<span class="s1">chunk = end &gt; chunk.end ? </span><span class="s2">this</span><span class="s1">.byStart[chunk.end] : </span><span class="s2">null</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">reset(start, end) {</span>
		<span class="s1">start = start + </span><span class="s2">this</span><span class="s1">.offset;</span>
		<span class="s1">end = end + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.original.length !== </span><span class="s3">0</span><span class="s1">) {</span>
			<span class="s2">while </span><span class="s1">(start &lt; </span><span class="s3">0</span><span class="s1">) start += </span><span class="s2">this</span><span class="s1">.original.length;</span>
			<span class="s2">while </span><span class="s1">(end &lt; </span><span class="s3">0</span><span class="s1">) end += </span><span class="s2">this</span><span class="s1">.original.length;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(start === end) </span><span class="s2">return this</span><span class="s1">;</span>

		<span class="s2">if </span><span class="s1">(start &lt; </span><span class="s3">0 </span><span class="s1">|| end &gt; </span><span class="s2">this</span><span class="s1">.original.length) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Character is out of bounds'</span><span class="s1">);</span>
		<span class="s2">if </span><span class="s1">(start &gt; end) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'end must be greater than start'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">._split(start);</span>
		<span class="s2">this</span><span class="s1">._split(end);</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byStart[start];</span>

		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.reset();</span>

			<span class="s1">chunk = end &gt; chunk.end ? </span><span class="s2">this</span><span class="s1">.byStart[chunk.end] : </span><span class="s2">null</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">lastChar() {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro.length) </span><span class="s2">return this</span><span class="s1">.outro[</span><span class="s2">this</span><span class="s1">.outro.length - </span><span class="s3">1</span><span class="s1">];</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.lastChunk;</span>
		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(chunk.outro.length) </span><span class="s2">return </span><span class="s1">chunk.outro[chunk.outro.length - </span><span class="s3">1</span><span class="s1">];</span>
			<span class="s2">if </span><span class="s1">(chunk.content.length) </span><span class="s2">return </span><span class="s1">chunk.content[chunk.content.length - </span><span class="s3">1</span><span class="s1">];</span>
			<span class="s2">if </span><span class="s1">(chunk.intro.length) </span><span class="s2">return </span><span class="s1">chunk.intro[chunk.intro.length - </span><span class="s3">1</span><span class="s1">];</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">((chunk = chunk.previous));</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length) </span><span class="s2">return this</span><span class="s1">.intro[</span><span class="s2">this</span><span class="s1">.intro.length - </span><span class="s3">1</span><span class="s1">];</span>
		<span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">lastLine() {</span>
		<span class="s2">let </span><span class="s1">lineIndex = </span><span class="s2">this</span><span class="s1">.outro.lastIndexOf(n);</span>
		<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s3">1</span><span class="s1">) </span><span class="s2">return this</span><span class="s1">.outro.substr(lineIndex + </span><span class="s3">1</span><span class="s1">);</span>
		<span class="s2">let </span><span class="s1">lineStr = </span><span class="s2">this</span><span class="s1">.outro;</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.lastChunk;</span>
		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(chunk.outro.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
				<span class="s1">lineIndex = chunk.outro.lastIndexOf(n);</span>
				<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s3">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">chunk.outro.substr(lineIndex + </span><span class="s3">1</span><span class="s1">) + lineStr;</span>
				<span class="s1">lineStr = chunk.outro + lineStr;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(chunk.content.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
				<span class="s1">lineIndex = chunk.content.lastIndexOf(n);</span>
				<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s3">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">chunk.content.substr(lineIndex + </span><span class="s3">1</span><span class="s1">) + lineStr;</span>
				<span class="s1">lineStr = chunk.content + lineStr;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(chunk.intro.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
				<span class="s1">lineIndex = chunk.intro.lastIndexOf(n);</span>
				<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s3">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">chunk.intro.substr(lineIndex + </span><span class="s3">1</span><span class="s1">) + lineStr;</span>
				<span class="s1">lineStr = chunk.intro + lineStr;</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">((chunk = chunk.previous));</span>
		<span class="s1">lineIndex = </span><span class="s2">this</span><span class="s1">.intro.lastIndexOf(n);</span>
		<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s3">1</span><span class="s1">) </span><span class="s2">return this</span><span class="s1">.intro.substr(lineIndex + </span><span class="s3">1</span><span class="s1">) + lineStr;</span>
		<span class="s2">return this</span><span class="s1">.intro + lineStr;</span>
	<span class="s1">}</span>

	<span class="s1">slice(start = </span><span class="s3">0</span><span class="s1">, end = </span><span class="s2">this</span><span class="s1">.original.length - </span><span class="s2">this</span><span class="s1">.offset) {</span>
		<span class="s1">start = start + </span><span class="s2">this</span><span class="s1">.offset;</span>
		<span class="s1">end = end + </span><span class="s2">this</span><span class="s1">.offset;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.original.length !== </span><span class="s3">0</span><span class="s1">) {</span>
			<span class="s2">while </span><span class="s1">(start &lt; </span><span class="s3">0</span><span class="s1">) start += </span><span class="s2">this</span><span class="s1">.original.length;</span>
			<span class="s2">while </span><span class="s1">(end &lt; </span><span class="s3">0</span><span class="s1">) end += </span><span class="s2">this</span><span class="s1">.original.length;</span>
		<span class="s1">}</span>

		<span class="s2">let </span><span class="s1">result = </span><span class="s0">''</span><span class="s1">;</span>

		<span class="s4">// find start chunk</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk;</span>
		<span class="s2">while </span><span class="s1">(chunk &amp;&amp; (chunk.start &gt; start || chunk.end &lt;= start)) {</span>
			<span class="s4">// found end chunk before start</span>
			<span class="s2">if </span><span class="s1">(chunk.start &lt; end &amp;&amp; chunk.end &gt;= end) {</span>
				<span class="s2">return </span><span class="s1">result;</span>
			<span class="s1">}</span>

			<span class="s1">chunk = chunk.next;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(chunk &amp;&amp; chunk.edited &amp;&amp; chunk.start !== start)</span>
			<span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Cannot use replaced character </span><span class="s1">${start} </span><span class="s0">as slice start anchor.`</span><span class="s1">);</span>

		<span class="s2">const </span><span class="s1">startChunk = chunk;</span>
		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s2">if </span><span class="s1">(chunk.intro &amp;&amp; (startChunk !== chunk || chunk.start === start)) {</span>
				<span class="s1">result += chunk.intro;</span>
			<span class="s1">}</span>

			<span class="s2">const </span><span class="s1">containsEnd = chunk.start &lt; end &amp;&amp; chunk.end &gt;= end;</span>
			<span class="s2">if </span><span class="s1">(containsEnd &amp;&amp; chunk.edited &amp;&amp; chunk.end !== end)</span>
				<span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Cannot use replaced character </span><span class="s1">${end} </span><span class="s0">as slice end anchor.`</span><span class="s1">);</span>

			<span class="s2">const </span><span class="s1">sliceStart = startChunk === chunk ? start - chunk.start : </span><span class="s3">0</span><span class="s1">;</span>
			<span class="s2">const </span><span class="s1">sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;</span>

			<span class="s1">result += chunk.content.slice(sliceStart, sliceEnd);</span>

			<span class="s2">if </span><span class="s1">(chunk.outro &amp;&amp; (!containsEnd || chunk.end === end)) {</span>
				<span class="s1">result += chunk.outro;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(containsEnd) {</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s1">chunk = chunk.next;</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">result;</span>
	<span class="s1">}</span>

	<span class="s4">// TODO deprecate this? not really very useful</span>
	<span class="s1">snip(start, end) {</span>
		<span class="s2">const </span><span class="s1">clone = </span><span class="s2">this</span><span class="s1">.clone();</span>
		<span class="s1">clone.remove(</span><span class="s3">0</span><span class="s1">, start);</span>
		<span class="s1">clone.remove(end, clone.original.length);</span>

		<span class="s2">return </span><span class="s1">clone;</span>
	<span class="s1">}</span>

	<span class="s1">_split(index) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.byStart[index] || </span><span class="s2">this</span><span class="s1">.byEnd[index]) </span><span class="s2">return</span><span class="s1">;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.lastSearchedChunk;</span>
		<span class="s2">let </span><span class="s1">previousChunk = chunk;</span>
		<span class="s2">const </span><span class="s1">searchForward = index &gt; chunk.end;</span>

		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s2">if </span><span class="s1">(chunk.contains(index)) </span><span class="s2">return this</span><span class="s1">._splitChunk(chunk, index);</span>

			<span class="s1">chunk = searchForward ? </span><span class="s2">this</span><span class="s1">.byStart[chunk.end] : </span><span class="s2">this</span><span class="s1">.byEnd[chunk.start];</span>

			<span class="s4">// Prevent infinite loop (e.g. via empty chunks, where start === end)</span>
			<span class="s2">if </span><span class="s1">(chunk === previousChunk) </span><span class="s2">return</span><span class="s1">;</span>

			<span class="s1">previousChunk = chunk;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">_splitChunk(chunk, index) {</span>
		<span class="s2">if </span><span class="s1">(chunk.edited &amp;&amp; chunk.content.length) {</span>
			<span class="s4">// zero-length edited chunks are a special case (overlapping replacements)</span>
			<span class="s2">const </span><span class="s1">loc = getLocator(</span><span class="s2">this</span><span class="s1">.original)(index);</span>
			<span class="s2">throw new </span><span class="s1">Error(</span>
				<span class="s0">`Cannot split a chunk that has already been edited (</span><span class="s1">${loc.line}</span><span class="s0">:</span><span class="s1">${loc.column} </span><span class="s0">– &quot;</span><span class="s1">${chunk.original}</span><span class="s0">&quot;)`</span><span class="s1">,</span>
			<span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">const </span><span class="s1">newChunk = chunk.split(index);</span>

		<span class="s2">this</span><span class="s1">.byEnd[index] = chunk;</span>
		<span class="s2">this</span><span class="s1">.byStart[index] = newChunk;</span>
		<span class="s2">this</span><span class="s1">.byEnd[newChunk.end] = newChunk;</span>

		<span class="s2">if </span><span class="s1">(chunk === </span><span class="s2">this</span><span class="s1">.lastChunk) </span><span class="s2">this</span><span class="s1">.lastChunk = newChunk;</span>

		<span class="s2">this</span><span class="s1">.lastSearchedChunk = chunk;</span>
		<span class="s2">return true</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">toString() {</span>
		<span class="s2">let </span><span class="s1">str = </span><span class="s2">this</span><span class="s1">.intro;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk;</span>
		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">str += chunk.toString();</span>
			<span class="s1">chunk = chunk.next;</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">str + </span><span class="s2">this</span><span class="s1">.outro;</span>
	<span class="s1">}</span>

	<span class="s1">isEmpty() {</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk;</span>
		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(</span>
				<span class="s1">(chunk.intro.length &amp;&amp; chunk.intro.trim()) ||</span>
				<span class="s1">(chunk.content.length &amp;&amp; chunk.content.trim()) ||</span>
				<span class="s1">(chunk.outro.length &amp;&amp; chunk.outro.trim())</span>
			<span class="s1">)</span>
				<span class="s2">return false</span><span class="s1">;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">((chunk = chunk.next));</span>
		<span class="s2">return true</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">length() {</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk;</span>
		<span class="s2">let </span><span class="s1">length = </span><span class="s3">0</span><span class="s1">;</span>
		<span class="s2">do </span><span class="s1">{</span>
			<span class="s1">length += chunk.intro.length + chunk.content.length + chunk.outro.length;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">((chunk = chunk.next));</span>
		<span class="s2">return </span><span class="s1">length;</span>
	<span class="s1">}</span>

	<span class="s1">trimLines() {</span>
		<span class="s2">return this</span><span class="s1">.trim(</span><span class="s0">'[</span><span class="s5">\\</span><span class="s0">r</span><span class="s5">\\</span><span class="s0">n]'</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">trim(charType) {</span>
		<span class="s2">return this</span><span class="s1">.trimStart(charType).trimEnd(charType);</span>
	<span class="s1">}</span>

	<span class="s1">trimEndAborted(charType) {</span>
		<span class="s2">const </span><span class="s1">rx = </span><span class="s2">new </span><span class="s1">RegExp((charType || </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">s'</span><span class="s1">) + </span><span class="s0">'+$'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">.outro = </span><span class="s2">this</span><span class="s1">.outro.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro.length) </span><span class="s2">return true</span><span class="s1">;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.lastChunk;</span>

		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">const </span><span class="s1">end = chunk.end;</span>
			<span class="s2">const </span><span class="s1">aborted = chunk.trimEnd(rx);</span>

			<span class="s4">// if chunk was trimmed, we have a new lastChunk</span>
			<span class="s2">if </span><span class="s1">(chunk.end !== end) {</span>
				<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.lastChunk === chunk) {</span>
					<span class="s2">this</span><span class="s1">.lastChunk = chunk.next;</span>
				<span class="s1">}</span>

				<span class="s2">this</span><span class="s1">.byEnd[chunk.end] = chunk;</span>
				<span class="s2">this</span><span class="s1">.byStart[chunk.next.start] = chunk.next;</span>
				<span class="s2">this</span><span class="s1">.byEnd[chunk.next.end] = chunk.next;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(aborted) </span><span class="s2">return true</span><span class="s1">;</span>
			<span class="s1">chunk = chunk.previous;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">(chunk);</span>

		<span class="s2">return false</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">trimEnd(charType) {</span>
		<span class="s2">this</span><span class="s1">.trimEndAborted(charType);</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>
	<span class="s1">trimStartAborted(charType) {</span>
		<span class="s2">const </span><span class="s1">rx = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">'^' </span><span class="s1">+ (charType || </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">s'</span><span class="s1">) + </span><span class="s0">'+'</span><span class="s1">);</span>

		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length) </span><span class="s2">return true</span><span class="s1">;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk;</span>

		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">const </span><span class="s1">end = chunk.end;</span>
			<span class="s2">const </span><span class="s1">aborted = chunk.trimStart(rx);</span>

			<span class="s2">if </span><span class="s1">(chunk.end !== end) {</span>
				<span class="s4">// special case...</span>
				<span class="s2">if </span><span class="s1">(chunk === </span><span class="s2">this</span><span class="s1">.lastChunk) </span><span class="s2">this</span><span class="s1">.lastChunk = chunk.next;</span>

				<span class="s2">this</span><span class="s1">.byEnd[chunk.end] = chunk;</span>
				<span class="s2">this</span><span class="s1">.byStart[chunk.next.start] = chunk.next;</span>
				<span class="s2">this</span><span class="s1">.byEnd[chunk.next.end] = chunk.next;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(aborted) </span><span class="s2">return true</span><span class="s1">;</span>
			<span class="s1">chunk = chunk.next;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">(chunk);</span>

		<span class="s2">return false</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">trimStart(charType) {</span>
		<span class="s2">this</span><span class="s1">.trimStartAborted(charType);</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">hasChanged() {</span>
		<span class="s2">return this</span><span class="s1">.original !== </span><span class="s2">this</span><span class="s1">.toString();</span>
	<span class="s1">}</span>

	<span class="s1">_replaceRegexp(searchValue, replacement) {</span>
		<span class="s2">function </span><span class="s1">getReplacement(match, str) {</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">replacement === </span><span class="s0">'string'</span><span class="s1">) {</span>
				<span class="s2">return </span><span class="s1">replacement.replace(</span><span class="s6">/\$(\$|&amp;|\d+)/g</span><span class="s1">, (_, i) =&gt; {</span>
					<span class="s4">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter</span>
					<span class="s2">if </span><span class="s1">(i === </span><span class="s0">'$'</span><span class="s1">) </span><span class="s2">return </span><span class="s0">'$'</span><span class="s1">;</span>
					<span class="s2">if </span><span class="s1">(i === </span><span class="s0">'&amp;'</span><span class="s1">) </span><span class="s2">return </span><span class="s1">match[</span><span class="s3">0</span><span class="s1">];</span>
					<span class="s2">const </span><span class="s1">num = +i;</span>
					<span class="s2">if </span><span class="s1">(num &lt; match.length) </span><span class="s2">return </span><span class="s1">match[+i];</span>
					<span class="s2">return </span><span class="s0">`$</span><span class="s1">${i}</span><span class="s0">`</span><span class="s1">;</span>
				<span class="s1">});</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s2">return </span><span class="s1">replacement(...match, match.index, str, match.groups);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">function </span><span class="s1">matchAll(re, str) {</span>
			<span class="s2">let </span><span class="s1">match;</span>
			<span class="s2">const </span><span class="s1">matches = [];</span>
			<span class="s2">while </span><span class="s1">((match = re.exec(str))) {</span>
				<span class="s1">matches.push(match);</span>
			<span class="s1">}</span>
			<span class="s2">return </span><span class="s1">matches;</span>
		<span class="s1">}</span>
		<span class="s2">if </span><span class="s1">(searchValue.global) {</span>
			<span class="s2">const </span><span class="s1">matches = matchAll(searchValue, </span><span class="s2">this</span><span class="s1">.original);</span>
			<span class="s1">matches.forEach((match) =&gt; {</span>
				<span class="s2">if </span><span class="s1">(match.index != </span><span class="s2">null</span><span class="s1">) {</span>
					<span class="s2">const </span><span class="s1">replacement = getReplacement(match, </span><span class="s2">this</span><span class="s1">.original);</span>
					<span class="s2">if </span><span class="s1">(replacement !== match[</span><span class="s3">0</span><span class="s1">]) {</span>
						<span class="s2">this</span><span class="s1">.overwrite(match.index, match.index + match[</span><span class="s3">0</span><span class="s1">].length, replacement);</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">});</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">const </span><span class="s1">match = </span><span class="s2">this</span><span class="s1">.original.match(searchValue);</span>
			<span class="s2">if </span><span class="s1">(match &amp;&amp; match.index != </span><span class="s2">null</span><span class="s1">) {</span>
				<span class="s2">const </span><span class="s1">replacement = getReplacement(match, </span><span class="s2">this</span><span class="s1">.original);</span>
				<span class="s2">if </span><span class="s1">(replacement !== match[</span><span class="s3">0</span><span class="s1">]) {</span>
					<span class="s2">this</span><span class="s1">.overwrite(match.index, match.index + match[</span><span class="s3">0</span><span class="s1">].length, replacement);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">_replaceString(string, replacement) {</span>
		<span class="s2">const </span><span class="s1">{ original } = </span><span class="s2">this</span><span class="s1">;</span>
		<span class="s2">const </span><span class="s1">index = original.indexOf(string);</span>

		<span class="s2">if </span><span class="s1">(index !== -</span><span class="s3">1</span><span class="s1">) {</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">replacement === </span><span class="s0">'function'</span><span class="s1">) {</span>
				<span class="s1">replacement = replacement(string, index, original);</span>
			<span class="s1">}</span>
			<span class="s2">if </span><span class="s1">(string !== replacement) {</span>
				<span class="s2">this</span><span class="s1">.overwrite(index, index + string.length, replacement);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">replace(searchValue, replacement) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">searchValue === </span><span class="s0">'string'</span><span class="s1">) {</span>
			<span class="s2">return this</span><span class="s1">._replaceString(searchValue, replacement);</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">._replaceRegexp(searchValue, replacement);</span>
	<span class="s1">}</span>

	<span class="s1">_replaceAllString(string, replacement) {</span>
		<span class="s2">const </span><span class="s1">{ original } = </span><span class="s2">this</span><span class="s1">;</span>
		<span class="s2">const </span><span class="s1">stringLength = string.length;</span>
		<span class="s2">for </span><span class="s1">(</span>
			<span class="s2">let </span><span class="s1">index = original.indexOf(string);</span>
			<span class="s1">index !== -</span><span class="s3">1</span><span class="s1">;</span>
			<span class="s1">index = original.indexOf(string, index + stringLength)</span>
		<span class="s1">) {</span>
			<span class="s2">const </span><span class="s1">previous = original.slice(index, index + stringLength);</span>
			<span class="s2">let </span><span class="s1">_replacement = replacement;</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">replacement === </span><span class="s0">'function'</span><span class="s1">) {</span>
				<span class="s1">_replacement = replacement(previous, index, original);</span>
			<span class="s1">}</span>
			<span class="s2">if </span><span class="s1">(previous !== _replacement) </span><span class="s2">this</span><span class="s1">.overwrite(index, index + stringLength, _replacement);</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">replaceAll(searchValue, replacement) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">searchValue === </span><span class="s0">'string'</span><span class="s1">) {</span>
			<span class="s2">return this</span><span class="s1">._replaceAllString(searchValue, replacement);</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(!searchValue.global) {</span>
			<span class="s2">throw new </span><span class="s1">TypeError(</span>
				<span class="s0">'MagicString.prototype.replaceAll called with a non-global RegExp argument'</span><span class="s1">,</span>
			<span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">._replaceRegexp(searchValue, replacement);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">hasOwnProp = Object.prototype.hasOwnProperty;</span>

<span class="s2">class </span><span class="s1">Bundle {</span>
	<span class="s1">constructor(options = {}) {</span>
		<span class="s2">this</span><span class="s1">.intro = options.intro || </span><span class="s0">''</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.separator = options.separator !== undefined ? options.separator : </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
		<span class="s2">this</span><span class="s1">.sources = [];</span>
		<span class="s2">this</span><span class="s1">.uniqueSources = [];</span>
		<span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename = {};</span>
	<span class="s1">}</span>

	<span class="s1">addSource(source) {</span>
		<span class="s2">if </span><span class="s1">(source </span><span class="s2">instanceof </span><span class="s1">MagicString) {</span>
			<span class="s2">return this</span><span class="s1">.addSource({</span>
				<span class="s1">content: source,</span>
				<span class="s1">filename: source.filename,</span>
				<span class="s1">separator: </span><span class="s2">this</span><span class="s1">.separator,</span>
			<span class="s1">});</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(!isObject(source) || !source.content) {</span>
			<span class="s2">throw new </span><span class="s1">Error(</span>
				<span class="s0">'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'</span><span class="s1">,</span>
			<span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s1">[</span><span class="s0">'filename'</span><span class="s1">, </span><span class="s0">'ignoreList'</span><span class="s1">, </span><span class="s0">'indentExclusionRanges'</span><span class="s1">, </span><span class="s0">'separator'</span><span class="s1">].forEach((option) =&gt; {</span>
			<span class="s2">if </span><span class="s1">(!hasOwnProp.call(source, option)) source[option] = source.content[option];</span>
		<span class="s1">});</span>

		<span class="s2">if </span><span class="s1">(source.separator === undefined) {</span>
			<span class="s4">// TODO there's a bunch of this sort of thing, needs cleaning up</span>
			<span class="s1">source.separator = </span><span class="s2">this</span><span class="s1">.separator;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(source.filename) {</span>
			<span class="s2">if </span><span class="s1">(!hasOwnProp.call(</span><span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename, source.filename)) {</span>
				<span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename[source.filename] = </span><span class="s2">this</span><span class="s1">.uniqueSources.length;</span>
				<span class="s2">this</span><span class="s1">.uniqueSources.push({ filename: source.filename, content: source.content.original });</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s2">const </span><span class="s1">uniqueSource = </span><span class="s2">this</span><span class="s1">.uniqueSources[</span><span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename[source.filename]];</span>
				<span class="s2">if </span><span class="s1">(source.content.original !== uniqueSource.content) {</span>
					<span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Illegal source: same filename (</span><span class="s1">${source.filename}</span><span class="s0">), different contents`</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.sources.push(source);</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">append(str, options) {</span>
		<span class="s2">this</span><span class="s1">.addSource({</span>
			<span class="s1">content: </span><span class="s2">new </span><span class="s1">MagicString(str),</span>
			<span class="s1">separator: (options &amp;&amp; options.separator) || </span><span class="s0">''</span><span class="s1">,</span>
		<span class="s1">});</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">clone() {</span>
		<span class="s2">const </span><span class="s1">bundle = </span><span class="s2">new </span><span class="s1">Bundle({</span>
			<span class="s1">intro: </span><span class="s2">this</span><span class="s1">.intro,</span>
			<span class="s1">separator: </span><span class="s2">this</span><span class="s1">.separator,</span>
		<span class="s1">});</span>

		<span class="s2">this</span><span class="s1">.sources.forEach((source) =&gt; {</span>
			<span class="s1">bundle.addSource({</span>
				<span class="s1">filename: source.filename,</span>
				<span class="s1">content: source.content.clone(),</span>
				<span class="s1">separator: source.separator,</span>
			<span class="s1">});</span>
		<span class="s1">});</span>

		<span class="s2">return </span><span class="s1">bundle;</span>
	<span class="s1">}</span>

	<span class="s1">generateDecodedMap(options = {}) {</span>
		<span class="s2">const </span><span class="s1">names = [];</span>
		<span class="s2">let </span><span class="s1">x_google_ignoreList = undefined;</span>
		<span class="s2">this</span><span class="s1">.sources.forEach((source) =&gt; {</span>
			<span class="s1">Object.keys(source.content.storedNames).forEach((name) =&gt; {</span>
				<span class="s2">if </span><span class="s1">(!~names.indexOf(name)) names.push(name);</span>
			<span class="s1">});</span>
		<span class="s1">});</span>

		<span class="s2">const </span><span class="s1">mappings = </span><span class="s2">new </span><span class="s1">Mappings(options.hires);</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro) {</span>
			<span class="s1">mappings.advance(</span><span class="s2">this</span><span class="s1">.intro);</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.sources.forEach((source, i) =&gt; {</span>
			<span class="s2">if </span><span class="s1">(i &gt; </span><span class="s3">0</span><span class="s1">) {</span>
				<span class="s1">mappings.advance(</span><span class="s2">this</span><span class="s1">.separator);</span>
			<span class="s1">}</span>

			<span class="s2">const </span><span class="s1">sourceIndex = source.filename ? </span><span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename[source.filename] : -</span><span class="s3">1</span><span class="s1">;</span>
			<span class="s2">const </span><span class="s1">magicString = source.content;</span>
			<span class="s2">const </span><span class="s1">locate = getLocator(magicString.original);</span>

			<span class="s2">if </span><span class="s1">(magicString.intro) {</span>
				<span class="s1">mappings.advance(magicString.intro);</span>
			<span class="s1">}</span>

			<span class="s1">magicString.firstChunk.eachNext((chunk) =&gt; {</span>
				<span class="s2">const </span><span class="s1">loc = locate(chunk.start);</span>

				<span class="s2">if </span><span class="s1">(chunk.intro.length) mappings.advance(chunk.intro);</span>

				<span class="s2">if </span><span class="s1">(source.filename) {</span>
					<span class="s2">if </span><span class="s1">(chunk.edited) {</span>
						<span class="s1">mappings.addEdit(</span>
							<span class="s1">sourceIndex,</span>
							<span class="s1">chunk.content,</span>
							<span class="s1">loc,</span>
							<span class="s1">chunk.storeName ? names.indexOf(chunk.original) : -</span><span class="s3">1</span><span class="s1">,</span>
						<span class="s1">);</span>
					<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
						<span class="s1">mappings.addUneditedChunk(</span>
							<span class="s1">sourceIndex,</span>
							<span class="s1">chunk,</span>
							<span class="s1">magicString.original,</span>
							<span class="s1">loc,</span>
							<span class="s1">magicString.sourcemapLocations,</span>
						<span class="s1">);</span>
					<span class="s1">}</span>
				<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
					<span class="s1">mappings.advance(chunk.content);</span>
				<span class="s1">}</span>

				<span class="s2">if </span><span class="s1">(chunk.outro.length) mappings.advance(chunk.outro);</span>
			<span class="s1">});</span>

			<span class="s2">if </span><span class="s1">(magicString.outro) {</span>
				<span class="s1">mappings.advance(magicString.outro);</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(source.ignoreList &amp;&amp; sourceIndex !== -</span><span class="s3">1</span><span class="s1">) {</span>
				<span class="s2">if </span><span class="s1">(x_google_ignoreList === undefined) {</span>
					<span class="s1">x_google_ignoreList = [];</span>
				<span class="s1">}</span>
				<span class="s1">x_google_ignoreList.push(sourceIndex);</span>
			<span class="s1">}</span>
		<span class="s1">});</span>

		<span class="s2">return </span><span class="s1">{</span>
			<span class="s1">file: options.file ? options.file.split(</span><span class="s6">/[/\\]/</span><span class="s1">).pop() : undefined,</span>
			<span class="s1">sources: </span><span class="s2">this</span><span class="s1">.uniqueSources.map((source) =&gt; {</span>
				<span class="s2">return </span><span class="s1">options.file ? getRelativePath(options.file, source.filename) : source.filename;</span>
			<span class="s1">}),</span>
			<span class="s1">sourcesContent: </span><span class="s2">this</span><span class="s1">.uniqueSources.map((source) =&gt; {</span>
				<span class="s2">return </span><span class="s1">options.includeContent ? source.content : </span><span class="s2">null</span><span class="s1">;</span>
			<span class="s1">}),</span>
			<span class="s1">names,</span>
			<span class="s1">mappings: mappings.raw,</span>
			<span class="s1">x_google_ignoreList,</span>
		<span class="s1">};</span>
	<span class="s1">}</span>

	<span class="s1">generateMap(options) {</span>
		<span class="s2">return new </span><span class="s1">SourceMap(</span><span class="s2">this</span><span class="s1">.generateDecodedMap(options));</span>
	<span class="s1">}</span>

	<span class="s1">getIndentString() {</span>
		<span class="s2">const </span><span class="s1">indentStringCounts = {};</span>

		<span class="s2">this</span><span class="s1">.sources.forEach((source) =&gt; {</span>
			<span class="s2">const </span><span class="s1">indentStr = source.content._getRawIndentString();</span>

			<span class="s2">if </span><span class="s1">(indentStr === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>

			<span class="s2">if </span><span class="s1">(!indentStringCounts[indentStr]) indentStringCounts[indentStr] = </span><span class="s3">0</span><span class="s1">;</span>
			<span class="s1">indentStringCounts[indentStr] += </span><span class="s3">1</span><span class="s1">;</span>
		<span class="s1">});</span>

		<span class="s2">return </span><span class="s1">(</span>
			<span class="s1">Object.keys(indentStringCounts).sort((a, b) =&gt; {</span>
				<span class="s2">return </span><span class="s1">indentStringCounts[a] - indentStringCounts[b];</span>
			<span class="s1">})[</span><span class="s3">0</span><span class="s1">] || </span><span class="s0">'</span><span class="s5">\t</span><span class="s0">'</span>
		<span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">indent(indentStr) {</span>
		<span class="s2">if </span><span class="s1">(!arguments.length) {</span>
			<span class="s1">indentStr = </span><span class="s2">this</span><span class="s1">.getIndentString();</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(indentStr === </span><span class="s0">''</span><span class="s1">) </span><span class="s2">return this</span><span class="s1">; </span><span class="s4">// noop</span>

		<span class="s2">let </span><span class="s1">trailingNewline = !</span><span class="s2">this</span><span class="s1">.intro || </span><span class="s2">this</span><span class="s1">.intro.slice(-</span><span class="s3">1</span><span class="s1">) === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>

		<span class="s2">this</span><span class="s1">.sources.forEach((source, i) =&gt; {</span>
			<span class="s2">const </span><span class="s1">separator = source.separator !== undefined ? source.separator : </span><span class="s2">this</span><span class="s1">.separator;</span>
			<span class="s2">const </span><span class="s1">indentStart = trailingNewline || (i &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; </span><span class="s6">/\r?\n$/</span><span class="s1">.test(separator));</span>

			<span class="s1">source.content.indent(indentStr, {</span>
				<span class="s1">exclude: source.indentExclusionRanges,</span>
				<span class="s1">indentStart, </span><span class="s4">//: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )</span>
			<span class="s1">});</span>

			<span class="s1">trailingNewline = source.content.lastChar() === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
		<span class="s1">});</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro) {</span>
			<span class="s2">this</span><span class="s1">.intro =</span>
				<span class="s1">indentStr +</span>
				<span class="s2">this</span><span class="s1">.intro.replace(</span><span class="s6">/^[^\n]/gm</span><span class="s1">, (match, index) =&gt; {</span>
					<span class="s2">return </span><span class="s1">index &gt; </span><span class="s3">0 </span><span class="s1">? indentStr + match : match;</span>
				<span class="s1">});</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">prepend(str) {</span>
		<span class="s2">this</span><span class="s1">.intro = str + </span><span class="s2">this</span><span class="s1">.intro;</span>
		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">toString() {</span>
		<span class="s2">const </span><span class="s1">body = </span><span class="s2">this</span><span class="s1">.sources</span>
			<span class="s1">.map((source, i) =&gt; {</span>
				<span class="s2">const </span><span class="s1">separator = source.separator !== undefined ? source.separator : </span><span class="s2">this</span><span class="s1">.separator;</span>
				<span class="s2">const </span><span class="s1">str = (i &gt; </span><span class="s3">0 </span><span class="s1">? separator : </span><span class="s0">''</span><span class="s1">) + source.content.toString();</span>

				<span class="s2">return </span><span class="s1">str;</span>
			<span class="s1">})</span>
			<span class="s1">.join(</span><span class="s0">''</span><span class="s1">);</span>

		<span class="s2">return this</span><span class="s1">.intro + body;</span>
	<span class="s1">}</span>

	<span class="s1">isEmpty() {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length &amp;&amp; </span><span class="s2">this</span><span class="s1">.intro.trim()) </span><span class="s2">return false</span><span class="s1">;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.sources.some((source) =&gt; !source.content.isEmpty())) </span><span class="s2">return false</span><span class="s1">;</span>
		<span class="s2">return true</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">length() {</span>
		<span class="s2">return this</span><span class="s1">.sources.reduce(</span>
			<span class="s1">(length, source) =&gt; length + source.content.length(),</span>
			<span class="s2">this</span><span class="s1">.intro.length,</span>
		<span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">trimLines() {</span>
		<span class="s2">return this</span><span class="s1">.trim(</span><span class="s0">'[</span><span class="s5">\\</span><span class="s0">r</span><span class="s5">\\</span><span class="s0">n]'</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">trim(charType) {</span>
		<span class="s2">return this</span><span class="s1">.trimStart(charType).trimEnd(charType);</span>
	<span class="s1">}</span>

	<span class="s1">trimStart(charType) {</span>
		<span class="s2">const </span><span class="s1">rx = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">'^' </span><span class="s1">+ (charType || </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">s'</span><span class="s1">) + </span><span class="s0">'+'</span><span class="s1">);</span>
		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>

		<span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.intro) {</span>
			<span class="s2">let </span><span class="s1">source;</span>
			<span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">;</span>

			<span class="s2">do </span><span class="s1">{</span>
				<span class="s1">source = </span><span class="s2">this</span><span class="s1">.sources[i++];</span>
				<span class="s2">if </span><span class="s1">(!source) {</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s2">while </span><span class="s1">(!source.content.trimStartAborted(charType));</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">trimEnd(charType) {</span>
		<span class="s2">const </span><span class="s1">rx = </span><span class="s2">new </span><span class="s1">RegExp((charType || </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">s'</span><span class="s1">) + </span><span class="s0">'+$'</span><span class="s1">);</span>

		<span class="s2">let </span><span class="s1">source;</span>
		<span class="s2">let </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.sources.length - </span><span class="s3">1</span><span class="s1">;</span>

		<span class="s2">do </span><span class="s1">{</span>
			<span class="s1">source = </span><span class="s2">this</span><span class="s1">.sources[i--];</span>
			<span class="s2">if </span><span class="s1">(!source) {</span>
				<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx, </span><span class="s0">''</span><span class="s1">);</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">(!source.content.trimEndAborted(charType));</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">MagicString.Bundle = Bundle;</span>
<span class="s1">MagicString.SourceMap = SourceMap;</span>
<span class="s1">MagicString.default = MagicString; </span><span class="s4">// work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121</span>

<span class="s1">module.exports = MagicString;</span>
<span class="s4">//# sourceMappingURL=magic-string.cjs.js.map</span>
</pre>
</body>
</html>