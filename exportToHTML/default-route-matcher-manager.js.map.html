<html>
<head>
<title>default-route-matcher-manager.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
default-route-matcher-manager.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/route-matcher-managers/default-route-matcher-manager.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isDynamicRoute } from '../../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from '../route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { RouteDefinition } from '../route-definitions/route-definition'</span><span class="s3">\n</span><span class="s1">import type { RouteMatcherProvider } from '../route-matcher-providers/route-matcher-provider'</span><span class="s3">\n</span><span class="s1">import type { RouteMatcher } from '../route-matchers/route-matcher'</span><span class="s3">\n</span><span class="s1">import type { MatchOptions, RouteMatcherManager } from './route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import { getSortedRoutes } from '../../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import { LocaleRouteMatcher } from '../route-matchers/locale-route-matcher'</span><span class="s3">\n</span><span class="s1">import { ensureLeadingSlash } from '../../shared/lib/page-path/ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../lib/detached-promise'</span><span class="s3">\n\n</span><span class="s1">interface RouteMatchers {</span><span class="s3">\n  </span><span class="s1">static: ReadonlyArray&lt;RouteMatcher&gt;</span><span class="s3">\n  </span><span class="s1">dynamic: ReadonlyArray&lt;RouteMatcher&gt;</span><span class="s3">\n  </span><span class="s1">duplicates: Record&lt;string, ReadonlyArray&lt;RouteMatcher&gt;&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class DefaultRouteMatcherManager implements RouteMatcherManager {</span><span class="s3">\n  </span><span class="s1">private readonly providers: Array&lt;RouteMatcherProvider&gt; = []</span><span class="s3">\n  </span><span class="s1">protected readonly matchers: RouteMatchers = {</span><span class="s3">\n    </span><span class="s1">static: [],</span><span class="s3">\n    </span><span class="s1">dynamic: [],</span><span class="s3">\n    </span><span class="s1">duplicates: {},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">private lastCompilationID = this.compilationID</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When this value changes, it indicates that a change has been introduced</span><span class="s3">\n   </span><span class="s1">* that requires recompilation.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private get compilationID() {</span><span class="s3">\n    </span><span class="s1">return this.providers.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private waitTillReadyPromise?: Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">public async waitTillReady(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.waitTillReadyPromise) {</span><span class="s3">\n      </span><span class="s1">await this.waitTillReadyPromise</span><span class="s3">\n      </span><span class="s1">delete this.waitTillReadyPromise</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private previousMatchers: ReadonlyArray&lt;RouteMatcher&gt; = []</span><span class="s3">\n  </span><span class="s1">public async reload() {</span><span class="s3">\n    </span><span class="s1">const { promise, resolve, reject } = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">this.waitTillReadyPromise = promise</span><span class="s3">\n\n    </span><span class="s1">// Grab the compilation ID for this run, we'll verify it at the end to</span><span class="s3">\n    </span><span class="s1">// ensure that if any routes were added before reloading is finished that</span><span class="s3">\n    </span><span class="s1">// we error out.</span><span class="s3">\n    </span><span class="s1">const compilationID = this.compilationID</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// Collect all the matchers from each provider.</span><span class="s3">\n      </span><span class="s1">const matchers: Array&lt;RouteMatcher&gt; = []</span><span class="s3">\n\n      </span><span class="s1">// Get all the providers matchers.</span><span class="s3">\n      </span><span class="s1">const providersMatchers: ReadonlyArray&lt;ReadonlyArray&lt;RouteMatcher&gt;&gt; =</span><span class="s3">\n        </span><span class="s1">await Promise.all(this.providers.map((provider) =&gt; provider.matchers()))</span><span class="s3">\n\n      </span><span class="s1">// Use this to detect duplicate pathnames.</span><span class="s3">\n      </span><span class="s1">const all = new Map&lt;string, RouteMatcher&gt;()</span><span class="s3">\n      </span><span class="s1">const duplicates: Record&lt;string, RouteMatcher[]&gt; = {}</span><span class="s3">\n      </span><span class="s1">for (const providerMatchers of providersMatchers) {</span><span class="s3">\n        </span><span class="s1">for (const matcher of providerMatchers) {</span><span class="s3">\n          </span><span class="s1">// Reset duplicated matches when reloading from pages conflicting state.</span><span class="s3">\n          </span><span class="s1">if (matcher.duplicated) delete matcher.duplicated</span><span class="s3">\n          </span><span class="s1">// Test to see if the matcher being added is a duplicate.</span><span class="s3">\n          </span><span class="s1">const duplicate = all.get(matcher.definition.pathname)</span><span class="s3">\n          </span><span class="s1">if (duplicate) {</span><span class="s3">\n            </span><span class="s1">// This looks a little weird, but essentially if the pathname</span><span class="s3">\n            </span><span class="s1">// already exists in the duplicates map, then we got that array</span><span class="s3">\n            </span><span class="s1">// reference. Otherwise, we create a new array with the original</span><span class="s3">\n            </span><span class="s1">// duplicate first. Then we push the new matcher into the duplicate</span><span class="s3">\n            </span><span class="s1">// array, and reset it to the duplicates object (which may be a</span><span class="s3">\n            </span><span class="s1">// no-op if the pathname already existed in the duplicates object).</span><span class="s3">\n            </span><span class="s1">// Then we set the array of duplicates on both the original</span><span class="s3">\n            </span><span class="s1">// duplicate object and the new one, so we can keep them in sync.</span><span class="s3">\n            </span><span class="s1">// If a new duplicate is found, and it matches an existing pathname,</span><span class="s3">\n            </span><span class="s1">// the retrieval of the `other` will actually return the array</span><span class="s3">\n            </span><span class="s1">// reference used by all other duplicates. This is why ReadonlyArray</span><span class="s3">\n            </span><span class="s1">// is so important! Array's are always references!</span><span class="s3">\n            </span><span class="s1">const others = duplicates[matcher.definition.pathname] ?? [</span><span class="s3">\n              </span><span class="s1">duplicate,</span><span class="s3">\n            </span><span class="s1">]</span><span class="s3">\n            </span><span class="s1">others.push(matcher)</span><span class="s3">\n            </span><span class="s1">duplicates[matcher.definition.pathname] = others</span><span class="s3">\n\n            </span><span class="s1">// Add duplicated details to each route.</span><span class="s3">\n            </span><span class="s1">duplicate.duplicated = others</span><span class="s3">\n            </span><span class="s1">matcher.duplicated = others</span><span class="s3">\n\n            </span><span class="s1">// TODO: see if we should error for duplicates in production?</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">matchers.push(matcher)</span><span class="s3">\n\n          </span><span class="s1">// Add the matcher's pathname to the set.</span><span class="s3">\n          </span><span class="s1">all.set(matcher.definition.pathname, matcher)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Update the duplicate matchers. This is used in the development manager</span><span class="s3">\n      </span><span class="s1">// to warn about duplicates.</span><span class="s3">\n      </span><span class="s1">this.matchers.duplicates = duplicates</span><span class="s3">\n\n      </span><span class="s1">// If the cache is the same as what we just parsed, we can exit now. We</span><span class="s3">\n      </span><span class="s1">// can tell by using the `===` which compares object identity, which for</span><span class="s3">\n      </span><span class="s1">// the manifest matchers, will return the same matcher each time.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.previousMatchers.length === matchers.length &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.previousMatchers.every(</span><span class="s3">\n          </span><span class="s1">(cachedMatcher, index) =&gt; cachedMatcher === matchers[index]</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.previousMatchers = matchers</span><span class="s3">\n\n      </span><span class="s1">// For matchers that are for static routes, filter them now.</span><span class="s3">\n      </span><span class="s1">this.matchers.static = matchers.filter((matcher) =&gt; !matcher.isDynamic)</span><span class="s3">\n\n      </span><span class="s1">// For matchers that are for dynamic routes, filter them and sort them now.</span><span class="s3">\n      </span><span class="s1">const dynamic = matchers.filter((matcher) =&gt; matcher.isDynamic)</span><span class="s3">\n\n      </span><span class="s1">// As `getSortedRoutes` only takes an array of strings, we need to create</span><span class="s3">\n      </span><span class="s1">// a map of the pathnames (used for sorting) and the matchers. When we</span><span class="s3">\n      </span><span class="s1">// have locales, there may be multiple matches for the same pathname. To</span><span class="s3">\n      </span><span class="s1">// handle this, we keep a map of all the indexes (in `reference`) and</span><span class="s3">\n      </span><span class="s1">// merge them in later.</span><span class="s3">\n\n      </span><span class="s1">const reference = new Map&lt;string, number[]&gt;()</span><span class="s3">\n      </span><span class="s1">const pathnames = new Array&lt;string&gt;()</span><span class="s3">\n      </span><span class="s1">for (let index = 0; index &lt; dynamic.length; index++) {</span><span class="s3">\n        </span><span class="s1">// Grab the pathname from the definition.</span><span class="s3">\n        </span><span class="s1">const pathname = dynamic[index].definition.pathname</span><span class="s3">\n\n        </span><span class="s1">// Grab the index in the dynamic array, push it into the reference.</span><span class="s3">\n        </span><span class="s1">const indexes = reference.get(pathname) ?? []</span><span class="s3">\n        </span><span class="s1">indexes.push(index)</span><span class="s3">\n\n        </span><span class="s1">// If this is the first one set it. If it isn't, we don't need to</span><span class="s3">\n        </span><span class="s1">// because pushing above on the array will mutate the array already</span><span class="s3">\n        </span><span class="s1">// stored there because array's are always a reference!</span><span class="s3">\n        </span><span class="s1">if (indexes.length === 1) reference.set(pathname, indexes)</span><span class="s3">\n        </span><span class="s1">// Otherwise, continue, we've already added this pathname before.</span><span class="s3">\n        </span><span class="s1">else continue</span><span class="s3">\n\n        </span><span class="s1">pathnames.push(pathname)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Sort the array of pathnames.</span><span class="s3">\n      </span><span class="s1">const sorted = getSortedRoutes(pathnames)</span><span class="s3">\n\n      </span><span class="s1">// For each of the sorted pathnames, iterate over them, grabbing the list</span><span class="s3">\n      </span><span class="s1">// of indexes and merging them back into the new `sortedDynamicMatchers`</span><span class="s3">\n      </span><span class="s1">// array. The order of the same matching pathname doesn't matter because</span><span class="s3">\n      </span><span class="s1">// they will have other matching characteristics (like the locale) that</span><span class="s3">\n      </span><span class="s1">// is considered.</span><span class="s3">\n      </span><span class="s1">const sortedDynamicMatchers: Array&lt;RouteMatcher&gt; = []</span><span class="s3">\n      </span><span class="s1">for (const pathname of sorted) {</span><span class="s3">\n        </span><span class="s1">const indexes = reference.get(pathname)</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(indexes)) {</span><span class="s3">\n          </span><span class="s1">throw new Error('Invariant: expected to find identity in indexes map')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const dynamicMatches = indexes.map((index) =&gt; dynamic[index])</span><span class="s3">\n\n        </span><span class="s1">sortedDynamicMatchers.push(...dynamicMatches)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.matchers.dynamic = sortedDynamicMatchers</span><span class="s3">\n\n      </span><span class="s1">// This means that there was a new matcher pushed while we were waiting</span><span class="s3">\n      </span><span class="s1">if (this.compilationID !== compilationID) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">'Invariant: expected compilation to finish before new matchers were added, possible missing await'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">reject(err)</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">// The compilation ID matched, so mark the complication as finished.</span><span class="s3">\n      </span><span class="s1">this.lastCompilationID = compilationID</span><span class="s3">\n      </span><span class="s1">resolve()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public push(provider: RouteMatcherProvider): void {</span><span class="s3">\n    </span><span class="s1">this.providers.push(provider)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async test(pathname: string, options: MatchOptions): Promise&lt;boolean&gt; {</span><span class="s3">\n    </span><span class="s1">// See if there's a match for the pathname...</span><span class="s3">\n    </span><span class="s1">const match = await this.match(pathname, options)</span><span class="s3">\n\n    </span><span class="s1">// This default implementation only needs to check to see if there _was_ a</span><span class="s3">\n    </span><span class="s1">// match. The development matcher actually changes it's behavior by not</span><span class="s3">\n    </span><span class="s1">// recompiling the routes.</span><span class="s3">\n    </span><span class="s1">return match !== null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async match(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options: MatchOptions</span><span class="s3">\n  </span><span class="s1">): Promise&lt;RouteMatch&lt;RouteDefinition&lt;RouteKind&gt;&gt; | null&gt; {</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Iterate</span><span class="s3">\&quot; </span><span class="s1">over the match options. Once we found a single match, exit with</span><span class="s3">\n    </span><span class="s1">// it, otherwise return null below. If no match is found, the inner block</span><span class="s3">\n    </span><span class="s1">// won't be called.</span><span class="s3">\n    </span><span class="s1">for await (const match of this.matchAll(pathname, options)) {</span><span class="s3">\n      </span><span class="s1">return match</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is a point for other managers to override to inject other checking</span><span class="s3">\n   </span><span class="s1">* behavior like duplicate route checking on a per-request basis.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname the pathname to validate against</span><span class="s3">\n   </span><span class="s1">* @param matcher the matcher to validate/test with</span><span class="s3">\n   </span><span class="s1">* @returns the match if found</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">protected validate(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">matcher: RouteMatcher,</span><span class="s3">\n    </span><span class="s1">options: MatchOptions</span><span class="s3">\n  </span><span class="s1">): RouteMatch | null {</span><span class="s3">\n    </span><span class="s1">if (matcher instanceof LocaleRouteMatcher) {</span><span class="s3">\n      </span><span class="s1">return matcher.match(pathname, options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the locale was inferred from the default locale, then it will have</span><span class="s3">\n    </span><span class="s1">// already added a locale to the pathname. We need to remove it before</span><span class="s3">\n    </span><span class="s1">// matching because this matcher is not locale aware.</span><span class="s3">\n    </span><span class="s1">if (options.i18n?.inferredFromDefault) {</span><span class="s3">\n      </span><span class="s1">return matcher.match(options.i18n.pathname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return matcher.match(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async *matchAll(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options: MatchOptions</span><span class="s3">\n  </span><span class="s1">): AsyncGenerator&lt;RouteMatch&lt;RouteDefinition&lt;RouteKind&gt;&gt;, null, undefined&gt; {</span><span class="s3">\n    </span><span class="s1">// Guard against the matcher manager from being run before it needs to be</span><span class="s3">\n    </span><span class="s1">// recompiled. This was preferred to re-running the compilation here because</span><span class="s3">\n    </span><span class="s1">// it should be re-ran only when it changes. If a match is attempted before</span><span class="s3">\n    </span><span class="s1">// this is done, it indicates that there is a case where a provider is added</span><span class="s3">\n    </span><span class="s1">// before it was recompiled (an error). We also don't want to affect request</span><span class="s3">\n    </span><span class="s1">// times.</span><span class="s3">\n    </span><span class="s1">if (this.lastCompilationID !== this.compilationID) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Invariant: expected routes to have been loaded before match'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Ensure that path matching is done with a leading slash.</span><span class="s3">\n    </span><span class="s1">pathname = ensureLeadingSlash(pathname)</span><span class="s3">\n\n    </span><span class="s1">// If this pathname doesn't look like a dynamic route, and this pathname is</span><span class="s3">\n    </span><span class="s1">// listed in the normalized list of routes, then return it. This ensures</span><span class="s3">\n    </span><span class="s1">// that when a route like `/user/[id]` is encountered, it doesn't just match</span><span class="s3">\n    </span><span class="s1">// with the list of normalized routes.</span><span class="s3">\n    </span><span class="s1">if (!isDynamicRoute(pathname)) {</span><span class="s3">\n      </span><span class="s1">for (const matcher of this.matchers.static) {</span><span class="s3">\n        </span><span class="s1">const match = this.validate(pathname, matcher, options)</span><span class="s3">\n        </span><span class="s1">if (!match) continue</span><span class="s3">\n\n        </span><span class="s1">yield match</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we should skip handling dynamic routes, exit now.</span><span class="s3">\n    </span><span class="s1">if (options?.skipDynamic) return null</span><span class="s3">\n\n    </span><span class="s1">// Loop over the dynamic matchers, yielding each match.</span><span class="s3">\n    </span><span class="s1">for (const matcher of this.matchers.dynamic) {</span><span class="s3">\n      </span><span class="s1">const match = this.validate(pathname, matcher, options)</span><span class="s3">\n      </span><span class="s1">if (!match) continue</span><span class="s3">\n\n      </span><span class="s1">yield match</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We tried direct matching against the pathname and against all the dynamic</span><span class="s3">\n    </span><span class="s1">// paths, so there was no match.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;DefaultRouteMatcherManager&quot;</span><span class="s0">,</span><span class="s1">&quot;compilationID&quot;</span><span class="s0">,</span><span class="s1">&quot;providers&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;waitTillReady&quot;</span><span class="s0">,</span><span class="s1">&quot;waitTillReadyPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;reload&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;DetachedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;matchers&quot;</span><span class="s0">,</span><span class="s1">&quot;providersMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;provider&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicates&quot;</span><span class="s0">,</span><span class="s1">&quot;providerMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicated&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicate&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;others&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;previousMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;reference&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnames&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;indexes&quot;</span><span class="s0">,</span><span class="s1">&quot;sorted&quot;</span><span class="s0">,</span><span class="s1">&quot;getSortedRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;sortedDynamicMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCompilationID&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;matchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;LocaleRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;inferredFromDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureLeadingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;skipDynamic&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>