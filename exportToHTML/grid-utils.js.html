<html>
<head>
<title>grid-utils.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
grid-utils.js</font>
</center></td></tr></table>
<pre><span class="s0">let </span><span class="s1">parser = require(</span><span class="s2">'postcss-value-parser'</span><span class="s1">)</span>
<span class="s0">let </span><span class="s1">list = require(</span><span class="s2">'postcss'</span><span class="s1">).list</span>

<span class="s0">let </span><span class="s1">uniq = require(</span><span class="s2">'../utils'</span><span class="s1">).uniq</span>
<span class="s0">let </span><span class="s1">escapeRegexp = require(</span><span class="s2">'../utils'</span><span class="s1">).escapeRegexp</span>
<span class="s0">let </span><span class="s1">splitSelector = require(</span><span class="s2">'../utils'</span><span class="s1">).splitSelector</span>

<span class="s0">function </span><span class="s1">convert(value) {</span>
  <span class="s0">if </span><span class="s1">(</span>
    <span class="s1">value &amp;&amp;</span>
    <span class="s1">value.length === </span><span class="s3">2 </span><span class="s1">&amp;&amp;</span>
    <span class="s1">value[</span><span class="s3">0</span><span class="s1">] === </span><span class="s2">'span' </span><span class="s1">&amp;&amp;</span>
    <span class="s1">parseInt(value[</span><span class="s3">1</span><span class="s1">], </span><span class="s3">10</span><span class="s1">) &gt; </span><span class="s3">0</span>
  <span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">[</span><span class="s0">false</span><span class="s1">, parseInt(value[</span><span class="s3">1</span><span class="s1">], </span><span class="s3">10</span><span class="s1">)]</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(value &amp;&amp; value.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp; parseInt(value[</span><span class="s3">0</span><span class="s1">], </span><span class="s3">10</span><span class="s1">) &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">[parseInt(value[</span><span class="s3">0</span><span class="s1">], </span><span class="s3">10</span><span class="s1">), </span><span class="s0">false</span><span class="s1">]</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">[</span><span class="s0">false</span><span class="s1">, </span><span class="s0">false</span><span class="s1">]</span>
<span class="s1">}</span>

<span class="s1">exports.translate = translate</span>

<span class="s0">function </span><span class="s1">translate(values, startIndex, endIndex) {</span>
  <span class="s0">let </span><span class="s1">startValue = values[startIndex]</span>
  <span class="s0">let </span><span class="s1">endValue = values[endIndex]</span>

  <span class="s0">if </span><span class="s1">(!startValue) {</span>
    <span class="s0">return </span><span class="s1">[</span><span class="s0">false</span><span class="s1">, </span><span class="s0">false</span><span class="s1">]</span>
  <span class="s1">}</span>

  <span class="s0">let </span><span class="s1">[start, spanStart] = convert(startValue)</span>
  <span class="s0">let </span><span class="s1">[end, spanEnd] = convert(endValue)</span>

  <span class="s0">if </span><span class="s1">(start &amp;&amp; !endValue) {</span>
    <span class="s0">return </span><span class="s1">[start, </span><span class="s0">false</span><span class="s1">]</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(spanStart &amp;&amp; end) {</span>
    <span class="s0">return </span><span class="s1">[end - spanStart, spanStart]</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(start &amp;&amp; spanEnd) {</span>
    <span class="s0">return </span><span class="s1">[start, spanEnd]</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(start &amp;&amp; end) {</span>
    <span class="s0">return </span><span class="s1">[start, end - start]</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">[</span><span class="s0">false</span><span class="s1">, </span><span class="s0">false</span><span class="s1">]</span>
<span class="s1">}</span>

<span class="s1">exports.parse = parse</span>

<span class="s0">function </span><span class="s1">parse(decl) {</span>
  <span class="s0">let </span><span class="s1">node = parser(decl.value)</span>

  <span class="s0">let </span><span class="s1">values = []</span>
  <span class="s0">let </span><span class="s1">current = </span><span class="s3">0</span>
  <span class="s1">values[current] = []</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i of node.nodes) {</span>
    <span class="s0">if </span><span class="s1">(i.type === </span><span class="s2">'div'</span><span class="s1">) {</span>
      <span class="s1">current += </span><span class="s3">1</span>
      <span class="s1">values[current] = []</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(i.type === </span><span class="s2">'word'</span><span class="s1">) {</span>
      <span class="s1">values[current].push(i.value)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">values</span>
<span class="s1">}</span>

<span class="s1">exports.insertDecl = insertDecl</span>

<span class="s0">function </span><span class="s1">insertDecl(decl, prop, value) {</span>
  <span class="s0">if </span><span class="s1">(value &amp;&amp; !decl.parent.some(i =&gt; i.prop === </span><span class="s2">`-ms-</span><span class="s1">${prop}</span><span class="s2">`</span><span class="s1">)) {</span>
    <span class="s1">decl.cloneBefore({</span>
      <span class="s1">prop: </span><span class="s2">`-ms-</span><span class="s1">${prop}</span><span class="s2">`</span><span class="s1">,</span>
      <span class="s1">value: value.toString()</span>
    <span class="s1">})</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// Track transforms</span>

<span class="s1">exports.prefixTrackProp = prefixTrackProp</span>

<span class="s0">function </span><span class="s1">prefixTrackProp({ prefix, prop }) {</span>
  <span class="s0">return </span><span class="s1">prefix + prop.replace(</span><span class="s2">'template-'</span><span class="s1">, </span><span class="s2">''</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">transformRepeat({ nodes }, { gap }) {</span>
  <span class="s0">let </span><span class="s1">{ count, size } = nodes.reduce(</span>
    <span class="s1">(result, node) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">'div' </span><span class="s1">&amp;&amp; node.value === </span><span class="s2">','</span><span class="s1">) {</span>
        <span class="s1">result.key = </span><span class="s2">'size'</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s1">result[result.key].push(parser.stringify(node))</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">result</span>
    <span class="s1">},</span>
    <span class="s1">{</span>
      <span class="s1">count: [],</span>
      <span class="s1">key: </span><span class="s2">'count'</span><span class="s1">,</span>
      <span class="s1">size: []</span>
    <span class="s1">}</span>
  <span class="s1">)</span>

  <span class="s4">// insert gap values</span>
  <span class="s0">if </span><span class="s1">(gap) {</span>
    <span class="s1">size = size.filter(i =&gt; i.trim())</span>
    <span class="s0">let </span><span class="s1">val = []</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">1</span><span class="s1">; i &lt;= count; i++) {</span>
      <span class="s1">size.forEach((item, index) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(index &gt; </span><span class="s3">0 </span><span class="s1">|| i &gt; </span><span class="s3">1</span><span class="s1">) {</span>
          <span class="s1">val.push(gap)</span>
        <span class="s1">}</span>
        <span class="s1">val.push(item)</span>
      <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">val.join(</span><span class="s2">' '</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s2">`(</span><span class="s1">${size.join(</span><span class="s2">''</span><span class="s1">)}</span><span class="s2">)[</span><span class="s1">${count.join(</span><span class="s2">''</span><span class="s1">)}</span><span class="s2">]`</span>
<span class="s1">}</span>

<span class="s1">exports.prefixTrackValue = prefixTrackValue</span>

<span class="s0">function </span><span class="s1">prefixTrackValue({ gap, value }) {</span>
  <span class="s0">let </span><span class="s1">result = parser(value).nodes.reduce((nodes, node) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; node.value === </span><span class="s2">'repeat'</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s1">nodes.concat({</span>
        <span class="s1">type: </span><span class="s2">'word'</span><span class="s1">,</span>
        <span class="s1">value: transformRepeat(node, { gap })</span>
      <span class="s1">})</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(gap &amp;&amp; node.type === </span><span class="s2">'space'</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s1">nodes.concat(</span>
        <span class="s1">{</span>
          <span class="s1">type: </span><span class="s2">'space'</span><span class="s1">,</span>
          <span class="s1">value: </span><span class="s2">' '</span>
        <span class="s1">},</span>
        <span class="s1">{</span>
          <span class="s1">type: </span><span class="s2">'word'</span><span class="s1">,</span>
          <span class="s1">value: gap</span>
        <span class="s1">},</span>
        <span class="s1">node</span>
      <span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">nodes.concat(node)</span>
  <span class="s1">}, [])</span>

  <span class="s0">return </span><span class="s1">parser.stringify(result)</span>
<span class="s1">}</span>

<span class="s4">// Parse grid-template-areas</span>

<span class="s0">let </span><span class="s1">DOTS = </span><span class="s5">/^\.+$/</span>

<span class="s0">function </span><span class="s1">track(start, end) {</span>
  <span class="s0">return </span><span class="s1">{ end, span: end - start, start }</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getColumns(line) {</span>
  <span class="s0">return </span><span class="s1">line.trim().split(</span><span class="s5">/\s+/g</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s1">exports.parseGridAreas = parseGridAreas</span>

<span class="s0">function </span><span class="s1">parseGridAreas({ gap, rows }) {</span>
  <span class="s0">return </span><span class="s1">rows.reduce((areas, line, rowIndex) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(gap.row) rowIndex *= </span><span class="s3">2</span>

    <span class="s0">if </span><span class="s1">(line.trim() === </span><span class="s2">''</span><span class="s1">) </span><span class="s0">return </span><span class="s1">areas</span>

    <span class="s1">getColumns(line).forEach((area, columnIndex) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(DOTS.test(area)) </span><span class="s0">return</span>

      <span class="s0">if </span><span class="s1">(gap.column) columnIndex *= </span><span class="s3">2</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">areas[area] === </span><span class="s2">'undefined'</span><span class="s1">) {</span>
        <span class="s1">areas[area] = {</span>
          <span class="s1">column: track(columnIndex + </span><span class="s3">1</span><span class="s1">, columnIndex + </span><span class="s3">2</span><span class="s1">),</span>
          <span class="s1">row: track(rowIndex + </span><span class="s3">1</span><span class="s1">, rowIndex + </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">let </span><span class="s1">{ column, row } = areas[area]</span>

        <span class="s1">column.start = Math.min(column.start, columnIndex + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">column.end = Math.max(column.end, columnIndex + </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">column.span = column.end - column.start</span>

        <span class="s1">row.start = Math.min(row.start, rowIndex + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">row.end = Math.max(row.end, rowIndex + </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">row.span = row.end - row.start</span>
      <span class="s1">}</span>
    <span class="s1">})</span>

    <span class="s0">return </span><span class="s1">areas</span>
  <span class="s1">}, {})</span>
<span class="s1">}</span>

<span class="s4">// Parse grid-template</span>

<span class="s0">function </span><span class="s1">testTrack(node) {</span>
  <span class="s0">return </span><span class="s1">node.type === </span><span class="s2">'word' </span><span class="s1">&amp;&amp; </span><span class="s5">/^\[.+]$/</span><span class="s1">.test(node.value)</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">verifyRowSize(result) {</span>
  <span class="s0">if </span><span class="s1">(result.areas.length &gt; result.rows.length) {</span>
    <span class="s1">result.rows.push(</span><span class="s2">'auto'</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">result</span>
<span class="s1">}</span>

<span class="s1">exports.parseTemplate = parseTemplate</span>

<span class="s0">function </span><span class="s1">parseTemplate({ decl, gap }) {</span>
  <span class="s0">let </span><span class="s1">gridTemplate = parser(decl.value).nodes.reduce(</span>
    <span class="s1">(result, node) =&gt; {</span>
      <span class="s0">let </span><span class="s1">{ type, value } = node</span>

      <span class="s0">if </span><span class="s1">(testTrack(node) || type === </span><span class="s2">'space'</span><span class="s1">) </span><span class="s0">return </span><span class="s1">result</span>

      <span class="s4">// area</span>
      <span class="s0">if </span><span class="s1">(type === </span><span class="s2">'string'</span><span class="s1">) {</span>
        <span class="s1">result = verifyRowSize(result)</span>
        <span class="s1">result.areas.push(value)</span>
      <span class="s1">}</span>

      <span class="s4">// values and function</span>
      <span class="s0">if </span><span class="s1">(type === </span><span class="s2">'word' </span><span class="s1">|| type === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">result[result.key].push(parser.stringify(node))</span>
      <span class="s1">}</span>

      <span class="s4">// divider(/)</span>
      <span class="s0">if </span><span class="s1">(type === </span><span class="s2">'div' </span><span class="s1">&amp;&amp; value === </span><span class="s2">'/'</span><span class="s1">) {</span>
        <span class="s1">result.key = </span><span class="s2">'columns'</span>
        <span class="s1">result = verifyRowSize(result)</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">result</span>
    <span class="s1">},</span>
    <span class="s1">{</span>
      <span class="s1">areas: [],</span>
      <span class="s1">columns: [],</span>
      <span class="s1">key: </span><span class="s2">'rows'</span><span class="s1">,</span>
      <span class="s1">rows: []</span>
    <span class="s1">}</span>
  <span class="s1">)</span>

  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">areas: parseGridAreas({</span>
      <span class="s1">gap,</span>
      <span class="s1">rows: gridTemplate.areas</span>
    <span class="s1">}),</span>
    <span class="s1">columns: prefixTrackValue({</span>
      <span class="s1">gap: gap.column,</span>
      <span class="s1">value: gridTemplate.columns.join(</span><span class="s2">' '</span><span class="s1">)</span>
    <span class="s1">}),</span>
    <span class="s1">rows: prefixTrackValue({</span>
      <span class="s1">gap: gap.row,</span>
      <span class="s1">value: gridTemplate.rows.join(</span><span class="s2">' '</span><span class="s1">)</span>
    <span class="s1">})</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// Insert parsed grid areas</span>

<span class="s4">/**</span>
 <span class="s4">* Get an array of -ms- prefixed props and values</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Object} [area] area object with column and row data</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Boolean} [addRowSpan] should we add grid-column-row value?</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Boolean} [addColumnSpan] should we add grid-column-span value?</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{Array&lt;Object&gt;}</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">getMSDecls(area, addRowSpan = </span><span class="s0">false</span><span class="s1">, addColumnSpan = </span><span class="s0">false</span><span class="s1">) {</span>
  <span class="s0">let </span><span class="s1">result = [</span>
    <span class="s1">{</span>
      <span class="s1">prop: </span><span class="s2">'-ms-grid-row'</span><span class="s1">,</span>
      <span class="s1">value: String(area.row.start)</span>
    <span class="s1">}</span>
  <span class="s1">]</span>
  <span class="s0">if </span><span class="s1">(area.row.span &gt; </span><span class="s3">1 </span><span class="s1">|| addRowSpan) {</span>
    <span class="s1">result.push({</span>
      <span class="s1">prop: </span><span class="s2">'-ms-grid-row-span'</span><span class="s1">,</span>
      <span class="s1">value: String(area.row.span)</span>
    <span class="s1">})</span>
  <span class="s1">}</span>
  <span class="s1">result.push({</span>
    <span class="s1">prop: </span><span class="s2">'-ms-grid-column'</span><span class="s1">,</span>
    <span class="s1">value: String(area.column.start)</span>
  <span class="s1">})</span>
  <span class="s0">if </span><span class="s1">(area.column.span &gt; </span><span class="s3">1 </span><span class="s1">|| addColumnSpan) {</span>
    <span class="s1">result.push({</span>
      <span class="s1">prop: </span><span class="s2">'-ms-grid-column-span'</span><span class="s1">,</span>
      <span class="s1">value: String(area.column.span)</span>
    <span class="s1">})</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">result</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getParentMedia(parent) {</span>
  <span class="s0">if </span><span class="s1">(parent.type === </span><span class="s2">'atrule' </span><span class="s1">&amp;&amp; parent.name === </span><span class="s2">'media'</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">parent</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(!parent.parent) {</span>
    <span class="s0">return false</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">getParentMedia(parent.parent)</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* change selectors for rules with duplicate grid-areas.</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Array&lt;Rule&gt;} rules</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Array&lt;String&gt;} templateSelectors</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{Array&lt;Rule&gt;} rules with changed selectors</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {</span>
  <span class="s1">ruleSelectors = ruleSelectors.map(selector =&gt; {</span>
    <span class="s0">let </span><span class="s1">selectorBySpace = list.space(selector)</span>
    <span class="s0">let </span><span class="s1">selectorByComma = list.comma(selector)</span>

    <span class="s0">if </span><span class="s1">(selectorBySpace.length &gt; selectorByComma.length) {</span>
      <span class="s1">selector = selectorBySpace.slice(-</span><span class="s3">1</span><span class="s1">).join(</span><span class="s2">''</span><span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">selector</span>
  <span class="s1">})</span>

  <span class="s0">return </span><span class="s1">ruleSelectors.map(ruleSelector =&gt; {</span>
    <span class="s0">let </span><span class="s1">newSelector = templateSelectors.map((tplSelector, index) =&gt; {</span>
      <span class="s0">let </span><span class="s1">space = index === </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: </span><span class="s2">' '</span>
      <span class="s0">return </span><span class="s2">`</span><span class="s1">${space}${tplSelector} </span><span class="s2">&gt; </span><span class="s1">${ruleSelector}</span><span class="s2">`</span>
    <span class="s1">})</span>

    <span class="s0">return </span><span class="s1">newSelector</span>
  <span class="s1">})</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* check if selector of rules are equal</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Rule} ruleA</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Rule} ruleB</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{Boolean}</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">selectorsEqual(ruleA, ruleB) {</span>
  <span class="s0">return </span><span class="s1">ruleA.selectors.some(sel =&gt; {</span>
    <span class="s0">return </span><span class="s1">ruleB.selectors.includes(sel)</span>
  <span class="s1">})</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* Parse data from all grid-template(-areas) declarations</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Root} css css root</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{Object} parsed data</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">parseGridTemplatesData(css) {</span>
  <span class="s0">let </span><span class="s1">parsed = []</span>

  <span class="s4">// we walk through every grid-template(-areas) declaration and store</span>
  <span class="s4">// data with the same area names inside the item</span>
  <span class="s1">css.walkDecls(</span><span class="s5">/grid-template(-areas)?$/</span><span class="s1">, d =&gt; {</span>
    <span class="s0">let </span><span class="s1">rule = d.parent</span>
    <span class="s0">let </span><span class="s1">media = getParentMedia(rule)</span>
    <span class="s0">let </span><span class="s1">gap = getGridGap(d)</span>
    <span class="s0">let </span><span class="s1">inheritedGap = inheritGridGap(d, gap)</span>
    <span class="s0">let </span><span class="s1">{ areas } = parseTemplate({ decl: d, gap: inheritedGap || gap })</span>
    <span class="s0">let </span><span class="s1">areaNames = Object.keys(areas)</span>

    <span class="s4">// skip node if it doesn't have areas</span>
    <span class="s0">if </span><span class="s1">(areaNames.length === </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s0">return true</span>
    <span class="s1">}</span>

    <span class="s4">// check parsed array for item that include the same area names</span>
    <span class="s4">// return index of that item</span>
    <span class="s0">let </span><span class="s1">index = parsed.reduce((acc, { allAreas }, idx) =&gt; {</span>
      <span class="s0">let </span><span class="s1">hasAreas = allAreas &amp;&amp; areaNames.some(area =&gt; allAreas.includes(area))</span>
      <span class="s0">return </span><span class="s1">hasAreas ? idx : acc</span>
    <span class="s1">}, </span><span class="s0">null</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">(index !== </span><span class="s0">null</span><span class="s1">) {</span>
      <span class="s4">// index is found, add the grid-template data to that item</span>
      <span class="s0">let </span><span class="s1">{ allAreas, rules } = parsed[index]</span>

      <span class="s4">// check if rule has no duplicate area names</span>
      <span class="s0">let </span><span class="s1">hasNoDuplicates = rules.some(r =&gt; {</span>
        <span class="s0">return </span><span class="s1">r.hasDuplicates === </span><span class="s0">false </span><span class="s1">&amp;&amp; selectorsEqual(r, rule)</span>
      <span class="s1">})</span>

      <span class="s0">let </span><span class="s1">duplicatesFound = </span><span class="s0">false</span>

      <span class="s4">// check need to gather all duplicate area names</span>
      <span class="s0">let </span><span class="s1">duplicateAreaNames = rules.reduce((acc, r) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(!r.params &amp;&amp; selectorsEqual(r, rule)) {</span>
          <span class="s1">duplicatesFound = </span><span class="s0">true</span>
          <span class="s0">return </span><span class="s1">r.duplicateAreaNames</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(!duplicatesFound) {</span>
          <span class="s1">areaNames.forEach(name =&gt; {</span>
            <span class="s0">if </span><span class="s1">(r.areas[name]) {</span>
              <span class="s1">acc.push(name)</span>
            <span class="s1">}</span>
          <span class="s1">})</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">uniq(acc)</span>
      <span class="s1">}, [])</span>

      <span class="s4">// update grid-row/column-span values for areas with duplicate</span>
      <span class="s4">// area names. @see #1084 and #1146</span>
      <span class="s1">rules.forEach(r =&gt; {</span>
        <span class="s1">areaNames.forEach(name =&gt; {</span>
          <span class="s0">let </span><span class="s1">area = r.areas[name]</span>
          <span class="s0">if </span><span class="s1">(area &amp;&amp; area.row.span !== areas[name].row.span) {</span>
            <span class="s1">areas[name].row.updateSpan = </span><span class="s0">true</span>
          <span class="s1">}</span>

          <span class="s0">if </span><span class="s1">(area &amp;&amp; area.column.span !== areas[name].column.span) {</span>
            <span class="s1">areas[name].column.updateSpan = </span><span class="s0">true</span>
          <span class="s1">}</span>
        <span class="s1">})</span>
      <span class="s1">})</span>

      <span class="s1">parsed[index].allAreas = uniq([...allAreas, ...areaNames])</span>
      <span class="s1">parsed[index].rules.push({</span>
        <span class="s1">areas,</span>
        <span class="s1">duplicateAreaNames,</span>
        <span class="s1">hasDuplicates: !hasNoDuplicates,</span>
        <span class="s1">node: rule,</span>
        <span class="s1">params: media.params,</span>
        <span class="s1">selectors: rule.selectors</span>
      <span class="s1">})</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s4">// index is NOT found, push the new item to the parsed array</span>
      <span class="s1">parsed.push({</span>
        <span class="s1">allAreas: areaNames,</span>
        <span class="s1">areasCount: </span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">rules: [</span>
          <span class="s1">{</span>
            <span class="s1">areas,</span>
            <span class="s1">duplicateAreaNames: [],</span>
            <span class="s1">duplicateRules: [],</span>
            <span class="s1">hasDuplicates: </span><span class="s0">false</span><span class="s1">,</span>
            <span class="s1">node: rule,</span>
            <span class="s1">params: media.params,</span>
            <span class="s1">selectors: rule.selectors</span>
          <span class="s1">}</span>
        <span class="s1">]</span>
      <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">undefined</span>
  <span class="s1">})</span>

  <span class="s0">return </span><span class="s1">parsed</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* insert prefixed grid-area declarations</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Root}  css css root</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Function} isDisabled check if the rule is disabled</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{void}</span>
 <span class="s4">*/</span>
<span class="s1">exports.insertAreas = insertAreas</span>

<span class="s0">function </span><span class="s1">insertAreas(css, isDisabled) {</span>
  <span class="s4">// parse grid-template declarations</span>
  <span class="s0">let </span><span class="s1">gridTemplatesData = parseGridTemplatesData(css)</span>

  <span class="s4">// return undefined if no declarations found</span>
  <span class="s0">if </span><span class="s1">(gridTemplatesData.length === </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">undefined</span>
  <span class="s1">}</span>

  <span class="s4">// we need to store the rules that we will insert later</span>
  <span class="s0">let </span><span class="s1">rulesToInsert = {}</span>

  <span class="s1">css.walkDecls(</span><span class="s2">'grid-area'</span><span class="s1">, gridArea =&gt; {</span>
    <span class="s0">let </span><span class="s1">gridAreaRule = gridArea.parent</span>
    <span class="s0">let </span><span class="s1">hasPrefixedRow = gridAreaRule.first.prop === </span><span class="s2">'-ms-grid-row'</span>
    <span class="s0">let </span><span class="s1">gridAreaMedia = getParentMedia(gridAreaRule)</span>

    <span class="s0">if </span><span class="s1">(isDisabled(gridArea)) {</span>
      <span class="s0">return </span><span class="s1">undefined</span>
    <span class="s1">}</span>

    <span class="s0">let </span><span class="s1">gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule)</span>

    <span class="s0">let </span><span class="s1">value = gridArea.value</span>
    <span class="s4">// found the data that matches grid-area identifier</span>
    <span class="s0">let </span><span class="s1">data = gridTemplatesData.filter(d =&gt; d.allAreas.includes(value))[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">(!data) {</span>
      <span class="s0">return true</span>
    <span class="s1">}</span>

    <span class="s0">let </span><span class="s1">lastArea = data.allAreas[data.allAreas.length - </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">let </span><span class="s1">selectorBySpace = list.space(gridAreaRule.selector)</span>
    <span class="s0">let </span><span class="s1">selectorByComma = list.comma(gridAreaRule.selector)</span>
    <span class="s0">let </span><span class="s1">selectorIsComplex =</span>
      <span class="s1">selectorBySpace.length &gt; </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
      <span class="s1">selectorBySpace.length &gt; selectorByComma.length</span>

    <span class="s4">// prevent doubling of prefixes</span>
    <span class="s0">if </span><span class="s1">(hasPrefixedRow) {</span>
      <span class="s0">return false</span>
    <span class="s1">}</span>

    <span class="s4">// create the empty object with the key as the last area name</span>
    <span class="s4">// e.g if we have templates with &quot;a b c&quot; values, &quot;c&quot; will be the last area</span>
    <span class="s0">if </span><span class="s1">(!rulesToInsert[lastArea]) {</span>
      <span class="s1">rulesToInsert[lastArea] = {}</span>
    <span class="s1">}</span>

    <span class="s0">let </span><span class="s1">lastRuleIsSet = </span><span class="s0">false</span>

    <span class="s4">// walk through every grid-template rule data</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">rule of data.rules) {</span>
      <span class="s0">let </span><span class="s1">area = rule.areas[value]</span>
      <span class="s0">let </span><span class="s1">hasDuplicateName = rule.duplicateAreaNames.includes(value)</span>

      <span class="s4">// if we can't find the area name, update lastRule and continue</span>
      <span class="s0">if </span><span class="s1">(!area) {</span>
        <span class="s0">let </span><span class="s1">lastRule = rulesToInsert[lastArea].lastRule</span>
        <span class="s0">let </span><span class="s1">lastRuleIndex</span>
        <span class="s0">if </span><span class="s1">(lastRule) {</span>
          <span class="s1">lastRuleIndex = css.index(lastRule)</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s4">/* c8 ignore next 2 */</span>
          <span class="s1">lastRuleIndex = -</span><span class="s3">1</span>
        <span class="s1">}</span>

        <span class="s0">if </span><span class="s1">(gridAreaRuleIndex &gt; lastRuleIndex) {</span>
          <span class="s1">rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule</span>
        <span class="s1">}</span>
        <span class="s0">continue</span>
      <span class="s1">}</span>

      <span class="s4">// for grid-templates inside media rule we need to create empty</span>
      <span class="s4">// array to push prefixed grid-area rules later</span>
      <span class="s0">if </span><span class="s1">(rule.params &amp;&amp; !rulesToInsert[lastArea][rule.params]) {</span>
        <span class="s1">rulesToInsert[lastArea][rule.params] = []</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">((!rule.hasDuplicates || !hasDuplicateName) &amp;&amp; !rule.params) {</span>
        <span class="s4">// grid-template has no duplicates and not inside media rule</span>

        <span class="s1">getMSDecls(area, </span><span class="s0">false</span><span class="s1">, </span><span class="s0">false</span><span class="s1">)</span>
          <span class="s1">.reverse()</span>
          <span class="s1">.forEach(i =&gt;</span>
            <span class="s1">gridAreaRule.prepend(</span>
              <span class="s1">Object.assign(i, {</span>
                <span class="s1">raws: {</span>
                  <span class="s1">between: gridArea.raws.between</span>
                <span class="s1">}</span>
              <span class="s1">})</span>
            <span class="s1">)</span>
          <span class="s1">)</span>

        <span class="s1">rulesToInsert[lastArea].lastRule = gridAreaRule</span>
        <span class="s1">lastRuleIsSet = </span><span class="s0">true</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(rule.hasDuplicates &amp;&amp; !rule.params &amp;&amp; !selectorIsComplex) {</span>
        <span class="s4">// grid-template has duplicates and not inside media rule</span>
        <span class="s0">let </span><span class="s1">cloned = gridAreaRule.clone()</span>
        <span class="s1">cloned.removeAll()</span>

        <span class="s1">getMSDecls(area, area.row.updateSpan, area.column.updateSpan)</span>
          <span class="s1">.reverse()</span>
          <span class="s1">.forEach(i =&gt;</span>
            <span class="s1">cloned.prepend(</span>
              <span class="s1">Object.assign(i, {</span>
                <span class="s1">raws: {</span>
                  <span class="s1">between: gridArea.raws.between</span>
                <span class="s1">}</span>
              <span class="s1">})</span>
            <span class="s1">)</span>
          <span class="s1">)</span>

        <span class="s1">cloned.selectors = changeDuplicateAreaSelectors(</span>
          <span class="s1">cloned.selectors,</span>
          <span class="s1">rule.selectors</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">(rulesToInsert[lastArea].lastRule) {</span>
          <span class="s1">rulesToInsert[lastArea].lastRule.after(cloned)</span>
        <span class="s1">}</span>
        <span class="s1">rulesToInsert[lastArea].lastRule = cloned</span>
        <span class="s1">lastRuleIsSet = </span><span class="s0">true</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span>
        <span class="s1">rule.hasDuplicates &amp;&amp;</span>
        <span class="s1">!rule.params &amp;&amp;</span>
        <span class="s1">selectorIsComplex &amp;&amp;</span>
        <span class="s1">gridAreaRule.selector.includes(rule.selectors[</span><span class="s3">0</span><span class="s1">])</span>
      <span class="s1">) {</span>
        <span class="s4">// grid-template has duplicates and not inside media rule</span>
        <span class="s4">// and the selector is complex</span>
        <span class="s1">gridAreaRule.walkDecls(</span><span class="s5">/-ms-grid-(row|column)/</span><span class="s1">, d =&gt; d.remove())</span>
        <span class="s1">getMSDecls(area, area.row.updateSpan, area.column.updateSpan)</span>
          <span class="s1">.reverse()</span>
          <span class="s1">.forEach(i =&gt;</span>
            <span class="s1">gridAreaRule.prepend(</span>
              <span class="s1">Object.assign(i, {</span>
                <span class="s1">raws: {</span>
                  <span class="s1">between: gridArea.raws.between</span>
                <span class="s1">}</span>
              <span class="s1">})</span>
            <span class="s1">)</span>
          <span class="s1">)</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(rule.params) {</span>
        <span class="s4">// grid-template is inside media rule</span>
        <span class="s4">// if we're inside media rule, we need to store prefixed rules</span>
        <span class="s4">// inside rulesToInsert object to be able to preserve the order of media</span>
        <span class="s4">// rules and merge them easily</span>
        <span class="s0">let </span><span class="s1">cloned = gridAreaRule.clone()</span>
        <span class="s1">cloned.removeAll()</span>

        <span class="s1">getMSDecls(area, area.row.updateSpan, area.column.updateSpan)</span>
          <span class="s1">.reverse()</span>
          <span class="s1">.forEach(i =&gt;</span>
            <span class="s1">cloned.prepend(</span>
              <span class="s1">Object.assign(i, {</span>
                <span class="s1">raws: {</span>
                  <span class="s1">between: gridArea.raws.between</span>
                <span class="s1">}</span>
              <span class="s1">})</span>
            <span class="s1">)</span>
          <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">(rule.hasDuplicates &amp;&amp; hasDuplicateName) {</span>
          <span class="s1">cloned.selectors = changeDuplicateAreaSelectors(</span>
            <span class="s1">cloned.selectors,</span>
            <span class="s1">rule.selectors</span>
          <span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s1">cloned.raws = rule.node.raws</span>

        <span class="s0">if </span><span class="s1">(css.index(rule.node.parent) &gt; gridAreaRuleIndex) {</span>
          <span class="s4">// append the prefixed rules right inside media rule</span>
          <span class="s4">// with grid-template</span>
          <span class="s1">rule.node.parent.append(cloned)</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s4">// store the rule to insert later</span>
          <span class="s1">rulesToInsert[lastArea][rule.params].push(cloned)</span>
        <span class="s1">}</span>

        <span class="s4">// set new rule as last rule ONLY if we didn't set lastRule for</span>
        <span class="s4">// this grid-area before</span>
        <span class="s0">if </span><span class="s1">(!lastRuleIsSet) {</span>
          <span class="s1">rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">undefined</span>
  <span class="s1">})</span>

  <span class="s4">// append stored rules inside the media rules</span>
  <span class="s1">Object.keys(rulesToInsert).forEach(area =&gt; {</span>
    <span class="s0">let </span><span class="s1">data = rulesToInsert[area]</span>
    <span class="s0">let </span><span class="s1">lastRule = data.lastRule</span>
    <span class="s1">Object.keys(data)</span>
      <span class="s1">.reverse()</span>
      <span class="s1">.filter(p =&gt; p !== </span><span class="s2">'lastRule'</span><span class="s1">)</span>
      <span class="s1">.forEach(params =&gt; {</span>
        <span class="s0">if </span><span class="s1">(data[params].length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; lastRule) {</span>
          <span class="s1">lastRule.after({ name: </span><span class="s2">'media'</span><span class="s1">, params })</span>
          <span class="s1">lastRule.next().append(data[params])</span>
        <span class="s1">}</span>
      <span class="s1">})</span>
  <span class="s1">})</span>

  <span class="s0">return </span><span class="s1">undefined</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* Warn user if grid area identifiers are not found</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Object} areas</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Declaration} decl</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Result} result</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{void}</span>
 <span class="s4">*/</span>
<span class="s1">exports.warnMissedAreas = warnMissedAreas</span>

<span class="s0">function </span><span class="s1">warnMissedAreas(areas, decl, result) {</span>
  <span class="s0">let </span><span class="s1">missed = Object.keys(areas)</span>

  <span class="s1">decl.root().walkDecls(</span><span class="s2">'grid-area'</span><span class="s1">, gridArea =&gt; {</span>
    <span class="s1">missed = missed.filter(e =&gt; e !== gridArea.value)</span>
  <span class="s1">})</span>

  <span class="s0">if </span><span class="s1">(missed.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">decl.warn(result, </span><span class="s2">'Can not find grid areas: ' </span><span class="s1">+ missed.join(</span><span class="s2">', '</span><span class="s1">))</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">undefined</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* compare selectors with grid-area rule and grid-template rule</span>
 <span class="s4">* show warning if grid-template selector is not found</span>
 <span class="s4">* (this function used for grid-area rule)</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Declaration} decl</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Result} result</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{void}</span>
 <span class="s4">*/</span>
<span class="s1">exports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound</span>

<span class="s0">function </span><span class="s1">warnTemplateSelectorNotFound(decl, result) {</span>
  <span class="s0">let </span><span class="s1">rule = decl.parent</span>
  <span class="s0">let </span><span class="s1">root = decl.root()</span>
  <span class="s0">let </span><span class="s1">duplicatesFound = </span><span class="s0">false</span>

  <span class="s4">// slice selector array. Remove the last part (for comparison)</span>
  <span class="s0">let </span><span class="s1">slicedSelectorArr = list</span>
    <span class="s1">.space(rule.selector)</span>
    <span class="s1">.filter(str =&gt; str !== </span><span class="s2">'&gt;'</span><span class="s1">)</span>
    <span class="s1">.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">)</span>

  <span class="s4">// we need to compare only if selector is complex.</span>
  <span class="s4">// e.g '.grid-cell' is simple, but '.parent &gt; .grid-cell' is complex</span>
  <span class="s0">if </span><span class="s1">(slicedSelectorArr.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s0">let </span><span class="s1">gridTemplateFound = </span><span class="s0">false</span>
    <span class="s0">let </span><span class="s1">foundAreaSelector = </span><span class="s0">null</span>

    <span class="s1">root.walkDecls(</span><span class="s5">/grid-template(-areas)?$/</span><span class="s1">, d =&gt; {</span>
      <span class="s0">let </span><span class="s1">parent = d.parent</span>
      <span class="s0">let </span><span class="s1">templateSelectors = parent.selectors</span>

      <span class="s0">let </span><span class="s1">{ areas } = parseTemplate({ decl: d, gap: getGridGap(d) })</span>
      <span class="s0">let </span><span class="s1">hasArea = areas[decl.value]</span>

      <span class="s4">// find the the matching selectors</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">tplSelector of templateSelectors) {</span>
        <span class="s0">if </span><span class="s1">(gridTemplateFound) {</span>
          <span class="s0">break</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">tplSelectorArr = list.space(tplSelector).filter(str =&gt; str !== </span><span class="s2">'&gt;'</span><span class="s1">)</span>

        <span class="s1">gridTemplateFound = tplSelectorArr.every(</span>
          <span class="s1">(item, idx) =&gt; item === slicedSelectorArr[idx]</span>
        <span class="s1">)</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(gridTemplateFound || !hasArea) {</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(!foundAreaSelector) {</span>
        <span class="s1">foundAreaSelector = parent.selector</span>
      <span class="s1">}</span>

      <span class="s4">// if we found the duplicate area with different selector</span>
      <span class="s0">if </span><span class="s1">(foundAreaSelector &amp;&amp; foundAreaSelector !== parent.selector) {</span>
        <span class="s1">duplicatesFound = </span><span class="s0">true</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">undefined</span>
    <span class="s1">})</span>

    <span class="s4">// warn user if we didn't find template</span>
    <span class="s0">if </span><span class="s1">(!gridTemplateFound &amp;&amp; duplicatesFound) {</span>
      <span class="s1">decl.warn(</span>
        <span class="s1">result,</span>
        <span class="s2">'Autoprefixer cannot find a grid-template ' </span><span class="s1">+</span>
          <span class="s2">`containing the duplicate grid-area &quot;</span><span class="s1">${decl.value}</span><span class="s2">&quot; ` </span><span class="s1">+</span>
          <span class="s2">`with full selector matching: </span><span class="s1">${slicedSelectorArr.join(</span><span class="s2">' '</span><span class="s1">)}</span><span class="s2">`</span>
      <span class="s1">)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* warn user if both grid-area and grid-(row|column)</span>
 <span class="s4">* declarations are present in the same rule</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Declaration} decl</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Result} result</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{void}</span>
 <span class="s4">*/</span>
<span class="s1">exports.warnIfGridRowColumnExists = warnIfGridRowColumnExists</span>

<span class="s0">function </span><span class="s1">warnIfGridRowColumnExists(decl, result) {</span>
  <span class="s0">let </span><span class="s1">rule = decl.parent</span>
  <span class="s0">let </span><span class="s1">decls = []</span>
  <span class="s1">rule.walkDecls(</span><span class="s5">/^grid-(row|column)/</span><span class="s1">, d =&gt; {</span>
    <span class="s0">if </span><span class="s1">(</span>
      <span class="s1">!d.prop.endsWith(</span><span class="s2">'-end'</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">!d.value.startsWith(</span><span class="s2">'span'</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">!d.prop.endsWith(</span><span class="s2">'-gap'</span><span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s1">decls.push(d)</span>
    <span class="s1">}</span>
  <span class="s1">})</span>
  <span class="s0">if </span><span class="s1">(decls.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">decls.forEach(d =&gt; {</span>
      <span class="s1">d.warn(</span>
        <span class="s1">result,</span>
        <span class="s2">'You already have a grid-area declaration present in the rule. ' </span><span class="s1">+</span>
          <span class="s2">`You should use either grid-area or </span><span class="s1">${d.prop}</span><span class="s2">, not both`</span>
      <span class="s1">)</span>
    <span class="s1">})</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">undefined</span>
<span class="s1">}</span>

<span class="s4">// Gap utils</span>

<span class="s1">exports.getGridGap = getGridGap</span>

<span class="s0">function </span><span class="s1">getGridGap(decl) {</span>
  <span class="s0">let </span><span class="s1">gap = {}</span>

  <span class="s4">// try to find gap</span>
  <span class="s0">let </span><span class="s1">testGap = </span><span class="s5">/^(grid-)?((row|column)-)?gap$/</span>
  <span class="s1">decl.parent.walkDecls(testGap, ({ prop, value }) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s5">/^(grid-)?gap$/</span><span class="s1">.test(prop)) {</span>
      <span class="s0">let </span><span class="s1">[row, , column] = parser(value).nodes</span>

      <span class="s1">gap.row = row &amp;&amp; parser.stringify(row)</span>
      <span class="s1">gap.column = column ? parser.stringify(column) : gap.row</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s5">/^(grid-)?row-gap$/</span><span class="s1">.test(prop)) gap.row = value</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s5">/^(grid-)?column-gap$/</span><span class="s1">.test(prop)) gap.column = value</span>
  <span class="s1">})</span>

  <span class="s0">return </span><span class="s1">gap</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* parse media parameters (for example 'min-width: 500px')</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{String} params parameter to parse</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{}</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">parseMediaParams(params) {</span>
  <span class="s0">if </span><span class="s1">(!params) {</span>
    <span class="s0">return </span><span class="s1">[]</span>
  <span class="s1">}</span>
  <span class="s0">let </span><span class="s1">parsed = parser(params)</span>
  <span class="s0">let </span><span class="s1">prop</span>
  <span class="s0">let </span><span class="s1">value</span>

  <span class="s1">parsed.walk(node =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">'word' </span><span class="s1">&amp;&amp; </span><span class="s5">/min|max/g</span><span class="s1">.test(node.value)) {</span>
      <span class="s1">prop = node.value</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(node.value.includes(</span><span class="s2">'px'</span><span class="s1">)) {</span>
      <span class="s1">value = parseInt(node.value.replace(</span><span class="s5">/\D/g</span><span class="s1">, </span><span class="s2">''</span><span class="s1">))</span>
    <span class="s1">}</span>
  <span class="s1">})</span>

  <span class="s0">return </span><span class="s1">[prop, value]</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* Compare the selectors and decide if we</span>
 <span class="s4">* need to inherit gap from compared selector or not.</span>
 <span class="s4">* </span><span class="s6">@type </span><span class="s4">{String} selA</span>
 <span class="s4">* </span><span class="s6">@type </span><span class="s4">{String} selB</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{Boolean}</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">shouldInheritGap(selA, selB) {</span>
  <span class="s0">let </span><span class="s1">result</span>

  <span class="s4">// get arrays of selector split in 3-deep array</span>
  <span class="s0">let </span><span class="s1">splitSelectorArrA = splitSelector(selA)</span>
  <span class="s0">let </span><span class="s1">splitSelectorArrB = splitSelector(selB)</span>

  <span class="s0">if </span><span class="s1">(splitSelectorArrA[</span><span class="s3">0</span><span class="s1">].length &lt; splitSelectorArrB[</span><span class="s3">0</span><span class="s1">].length) {</span>
    <span class="s4">// abort if selectorA has lower descendant specificity then selectorB</span>
    <span class="s4">// (e.g '.grid' and '.hello .world .grid')</span>
    <span class="s0">return false</span>
  <span class="s1">} </span><span class="s0">else if </span><span class="s1">(splitSelectorArrA[</span><span class="s3">0</span><span class="s1">].length &gt; splitSelectorArrB[</span><span class="s3">0</span><span class="s1">].length) {</span>
    <span class="s4">// if selectorA has higher descendant specificity then selectorB</span>
    <span class="s4">// (e.g '.foo .bar .grid' and '.grid')</span>

    <span class="s0">let </span><span class="s1">idx = splitSelectorArrA[</span><span class="s3">0</span><span class="s1">].reduce((res, [item], index) =&gt; {</span>
      <span class="s0">let </span><span class="s1">firstSelectorPart = splitSelectorArrB[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
      <span class="s0">if </span><span class="s1">(item === firstSelectorPart) {</span>
        <span class="s0">return </span><span class="s1">index</span>
      <span class="s1">}</span>
      <span class="s0">return false</span>
    <span class="s1">}, </span><span class="s0">false</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">(idx) {</span>
      <span class="s1">result = splitSelectorArrB[</span><span class="s3">0</span><span class="s1">].every((arr, index) =&gt; {</span>
        <span class="s0">return </span><span class="s1">arr.every(</span>
          <span class="s1">(part, innerIndex) =&gt;</span>
            <span class="s4">// because selectorA has more space elements, we need to slice</span>
            <span class="s4">// selectorA array by 'idx' number to compare them</span>
            <span class="s1">splitSelectorArrA[</span><span class="s3">0</span><span class="s1">].slice(idx)[index][innerIndex] === part</span>
        <span class="s1">)</span>
      <span class="s1">})</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s4">// if selectorA has the same descendant specificity as selectorB</span>
    <span class="s4">// this condition covers cases such as: '.grid.foo.bar' and '.grid'</span>
    <span class="s1">result = splitSelectorArrB.some(byCommaArr =&gt; {</span>
      <span class="s0">return </span><span class="s1">byCommaArr.every((bySpaceArr, index) =&gt; {</span>
        <span class="s0">return </span><span class="s1">bySpaceArr.every(</span>
          <span class="s1">(part, innerIndex) =&gt; splitSelectorArrA[</span><span class="s3">0</span><span class="s1">][index][innerIndex] === part</span>
        <span class="s1">)</span>
      <span class="s1">})</span>
    <span class="s1">})</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">result</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* inherit grid gap values from the closest rule above</span>
 <span class="s4">* with the same selector</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Declaration} decl</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{Object} gap gap values</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{Object | Boolean} return gap values or false (if not found)</span>
 <span class="s4">*/</span>
<span class="s1">exports.inheritGridGap = inheritGridGap</span>

<span class="s0">function </span><span class="s1">inheritGridGap(decl, gap) {</span>
  <span class="s0">let </span><span class="s1">rule = decl.parent</span>
  <span class="s0">let </span><span class="s1">mediaRule = getParentMedia(rule)</span>
  <span class="s0">let </span><span class="s1">root = rule.root()</span>

  <span class="s4">// get an array of selector split in 3-deep array</span>
  <span class="s0">let </span><span class="s1">splitSelectorArr = splitSelector(rule.selector)</span>

  <span class="s4">// abort if the rule already has gaps</span>
  <span class="s0">if </span><span class="s1">(Object.keys(gap).length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s0">return false</span>
  <span class="s1">}</span>

  <span class="s4">// e.g ['min-width']</span>
  <span class="s0">let </span><span class="s1">[prop] = parseMediaParams(mediaRule.params)</span>

  <span class="s0">let </span><span class="s1">lastBySpace = splitSelectorArr[</span><span class="s3">0</span><span class="s1">]</span>

  <span class="s4">// get escaped value from the selector</span>
  <span class="s4">// if we have '.grid-2.foo.bar' selector, will be '\.grid\-2'</span>
  <span class="s0">let </span><span class="s1">escaped = escapeRegexp(lastBySpace[lastBySpace.length - </span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">])</span>

  <span class="s0">let </span><span class="s1">regexp = </span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">`(</span><span class="s1">${escaped}</span><span class="s2">$)|(</span><span class="s1">${escaped}</span><span class="s2">[,.])`</span><span class="s1">)</span>

  <span class="s4">// find the closest rule with the same selector</span>
  <span class="s0">let </span><span class="s1">closestRuleGap</span>
  <span class="s1">root.walkRules(regexp, r =&gt; {</span>
    <span class="s0">let </span><span class="s1">gridGap</span>

    <span class="s4">// abort if are checking the same rule</span>
    <span class="s0">if </span><span class="s1">(rule.toString() === r.toString()) {</span>
      <span class="s0">return false</span>
    <span class="s1">}</span>

    <span class="s4">// find grid-gap values</span>
    <span class="s1">r.walkDecls(</span><span class="s2">'grid-gap'</span><span class="s1">, d =&gt; (gridGap = getGridGap(d)))</span>

    <span class="s4">// skip rule without gaps</span>
    <span class="s0">if </span><span class="s1">(!gridGap || Object.keys(gridGap).length === </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s0">return true</span>
    <span class="s1">}</span>

    <span class="s4">// skip rules that should not be inherited from</span>
    <span class="s0">if </span><span class="s1">(!shouldInheritGap(rule.selector, r.selector)) {</span>
      <span class="s0">return true</span>
    <span class="s1">}</span>

    <span class="s0">let </span><span class="s1">media = getParentMedia(r)</span>
    <span class="s0">if </span><span class="s1">(media) {</span>
      <span class="s4">// if we are inside media, we need to check that media props match</span>
      <span class="s4">// e.g ('min-width' === 'min-width')</span>
      <span class="s0">let </span><span class="s1">propToCompare = parseMediaParams(media.params)[</span><span class="s3">0</span><span class="s1">]</span>
      <span class="s0">if </span><span class="s1">(propToCompare === prop) {</span>
        <span class="s1">closestRuleGap = gridGap</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">closestRuleGap = gridGap</span>
      <span class="s0">return true</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">undefined</span>
  <span class="s1">})</span>

  <span class="s4">// if we find the closest gap object</span>
  <span class="s0">if </span><span class="s1">(closestRuleGap &amp;&amp; Object.keys(closestRuleGap).length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">closestRuleGap</span>
  <span class="s1">}</span>
  <span class="s0">return false</span>
<span class="s1">}</span>

<span class="s1">exports.warnGridGap = warnGridGap</span>

<span class="s0">function </span><span class="s1">warnGridGap({ decl, gap, hasColumns, result }) {</span>
  <span class="s0">let </span><span class="s1">hasBothGaps = gap.row &amp;&amp; gap.column</span>
  <span class="s0">if </span><span class="s1">(!hasColumns &amp;&amp; (hasBothGaps || (gap.column &amp;&amp; !gap.row))) {</span>
    <span class="s0">delete </span><span class="s1">gap.column</span>
    <span class="s1">decl.warn(</span>
      <span class="s1">result,</span>
      <span class="s2">'Can not implement grid-gap without grid-template-columns'</span>
    <span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* normalize the grid-template-rows/columns values</span>
 <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{String} str grid-template-rows/columns value</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{Array} normalized array with values</span>
 <span class="s4">* </span><span class="s6">@example</span>
 <span class="s4">* let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')</span>
 <span class="s4">* normalized // &lt;= ['1fr', '20px', '50px', '20px', '50px', '1fr']</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">normalizeRowColumn(str) {</span>
  <span class="s0">let </span><span class="s1">normalized = parser(str).nodes.reduce((result, node) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; node.value === </span><span class="s2">'repeat'</span><span class="s1">) {</span>
      <span class="s0">let </span><span class="s1">key = </span><span class="s2">'count'</span>

      <span class="s0">let </span><span class="s1">[count, value] = node.nodes.reduce(</span>
        <span class="s1">(acc, n) =&gt; {</span>
          <span class="s0">if </span><span class="s1">(n.type === </span><span class="s2">'word' </span><span class="s1">&amp;&amp; key === </span><span class="s2">'count'</span><span class="s1">) {</span>
            <span class="s1">acc[</span><span class="s3">0</span><span class="s1">] = Math.abs(parseInt(n.value))</span>
            <span class="s0">return </span><span class="s1">acc</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(n.type === </span><span class="s2">'div' </span><span class="s1">&amp;&amp; n.value === </span><span class="s2">','</span><span class="s1">) {</span>
            <span class="s1">key = </span><span class="s2">'value'</span>
            <span class="s0">return </span><span class="s1">acc</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(key === </span><span class="s2">'value'</span><span class="s1">) {</span>
            <span class="s1">acc[</span><span class="s3">1</span><span class="s1">] += parser.stringify(n)</span>
          <span class="s1">}</span>
          <span class="s0">return </span><span class="s1">acc</span>
        <span class="s1">},</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s1">, </span><span class="s2">''</span><span class="s1">]</span>
      <span class="s1">)</span>

      <span class="s0">if </span><span class="s1">(count) {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; count; i++) {</span>
          <span class="s1">result.push(value)</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">result</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">'space'</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s1">result</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">result.concat(parser.stringify(node))</span>
  <span class="s1">}, [])</span>

  <span class="s0">return </span><span class="s1">normalized</span>
<span class="s1">}</span>

<span class="s1">exports.autoplaceGridItems = autoplaceGridItems</span>

<span class="s4">/**</span>
 <span class="s4">* Autoplace grid items</span>
 <span class="s4">* </span><span class="s6">@param </span><span class="s4">{Declaration} decl</span>
 <span class="s4">* </span><span class="s6">@param </span><span class="s4">{Result} result</span>
 <span class="s4">* </span><span class="s6">@param </span><span class="s4">{Object} gap gap values</span>
 <span class="s4">* </span><span class="s6">@param </span><span class="s4">{String} autoflowValue grid-auto-flow value</span>
 <span class="s4">* </span><span class="s6">@return </span><span class="s4">{void}</span>
 <span class="s4">* </span><span class="s6">@see </span><span class="s4">https://github.com/postcss/autoprefixer/issues/1148</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">autoplaceGridItems(decl, result, gap, autoflowValue = </span><span class="s2">'row'</span><span class="s1">) {</span>
  <span class="s0">let </span><span class="s1">{ parent } = decl</span>

  <span class="s0">let </span><span class="s1">rowDecl = parent.nodes.find(i =&gt; i.prop === </span><span class="s2">'grid-template-rows'</span><span class="s1">)</span>
  <span class="s0">let </span><span class="s1">rows = normalizeRowColumn(rowDecl.value)</span>
  <span class="s0">let </span><span class="s1">columns = normalizeRowColumn(decl.value)</span>

  <span class="s4">// Build array of area names with dummy values. If we have 3 columns and</span>
  <span class="s4">// 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']</span>
  <span class="s0">let </span><span class="s1">filledRows = rows.map((_, rowIndex) =&gt; {</span>
    <span class="s0">return </span><span class="s1">Array.from(</span>
      <span class="s1">{ length: columns.length },</span>
      <span class="s1">(v, k) =&gt; k + rowIndex * columns.length + </span><span class="s3">1</span>
    <span class="s1">).join(</span><span class="s2">' '</span><span class="s1">)</span>
  <span class="s1">})</span>

  <span class="s0">let </span><span class="s1">areas = parseGridAreas({ gap, rows: filledRows })</span>
  <span class="s0">let </span><span class="s1">keys = Object.keys(areas)</span>
  <span class="s0">let </span><span class="s1">items = keys.map(i =&gt; areas[i])</span>

  <span class="s4">// Change the order of cells if grid-auto-flow value is 'column'</span>
  <span class="s0">if </span><span class="s1">(autoflowValue.includes(</span><span class="s2">'column'</span><span class="s1">)) {</span>
    <span class="s1">items = items.sort((a, b) =&gt; a.column.start - b.column.start)</span>
  <span class="s1">}</span>

  <span class="s4">// Insert new rules</span>
  <span class="s1">items.reverse().forEach((item, index) =&gt; {</span>
    <span class="s0">let </span><span class="s1">{ column, row } = item</span>
    <span class="s0">let </span><span class="s1">nodeSelector = parent.selectors</span>
      <span class="s1">.map(sel =&gt; sel + </span><span class="s2">` &gt; *:nth-child(</span><span class="s1">${keys.length - index}</span><span class="s2">)`</span><span class="s1">)</span>
      <span class="s1">.join(</span><span class="s2">', '</span><span class="s1">)</span>

    <span class="s4">// create new rule</span>
    <span class="s0">let </span><span class="s1">node = parent.clone().removeAll()</span>

    <span class="s4">// change rule selector</span>
    <span class="s1">node.selector = nodeSelector</span>

    <span class="s4">// insert prefixed row/column values</span>
    <span class="s1">node.append({ prop: </span><span class="s2">'-ms-grid-row'</span><span class="s1">, value: row.start })</span>
    <span class="s1">node.append({ prop: </span><span class="s2">'-ms-grid-column'</span><span class="s1">, value: column.start })</span>

    <span class="s4">// insert rule</span>
    <span class="s1">parent.after(node)</span>
  <span class="s1">})</span>

  <span class="s0">return </span><span class="s1">undefined</span>
<span class="s1">}</span>
</pre>
</body>
</html>