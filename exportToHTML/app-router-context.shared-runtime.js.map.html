<html>
<head>
<title>app-router-context.shared-runtime.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-router-context.shared-runtime.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/shared/lib/app-router-context.shared-runtime.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FocusAndScrollRef,</span><span class="s3">\n  </span><span class="s1">PrefetchKind,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import React from 'react'</span><span class="s3">\n\n</span><span class="s1">export type ChildSegmentMap = Map&lt;string, CacheNode&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cache node used in app-router / layout-router.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type CacheNode = ReadyCacheNode | LazyCacheNode</span><span class="s3">\n\n</span><span class="s1">export type LoadingModuleData =</span><span class="s3">\n  </span><span class="s1">| [React.JSX.Element, React.ReactNode, React.ReactNode]</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">/** viewport metadata node */</span><span class="s3">\n</span><span class="s1">export type HeadData = React.ReactNode</span><span class="s3">\n\n</span><span class="s1">export type LazyCacheNode = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When rsc is null, this is a lazily-initialized cache node.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* If the app attempts to render it, it triggers a lazy data fetch,</span><span class="s3">\n   </span><span class="s1">* postpones the render, and schedules an update to a new tree.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* TODO: This mechanism should not be used when PPR is enabled, though it</span><span class="s3">\n   </span><span class="s1">* currently is in some cases until we've implemented partial</span><span class="s3">\n   </span><span class="s1">* segment fetching.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rsc: null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A prefetched version of the segment data. See explanation in corresponding</span><span class="s3">\n   </span><span class="s1">* field of ReadyCacheNode (below).</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Since LazyCacheNode mostly only exists in the non-PPR implementation, this</span><span class="s3">\n   </span><span class="s1">* will usually be null, but it could have been cloned from a previous</span><span class="s3">\n   </span><span class="s1">* CacheNode that was created by the PPR implementation. Eventually we want</span><span class="s3">\n   </span><span class="s1">* to migrate everything away from LazyCacheNode entirely.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetchRsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A pending response for the lazy data fetch. If this is not present</span><span class="s3">\n   </span><span class="s1">* during render, it is lazily created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">lazyData: Promise&lt;FetchServerResponseResult&gt; | null</span><span class="s3">\n\n  </span><span class="s1">prefetchHead: HeadData | null</span><span class="s3">\n\n  </span><span class="s1">head: HeadData</span><span class="s3">\n\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Child parallel routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">parallelRoutes: Map&lt;string, ChildSegmentMap&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The timestamp of the navigation that last updated the CacheNode's data. If</span><span class="s3">\n   </span><span class="s1">* a CacheNode is reused from a previous navigation, this value is not</span><span class="s3">\n   </span><span class="s1">* updated. Used to track the staleness of the data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadyCacheNode = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When rsc is not null, it represents the RSC data for the</span><span class="s3">\n   </span><span class="s1">* corresponding segment.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* `null` is a valid React Node but because segment data is always a</span><span class="s3">\n   </span><span class="s1">* &lt;LayoutRouter&gt; component, we can use `null` to represent empty.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* TODO: For additional type safety, update this type to</span><span class="s3">\n   </span><span class="s1">* Exclude&lt;React.ReactNode, null&gt;. Need to update createEmptyCacheNode to</span><span class="s3">\n   </span><span class="s1">* accept rsc as an argument, or just inline the callers.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Represents a static version of the segment that can be shown immediately,</span><span class="s3">\n   </span><span class="s1">* and may or may not contain dynamic holes. It's prefetched before a</span><span class="s3">\n   </span><span class="s1">* navigation occurs.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* During rendering, we will choose whether to render `rsc` or `prefetchRsc`</span><span class="s3">\n   </span><span class="s1">* with `useDeferredValue`. As with the `rsc` field, a value of `null` means</span><span class="s3">\n   </span><span class="s1">* no value was provided. In this case, the LayoutRouter will go straight to</span><span class="s3">\n   </span><span class="s1">* rendering the `rsc` value; if that one is also missing, it will suspend and</span><span class="s3">\n   </span><span class="s1">* trigger a lazy fetch.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetchRsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* There should never be a lazy data request in this case.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">lazyData: null</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null</span><span class="s3">\n\n  </span><span class="s1">head: HeadData</span><span class="s3">\n\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n\n  </span><span class="s1">parallelRoutes: Map&lt;string, ChildSegmentMap&gt;</span><span class="s3">\n\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface NavigateOptions {</span><span class="s3">\n  </span><span class="s1">scroll?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface PrefetchOptions {</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n  </span><span class="s1">onInvalidate?: () =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface AppRouterInstance {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the previous history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">back(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the next history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">forward(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Refresh the current page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">refresh(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Refresh the current page. Use in development only.</span><span class="s3">\n   </span><span class="s1">* @internal</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hmrRefresh(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the provided href.</span><span class="s3">\n   </span><span class="s1">* Pushes a new history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">push(href: string, options?: NavigateOptions): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the provided href.</span><span class="s3">\n   </span><span class="s1">* Replaces the current history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">replace(href: string, options?: NavigateOptions): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Prefetch the provided href.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetch(href: string, options?: PrefetchOptions): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const AppRouterContext = React.createContext&lt;AppRouterInstance | null&gt;(</span><span class="s3">\n  </span><span class="s1">null</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const LayoutRouterContext = React.createContext&lt;{</span><span class="s3">\n  </span><span class="s1">parentTree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">parentCacheNode: CacheNode</span><span class="s3">\n  </span><span class="s1">parentSegmentPath: FlightSegmentPath | null</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n</span><span class="s1">} | null&gt;(null)</span><span class="s3">\n\n</span><span class="s1">export const GlobalLayoutRouterContext = React.createContext&lt;{</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">focusAndScrollRef: FocusAndScrollRef</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null</span><span class="s3">\n</span><span class="s1">}&gt;(null as any)</span><span class="s3">\n\n</span><span class="s1">export const TemplateContext = React.createContext&lt;React.ReactNode&gt;(null as any)</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">AppRouterContext.displayName = 'AppRouterContext'</span><span class="s3">\n  </span><span class="s1">LayoutRouterContext.displayName = 'LayoutRouterContext'</span><span class="s3">\n  </span><span class="s1">GlobalLayoutRouterContext.displayName = 'GlobalLayoutRouterContext'</span><span class="s3">\n  </span><span class="s1">TemplateContext.displayName = 'TemplateContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const MissingSlotContext = React.createContext&lt;Set&lt;string&gt;&gt;(new Set())</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;AppRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;GlobalLayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;LayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;MissingSlotContext&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateContext&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;createContext&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;displayName&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;;;;;;;;;;;;;;;IAiKaA,gBAAgB;eAAhBA;;IAUAC,yBAAyB;eAAzBA;;IAPAC,mBAAmB;eAAnBA;;IAsBAC,kBAAkB;eAAlBA;;IATAC,eAAe;eAAfA;;;;gEAtKK;AAsJX,MAAMJ,mBAAmBK,cAAK,CAACC,aAAa,CACjD;AAEK,MAAMJ,sBAAsBG,cAAK,CAACC,aAAa,CAK5C;AAEH,MAAML,4BAA4BI,cAAK,CAACC,aAAa,CAIzD;AAEI,MAAMF,kBAAkBC,cAAK,CAACC,aAAa,CAAkB;AAEpE,IAAIC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAc;IACzCT,iBAAiBU,WAAW,GAAG;IAC/BR,oBAAoBQ,WAAW,GAAG;IAClCT,0BAA0BS,WAAW,GAAG;IACxCN,gBAAgBM,WAAW,GAAG;AAChC;AAEO,MAAMP,qBAAqBE,cAAK,CAACC,aAAa,CAAc,IAAIK&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>