<html>
<head>
<title>explicitReturnTypeUtils.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
explicitReturnTypeUtils.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.doesImmediatelyReturnFunctionExpression = doesImmediatelyReturnFunctionExpression;</span>
<span class="s1">exports.isTypedFunctionExpression = isTypedFunctionExpression;</span>
<span class="s1">exports.isValidFunctionExpressionReturnType = isValidFunctionExpressionReturnType;</span>
<span class="s1">exports.checkFunctionReturnType = checkFunctionReturnType;</span>
<span class="s1">exports.checkFunctionExpressionReturnType = checkFunctionExpressionReturnType;</span>
<span class="s1">exports.ancestorHasReturnType = ancestorHasReturnType;</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">astUtils_1 = require(</span><span class="s0">&quot;./astUtils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">getFunctionHeadLoc_1 = require(</span><span class="s0">&quot;./getFunctionHeadLoc&quot;</span><span class="s1">);</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a node is a variable declarator with a type annotation.</span>
 <span class="s3">* ```</span>
 <span class="s3">* const x: Foo = ...</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isVariableDeclaratorWithTypeAnnotation(node) {</span>
    <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.VariableDeclarator &amp;&amp; !!node.id.typeAnnotation);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a node is a class property with a type annotation.</span>
 <span class="s3">* ```</span>
 <span class="s3">* public x: Foo = ...</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isPropertyDefinitionWithTypeAnnotation(node) {</span>
    <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.PropertyDefinition &amp;&amp; !!node.typeAnnotation);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a node belongs to:</span>
 <span class="s3">* ```</span>
 <span class="s3">* foo(() =&gt; 1)</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isFunctionArgument(parent, callee) {</span>
    <span class="s2">return </span><span class="s1">(parent.type === utils_1.AST_NODE_TYPES.CallExpression &amp;&amp;</span>
        <span class="s3">// make sure this isn't an IIFE</span>
        <span class="s1">parent.callee !== callee);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a node is type-constrained in JSX</span>
 <span class="s3">* ```</span>
 <span class="s3">* &lt;Foo x={() =&gt; {}} /&gt;</span>
 <span class="s3">* &lt;Bar&gt;{() =&gt; {}}&lt;/Bar&gt;</span>
 <span class="s3">* &lt;Baz {...props} /&gt;</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isTypedJSX(node) {</span>
    <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.JSXExpressionContainer ||</span>
        <span class="s1">node.type === utils_1.AST_NODE_TYPES.JSXSpreadAttribute);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isTypedParent(parent, callee) {</span>
    <span class="s2">return </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, astUtils_1.isTypeAssertion)(parent) ||</span>
        <span class="s1">isVariableDeclaratorWithTypeAnnotation(parent) ||</span>
        <span class="s1">isDefaultFunctionParameterWithTypeAnnotation(parent) ||</span>
        <span class="s1">isPropertyDefinitionWithTypeAnnotation(parent) ||</span>
        <span class="s1">isFunctionArgument(parent, callee) ||</span>
        <span class="s1">isTypedJSX(parent));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isDefaultFunctionParameterWithTypeAnnotation(node) {</span>
    <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.AssignmentPattern &amp;&amp;</span>
        <span class="s1">node.left.typeAnnotation != </span><span class="s2">null</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a node belongs to:</span>
 <span class="s3">* ```</span>
 <span class="s3">* new Foo(() =&gt; {})</span>
 <span class="s3">*         ^^^^^^^^</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isConstructorArgument(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === utils_1.AST_NODE_TYPES.NewExpression;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a node is a property or a nested property of a typed object:</span>
 <span class="s3">* ```</span>
 <span class="s3">* const x: Foo = { prop: () =&gt; {} }</span>
 <span class="s3">* const x = { prop: () =&gt; {} } as Foo</span>
 <span class="s3">* const x = &lt;Foo&gt;{ prop: () =&gt; {} }</span>
 <span class="s3">* const x: Foo = { bar: { prop: () =&gt; {} } }</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isPropertyOfObjectWithType(property) {</span>
    <span class="s2">if </span><span class="s1">(!property || property.type !== utils_1.AST_NODE_TYPES.Property) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">objectExpr = property.parent;</span>
    <span class="s2">if </span><span class="s1">(objectExpr.type !== utils_1.AST_NODE_TYPES.ObjectExpression) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">parent = objectExpr.parent;</span>
    <span class="s2">return </span><span class="s1">isTypedParent(parent) || isPropertyOfObjectWithType(parent);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a function belongs to:</span>
 <span class="s3">* ```</span>
 <span class="s3">* () =&gt; () =&gt; ...</span>
 <span class="s3">* () =&gt; function () { ... }</span>
 <span class="s3">* () =&gt; { return () =&gt; ... }</span>
 <span class="s3">* () =&gt; { return function () { ... } }</span>
 <span class="s3">* function fn() { return () =&gt; ... }</span>
 <span class="s3">* function fn() { return function() { ... } }</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">doesImmediatelyReturnFunctionExpression({ node, returns, }) {</span>
    <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &amp;&amp;</span>
        <span class="s1">utils_1.ASTUtils.isFunction(node.body)) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(returns.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">returns.every(node =&gt; node.argument &amp;&amp; utils_1.ASTUtils.isFunction(node.argument));</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a function belongs to:</span>
 <span class="s3">* ```</span>
 <span class="s3">* ({ action: 'xxx' } as const)</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isConstAssertion(node) {</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, astUtils_1.isTypeAssertion)(node)) {</span>
        <span class="s2">const </span><span class="s1">{ typeAnnotation } = node;</span>
        <span class="s2">if </span><span class="s1">(typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference) {</span>
            <span class="s2">const </span><span class="s1">{ typeName } = typeAnnotation;</span>
            <span class="s2">if </span><span class="s1">(typeName.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                <span class="s1">typeName.name === </span><span class="s0">'const'</span><span class="s1">) {</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* True when the provided function expression is typed.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isTypedFunctionExpression(node, options) {</span>
    <span class="s2">if </span><span class="s1">(!options.allowTypedFunctionExpressions) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(isTypedParent(node.parent, node) ||</span>
        <span class="s1">isPropertyOfObjectWithType(node.parent) ||</span>
        <span class="s1">isConstructorArgument(node.parent));</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Check whether the function expression return type is either typed or valid</span>
 <span class="s3">* with the provided options.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isValidFunctionExpressionReturnType(node, options) {</span>
    <span class="s2">if </span><span class="s1">(isTypedFunctionExpression(node, options)) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.allowExpressions &amp;&amp;</span>
        <span class="s1">node.parent.type !== utils_1.AST_NODE_TYPES.VariableDeclarator &amp;&amp;</span>
        <span class="s1">node.parent.type !== utils_1.AST_NODE_TYPES.MethodDefinition &amp;&amp;</span>
        <span class="s1">node.parent.type !== utils_1.AST_NODE_TYPES.ExportDefaultDeclaration &amp;&amp;</span>
        <span class="s1">node.parent.type !== utils_1.AST_NODE_TYPES.PropertyDefinition) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// https://github.com/typescript-eslint/typescript-eslint/issues/653</span>
    <span class="s2">if </span><span class="s1">(!options.allowDirectConstAssertionInArrowFunctions ||</span>
        <span class="s1">node.type !== utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">body = node.body;</span>
    <span class="s2">while </span><span class="s1">(body.type === utils_1.AST_NODE_TYPES.TSSatisfiesExpression) {</span>
        <span class="s1">body = body.expression;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">isConstAssertion(body);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Check that the function expression or declaration is valid.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isValidFunctionReturnType({ node, returns }, options) {</span>
    <span class="s2">if </span><span class="s1">(options.allowHigherOrderFunctions &amp;&amp;</span>
        <span class="s1">doesImmediatelyReturnFunctionExpression({ node, returns })) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(node.returnType != </span><span class="s2">null </span><span class="s1">||</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, astUtils_1.isConstructor)(node.parent) ||</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, astUtils_1.isSetter)(node.parent));</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a function declaration/expression has a return type.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">checkFunctionReturnType({ node, returns }, options, sourceCode, report) {</span>
    <span class="s2">if </span><span class="s1">(isValidFunctionReturnType({ node, returns }, options)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">report((</span><span class="s4">0</span><span class="s1">, getFunctionHeadLoc_1.getFunctionHeadLoc)(node, sourceCode));</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a function declaration/expression has a return type.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">checkFunctionExpressionReturnType(info, options, sourceCode, report) {</span>
    <span class="s2">if </span><span class="s1">(isValidFunctionExpressionReturnType(info.node, options)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">checkFunctionReturnType(info, options, sourceCode, report);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Check whether any ancestor of the provided function has a valid return type.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">ancestorHasReturnType(node) {</span>
    <span class="s2">let </span><span class="s1">ancestor = node.parent;</span>
    <span class="s2">if </span><span class="s1">(ancestor.type === utils_1.AST_NODE_TYPES.Property) {</span>
        <span class="s1">ancestor = ancestor.value;</span>
    <span class="s1">}</span>
    <span class="s3">// if the ancestor is not a return, then this function was not returned at all, so we can exit early</span>
    <span class="s2">const </span><span class="s1">isReturnStatement = ancestor.type === utils_1.AST_NODE_TYPES.ReturnStatement;</span>
    <span class="s2">const </span><span class="s1">isBodylessArrow = ancestor.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &amp;&amp;</span>
        <span class="s1">ancestor.body.type !== utils_1.AST_NODE_TYPES.BlockStatement;</span>
    <span class="s2">if </span><span class="s1">(!isReturnStatement &amp;&amp; !isBodylessArrow) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">while </span><span class="s1">(ancestor) {</span>
        <span class="s2">switch </span><span class="s1">(ancestor.type) {</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ArrowFunctionExpression:</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.FunctionExpression:</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.FunctionDeclaration:</span>
                <span class="s2">if </span><span class="s1">(ancestor.returnType) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s3">// const x: Foo = () =&gt; {};</span>
            <span class="s3">// Assume that a typed variable types the function expression</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.VariableDeclarator:</span>
                <span class="s2">return </span><span class="s1">!!ancestor.id.typeAnnotation;</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
                <span class="s2">return </span><span class="s1">!!ancestor.typeAnnotation;</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ExpressionStatement:</span>
                <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">ancestor = ancestor.parent;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
</pre>
</body>
</html>