<html>
<head>
<title>mock-request.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mock-request.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">MockedRequest: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">MockedResponse: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createRequestResponseMocks: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">MockedRequest: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">MockedRequest;</span>
    <span class="s1">},</span>
    <span class="s1">MockedResponse: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">MockedResponse;</span>
    <span class="s1">},</span>
    <span class="s1">createRequestResponseMocks: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createRequestResponseMocks;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_stream = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;stream&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../web/utils&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">MockedRequest </span><span class="s2">extends </span><span class="s1">_stream.default.Readable {</span>
    <span class="s1">constructor({ url, headers, method, socket = </span><span class="s2">null</span><span class="s1">, readable }){</span>
        <span class="s2">super</span><span class="s1">(), </span><span class="s4">// This is hardcoded for now, but can be updated to be configurable if needed.</span>
        <span class="s2">this</span><span class="s1">.httpVersion = </span><span class="s0">'1.0'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.httpVersionMajor = </span><span class="s3">1</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.httpVersionMinor = </span><span class="s3">0</span><span class="s1">, </span><span class="s4">// If we don't actually have a socket, we'll just use a mock one that</span>
        <span class="s4">// always returns false for the `encrypted` property and undefined for the</span>
        <span class="s4">// `remoteAddress` property.</span>
        <span class="s2">this</span><span class="s1">.socket = </span><span class="s2">new </span><span class="s1">Proxy({}, {</span>
            <span class="s1">get: (_target, prop)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(prop !== </span><span class="s0">'encrypted' </span><span class="s1">&amp;&amp; prop !== </span><span class="s0">'remoteAddress'</span><span class="s1">) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E52&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(prop === </span><span class="s0">'remoteAddress'</span><span class="s1">) </span><span class="s2">return </span><span class="s1">undefined;</span>
                <span class="s4">// For this mock request, always ensure we just respond with the encrypted</span>
                <span class="s4">// set to false to ensure there's no odd leakages.</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">this</span><span class="s1">.url = url;</span>
        <span class="s2">this</span><span class="s1">.headers = headers;</span>
        <span class="s2">this</span><span class="s1">.method = method;</span>
        <span class="s2">if </span><span class="s1">(readable) {</span>
            <span class="s2">this</span><span class="s1">.bodyReadable = readable;</span>
            <span class="s2">this</span><span class="s1">.bodyReadable.on(</span><span class="s0">'end'</span><span class="s1">, ()=&gt;</span><span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'end'</span><span class="s1">));</span>
            <span class="s2">this</span><span class="s1">.bodyReadable.on(</span><span class="s0">'close'</span><span class="s1">, ()=&gt;</span><span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'close'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(socket) {</span>
            <span class="s2">this</span><span class="s1">.socket = socket;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">get headersDistinct() {</span>
        <span class="s2">const </span><span class="s1">headers = {};</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(</span><span class="s2">this</span><span class="s1">.headers)){</span>
            <span class="s2">if </span><span class="s1">(!value) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">headers[key] = Array.isArray(value) ? value : [</span>
                <span class="s1">value</span>
            <span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">headers;</span>
    <span class="s1">}</span>
    <span class="s1">_read(size) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.bodyReadable) {</span>
            <span class="s2">return this</span><span class="s1">.bodyReadable._read(size);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'end'</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'close'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* The `connection` property is just an alias for the `socket` property.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@deprecated </span><span class="s4">— since v13.0.0 - Use socket instead.</span>
   <span class="s4">*/ </span><span class="s1">get connection() {</span>
        <span class="s2">return this</span><span class="s1">.socket;</span>
    <span class="s1">}</span>
    <span class="s4">// The following methods are not implemented as they are not used in the</span>
    <span class="s4">// Next.js codebase.</span>
    <span class="s1">get aborted() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E52&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get complete() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E52&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get trailers() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E52&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get trailersDistinct() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E52&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get rawTrailers() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E52&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get rawHeaders() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">setTimeout() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">MockedResponse </span><span class="s2">extends </span><span class="s1">_stream.default.Writable {</span>
    <span class="s1">constructor(res = {}){</span>
        <span class="s2">super</span><span class="s1">(), </span><span class="s2">this</span><span class="s1">.statusMessage = </span><span class="s0">''</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.finished = </span><span class="s2">false</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.headersSent = </span><span class="s2">false</span><span class="s1">, </span><span class="s4">/**</span>
   <span class="s4">* A list of buffers that have been written to the response.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@internal </span><span class="s4">- used internally by Next.js</span>
   <span class="s4">*/ </span><span class="s2">this</span><span class="s1">.buffers = [];</span>
        <span class="s2">this</span><span class="s1">.statusCode = res.statusCode ?? </span><span class="s3">200</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.socket = res.socket ?? </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.headers = res.headers ? (</span><span class="s3">0</span><span class="s1">, _utils.fromNodeOutgoingHttpHeaders)(res.headers) : </span><span class="s2">new </span><span class="s1">Headers();</span>
        <span class="s2">this</span><span class="s1">.headPromise = </span><span class="s2">new </span><span class="s1">Promise((resolve)=&gt;{</span>
            <span class="s2">this</span><span class="s1">.headPromiseResolve = resolve;</span>
        <span class="s1">});</span>
        <span class="s4">// Attach listeners for the `finish`, `end`, and `error` events to the</span>
        <span class="s4">// `MockedResponse` instance.</span>
        <span class="s2">this</span><span class="s1">.hasStreamed = </span><span class="s2">new </span><span class="s1">Promise((resolve, reject)=&gt;{</span>
            <span class="s2">this</span><span class="s1">.on(</span><span class="s0">'finish'</span><span class="s1">, ()=&gt;resolve(</span><span class="s2">true</span><span class="s1">));</span>
            <span class="s2">this</span><span class="s1">.on(</span><span class="s0">'end'</span><span class="s1">, ()=&gt;resolve(</span><span class="s2">true</span><span class="s1">));</span>
            <span class="s2">this</span><span class="s1">.on(</span><span class="s0">'error'</span><span class="s1">, (err)=&gt;reject(err));</span>
        <span class="s1">}).then((val)=&gt;{</span>
            <span class="s2">this</span><span class="s1">.headPromiseResolve == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.headPromiseResolve.call(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">val;</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(res.resWriter) {</span>
            <span class="s2">this</span><span class="s1">.resWriter = res.resWriter;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">appendHeader(name, value) {</span>
        <span class="s2">const </span><span class="s1">values = Array.isArray(value) ? value : [</span>
            <span class="s1">value</span>
        <span class="s1">];</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">v of values){</span>
            <span class="s2">this</span><span class="s1">.headers.append(name, v);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Returns true if the response has been sent, false otherwise.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@internal </span><span class="s4">- used internally by Next.js</span>
   <span class="s4">*/ </span><span class="s1">get isSent() {</span>
        <span class="s2">return this</span><span class="s1">.finished || </span><span class="s2">this</span><span class="s1">.headersSent;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* The `connection` property is just an alias for the `socket` property.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@deprecated </span><span class="s4">— since v13.0.0 - Use socket instead.</span>
   <span class="s4">*/ </span><span class="s1">get connection() {</span>
        <span class="s2">return this</span><span class="s1">.socket;</span>
    <span class="s1">}</span>
    <span class="s1">write(chunk) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.resWriter) {</span>
            <span class="s2">return this</span><span class="s1">.resWriter(chunk);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.buffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">end() {</span>
        <span class="s2">this</span><span class="s1">.finished = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">return super</span><span class="s1">.end(...arguments);</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* This method is a no-op because the `MockedResponse` instance is not</span>
   <span class="s4">* actually connected to a socket. This method is not specified on the</span>
   <span class="s4">* interface type for `ServerResponse` but is called by Node.js.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@see </span><span class="s4">https://github.com/nodejs/node/pull/7949</span>
   <span class="s4">*/ </span><span class="s1">_implicitHeader() {}</span>
    <span class="s1">_write(chunk, _encoding, callback) {</span>
        <span class="s2">this</span><span class="s1">.write(chunk);</span>
        <span class="s4">// According to Node.js documentation, the callback MUST be invoked to</span>
        <span class="s4">// signal that the write completed successfully. If this callback is not</span>
        <span class="s4">// invoked, the 'finish' event will not be emitted.</span>
        <span class="s4">//</span>
        <span class="s4">// https://nodejs.org/docs/latest-v16.x/api/stream.html#writable_writechunk-encoding-callback</span>
        <span class="s1">callback();</span>
    <span class="s1">}</span>
    <span class="s1">writeHead(statusCode, statusMessage, headers) {</span>
        <span class="s2">if </span><span class="s1">(!headers &amp;&amp; </span><span class="s2">typeof </span><span class="s1">statusMessage !== </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">headers = statusMessage;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">statusMessage === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; statusMessage.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.statusMessage = statusMessage;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(headers) {</span>
            <span class="s4">// When headers have been set with response.setHeader(), they will be</span>
            <span class="s4">// merged with any headers passed to response.writeHead(), with the</span>
            <span class="s4">// headers passed to response.writeHead() given precedence.</span>
            <span class="s4">//</span>
            <span class="s4">// https://nodejs.org/api/http.html#responsewriteheadstatuscode-statusmessage-headers</span>
            <span class="s4">//</span>
            <span class="s4">// For this reason, we need to only call `set` to ensure that this will</span>
            <span class="s4">// overwrite any existing headers.</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(headers)) {</span>
                <span class="s4">// headers may be an Array where the keys and values are in the same list.</span>
                <span class="s4">// It is not a list of tuples. So, the even-numbered offsets are key</span>
                <span class="s4">// values, and the odd-numbered offsets are the associated values. The</span>
                <span class="s4">// array is in the same format as request.rawHeaders.</span>
                <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; headers.length; i += </span><span class="s3">2</span><span class="s1">){</span>
                    <span class="s4">// The header key is always a string according to the spec.</span>
                    <span class="s2">this</span><span class="s1">.setHeader(headers[i], headers[i + </span><span class="s3">1</span><span class="s1">]);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(headers)){</span>
                    <span class="s4">// Skip undefined values</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'undefined'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
                    <span class="s2">this</span><span class="s1">.setHeader(key, value);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.statusCode = statusCode;</span>
        <span class="s2">this</span><span class="s1">.headersSent = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.headPromiseResolve == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.headPromiseResolve.call(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">hasHeader(name) {</span>
        <span class="s2">return this</span><span class="s1">.headers.has(name);</span>
    <span class="s1">}</span>
    <span class="s1">getHeader(name) {</span>
        <span class="s2">return this</span><span class="s1">.headers.get(name) ?? undefined;</span>
    <span class="s1">}</span>
    <span class="s1">getHeaders() {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.toNodeOutgoingHttpHeaders)(</span><span class="s2">this</span><span class="s1">.headers);</span>
    <span class="s1">}</span>
    <span class="s1">getHeaderNames() {</span>
        <span class="s2">return </span><span class="s1">Array.from(</span><span class="s2">this</span><span class="s1">.headers.keys());</span>
    <span class="s1">}</span>
    <span class="s1">setHeader(name, value) {</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
            <span class="s4">// Because `set` here should override any existing values, we need to</span>
            <span class="s4">// delete the existing values before setting the new ones via `append`.</span>
            <span class="s2">this</span><span class="s1">.headers.delete(name);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">v of value){</span>
                <span class="s2">this</span><span class="s1">.headers.append(name, v);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'number'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.headers.set(name, value.toString());</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.headers.set(name, value);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">removeHeader(name) {</span>
        <span class="s2">this</span><span class="s1">.headers.delete(name);</span>
    <span class="s1">}</span>
    <span class="s1">flushHeaders() {</span>
    <span class="s4">// This is a no-op because we don't actually have a socket to flush the</span>
    <span class="s4">// headers to.</span>
    <span class="s1">}</span>
    <span class="s4">// The following methods are not implemented as they are not used in the</span>
    <span class="s4">// Next.js codebase.</span>
    <span class="s1">get strictContentLength() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">writeEarlyHints() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get req() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">assignSocket() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">detachSocket() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">writeContinue() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">writeProcessing() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get upgrading() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get chunkedEncoding() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get shouldKeepAlive() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get useChunkedEncodingByDefault() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get sendDate() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">setTimeout() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">addTrailers() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">setHeaders() {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Method not implemented.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E41&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRequestResponseMocks({ url, headers = {}, method = </span><span class="s0">'GET'</span><span class="s1">, bodyReadable, resWriter, socket = </span><span class="s2">null </span><span class="s1">}) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">req: </span><span class="s2">new </span><span class="s1">MockedRequest({</span>
            <span class="s1">url,</span>
            <span class="s1">headers,</span>
            <span class="s1">method,</span>
            <span class="s1">socket,</span>
            <span class="s1">readable: bodyReadable</span>
        <span class="s1">}),</span>
        <span class="s1">res: </span><span class="s2">new </span><span class="s1">MockedResponse({</span>
            <span class="s1">socket,</span>
            <span class="s1">resWriter</span>
        <span class="s1">})</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=mock-request.js.map</span></pre>
</body>
</html>