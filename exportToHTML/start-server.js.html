<html>
<head>
<title>start-server.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
start-server.js</font>
</center></td></tr></table>
<pre><span class="s0">// Start CPU profile if it wasn't already started.</span>
<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s4">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">getRequestHandlers: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">startServer: </span><span class="s3">null</span>
<span class="s1">});</span>
<span class="s3">function </span><span class="s1">_export(target, all) {</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">name </span><span class="s3">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">getRequestHandlers: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">getRequestHandlers;</span>
    <span class="s1">},</span>
    <span class="s1">startServer: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">startServer;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">require(</span><span class="s2">&quot;./cpu-profile&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_getnetworkhost = require(</span><span class="s2">&quot;../../lib/get-network-host&quot;</span><span class="s1">);</span>
<span class="s1">require(</span><span class="s2">&quot;../next&quot;</span><span class="s1">);</span>
<span class="s1">require(</span><span class="s2">&quot;../require-hook&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_fs = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_v8 = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;v8&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_path = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_http = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;http&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_https = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;https&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_os = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;os&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_child_process = require(</span><span class="s2">&quot;child_process&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_watchpack = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;next/dist/compiled/watchpack&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_log = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s2">&quot;../../build/output/log&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_debug = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;next/dist/compiled/debug&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_utils = require(</span><span class="s2">&quot;./utils&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_formathostname = require(</span><span class="s2">&quot;./format-hostname&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_routerserver = require(</span><span class="s2">&quot;./router-server&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_constants = require(</span><span class="s2">&quot;../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_appinfolog = require(</span><span class="s2">&quot;./app-info-log&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_turbopackwarning = require(</span><span class="s2">&quot;../../lib/turbopack-warning&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_trace = require(</span><span class="s2">&quot;../../trace&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_isipv6 = require(</span><span class="s2">&quot;./is-ipv6&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_asynccallbackset = require(</span><span class="s2">&quot;./async-callback-set&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s3">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s3">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">WeakMap !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) </span><span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">cacheBabelInterop = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
    <span class="s3">var </span><span class="s1">cacheNodeInterop = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
    <span class="s3">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s3">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s3">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s3">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s3">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(obj === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s3">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s3">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s3">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">obj){</span>
        <span class="s3">if </span><span class="s1">(key !== </span><span class="s2">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s3">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s3">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(performance.getEntriesByName(</span><span class="s2">'next-start'</span><span class="s1">).length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">performance.mark(</span><span class="s2">'next-start'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">debug = (</span><span class="s4">0</span><span class="s1">, _debug.default)(</span><span class="s2">'next:start-server'</span><span class="s1">);</span>
<span class="s3">let </span><span class="s1">startServerSpan;</span>
<span class="s0">/**</span>
 <span class="s0">* Get the process ID (PID) of the process using the specified port</span>
 <span class="s0">*/ </span><span class="s1">async </span><span class="s3">function </span><span class="s1">getProcessIdUsingPort(port) {</span>
    <span class="s3">const </span><span class="s1">timeoutMs = </span><span class="s4">250</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">processLookupController = </span><span class="s3">new </span><span class="s1">AbortController();</span>
    <span class="s3">const </span><span class="s1">pidPromise = </span><span class="s3">new </span><span class="s1">Promise((resolve)=&gt;{</span>
        <span class="s3">const </span><span class="s1">handleError = (error)=&gt;{</span>
            <span class="s1">debug(</span><span class="s2">'Failed to get process ID for port'</span><span class="s1">, port, error);</span>
            <span class="s1">resolve(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">};</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s0">// Use lsof on Unix-like systems (macOS, Linux)</span>
            <span class="s3">if </span><span class="s1">(process.platform !== </span><span class="s2">'win32'</span><span class="s1">) {</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _child_process.exec)(</span><span class="s2">`lsof -ti:</span><span class="s1">${port} </span><span class="s2">-sTCP:LISTEN`</span><span class="s1">, {</span>
                    <span class="s1">signal: processLookupController.signal</span>
                <span class="s1">}, (error, stdout)=&gt;{</span>
                    <span class="s3">if </span><span class="s1">(error) {</span>
                        <span class="s1">handleError(error);</span>
                        <span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">// `-sTCP` will ensure there's only one port, clean up output</span>
                    <span class="s3">const </span><span class="s1">pid = stdout.trim();</span>
                    <span class="s1">resolve(pid || </span><span class="s3">null</span><span class="s1">);</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s0">// Use netstat on Windows</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _child_process.exec)(</span><span class="s2">`netstat -ano | findstr /C:&quot;:</span><span class="s1">${port} </span><span class="s2">&quot; | findstr LISTENING`</span><span class="s1">, {</span>
                    <span class="s1">signal: processLookupController.signal</span>
                <span class="s1">}, (error, stdout)=&gt;{</span>
                    <span class="s3">if </span><span class="s1">(error) {</span>
                        <span class="s1">handleError(error);</span>
                        <span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">// Clean up output and extract PID</span>
                    <span class="s3">const </span><span class="s1">cleanOutput = stdout.replace(</span><span class="s5">/\s+/g</span><span class="s1">, </span><span class="s2">' '</span><span class="s1">).trim();</span>
                    <span class="s3">if </span><span class="s1">(cleanOutput) {</span>
                        <span class="s3">const </span><span class="s1">lines = cleanOutput.split(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">);</span>
                        <span class="s3">const </span><span class="s1">firstLine = lines[</span><span class="s4">0</span><span class="s1">].trim();</span>
                        <span class="s3">if </span><span class="s1">(firstLine) {</span>
                            <span class="s3">const </span><span class="s1">parts = firstLine.split(</span><span class="s2">' '</span><span class="s1">);</span>
                            <span class="s3">const </span><span class="s1">pid = parts[parts.length - </span><span class="s4">1</span><span class="s1">];</span>
                            <span class="s1">resolve(pid || </span><span class="s3">null</span><span class="s1">);</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">resolve(</span><span class="s3">null</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">resolve(</span><span class="s3">null</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(cause) {</span>
            <span class="s1">handleError(Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'Unexpected error during process lookup'</span><span class="s1">, {</span>
                <span class="s1">cause</span>
            <span class="s1">}), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s2">&quot;E713&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s3">true</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">const </span><span class="s1">timeoutId = setTimeout(()=&gt;{</span>
        <span class="s1">processLookupController.abort(</span><span class="s2">`PID detection timed out after </span><span class="s1">${timeoutMs}</span><span class="s2">ms for port </span><span class="s1">${port}</span><span class="s2">.`</span><span class="s1">);</span>
    <span class="s1">}, timeoutMs);</span>
    <span class="s1">pidPromise.finally(()=&gt;clearTimeout(timeoutId));</span>
    <span class="s3">return </span><span class="s1">pidPromise;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s3">function </span><span class="s1">getRequestHandlers({ dir, port, isDev, onDevServerCleanup, server, hostname, minimalMode, keepAliveTimeout, experimentalHttpsServer, quiet }) {</span>
    <span class="s3">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _routerserver.initialize)({</span>
        <span class="s1">dir,</span>
        <span class="s1">port,</span>
        <span class="s1">hostname,</span>
        <span class="s1">onDevServerCleanup,</span>
        <span class="s1">dev: isDev,</span>
        <span class="s1">minimalMode,</span>
        <span class="s1">server,</span>
        <span class="s1">keepAliveTimeout,</span>
        <span class="s1">experimentalHttpsServer,</span>
        <span class="s1">startServerSpan,</span>
        <span class="s1">quiet</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s3">function </span><span class="s1">startServer(serverOptions) {</span>
    <span class="s3">const </span><span class="s1">{ dir, isDev, hostname, minimalMode, allowRetry, keepAliveTimeout, selfSignedCertificate } = serverOptions;</span>
    <span class="s3">let </span><span class="s1">{ port } = serverOptions;</span>
    <span class="s1">process.title = </span><span class="s2">`next-server (v</span><span class="s1">${</span><span class="s2">&quot;15.5.4&quot;</span><span class="s1">}</span><span class="s2">)`</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">handlersReady = ()=&gt;{};</span>
    <span class="s3">let </span><span class="s1">handlersError = ()=&gt;{};</span>
    <span class="s3">let </span><span class="s1">handlersPromise = </span><span class="s3">new </span><span class="s1">Promise((resolve, reject)=&gt;{</span>
        <span class="s1">handlersReady = resolve;</span>
        <span class="s1">handlersError = reject;</span>
    <span class="s1">});</span>
    <span class="s3">let </span><span class="s1">requestHandler = async (req, res)=&gt;{</span>
        <span class="s3">if </span><span class="s1">(handlersPromise) {</span>
            <span class="s3">await </span><span class="s1">handlersPromise;</span>
            <span class="s3">return </span><span class="s1">requestHandler(req, res);</span>
        <span class="s1">}</span>
        <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'Invariant request handler was not setup'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s2">&quot;E287&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s3">true</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
    <span class="s3">let </span><span class="s1">upgradeHandler = async (req, socket, head)=&gt;{</span>
        <span class="s3">if </span><span class="s1">(handlersPromise) {</span>
            <span class="s3">await </span><span class="s1">handlersPromise;</span>
            <span class="s3">return </span><span class="s1">upgradeHandler(req, socket, head);</span>
        <span class="s1">}</span>
        <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'Invariant upgrade handler was not setup'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s2">&quot;E290&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s3">true</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
    <span class="s3">let </span><span class="s1">nextServer;</span>
    <span class="s0">// setup server listener as fast as possible</span>
    <span class="s3">if </span><span class="s1">(selfSignedCertificate &amp;&amp; !isDev) {</span>
        <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'Using a self signed certificate is only supported with `next dev`.'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s2">&quot;E128&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s3">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async </span><span class="s3">function </span><span class="s1">requestListener(req, res) {</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(handlersPromise) {</span>
                <span class="s3">await </span><span class="s1">handlersPromise;</span>
                <span class="s1">handlersPromise = undefined;</span>
            <span class="s1">}</span>
            <span class="s3">await </span><span class="s1">requestHandler(req, res);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
            <span class="s1">res.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
            <span class="s1">res.end(</span><span class="s2">'Internal Server Error'</span><span class="s1">);</span>
            <span class="s1">_log.error(</span><span class="s2">`Failed to handle request for </span><span class="s1">${req.url}</span><span class="s2">`</span><span class="s1">);</span>
            <span class="s1">console.error(err);</span>
        <span class="s1">} </span><span class="s3">finally</span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(isDev) {</span>
                <span class="s3">if </span><span class="s1">(_v8.default.getHeapStatistics().used_heap_size &gt; </span><span class="s4">0.8 </span><span class="s1">* _v8.default.getHeapStatistics().heap_size_limit) {</span>
                    <span class="s1">_log.warn(</span><span class="s2">`Server is approaching the used memory threshold, restarting...`</span><span class="s1">);</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trace.trace)(</span><span class="s2">'server-restart-close-to-memory-threshold'</span><span class="s1">, undefined, {</span>
                        <span class="s2">'memory.heapSizeLimit'</span><span class="s1">: String(_v8.default.getHeapStatistics().heap_size_limit),</span>
                        <span class="s2">'memory.heapUsed'</span><span class="s1">: String(_v8.default.getHeapStatistics().used_heap_size)</span>
                    <span class="s1">}).stop();</span>
                    <span class="s3">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _trace.flushAllTraces)();</span>
                    <span class="s1">process.exit(_utils.RESTART_EXIT_CODE);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">server = selfSignedCertificate ? _https.default.createServer({</span>
        <span class="s1">key: _fs.default.readFileSync(selfSignedCertificate.key),</span>
        <span class="s1">cert: _fs.default.readFileSync(selfSignedCertificate.cert)</span>
    <span class="s1">}, requestListener) : _http.default.createServer(requestListener);</span>
    <span class="s3">if </span><span class="s1">(keepAliveTimeout) {</span>
        <span class="s1">server.keepAliveTimeout = keepAliveTimeout;</span>
    <span class="s1">}</span>
    <span class="s1">server.on(</span><span class="s2">'upgrade'</span><span class="s1">, async (req, socket, head)=&gt;{</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">await </span><span class="s1">upgradeHandler(req, socket, head);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
            <span class="s1">socket.destroy();</span>
            <span class="s1">_log.error(</span><span class="s2">`Failed to handle request for </span><span class="s1">${req.url}</span><span class="s2">`</span><span class="s1">);</span>
            <span class="s1">console.error(err);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">let </span><span class="s1">portRetryCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">originalPort = port;</span>
    <span class="s1">server.on(</span><span class="s2">'error'</span><span class="s1">, (err)=&gt;{</span>
        <span class="s3">if </span><span class="s1">(allowRetry &amp;&amp; port &amp;&amp; isDev &amp;&amp; err.code === </span><span class="s2">'EADDRINUSE' </span><span class="s1">&amp;&amp; portRetryCount &lt; </span><span class="s4">10</span><span class="s1">) {</span>
            <span class="s1">port += </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">portRetryCount += </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">server.listen(port, hostname);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">_log.error(</span><span class="s2">`Failed to start server`</span><span class="s1">);</span>
            <span class="s1">console.error(err);</span>
            <span class="s1">process.exit(</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">let </span><span class="s1">cleanupListeners = isDev ? </span><span class="s3">new </span><span class="s1">_asynccallbackset.AsyncCallbackSet() : undefined;</span>
    <span class="s3">await new </span><span class="s1">Promise((resolve)=&gt;{</span>
        <span class="s1">server.on(</span><span class="s2">'listening'</span><span class="s1">, async ()=&gt;{</span>
            <span class="s3">const </span><span class="s1">nodeDebugType = (</span><span class="s4">0</span><span class="s1">, _utils.getNodeDebugType)();</span>
            <span class="s3">const </span><span class="s1">addr = server.address();</span>
            <span class="s3">const </span><span class="s1">actualHostname = (</span><span class="s4">0</span><span class="s1">, _formathostname.formatHostname)(</span><span class="s3">typeof </span><span class="s1">addr === </span><span class="s2">'object' </span><span class="s1">? (addr == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: addr.address) || hostname || </span><span class="s2">'localhost' </span><span class="s1">: addr);</span>
            <span class="s3">const </span><span class="s1">formattedHostname = !hostname || actualHostname === </span><span class="s2">'0.0.0.0' </span><span class="s1">? </span><span class="s2">'localhost' </span><span class="s1">: actualHostname === </span><span class="s2">'[::]' </span><span class="s1">? </span><span class="s2">'[::1]' </span><span class="s1">: (</span><span class="s4">0</span><span class="s1">, _formathostname.formatHostname)(hostname);</span>
            <span class="s1">port = </span><span class="s3">typeof </span><span class="s1">addr === </span><span class="s2">'object' </span><span class="s1">? (addr == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: addr.port) || port : port;</span>
            <span class="s3">if </span><span class="s1">(portRetryCount) {</span>
                <span class="s3">const </span><span class="s1">pid = </span><span class="s3">await </span><span class="s1">getProcessIdUsingPort(originalPort);</span>
                <span class="s3">if </span><span class="s1">(pid) {</span>
                    <span class="s1">_log.warn(</span><span class="s2">`Port </span><span class="s1">${originalPort} </span><span class="s2">is in use by process </span><span class="s1">${pid}</span><span class="s2">, using available port </span><span class="s1">${port} </span><span class="s2">instead.`</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">_log.warn(</span><span class="s2">`Port </span><span class="s1">${originalPort} </span><span class="s2">is in use by an unknown process, using available port </span><span class="s1">${port} </span><span class="s2">instead.`</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">networkHostname = hostname ?? (</span><span class="s4">0</span><span class="s1">, _getnetworkhost.getNetworkHost)((</span><span class="s4">0</span><span class="s1">, _isipv6.isIPv6)(actualHostname) ? </span><span class="s2">'IPv6' </span><span class="s1">: </span><span class="s2">'IPv4'</span><span class="s1">);</span>
            <span class="s3">const </span><span class="s1">protocol = selfSignedCertificate ? </span><span class="s2">'https' </span><span class="s1">: </span><span class="s2">'http'</span><span class="s1">;</span>
            <span class="s3">const </span><span class="s1">networkUrl = networkHostname ? </span><span class="s2">`</span><span class="s1">${protocol}</span><span class="s2">://</span><span class="s1">${(</span><span class="s4">0</span><span class="s1">, _formathostname.formatHostname)(networkHostname)}</span><span class="s2">:</span><span class="s1">${port}</span><span class="s2">` </span><span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">const </span><span class="s1">appUrl = </span><span class="s2">`</span><span class="s1">${protocol}</span><span class="s2">://</span><span class="s1">${formattedHostname}</span><span class="s2">:</span><span class="s1">${port}</span><span class="s2">`</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(nodeDebugType) {</span>
                <span class="s3">const </span><span class="s1">formattedDebugAddress = (</span><span class="s4">0</span><span class="s1">, _utils.getFormattedDebugAddress)();</span>
                <span class="s1">_log.info(</span><span class="s2">`the --</span><span class="s1">${nodeDebugType} </span><span class="s2">option was detected, the Next.js router server should be inspected at </span><span class="s1">${formattedDebugAddress}</span><span class="s2">.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">// Store the selected port to:</span>
            <span class="s0">// - expose it to render workers</span>
            <span class="s0">// - re-use it for automatic dev server restarts with a randomly selected port</span>
            <span class="s1">process.env.PORT = port + </span><span class="s2">''</span><span class="s1">;</span>
            <span class="s1">process.env.__NEXT_PRIVATE_ORIGIN = appUrl;</span>
            <span class="s0">// Set experimental HTTPS flag for metadata resolution</span>
            <span class="s3">if </span><span class="s1">(selfSignedCertificate) {</span>
                <span class="s1">process.env.__NEXT_EXPERIMENTAL_HTTPS = </span><span class="s2">'1'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// Only load env and config in dev to for logging purposes</span>
            <span class="s3">let </span><span class="s1">envInfo;</span>
            <span class="s3">let </span><span class="s1">experimentalFeatures;</span>
            <span class="s3">if </span><span class="s1">(isDev) {</span>
                <span class="s3">const </span><span class="s1">startServerInfo = </span><span class="s3">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _appinfolog.getStartServerInfo)({</span>
                    <span class="s1">dir,</span>
                    <span class="s1">dev: isDev</span>
                <span class="s1">});</span>
                <span class="s1">envInfo = startServerInfo.envInfo;</span>
                <span class="s1">experimentalFeatures = startServerInfo.experimentalFeatures;</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _appinfolog.logStartInfo)({</span>
                <span class="s1">networkUrl,</span>
                <span class="s1">appUrl,</span>
                <span class="s1">envInfo,</span>
                <span class="s1">experimentalFeatures,</span>
                <span class="s1">maxExperimentalFeatures: </span><span class="s4">3</span>
            <span class="s1">});</span>
            <span class="s1">_log.event(</span><span class="s2">`Starting...`</span><span class="s1">);</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">let </span><span class="s1">cleanupStarted = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">let </span><span class="s1">closeUpgraded = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s3">const </span><span class="s1">cleanup = ()=&gt;{</span>
                    <span class="s3">if </span><span class="s1">(cleanupStarted) {</span>
                        <span class="s0">// We can get duplicate signals, e.g. when `ctrl+c` is used in an</span>
                        <span class="s0">// interactive shell (i.e. bash, zsh), the shell will recursively</span>
                        <span class="s0">// send SIGINT to children. The parent `next-dev` process will also</span>
                        <span class="s0">// send us SIGINT.</span>
                        <span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">cleanupStarted = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">(async ()=&gt;{</span>
                        <span class="s1">debug(</span><span class="s2">'start-server process cleanup'</span><span class="s1">);</span>
                        <span class="s0">// first, stop accepting new connections and finish pending requests,</span>
                        <span class="s0">// because they might affect `nextServer.close()` (e.g. by scheduling an `after`)</span>
                        <span class="s3">await new </span><span class="s1">Promise((res)=&gt;{</span>
                            <span class="s1">server.close((err)=&gt;{</span>
                                <span class="s3">if </span><span class="s1">(err) console.error(err);</span>
                                <span class="s1">res();</span>
                            <span class="s1">});</span>
                            <span class="s3">if </span><span class="s1">(isDev) {</span>
                                <span class="s1">server.closeAllConnections();</span>
                                <span class="s1">closeUpgraded == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: closeUpgraded();</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                        <span class="s0">// now that no new requests can come in, clean up the rest</span>
                        <span class="s3">await </span><span class="s1">Promise.all([</span>
                            <span class="s1">nextServer == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: nextServer.close().catch(console.error),</span>
                            <span class="s1">cleanupListeners == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: cleanupListeners.runAll().catch(console.error)</span>
                        <span class="s1">]);</span>
                        <span class="s1">debug(</span><span class="s2">'start-server process cleanup finished'</span><span class="s1">);</span>
                        <span class="s1">process.exit(</span><span class="s4">0</span><span class="s1">);</span>
                    <span class="s1">})();</span>
                <span class="s1">};</span>
                <span class="s0">// Make sure commands gracefully respect termination signals (e.g. from Docker)</span>
                <span class="s0">// Allow the graceful termination to be manually configurable</span>
                <span class="s3">if </span><span class="s1">(!process.env.NEXT_MANUAL_SIG_HANDLE) {</span>
                    <span class="s1">process.on(</span><span class="s2">'SIGINT'</span><span class="s1">, cleanup);</span>
                    <span class="s1">process.on(</span><span class="s2">'SIGTERM'</span><span class="s1">, cleanup);</span>
                <span class="s1">}</span>
                <span class="s3">const </span><span class="s1">initResult = </span><span class="s3">await </span><span class="s1">getRequestHandlers({</span>
                    <span class="s1">dir,</span>
                    <span class="s1">port,</span>
                    <span class="s1">isDev,</span>
                    <span class="s1">onDevServerCleanup: cleanupListeners ? cleanupListeners.add.bind(cleanupListeners) : undefined,</span>
                    <span class="s1">server,</span>
                    <span class="s1">hostname,</span>
                    <span class="s1">minimalMode,</span>
                    <span class="s1">keepAliveTimeout,</span>
                    <span class="s1">experimentalHttpsServer: !!selfSignedCertificate</span>
                <span class="s1">});</span>
                <span class="s1">requestHandler = initResult.requestHandler;</span>
                <span class="s1">upgradeHandler = initResult.upgradeHandler;</span>
                <span class="s1">nextServer = initResult.server;</span>
                <span class="s1">closeUpgraded = initResult.closeUpgraded;</span>
                <span class="s3">const </span><span class="s1">startServerProcessDuration = performance.mark(</span><span class="s2">'next-start-end'</span><span class="s1">) &amp;&amp; performance.measure(</span><span class="s2">'next-start-duration'</span><span class="s1">, </span><span class="s2">'next-start'</span><span class="s1">, </span><span class="s2">'next-start-end'</span><span class="s1">).duration;</span>
                <span class="s1">handlersReady();</span>
                <span class="s3">const </span><span class="s1">formatDurationText = startServerProcessDuration &gt; </span><span class="s4">2000 </span><span class="s1">? </span><span class="s2">`</span><span class="s1">${Math.round(startServerProcessDuration / </span><span class="s4">100</span><span class="s1">) / </span><span class="s4">10</span><span class="s1">}</span><span class="s2">s` </span><span class="s1">: </span><span class="s2">`</span><span class="s1">${Math.round(startServerProcessDuration)}</span><span class="s2">ms`</span><span class="s1">;</span>
                <span class="s1">_log.event(</span><span class="s2">`Ready in </span><span class="s1">${formatDurationText}</span><span class="s2">`</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(process.env.TURBOPACK) {</span>
                    <span class="s3">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _turbopackwarning.validateTurboNextConfig)({</span>
                        <span class="s1">dir: serverOptions.dir,</span>
                        <span class="s1">isDev: </span><span class="s3">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                <span class="s0">// fatal error if we can't setup</span>
                <span class="s1">handlersError();</span>
                <span class="s1">console.error(err);</span>
                <span class="s1">process.exit(</span><span class="s4">1</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">resolve();</span>
        <span class="s1">});</span>
        <span class="s1">server.listen(port, hostname);</span>
    <span class="s1">});</span>
    <span class="s3">if </span><span class="s1">(isDev) {</span>
        <span class="s3">function </span><span class="s1">watchConfigFiles(dirToWatch, onChange) {</span>
            <span class="s3">const </span><span class="s1">wp = </span><span class="s3">new </span><span class="s1">_watchpack.default();</span>
            <span class="s1">wp.watch({</span>
                <span class="s1">files: _constants.CONFIG_FILES.map((file)=&gt;_path.default.join(dirToWatch, file))</span>
            <span class="s1">});</span>
            <span class="s1">wp.on(</span><span class="s2">'change'</span><span class="s1">, onChange);</span>
        <span class="s1">}</span>
        <span class="s1">watchConfigFiles(dir, async (filename)=&gt;{</span>
            <span class="s3">if </span><span class="s1">(process.env.__NEXT_DISABLE_MEMORY_WATCHER) {</span>
                <span class="s1">_log.info(</span><span class="s2">`Detected change, manual restart required due to '__NEXT_DISABLE_MEMORY_WATCHER' usage`</span><span class="s1">);</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">_log.warn(</span><span class="s2">`Found a change in </span><span class="s1">${_path.default.basename(filename)}</span><span class="s2">. Restarting the server to apply the changes...`</span><span class="s1">);</span>
            <span class="s1">process.exit(_utils.RESTART_EXIT_CODE);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(process.env.NEXT_PRIVATE_WORKER &amp;&amp; process.send) {</span>
    <span class="s1">process.addListener(</span><span class="s2">'message'</span><span class="s1">, async (msg)=&gt;{</span>
        <span class="s3">if </span><span class="s1">(msg &amp;&amp; </span><span class="s3">typeof </span><span class="s1">msg === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; msg.nextWorkerOptions &amp;&amp; process.send) {</span>
            <span class="s1">startServerSpan = (</span><span class="s4">0</span><span class="s1">, _trace.trace)(</span><span class="s2">'start-dev-server'</span><span class="s1">, undefined, {</span>
                <span class="s1">cpus: String(_os.default.cpus().length),</span>
                <span class="s1">platform: _os.default.platform(),</span>
                <span class="s2">'memory.freeMem'</span><span class="s1">: String(_os.default.freemem()),</span>
                <span class="s2">'memory.totalMem'</span><span class="s1">: String(_os.default.totalmem()),</span>
                <span class="s2">'memory.heapSizeLimit'</span><span class="s1">: String(_v8.default.getHeapStatistics().heap_size_limit)</span>
            <span class="s1">});</span>
            <span class="s3">await </span><span class="s1">startServerSpan.traceAsyncFn(()=&gt;startServer(msg.nextWorkerOptions));</span>
            <span class="s3">const </span><span class="s1">memoryUsage = process.memoryUsage();</span>
            <span class="s1">startServerSpan.setAttribute(</span><span class="s2">'memory.rss'</span><span class="s1">, String(memoryUsage.rss));</span>
            <span class="s1">startServerSpan.setAttribute(</span><span class="s2">'memory.heapTotal'</span><span class="s1">, String(memoryUsage.heapTotal));</span>
            <span class="s1">startServerSpan.setAttribute(</span><span class="s2">'memory.heapUsed'</span><span class="s1">, String(memoryUsage.heapUsed));</span>
            <span class="s1">process.send({</span>
                <span class="s1">nextServerReady: </span><span class="s3">true</span><span class="s1">,</span>
                <span class="s1">port: process.env.PORT</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">process.send({</span>
        <span class="s1">nextWorkerReady: </span><span class="s3">true</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=start-server.js.map</span></pre>
</body>
</html>