<html>
<head>
<title>dispatcher.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dispatcher.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ URL } from </span><span class="s2">'url'</span>
<span class="s0">import </span><span class="s1">{ Duplex, Readable, Writable } from </span><span class="s2">'stream'</span>
<span class="s0">import </span><span class="s1">{ EventEmitter } from </span><span class="s2">'events'</span>
<span class="s0">import </span><span class="s1">{ Blob } from </span><span class="s2">'buffer'</span>
<span class="s0">import </span><span class="s1">{ IncomingHttpHeaders } from </span><span class="s2">'./header'</span>
<span class="s0">import </span><span class="s1">BodyReadable from </span><span class="s2">'./readable'</span>
<span class="s0">import </span><span class="s1">{ FormData } from </span><span class="s2">'./formdata'</span>
<span class="s0">import </span><span class="s1">Errors from </span><span class="s2">'./errors'</span>

<span class="s1">type AbortSignal = unknown;</span>

<span class="s0">export default </span><span class="s1">Dispatcher</span>

<span class="s3">/** Dispatcher is the core API used to dispatch requests. */</span>
<span class="s1">declare </span><span class="s0">class </span><span class="s1">Dispatcher </span><span class="s0">extends </span><span class="s1">EventEmitter {</span>
  <span class="s3">/** Dispatches a request. This API is expected to evolve through semver-major versions and is less stable than the preceding higher level APIs. It is primarily intended for library developers who implement higher level APIs on top of this. */</span>
  <span class="s1">dispatch(options: Dispatcher.DispatchOptions, handler: Dispatcher.DispatchHandlers): boolean;</span>
  <span class="s3">/** Starts two-way communications with the requested resource. */</span>
  <span class="s1">connect(options: Dispatcher.ConnectOptions): Promise&lt;Dispatcher.ConnectData&gt;;</span>
  <span class="s1">connect(options: Dispatcher.ConnectOptions, callback: (err: Error | </span><span class="s0">null</span><span class="s1">, data: Dispatcher.ConnectData) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
  <span class="s3">/** Compose a chain of dispatchers */</span>
  <span class="s1">compose(dispatchers: Dispatcher.DispatcherComposeInterceptor[]): Dispatcher.ComposedDispatcher;</span>
  <span class="s1">compose(...dispatchers: Dispatcher.DispatcherComposeInterceptor[]): Dispatcher.ComposedDispatcher;</span>
  <span class="s3">/** Performs an HTTP request. */</span>
  <span class="s1">request(options: Dispatcher.RequestOptions): Promise&lt;Dispatcher.ResponseData&gt;;</span>
  <span class="s1">request(options: Dispatcher.RequestOptions, callback: (err: Error | </span><span class="s0">null</span><span class="s1">, data: Dispatcher.ResponseData) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
  <span class="s3">/** For easy use with `stream.pipeline`. */</span>
  <span class="s1">pipeline(options: Dispatcher.PipelineOptions, handler: Dispatcher.PipelineHandler): Duplex;</span>
  <span class="s3">/** A faster version of `Dispatcher.request`. */</span>
  <span class="s1">stream(options: Dispatcher.RequestOptions, factory: Dispatcher.StreamFactory): Promise&lt;Dispatcher.StreamData&gt;;</span>
  <span class="s1">stream(options: Dispatcher.RequestOptions, factory: Dispatcher.StreamFactory, callback: (err: Error | </span><span class="s0">null</span><span class="s1">, data: Dispatcher.StreamData) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
  <span class="s3">/** Upgrade to a different protocol. */</span>
  <span class="s1">upgrade(options: Dispatcher.UpgradeOptions): Promise&lt;Dispatcher.UpgradeData&gt;;</span>
  <span class="s1">upgrade(options: Dispatcher.UpgradeOptions, callback: (err: Error | </span><span class="s0">null</span><span class="s1">, data: Dispatcher.UpgradeData) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
  <span class="s3">/** Closes the client and gracefully waits for enqueued requests to complete before invoking the callback (or returning a promise if no callback is provided). */</span>
  <span class="s1">close(): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
  <span class="s1">close(callback: () =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
  <span class="s3">/** Destroy the client abruptly with the given err. All the pending and running requests will be asynchronously aborted and error. Waits until socket is closed before invoking the callback (or returning a promise if no callback is provided). Since this operation is asynchronously dispatched there might still be some progress on dispatched requests. */</span>
  <span class="s1">destroy(): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
  <span class="s1">destroy(err: Error | </span><span class="s0">null</span><span class="s1">): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;;</span>
  <span class="s1">destroy(callback: () =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
  <span class="s1">destroy(err: Error | </span><span class="s0">null</span><span class="s1">, callback: () =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>

  <span class="s1">on(eventName: </span><span class="s2">'connect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">on(eventName: </span><span class="s2">'disconnect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">on(eventName: </span><span class="s2">'connectionError'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">on(eventName: </span><span class="s2">'drain'</span><span class="s1">, callback: (origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>


  <span class="s1">once(eventName: </span><span class="s2">'connect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">once(eventName: </span><span class="s2">'disconnect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">once(eventName: </span><span class="s2">'connectionError'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">once(eventName: </span><span class="s2">'drain'</span><span class="s1">, callback: (origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>


  <span class="s1">off(eventName: </span><span class="s2">'connect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">off(eventName: </span><span class="s2">'disconnect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">off(eventName: </span><span class="s2">'connectionError'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">off(eventName: </span><span class="s2">'drain'</span><span class="s1">, callback: (origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>


  <span class="s1">addListener(eventName: </span><span class="s2">'connect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">addListener(eventName: </span><span class="s2">'disconnect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">addListener(eventName: </span><span class="s2">'connectionError'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">addListener(eventName: </span><span class="s2">'drain'</span><span class="s1">, callback: (origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>

  <span class="s1">removeListener(eventName: </span><span class="s2">'connect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">removeListener(eventName: </span><span class="s2">'disconnect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">removeListener(eventName: </span><span class="s2">'connectionError'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">removeListener(eventName: </span><span class="s2">'drain'</span><span class="s1">, callback: (origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>

  <span class="s1">prependListener(eventName: </span><span class="s2">'connect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">prependListener(eventName: </span><span class="s2">'disconnect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">prependListener(eventName: </span><span class="s2">'connectionError'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">prependListener(eventName: </span><span class="s2">'drain'</span><span class="s1">, callback: (origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>

  <span class="s1">prependOnceListener(eventName: </span><span class="s2">'connect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">prependOnceListener(eventName: </span><span class="s2">'disconnect'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">prependOnceListener(eventName: </span><span class="s2">'connectionError'</span><span class="s1">, callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
  <span class="s1">prependOnceListener(eventName: </span><span class="s2">'drain'</span><span class="s1">, callback: (origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>

  <span class="s1">listeners(eventName: </span><span class="s2">'connect'</span><span class="s1">): ((origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">)[]</span>
  <span class="s1">listeners(eventName: </span><span class="s2">'disconnect'</span><span class="s1">): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">)[];</span>
  <span class="s1">listeners(eventName: </span><span class="s2">'connectionError'</span><span class="s1">): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">)[];</span>
  <span class="s1">listeners(eventName: </span><span class="s2">'drain'</span><span class="s1">): ((origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">)[];</span>

  <span class="s1">rawListeners(eventName: </span><span class="s2">'connect'</span><span class="s1">): ((origin: URL, targets: readonly Dispatcher[]) =&gt; </span><span class="s0">void</span><span class="s1">)[]</span>
  <span class="s1">rawListeners(eventName: </span><span class="s2">'disconnect'</span><span class="s1">): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">)[];</span>
  <span class="s1">rawListeners(eventName: </span><span class="s2">'connectionError'</span><span class="s1">): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) =&gt; </span><span class="s0">void</span><span class="s1">)[];</span>
  <span class="s1">rawListeners(eventName: </span><span class="s2">'drain'</span><span class="s1">): ((origin: URL) =&gt; </span><span class="s0">void</span><span class="s1">)[];</span>

  <span class="s1">emit(eventName: </span><span class="s2">'connect'</span><span class="s1">, origin: URL, targets: readonly Dispatcher[]): boolean;</span>
  <span class="s1">emit(eventName: </span><span class="s2">'disconnect'</span><span class="s1">, origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError): boolean;</span>
  <span class="s1">emit(eventName: </span><span class="s2">'connectionError'</span><span class="s1">, origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError): boolean;</span>
  <span class="s1">emit(eventName: </span><span class="s2">'drain'</span><span class="s1">, origin: URL): boolean;</span>
<span class="s1">}</span>

<span class="s1">declare namespace Dispatcher {</span>
  <span class="s0">export interface </span><span class="s1">ComposedDispatcher </span><span class="s0">extends </span><span class="s1">Dispatcher {}</span>
  <span class="s0">export </span><span class="s1">type DispatcherComposeInterceptor = (dispatch: Dispatcher[</span><span class="s2">'dispatch'</span><span class="s1">]) =&gt; Dispatcher[</span><span class="s2">'dispatch'</span><span class="s1">];</span>
  <span class="s0">export interface </span><span class="s1">DispatchOptions {</span>
    <span class="s1">origin?: string | URL;</span>
    <span class="s1">path: string;</span>
    <span class="s1">method: HttpMethod;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">body?: string | Buffer | Uint8Array | Readable | </span><span class="s0">null </span><span class="s1">| FormData;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">headers?: IncomingHttpHeaders | string[] | Iterable&lt;[string, string | string[] | undefined]&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** Query string params to be embedded in the request URL. Default: `null` */</span>
    <span class="s1">query?: Record&lt;string, any&gt;;</span>
    <span class="s3">/** Whether the requests can be safely retried or not. If `false` the request won't be sent until all preceding requests in the pipeline have completed. Default: `true` if `method` is `HEAD` or `GET`. */</span>
    <span class="s1">idempotent?: boolean;</span>
    <span class="s3">/** Whether the response is expected to take a long time and would end up blocking the pipeline. When this is set to `true` further pipelining will be avoided on the same connection until headers have been received. */</span>
    <span class="s1">blocking?: boolean;</span>
    <span class="s3">/** Upgrade the request. Should be used to specify the kind of upgrade i.e. `'Websocket'`. Default: `method === 'CONNECT' || null`. */</span>
    <span class="s1">upgrade?: boolean | string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** The amount of time, in milliseconds, the parser will wait to receive the complete HTTP headers. Defaults to 300 seconds. */</span>
    <span class="s1">headersTimeout?: number | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** The timeout after which a request will time out, in milliseconds. Monitors time between receiving body data. Use 0 to disable it entirely. Defaults to 300 seconds. */</span>
    <span class="s1">bodyTimeout?: number | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** Whether the request should stablish a keep-alive or not. Default `false` */</span>
    <span class="s1">reset?: boolean;</span>
    <span class="s3">/** Whether Undici should throw an error upon receiving a 4xx or 5xx response from the server. Defaults to false */</span>
    <span class="s1">throwOnError?: boolean;</span>
    <span class="s3">/** For H2, it appends the expect: 100-continue header, and halts the request body until a 100-continue is received from the remote server*/</span>
    <span class="s1">expectContinue?: boolean;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">ConnectOptions {</span>
    <span class="s1">origin: string | URL;</span>
    <span class="s1">path: string;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">headers?: IncomingHttpHeaders | string[] | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">signal?: AbortSignal | EventEmitter | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** This argument parameter is passed through to `ConnectData` */</span>
    <span class="s1">opaque?: unknown;</span>
    <span class="s3">/** Default: 0 */</span>
    <span class="s1">maxRedirections?: number;</span>
    <span class="s3">/** Default: false */</span>
    <span class="s1">redirectionLimitReached?: boolean;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">responseHeader?: </span><span class="s2">'raw' </span><span class="s1">| </span><span class="s0">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">RequestOptions </span><span class="s0">extends </span><span class="s1">DispatchOptions {</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">opaque?: unknown;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">signal?: AbortSignal | EventEmitter | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** Default: 0 */</span>
    <span class="s1">maxRedirections?: number;</span>
    <span class="s3">/** Default: false */</span>
    <span class="s1">redirectionLimitReached?: boolean;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">onInfo?: (info: { statusCode: number, headers: Record&lt;string, string | string[]&gt; }) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">responseHeader?: </span><span class="s2">'raw' </span><span class="s1">| </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** Default: `64 KiB` */</span>
    <span class="s1">highWaterMark?: number;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">PipelineOptions </span><span class="s0">extends </span><span class="s1">RequestOptions {</span>
    <span class="s3">/** `true` if the `handler` will return an object stream. Default: `false` */</span>
    <span class="s1">objectMode?: boolean;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">UpgradeOptions {</span>
    <span class="s1">path: string;</span>
    <span class="s3">/** Default: `'GET'` */</span>
    <span class="s1">method?: string;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">headers?: IncomingHttpHeaders | string[] | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** A string of comma separated protocols, in descending preference order. Default: `'Websocket'` */</span>
    <span class="s1">protocol?: string;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">signal?: AbortSignal | EventEmitter | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/** Default: 0 */</span>
    <span class="s1">maxRedirections?: number;</span>
    <span class="s3">/** Default: false */</span>
    <span class="s1">redirectionLimitReached?: boolean;</span>
    <span class="s3">/** Default: `null` */</span>
    <span class="s1">responseHeader?: </span><span class="s2">'raw' </span><span class="s1">| </span><span class="s0">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">ConnectData {</span>
    <span class="s1">statusCode: number;</span>
    <span class="s1">headers: IncomingHttpHeaders;</span>
    <span class="s1">socket: Duplex;</span>
    <span class="s1">opaque: unknown;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">ResponseData {</span>
    <span class="s1">statusCode: number;</span>
    <span class="s1">headers: IncomingHttpHeaders;</span>
    <span class="s1">body: BodyReadable &amp; BodyMixin;</span>
    <span class="s1">trailers: Record&lt;string, string&gt;;</span>
    <span class="s1">opaque: unknown;</span>
    <span class="s1">context: object;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">PipelineHandlerData {</span>
    <span class="s1">statusCode: number;</span>
    <span class="s1">headers: IncomingHttpHeaders;</span>
    <span class="s1">opaque: unknown;</span>
    <span class="s1">body: BodyReadable;</span>
    <span class="s1">context: object;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">StreamData {</span>
    <span class="s1">opaque: unknown;</span>
    <span class="s1">trailers: Record&lt;string, string&gt;;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">UpgradeData {</span>
    <span class="s1">headers: IncomingHttpHeaders;</span>
    <span class="s1">socket: Duplex;</span>
    <span class="s1">opaque: unknown;</span>
  <span class="s1">}</span>
  <span class="s0">export interface </span><span class="s1">StreamFactoryData {</span>
    <span class="s1">statusCode: number;</span>
    <span class="s1">headers: IncomingHttpHeaders;</span>
    <span class="s1">opaque: unknown;</span>
    <span class="s1">context: object;</span>
  <span class="s1">}</span>
  <span class="s0">export </span><span class="s1">type StreamFactory = (data: StreamFactoryData) =&gt; Writable;</span>
  <span class="s0">export interface </span><span class="s1">DispatchHandlers {</span>
    <span class="s3">/** Invoked before request is dispatched on socket. May be invoked multiple times when a request is retried when the request at the head of the pipeline fails. */</span>
    <span class="s1">onConnect?(abort: (err?: Error) =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/** Invoked when an error has occurred. */</span>
    <span class="s1">onError?(err: Error): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/** Invoked when request is upgraded either due to a `Upgrade` header or `CONNECT` method. */</span>
    <span class="s1">onUpgrade?(statusCode: number, headers: Buffer[] | string[] | </span><span class="s0">null</span><span class="s1">, socket: Duplex): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/** Invoked when response is received, before headers have been read. **/</span>
    <span class="s1">onResponseStarted?(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/** Invoked when statusCode and headers have been received. May be invoked multiple times due to 1xx informational headers. */</span>
    <span class="s1">onHeaders?(statusCode: number, headers: Buffer[], resume: () =&gt; </span><span class="s0">void</span><span class="s1">, statusText: string): boolean;</span>
    <span class="s3">/** Invoked when response payload data is received. */</span>
    <span class="s1">onData?(chunk: Buffer): boolean;</span>
    <span class="s3">/** Invoked when response payload and trailers have been received and the request has completed. */</span>
    <span class="s1">onComplete?(trailers: string[] | </span><span class="s0">null</span><span class="s1">): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/** Invoked when a body chunk is sent to the server. May be invoked multiple times for chunked requests */</span>
    <span class="s1">onBodySent?(chunkSize: number, totalBytesSent: number): </span><span class="s0">void</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">export </span><span class="s1">type PipelineHandler = (data: PipelineHandlerData) =&gt; Readable;</span>
  <span class="s0">export </span><span class="s1">type HttpMethod = </span><span class="s2">'GET' </span><span class="s1">| </span><span class="s2">'HEAD' </span><span class="s1">| </span><span class="s2">'POST' </span><span class="s1">| </span><span class="s2">'PUT' </span><span class="s1">| </span><span class="s2">'DELETE' </span><span class="s1">| </span><span class="s2">'CONNECT' </span><span class="s1">| </span><span class="s2">'OPTIONS' </span><span class="s1">| </span><span class="s2">'TRACE' </span><span class="s1">| </span><span class="s2">'PATCH'</span><span class="s1">;</span>

  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@link </span><span class="s3">https://fetch.spec.whatwg.org/#body-mixin</span>
   <span class="s3">*/</span>
  <span class="s0">interface </span><span class="s1">BodyMixin {</span>
    <span class="s1">readonly body?: never;</span>
    <span class="s1">readonly bodyUsed: boolean;</span>
    <span class="s1">arrayBuffer(): Promise&lt;ArrayBuffer&gt;;</span>
    <span class="s1">blob(): Promise&lt;Blob&gt;;</span>
    <span class="s1">bytes(): Promise&lt;Uint8Array&gt;;</span>
    <span class="s1">formData(): Promise&lt;never&gt;;</span>
    <span class="s1">json(): Promise&lt;unknown&gt;;</span>
    <span class="s1">text(): Promise&lt;string&gt;;</span>
  <span class="s1">}</span>

  <span class="s0">export interface </span><span class="s1">DispatchInterceptor {</span>
    <span class="s1">(dispatch: Dispatcher[</span><span class="s2">'dispatch'</span><span class="s1">]): Dispatcher[</span><span class="s2">'dispatch'</span><span class="s1">]</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>