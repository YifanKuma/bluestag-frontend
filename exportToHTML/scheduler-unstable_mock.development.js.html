<html>
<head>
<title>scheduler-unstable_mock.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scheduler-unstable_mock.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@license </span><span class="s0">React</span>
 <span class="s0">* scheduler-unstable_mock.development.js</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>
<span class="s3">&quot;production&quot; </span><span class="s2">!== process.env.NODE_ENV &amp;&amp;</span>
  <span class="s2">(</span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">function </span><span class="s2">push(heap, node) {</span>
      <span class="s4">var </span><span class="s2">index = heap.length;</span>
      <span class="s2">heap.push(node);</span>
      <span class="s2">a: </span><span class="s4">for </span><span class="s2">(; </span><span class="s5">0 </span><span class="s2">&lt; index; ) {</span>
        <span class="s4">var </span><span class="s2">parentIndex = (index - </span><span class="s5">1</span><span class="s2">) &gt;&gt;&gt; </span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">parent = heap[parentIndex];</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt; compare(parent, node))</span>
          <span class="s2">(heap[parentIndex] = node),</span>
            <span class="s2">(heap[index] = parent),</span>
            <span class="s2">(index = parentIndex);</span>
        <span class="s4">else break </span><span class="s2">a;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">peek(heap) {</span>
      <span class="s4">return </span><span class="s5">0 </span><span class="s2">=== heap.length ? </span><span class="s4">null </span><span class="s2">: heap[</span><span class="s5">0</span><span class="s2">];</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">pop(heap) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== heap.length) </span><span class="s4">return null</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">first = heap[</span><span class="s5">0</span><span class="s2">],</span>
        <span class="s2">last = heap.pop();</span>
      <span class="s4">if </span><span class="s2">(last !== first) {</span>
        <span class="s2">heap[</span><span class="s5">0</span><span class="s2">] = last;</span>
        <span class="s2">a: </span><span class="s4">for </span><span class="s2">(</span>
          <span class="s4">var </span><span class="s2">index = </span><span class="s5">0</span><span class="s2">, length = heap.length, halfLength = length &gt;&gt;&gt; </span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">index &lt; halfLength;</span>

        <span class="s2">) {</span>
          <span class="s4">var </span><span class="s2">leftIndex = </span><span class="s5">2 </span><span class="s2">* (index + </span><span class="s5">1</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">,</span>
            <span class="s2">left = heap[leftIndex],</span>
            <span class="s2">rightIndex = leftIndex + </span><span class="s5">1</span><span class="s2">,</span>
            <span class="s2">right = heap[rightIndex];</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&gt; compare(left, last))</span>
            <span class="s2">rightIndex &lt; length &amp;&amp; </span><span class="s5">0 </span><span class="s2">&gt; compare(right, left)</span>
              <span class="s2">? ((heap[index] = right),</span>
                <span class="s2">(heap[rightIndex] = last),</span>
                <span class="s2">(index = rightIndex))</span>
              <span class="s2">: ((heap[index] = left),</span>
                <span class="s2">(heap[leftIndex] = last),</span>
                <span class="s2">(index = leftIndex));</span>
          <span class="s4">else if </span><span class="s2">(rightIndex &lt; length &amp;&amp; </span><span class="s5">0 </span><span class="s2">&gt; compare(right, last))</span>
            <span class="s2">(heap[index] = right),</span>
              <span class="s2">(heap[rightIndex] = last),</span>
              <span class="s2">(index = rightIndex);</span>
          <span class="s4">else break </span><span class="s2">a;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">first;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">compare(a, b) {</span>
      <span class="s4">var </span><span class="s2">diff = a.sortIndex - b.sortIndex;</span>
      <span class="s4">return </span><span class="s5">0 </span><span class="s2">!== diff ? diff : a.id - b.id;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">advanceTimers(currentTime) {</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">timer = peek(timerQueue); </span><span class="s4">null </span><span class="s2">!== timer; ) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== timer.callback) pop(timerQueue);</span>
        <span class="s4">else if </span><span class="s2">(timer.startTime &lt;= currentTime)</span>
          <span class="s2">pop(timerQueue),</span>
            <span class="s2">(timer.sortIndex = timer.expirationTime),</span>
            <span class="s2">push(taskQueue, timer);</span>
        <span class="s4">else break</span><span class="s2">;</span>
        <span class="s2">timer = peek(timerQueue);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">handleTimeout(currentTime) {</span>
      <span class="s2">isHostTimeoutScheduled = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">advanceTimers(currentTime);</span>
      <span class="s4">if </span><span class="s2">(!isHostCallbackScheduled)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== peek(taskQueue))</span>
          <span class="s2">(isHostCallbackScheduled = !</span><span class="s5">0</span><span class="s2">), (scheduledCallback = flushWork);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">firstTimer = peek(timerQueue);</span>
          <span class="s4">null </span><span class="s2">!== firstTimer &amp;&amp;</span>
            <span class="s2">((currentTime = firstTimer.startTime - currentTime),</span>
            <span class="s2">(scheduledTimeout = handleTimeout),</span>
            <span class="s2">(timeoutTime = currentMockTime + currentTime));</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">flushWork(hasTimeRemaining, initialTime) {</span>
      <span class="s2">isHostCallbackScheduled = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">isHostTimeoutScheduled &amp;&amp;</span>
        <span class="s2">((isHostTimeoutScheduled = !</span><span class="s5">1</span><span class="s2">),</span>
        <span class="s2">(scheduledTimeout = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(timeoutTime = -</span><span class="s5">1</span><span class="s2">));</span>
      <span class="s2">isPerformingWork = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">previousPriorityLevel = currentPriorityLevel;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">a: {</span>
          <span class="s2">advanceTimers(initialTime);</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">currentTask = peek(taskQueue);</span>
            <span class="s4">null </span><span class="s2">!== currentTask &amp;&amp;</span>
            <span class="s2">(!(currentTask.expirationTime &gt; initialTime) ||</span>
              <span class="s2">(hasTimeRemaining &amp;&amp; !shouldYieldToHost()));</span>

          <span class="s2">) {</span>
            <span class="s4">var </span><span class="s2">callback = currentTask.callback;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">callback) {</span>
              <span class="s2">currentTask.callback = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s2">currentPriorityLevel = currentTask.priorityLevel;</span>
              <span class="s4">var </span><span class="s2">continuationCallback = callback(</span>
                <span class="s2">currentTask.expirationTime &lt;= initialTime</span>
              <span class="s2">);</span>
              <span class="s2">initialTime = currentMockTime;</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">continuationCallback) {</span>
                <span class="s4">if </span><span class="s2">(</span>
                  <span class="s2">((currentTask.callback = continuationCallback),</span>
                  <span class="s2">advanceTimers(initialTime),</span>
                  <span class="s2">shouldYieldForPaint)</span>
                <span class="s2">) {</span>
                  <span class="s4">var </span><span class="s2">JSCompiler_inline_result = (needsPaint = !</span><span class="s5">0</span><span class="s2">);</span>
                  <span class="s4">break </span><span class="s2">a;</span>
                <span class="s2">}</span>
              <span class="s2">} </span><span class="s4">else</span>
                <span class="s2">currentTask === peek(taskQueue) &amp;&amp; pop(taskQueue),</span>
                  <span class="s2">advanceTimers(initialTime);</span>
            <span class="s2">} </span><span class="s4">else </span><span class="s2">pop(taskQueue);</span>
            <span class="s2">currentTask = peek(taskQueue);</span>
          <span class="s2">}</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== currentTask) JSCompiler_inline_result = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">firstTimer = peek(timerQueue);</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== firstTimer) {</span>
              <span class="s4">var </span><span class="s2">ms = firstTimer.startTime - initialTime;</span>
              <span class="s2">scheduledTimeout = handleTimeout;</span>
              <span class="s2">timeoutTime = currentMockTime + ms;</span>
            <span class="s2">}</span>
            <span class="s2">JSCompiler_inline_result = !</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">JSCompiler_inline_result;</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(currentTask = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">(currentPriorityLevel = previousPriorityLevel),</span>
          <span class="s2">(isPerformingWork = !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">shouldYieldToHost() {</span>
      <span class="s4">return </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== expectedNumberOfYields &amp;&amp; </span><span class="s4">null </span><span class="s2">=== yieldedValues) ||</span>
        <span class="s2">(-</span><span class="s5">1 </span><span class="s2">!== expectedNumberOfYields &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== yieldedValues &amp;&amp;</span>
          <span class="s2">yieldedValues.length &gt;= expectedNumberOfYields) ||</span>
        <span class="s2">(shouldYieldForPaint &amp;&amp; needsPaint)</span>
        <span class="s2">? (didStop = !</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s2">: !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">unstable_flushAllWithoutAsserting() {</span>
      <span class="s4">if </span><span class="s2">(isFlushing) </span><span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Already flushing work.&quot;</span><span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== scheduledCallback) {</span>
        <span class="s4">var </span><span class="s2">cb = scheduledCallback;</span>
        <span class="s2">isFlushing = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">hasMoreWork = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">do </span><span class="s2">hasMoreWork = cb(!</span><span class="s5">0</span><span class="s2">, currentMockTime);</span>
          <span class="s4">while </span><span class="s2">(hasMoreWork);</span>
          <span class="s2">hasMoreWork || (scheduledCallback = </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">isFlushing = !</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">var </span><span class="s2">taskQueue = [],</span>
      <span class="s2">timerQueue = [],</span>
      <span class="s2">taskIdCounter = </span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">currentTask = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">currentPriorityLevel = </span><span class="s5">3</span><span class="s2">,</span>
      <span class="s2">isPerformingWork = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">isHostCallbackScheduled = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">isHostTimeoutScheduled = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">currentMockTime = </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">scheduledCallback = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">scheduledTimeout = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">timeoutTime = -</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">yieldedValues = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">expectedNumberOfYields = -</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">didStop = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">isFlushing = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">needsPaint = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">shouldYieldForPaint = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">disableYieldValue = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">exports.log = </span><span class="s4">function </span><span class="s2">(value) {</span>
      <span class="s3">&quot;disabledLog&quot; </span><span class="s2">=== console.log.name ||</span>
        <span class="s2">disableYieldValue ||</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== yieldedValues</span>
          <span class="s2">? (yieldedValues = [value])</span>
          <span class="s2">: yieldedValues.push(value));</span>
    <span class="s2">};</span>
    <span class="s2">exports.reset = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">if </span><span class="s2">(isFlushing) </span><span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot reset while already flushing work.&quot;</span><span class="s2">);</span>
      <span class="s2">currentMockTime = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">scheduledTimeout = scheduledCallback = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">timeoutTime = -</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">yieldedValues = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">expectedNumberOfYields = -</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">needsPaint = isFlushing = didStop = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_IdlePriority = </span><span class="s5">5</span><span class="s2">;</span>
    <span class="s2">exports.unstable_ImmediatePriority = </span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">exports.unstable_LowPriority = </span><span class="s5">4</span><span class="s2">;</span>
    <span class="s2">exports.unstable_NormalPriority = </span><span class="s5">3</span><span class="s2">;</span>
    <span class="s2">exports.unstable_Profiling = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">exports.unstable_UserBlockingPriority = </span><span class="s5">2</span><span class="s2">;</span>
    <span class="s2">exports.unstable_advanceTime = </span><span class="s4">function </span><span class="s2">(ms) {</span>
      <span class="s3">&quot;disabledLog&quot; </span><span class="s2">=== console.log.name ||</span>
        <span class="s2">disableYieldValue ||</span>
        <span class="s2">((currentMockTime += ms),</span>
        <span class="s4">null </span><span class="s2">!== scheduledTimeout &amp;&amp;</span>
          <span class="s2">timeoutTime &lt;= currentMockTime &amp;&amp;</span>
          <span class="s2">(scheduledTimeout(currentMockTime),</span>
          <span class="s2">(timeoutTime = -</span><span class="s5">1</span><span class="s2">),</span>
          <span class="s2">(scheduledTimeout = </span><span class="s4">null</span><span class="s2">)));</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_cancelCallback = </span><span class="s4">function </span><span class="s2">(task) {</span>
      <span class="s2">task.callback = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_clearLog = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== yieldedValues) </span><span class="s4">return </span><span class="s2">[];</span>
      <span class="s4">var </span><span class="s2">values = yieldedValues;</span>
      <span class="s2">yieldedValues = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">values;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_flushAll = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== yieldedValues)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;Log is not empty. Assert on the log of yielded values before flushing additional work.&quot;</span>
        <span class="s2">);</span>
      <span class="s2">unstable_flushAllWithoutAsserting();</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== yieldedValues)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;While flushing work, something yielded a value. Use an assertion helper to assert on the log of yielded values, e.g. expect(Scheduler).toFlushAndYield([...])&quot;</span>
        <span class="s2">);</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_flushAllWithoutAsserting =</span>
      <span class="s2">unstable_flushAllWithoutAsserting;</span>
    <span class="s2">exports.unstable_flushExpired = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">if </span><span class="s2">(isFlushing) </span><span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Already flushing work.&quot;</span><span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== scheduledCallback) {</span>
        <span class="s2">isFlushing = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">scheduledCallback(!</span><span class="s5">1</span><span class="s2">, currentMockTime) || (scheduledCallback = </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">isFlushing = !</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_flushNumberOfYields = </span><span class="s4">function </span><span class="s2">(count) {</span>
      <span class="s4">if </span><span class="s2">(isFlushing) </span><span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Already flushing work.&quot;</span><span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== scheduledCallback) {</span>
        <span class="s4">var </span><span class="s2">cb = scheduledCallback;</span>
        <span class="s2">expectedNumberOfYields = count;</span>
        <span class="s2">isFlushing = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">count = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">do </span><span class="s2">count = cb(!</span><span class="s5">0</span><span class="s2">, currentMockTime);</span>
          <span class="s4">while </span><span class="s2">(count &amp;&amp; !didStop);</span>
          <span class="s2">count || (scheduledCallback = </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">(expectedNumberOfYields = -</span><span class="s5">1</span><span class="s2">), (isFlushing = didStop = !</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_flushUntilNextPaint = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">if </span><span class="s2">(isFlushing) </span><span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Already flushing work.&quot;</span><span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== scheduledCallback) {</span>
        <span class="s4">var </span><span class="s2">cb = scheduledCallback;</span>
        <span class="s2">shouldYieldForPaint = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">needsPaint = !</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">isFlushing = !</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">hasMoreWork = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">do </span><span class="s2">hasMoreWork = cb(!</span><span class="s5">0</span><span class="s2">, currentMockTime);</span>
          <span class="s4">while </span><span class="s2">(hasMoreWork &amp;&amp; !didStop);</span>
          <span class="s2">hasMoreWork || (scheduledCallback = </span><span class="s4">null</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">isFlushing = didStop = shouldYieldForPaint = !</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_forceFrameRate = </span><span class="s4">function </span><span class="s2">() {};</span>
    <span class="s2">exports.unstable_getCurrentPriorityLevel = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">currentPriorityLevel;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_hasPendingWork = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return null </span><span class="s2">!== scheduledCallback;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_next = </span><span class="s4">function </span><span class="s2">(eventHandler) {</span>
      <span class="s4">switch </span><span class="s2">(currentPriorityLevel) {</span>
        <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">priorityLevel = </span><span class="s5">3</span><span class="s2">;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s2">priorityLevel = currentPriorityLevel;</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">previousPriorityLevel = currentPriorityLevel;</span>
      <span class="s2">currentPriorityLevel = priorityLevel;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">return </span><span class="s2">eventHandler();</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">currentPriorityLevel = previousPriorityLevel;</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_now = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">currentMockTime;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_requestPaint = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">needsPaint = !</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_runWithPriority = </span><span class="s4">function </span><span class="s2">(priorityLevel, eventHandler) {</span>
      <span class="s4">switch </span><span class="s2">(priorityLevel) {</span>
        <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">3</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s2">priorityLevel = </span><span class="s5">3</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">previousPriorityLevel = currentPriorityLevel;</span>
      <span class="s2">currentPriorityLevel = priorityLevel;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">return </span><span class="s2">eventHandler();</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">currentPriorityLevel = previousPriorityLevel;</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_scheduleCallback = </span><span class="s4">function </span><span class="s2">(</span>
      <span class="s2">priorityLevel,</span>
      <span class="s2">callback,</span>
      <span class="s2">options</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">currentTime = currentMockTime;</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options &amp;&amp; </span><span class="s4">null </span><span class="s2">!== options</span>
        <span class="s2">? ((options = options.delay),</span>
          <span class="s2">(options =</span>
            <span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">options &amp;&amp; </span><span class="s5">0 </span><span class="s2">&lt; options</span>
              <span class="s2">? currentTime + options</span>
              <span class="s2">: currentTime))</span>
        <span class="s2">: (options = currentTime);</span>
      <span class="s4">switch </span><span class="s2">(priorityLevel) {</span>
        <span class="s4">case </span><span class="s5">1</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">timeout = -</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s5">2</span><span class="s2">:</span>
          <span class="s2">timeout = </span><span class="s5">250</span><span class="s2">;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s5">5</span><span class="s2">:</span>
          <span class="s2">timeout = </span><span class="s5">1073741823</span><span class="s2">;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s5">4</span><span class="s2">:</span>
          <span class="s2">timeout = </span><span class="s5">1e4</span><span class="s2">;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s2">timeout = </span><span class="s5">5e3</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s2">timeout = options + timeout;</span>
      <span class="s2">priorityLevel = {</span>
        <span class="s2">id: taskIdCounter++,</span>
        <span class="s2">callback: callback,</span>
        <span class="s2">priorityLevel: priorityLevel,</span>
        <span class="s2">startTime: options,</span>
        <span class="s2">expirationTime: timeout,</span>
        <span class="s2">sortIndex: -</span><span class="s5">1</span>
      <span class="s2">};</span>
      <span class="s2">options &gt; currentTime</span>
        <span class="s2">? ((priorityLevel.sortIndex = options),</span>
          <span class="s2">push(timerQueue, priorityLevel),</span>
          <span class="s4">null </span><span class="s2">=== peek(taskQueue) &amp;&amp;</span>
            <span class="s2">priorityLevel === peek(timerQueue) &amp;&amp;</span>
            <span class="s2">(isHostTimeoutScheduled</span>
              <span class="s2">? ((scheduledTimeout = </span><span class="s4">null</span><span class="s2">), (timeoutTime = -</span><span class="s5">1</span><span class="s2">))</span>
              <span class="s2">: (isHostTimeoutScheduled = !</span><span class="s5">0</span><span class="s2">),</span>
            <span class="s2">(scheduledTimeout = handleTimeout),</span>
            <span class="s2">(timeoutTime = currentMockTime + (options - currentTime))))</span>
        <span class="s2">: ((priorityLevel.sortIndex = timeout),</span>
          <span class="s2">push(taskQueue, priorityLevel),</span>
          <span class="s2">isHostCallbackScheduled ||</span>
            <span class="s2">isPerformingWork ||</span>
            <span class="s2">((isHostCallbackScheduled = !</span><span class="s5">0</span><span class="s2">), (scheduledCallback = flushWork)));</span>
      <span class="s4">return </span><span class="s2">priorityLevel;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_setDisableYieldValue = </span><span class="s4">function </span><span class="s2">(newValue) {</span>
      <span class="s2">disableYieldValue = newValue;</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_shouldYield = shouldYieldToHost;</span>
    <span class="s2">exports.unstable_wrapCallback = </span><span class="s4">function </span><span class="s2">(callback) {</span>
      <span class="s4">var </span><span class="s2">parentPriorityLevel = currentPriorityLevel;</span>
      <span class="s4">return function </span><span class="s2">() {</span>
        <span class="s4">var </span><span class="s2">previousPriorityLevel = currentPriorityLevel;</span>
        <span class="s2">currentPriorityLevel = parentPriorityLevel;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">return </span><span class="s2">callback.apply(</span><span class="s4">this</span><span class="s2">, arguments);</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">currentPriorityLevel = previousPriorityLevel;</span>
        <span class="s2">}</span>
      <span class="s2">};</span>
    <span class="s2">};</span>
  <span class="s2">})();</span>
</pre>
</body>
</html>