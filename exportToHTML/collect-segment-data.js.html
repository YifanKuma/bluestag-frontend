<html>
<head>
<title>collect-segment-data.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
collect-segment-data.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;collectSegmentData&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">collectSegmentData;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_jsxruntime = require(</span><span class="s0">&quot;react/jsx-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_client = require(</span><span class="s0">&quot;react-server-dom-webpack/client&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_static = require(</span><span class="s0">&quot;react-server-dom-webpack/static&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nodewebstreamshelper = require(</span><span class="s0">&quot;../stream-utils/node-web-streams-helper&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_scheduler = require(</span><span class="s0">&quot;../../lib/scheduler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segmentvalueencoding = require(</span><span class="s0">&quot;../../shared/lib/segment-cache/segment-value-encoding&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createerrorhandler = require(</span><span class="s0">&quot;./create-error-handler&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">filterStackFrame = process.env.NODE_ENV !== </span><span class="s0">'production' </span><span class="s1">? require(</span><span class="s0">'../lib/source-maps'</span><span class="s1">).filterStackFrameDEV : undefined;</span>
<span class="s2">const </span><span class="s1">findSourceMapURL = process.env.NODE_ENV !== </span><span class="s0">'production' </span><span class="s1">? require(</span><span class="s0">'../lib/source-maps'</span><span class="s1">).findSourceMapURLDEV : undefined;</span>
<span class="s2">function </span><span class="s1">onSegmentPrerenderError(error) {</span>
    <span class="s2">const </span><span class="s1">digest = (</span><span class="s3">0</span><span class="s1">, _createerrorhandler.getDigestForWellKnownError)(error);</span>
    <span class="s2">if </span><span class="s1">(digest) {</span>
        <span class="s2">return </span><span class="s1">digest;</span>
    <span class="s1">}</span>
<span class="s4">// We don't need to log the errors because we would have already done that</span>
<span class="s4">// when generating the original Flight stream for the whole page.</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">collectSegmentData(isClientParamParsingEnabled, fullPageDataBuffer, staleTime, clientModules, serverConsumerManifest) {</span>
    <span class="s4">// Traverse the router tree and generate a prefetch response for each segment.</span>
    <span class="s4">// A mutable map to collect the results as we traverse the route tree.</span>
    <span class="s2">const </span><span class="s1">resultMap = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s4">// Before we start, warm up the module cache by decoding the page data once.</span>
    <span class="s4">// Then we can assume that any remaining async tasks that occur the next time</span>
    <span class="s4">// are due to hanging promises caused by dynamic data access. Note we only</span>
    <span class="s4">// have to do this once per page, not per individual segment.</span>
    <span class="s4">//</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _client.createFromReadableStream)((</span><span class="s3">0</span><span class="s1">, _nodewebstreamshelper.streamFromBuffer)(fullPageDataBuffer), {</span>
            <span class="s1">findSourceMapURL,</span>
            <span class="s1">serverConsumerManifest</span>
        <span class="s1">});</span>
        <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.waitAtLeastOneReactRenderTask)();</span>
    <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{}</span>
    <span class="s4">// Create an abort controller that we'll use to stop the stream.</span>
    <span class="s2">const </span><span class="s1">abortController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s2">const </span><span class="s1">onCompletedProcessingRouteTree = async ()=&gt;{</span>
        <span class="s4">// Since all we're doing is decoding and re-encoding a cached prerender, if</span>
        <span class="s4">// serializing the stream takes longer than a microtask, it must because of</span>
        <span class="s4">// hanging promises caused by dynamic data.</span>
        <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.waitAtLeastOneReactRenderTask)();</span>
        <span class="s1">abortController.abort();</span>
    <span class="s1">};</span>
    <span class="s4">// Generate a stream for the route tree prefetch. While we're walking the</span>
    <span class="s4">// tree, we'll also spawn additional tasks to generate the segment prefetches.</span>
    <span class="s4">// The promises for these tasks are pushed to a mutable array that we will</span>
    <span class="s4">// await once the route tree is fully rendered.</span>
    <span class="s2">const </span><span class="s1">segmentTasks = [];</span>
    <span class="s2">const </span><span class="s1">{ prelude: treeStream } = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _static.unstable_prerender)(</span><span class="s4">// RootTreePrefetch is not a valid return type for a React component, but</span>
    <span class="s4">// we need to use a component so that when we decode the original stream</span>
    <span class="s4">// inside of it, the side effects are transferred to the new stream.</span>
    <span class="s4">// @ts-expect-error</span>
    <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(PrefetchTreeData, {</span>
        <span class="s1">isClientParamParsingEnabled: isClientParamParsingEnabled,</span>
        <span class="s1">fullPageDataBuffer: fullPageDataBuffer,</span>
        <span class="s1">serverConsumerManifest: serverConsumerManifest,</span>
        <span class="s1">clientModules: clientModules,</span>
        <span class="s1">staleTime: staleTime,</span>
        <span class="s1">segmentTasks: segmentTasks,</span>
        <span class="s1">onCompletedProcessingRouteTree: onCompletedProcessingRouteTree</span>
    <span class="s1">}), clientModules, {</span>
        <span class="s1">filterStackFrame,</span>
        <span class="s1">signal: abortController.signal,</span>
        <span class="s1">onError: onSegmentPrerenderError</span>
    <span class="s1">});</span>
    <span class="s4">// Write the route tree to a special `/_tree` segment.</span>
    <span class="s2">const </span><span class="s1">treeBuffer = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _nodewebstreamshelper.streamToBuffer)(treeStream);</span>
    <span class="s1">resultMap.set(</span><span class="s0">'/_tree'</span><span class="s1">, treeBuffer);</span>
    <span class="s4">// Now that we've finished rendering the route tree, all the segment tasks</span>
    <span class="s4">// should have been spawned. Await them in parallel and write the segment</span>
    <span class="s4">// prefetches to the result map.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[segmentPath, buffer] of (</span><span class="s2">await </span><span class="s1">Promise.all(segmentTasks))){</span>
        <span class="s1">resultMap.set(segmentPath, buffer);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resultMap;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">PrefetchTreeData({ isClientParamParsingEnabled, fullPageDataBuffer, serverConsumerManifest, clientModules, staleTime, segmentTasks, onCompletedProcessingRouteTree }) {</span>
    <span class="s4">// We're currently rendering a Flight response for the route tree prefetch.</span>
    <span class="s4">// Inside this component, decode the Flight stream for the whole page. This is</span>
    <span class="s4">// a hack to transfer the side effects from the original Flight stream (e.g.</span>
    <span class="s4">// Float preloads) onto the Flight stream for the tree prefetch.</span>
    <span class="s4">// TODO: React needs a better way to do this. Needed for Server Actions, too.</span>
    <span class="s2">const </span><span class="s1">initialRSCPayload = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _client.createFromReadableStream)(createUnclosingPrefetchStream((</span><span class="s3">0</span><span class="s1">, _nodewebstreamshelper.streamFromBuffer)(fullPageDataBuffer)), {</span>
        <span class="s1">findSourceMapURL,</span>
        <span class="s1">serverConsumerManifest</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">buildId = initialRSCPayload.b;</span>
    <span class="s4">// FlightDataPath is an unsound type, hence the additional checks.</span>
    <span class="s2">const </span><span class="s1">flightDataPaths = initialRSCPayload.f;</span>
    <span class="s2">if </span><span class="s1">(flightDataPaths.length !== </span><span class="s3">1 </span><span class="s1">&amp;&amp; flightDataPaths[</span><span class="s3">0</span><span class="s1">].length !== </span><span class="s3">3</span><span class="s1">) {</span>
        <span class="s1">console.error(</span><span class="s0">'Internal Next.js error: InitialRSCPayload does not match the expected ' </span><span class="s1">+ </span><span class="s0">'shape for a prerendered page during segment prefetch generation.'</span><span class="s1">);</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">flightRouterState = flightDataPaths[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">seedData = flightDataPaths[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">head = flightDataPaths[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">2</span><span class="s1">];</span>
    <span class="s4">// Compute the route metadata tree by traversing the FlightRouterState. As we</span>
    <span class="s4">// walk the tree, we will also spawn a task to produce a prefetch response for</span>
    <span class="s4">// each segment.</span>
    <span class="s2">const </span><span class="s1">tree = collectSegmentDataImpl(isClientParamParsingEnabled, flightRouterState, buildId, seedData, clientModules, _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY, segmentTasks);</span>
    <span class="s2">const </span><span class="s1">isHeadPartial = </span><span class="s2">await </span><span class="s1">isPartialRSCData(head, clientModules);</span>
    <span class="s4">// Notify the abort controller that we're done processing the route tree.</span>
    <span class="s4">// Anything async that happens after this point must be due to hanging</span>
    <span class="s4">// promises in the original stream.</span>
    <span class="s1">onCompletedProcessingRouteTree();</span>
    <span class="s4">// Render the route tree to a special `/_tree` segment.</span>
    <span class="s2">const </span><span class="s1">treePrefetch = {</span>
        <span class="s1">buildId,</span>
        <span class="s1">tree,</span>
        <span class="s1">head,</span>
        <span class="s1">isHeadPartial,</span>
        <span class="s1">staleTime</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">treePrefetch;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">collectSegmentDataImpl(isClientParamParsingEnabled, route, buildId, seedData, clientModules, requestKey, segmentTasks) {</span>
    <span class="s4">// Metadata about the segment. Sent as part of the tree prefetch. Null if</span>
    <span class="s4">// there are no children.</span>
    <span class="s2">let </span><span class="s1">slotMetadata = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">children = route[</span><span class="s3">1</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">seedDataChildren = seedData !== </span><span class="s2">null </span><span class="s1">? seedData[</span><span class="s3">2</span><span class="s1">] : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">parallelRouteKey </span><span class="s2">in </span><span class="s1">children){</span>
        <span class="s2">const </span><span class="s1">childRoute = children[parallelRouteKey];</span>
        <span class="s2">const </span><span class="s1">childSegment = childRoute[</span><span class="s3">0</span><span class="s1">];</span>
        <span class="s2">const </span><span class="s1">childSeedData = seedDataChildren !== </span><span class="s2">null </span><span class="s1">? seedDataChildren[parallelRouteKey] : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">childRequestKey = (</span><span class="s3">0</span><span class="s1">, _segmentvalueencoding.appendSegmentRequestKeyPart)(requestKey, parallelRouteKey, (</span><span class="s3">0</span><span class="s1">, _segmentvalueencoding.createSegmentRequestKeyPart)(childSegment));</span>
        <span class="s2">const </span><span class="s1">childTree = collectSegmentDataImpl(isClientParamParsingEnabled, childRoute, buildId, childSeedData, clientModules, childRequestKey, segmentTasks);</span>
        <span class="s2">if </span><span class="s1">(slotMetadata === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">slotMetadata = {};</span>
        <span class="s1">}</span>
        <span class="s1">slotMetadata[parallelRouteKey] = childTree;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(seedData !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s4">// Spawn a task to write the segment data to a new Flight stream.</span>
        <span class="s1">segmentTasks.push(</span><span class="s4">// Since we're already in the middle of a render, wait until after the</span>
        <span class="s4">// current task to escape the current rendering context.</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.waitAtLeastOneReactRenderTask)().then(()=&gt;renderSegmentPrefetch(buildId, seedData, requestKey, clientModules)));</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s4">// This segment does not have any seed data. Skip generating a prefetch</span>
    <span class="s4">// response for it. We'll still include it in the route tree, though.</span>
    <span class="s4">// TODO: We should encode in the route tree whether a segment is missing</span>
    <span class="s4">// so we don't attempt to fetch it for no reason. As of now this shouldn't</span>
    <span class="s4">// ever happen in practice, though.</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">segment = route[</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s2">let </span><span class="s1">name;</span>
    <span class="s2">let </span><span class="s1">paramType = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">paramKey = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">segment === </span><span class="s0">'string'</span><span class="s1">) {</span>
        <span class="s1">name = segment;</span>
        <span class="s1">paramKey = segment;</span>
        <span class="s1">paramType = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">name = segment[</span><span class="s3">0</span><span class="s1">];</span>
        <span class="s1">paramKey = segment[</span><span class="s3">1</span><span class="s1">];</span>
        <span class="s1">paramType = segment[</span><span class="s3">2</span><span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s4">// Metadata about the segment. Sent to the client as part of the</span>
    <span class="s4">// tree prefetch.</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">name,</span>
        <span class="s1">paramType,</span>
        <span class="s4">// This value is ommitted from the prefetch response when clientParamParsing</span>
        <span class="s4">// is enabled. The flag only exists while we're testing the feature, in</span>
        <span class="s4">// case there's a bug and we need to revert.</span>
        <span class="s4">// TODO: Remove once clientParamParsing is enabled everywhere.</span>
        <span class="s1">paramKey: isClientParamParsingEnabled ? </span><span class="s2">null </span><span class="s1">: paramKey,</span>
        <span class="s1">slots: slotMetadata,</span>
        <span class="s1">isRootLayout: route[</span><span class="s3">4</span><span class="s1">] === </span><span class="s2">true</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">renderSegmentPrefetch(buildId, seedData, requestKey, clientModules) {</span>
    <span class="s4">// Render the segment data to a stream.</span>
    <span class="s4">// In the future, this is where we can include additional metadata, like the</span>
    <span class="s4">// stale time and cache tags.</span>
    <span class="s2">const </span><span class="s1">rsc = seedData[</span><span class="s3">1</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">loading = seedData[</span><span class="s3">3</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">segmentPrefetch = {</span>
        <span class="s1">buildId,</span>
        <span class="s1">rsc,</span>
        <span class="s1">loading,</span>
        <span class="s1">isPartial: </span><span class="s2">await </span><span class="s1">isPartialRSCData(rsc, clientModules)</span>
    <span class="s1">};</span>
    <span class="s4">// Since all we're doing is decoding and re-encoding a cached prerender, if</span>
    <span class="s4">// it takes longer than a microtask, it must because of hanging promises</span>
    <span class="s4">// caused by dynamic data. Abort the stream at the end of the current task.</span>
    <span class="s2">const </span><span class="s1">abortController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.waitAtLeastOneReactRenderTask)().then(()=&gt;abortController.abort());</span>
    <span class="s2">const </span><span class="s1">{ prelude: segmentStream } = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _static.unstable_prerender)(segmentPrefetch, clientModules, {</span>
        <span class="s1">filterStackFrame,</span>
        <span class="s1">signal: abortController.signal,</span>
        <span class="s1">onError: onSegmentPrerenderError</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">segmentBuffer = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _nodewebstreamshelper.streamToBuffer)(segmentStream);</span>
    <span class="s2">if </span><span class="s1">(requestKey === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY) {</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s0">'/_index'</span><span class="s1">,</span>
            <span class="s1">segmentBuffer</span>
        <span class="s1">];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">requestKey,</span>
            <span class="s1">segmentBuffer</span>
        <span class="s1">];</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">isPartialRSCData(rsc, clientModules) {</span>
    <span class="s4">// We can determine if a segment contains only partial data if it takes longer</span>
    <span class="s4">// than a task to encode, because dynamic data is encoded as an infinite</span>
    <span class="s4">// promise. We must do this in a separate Flight prerender from the one that</span>
    <span class="s4">// actually generates the prefetch stream because we need to include</span>
    <span class="s4">// `isPartial` in the stream itself.</span>
    <span class="s2">let </span><span class="s1">isPartial = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">abortController = </span><span class="s2">new </span><span class="s1">AbortController();</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _scheduler.waitAtLeastOneReactRenderTask)().then(()=&gt;{</span>
        <span class="s4">// If we haven't yet finished the outer task, then it must be because we</span>
        <span class="s4">// accessed dynamic data.</span>
        <span class="s1">isPartial = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">abortController.abort();</span>
    <span class="s1">});</span>
    <span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _static.unstable_prerender)(rsc, clientModules, {</span>
        <span class="s1">filterStackFrame,</span>
        <span class="s1">signal: abortController.signal,</span>
        <span class="s1">onError () {},</span>
        <span class="s1">onPostpone () {</span>
            <span class="s4">// If something postponed, i.e. when Cache Components is not enabled, we can</span>
            <span class="s4">// infer that the RSC data is partial.</span>
            <span class="s1">isPartial = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">isPartial;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createUnclosingPrefetchStream(originalFlightStream) {</span>
    <span class="s4">// When PPR is enabled, prefetch streams may contain references that never</span>
    <span class="s4">// resolve, because that's how we encode dynamic data access. In the decoded</span>
    <span class="s4">// object returned by the Flight client, these are reified into hanging</span>
    <span class="s4">// promises that suspend during render, which is effectively what we want.</span>
    <span class="s4">// The UI resolves when it switches to the dynamic data stream</span>
    <span class="s4">// (via useDeferredValue(dynamic, static)).</span>
    <span class="s4">//</span>
    <span class="s4">// However, the Flight implementation currently errors if the server closes</span>
    <span class="s4">// the response before all the references are resolved. As a cheat to work</span>
    <span class="s4">// around this, we wrap the original stream in a new stream that never closes,</span>
    <span class="s4">// and therefore doesn't error.</span>
    <span class="s2">const </span><span class="s1">reader = originalFlightStream.getReader();</span>
    <span class="s2">return new </span><span class="s1">ReadableStream({</span>
        <span class="s1">async pull (controller) {</span>
            <span class="s2">while</span><span class="s1">(</span><span class="s2">true</span><span class="s1">){</span>
                <span class="s2">const </span><span class="s1">{ done, value } = </span><span class="s2">await </span><span class="s1">reader.read();</span>
                <span class="s2">if </span><span class="s1">(!done) {</span>
                    <span class="s4">// Pass to the target stream and keep consuming the Flight response</span>
                    <span class="s4">// from the server.</span>
                    <span class="s1">controller.enqueue(value);</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// The server stream has closed. Exit, but intentionally do not close</span>
                <span class="s4">// the target stream.</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=collect-segment-data.js.map</span></pre>
</body>
</html>