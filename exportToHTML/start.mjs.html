<html>
<head>
<title>start.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
start.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ startWaapiAnimation } from </span><span class="s2">'motion-dom'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ noop } from </span><span class="s2">'motion-utils'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ optimizedAppearDataId } from </span><span class="s2">'./data-id.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ getOptimisedAppearId } from </span><span class="s2">'./get-appear-id.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ handoffOptimizedAppearAnimation } from </span><span class="s2">'./handoff.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ appearAnimationStore, appearComplete } from </span><span class="s2">'./store.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ appearStoreId } from </span><span class="s2">'./store-id.mjs'</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* A single time to use across all animations to manually set startTime</span>
 <span class="s3">* and ensure they're all in sync.</span>
 <span class="s3">*/</span>
<span class="s0">let </span><span class="s1">startFrameTime;</span>
<span class="s3">/**</span>
 <span class="s3">* A dummy animation to detect when Chrome is ready to start</span>
 <span class="s3">* painting the page and hold off from triggering the real animation</span>
 <span class="s3">* until then. We only need one animation to detect paint ready.</span>
 <span class="s3">*</span>
 <span class="s3">* https://bugs.chromium.org/p/chromium/issues/detail?id=1406850</span>
 <span class="s3">*/</span>
<span class="s0">let </span><span class="s1">readyAnimation;</span>
<span class="s3">/**</span>
 <span class="s3">* Keep track of animations that were suspended vs cancelled so we</span>
 <span class="s3">* can easily resume them when we're done measuring layout.</span>
 <span class="s3">*/</span>
<span class="s0">const </span><span class="s1">suspendedAnimations = </span><span class="s0">new </span><span class="s1">Set();</span>
<span class="s0">function </span><span class="s1">resumeSuspendedAnimations() {</span>
    <span class="s1">suspendedAnimations.forEach((data) =&gt; {</span>
        <span class="s1">data.animation.play();</span>
        <span class="s1">data.animation.startTime = data.startTime;</span>
    <span class="s1">});</span>
    <span class="s1">suspendedAnimations.clear();</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {</span>
    <span class="s3">// Prevent optimised appear animations if Motion has already started animating.</span>
    <span class="s0">if </span><span class="s1">(window.MotionIsMounted) {</span>
        <span class="s0">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">id = element.dataset[optimizedAppearDataId];</span>
    <span class="s0">if </span><span class="s1">(!id)</span>
        <span class="s0">return</span><span class="s1">;</span>
    <span class="s1">window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;</span>
    <span class="s0">const </span><span class="s1">storeId = appearStoreId(id, name);</span>
    <span class="s0">if </span><span class="s1">(!readyAnimation) {</span>
        <span class="s1">readyAnimation = startWaapiAnimation(element, name, [keyframes[</span><span class="s4">0</span><span class="s1">], keyframes[</span><span class="s4">0</span><span class="s1">]], </span>
        <span class="s3">/**</span>
         <span class="s3">* 10 secs is basically just a super-safe duration to give Chrome</span>
         <span class="s3">* long enough to get the animation ready.</span>
         <span class="s3">*/</span>
        <span class="s1">{ duration: </span><span class="s4">10000</span><span class="s1">, ease: </span><span class="s2">&quot;linear&quot; </span><span class="s1">});</span>
        <span class="s1">appearAnimationStore.set(storeId, {</span>
            <span class="s1">animation: readyAnimation,</span>
            <span class="s1">startTime: </span><span class="s0">null</span><span class="s1">,</span>
        <span class="s1">});</span>
        <span class="s3">/**</span>
         <span class="s3">* If there's no readyAnimation then there's been no instantiation</span>
         <span class="s3">* of handoff animations.</span>
         <span class="s3">*/</span>
        <span class="s1">window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;</span>
        <span class="s1">window.MotionHasOptimisedAnimation = (elementId, valueName) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(!elementId)</span>
                <span class="s0">return false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Keep a map of elementIds that have started animating. We check</span>
             <span class="s3">* via ID instead of Element because of hydration errors and</span>
             <span class="s3">* pre-hydration checks. We also actively record IDs as they start</span>
             <span class="s3">* animating rather than simply checking for data-appear-id as</span>
             <span class="s3">* this attrbute might be present but not lead to an animation, for</span>
             <span class="s3">* instance if the element's appear animation is on a different</span>
             <span class="s3">* breakpoint.</span>
             <span class="s3">*/</span>
            <span class="s0">if </span><span class="s1">(!valueName) {</span>
                <span class="s0">return </span><span class="s1">appearComplete.has(elementId);</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">animationId = appearStoreId(elementId, valueName);</span>
            <span class="s0">return </span><span class="s1">Boolean(appearAnimationStore.get(animationId));</span>
        <span class="s1">};</span>
        <span class="s1">window.MotionHandoffMarkAsComplete = (elementId) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(appearComplete.has(elementId)) {</span>
                <span class="s1">appearComplete.set(elementId, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s1">window.MotionHandoffIsComplete = (elementId) =&gt; {</span>
            <span class="s0">return </span><span class="s1">appearComplete.get(elementId) === </span><span class="s0">true</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s3">/**</span>
         <span class="s3">* We only need to cancel transform animations as</span>
         <span class="s3">* they're the ones that will interfere with the</span>
         <span class="s3">* layout animation measurements.</span>
         <span class="s3">*/</span>
        <span class="s1">window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) =&gt; {</span>
            <span class="s0">const </span><span class="s1">animationId = appearStoreId(elementId, valueName);</span>
            <span class="s0">const </span><span class="s1">data = appearAnimationStore.get(animationId);</span>
            <span class="s0">if </span><span class="s1">(!data)</span>
                <span class="s0">return</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(frame &amp;&amp; canResume === undefined) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* Wait until the end of the subsequent frame to cancel the animation</span>
                 <span class="s3">* to ensure we don't remove the animation before the main thread has</span>
                 <span class="s3">* had a chance to resolve keyframes and render.</span>
                 <span class="s3">*/</span>
                <span class="s1">frame.postRender(() =&gt; {</span>
                    <span class="s1">frame.postRender(() =&gt; {</span>
                        <span class="s1">data.animation.cancel();</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">data.animation.cancel();</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(frame &amp;&amp; canResume) {</span>
                <span class="s1">suspendedAnimations.add(data);</span>
                <span class="s1">frame.render(resumeSuspendedAnimations);</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">appearAnimationStore.delete(animationId);</span>
                <span class="s3">/**</span>
                 <span class="s3">* If there are no more animations left, we can remove the cancel function.</span>
                 <span class="s3">* This will let us know when we can stop checking for conflicting layout animations.</span>
                 <span class="s3">*/</span>
                <span class="s0">if </span><span class="s1">(!appearAnimationStore.size) {</span>
                    <span class="s1">window.MotionCancelOptimisedAnimation = undefined;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s1">window.MotionCheckAppearSync = (visualElement, valueName, value) =&gt; {</span>
            <span class="s0">const </span><span class="s1">appearId = getOptimisedAppearId(visualElement);</span>
            <span class="s0">if </span><span class="s1">(!appearId)</span>
                <span class="s0">return</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">valueIsOptimised = window.MotionHasOptimisedAnimation?.(appearId, valueName);</span>
            <span class="s0">const </span><span class="s1">externalAnimationValue = visualElement.props.values?.[valueName];</span>
            <span class="s0">if </span><span class="s1">(!valueIsOptimised || !externalAnimationValue)</span>
                <span class="s0">return</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">removeSyncCheck = value.on(</span><span class="s2">&quot;change&quot;</span><span class="s1">, (latestValue) =&gt; {</span>
                <span class="s0">if </span><span class="s1">(externalAnimationValue.get() !== latestValue) {</span>
                    <span class="s1">window.MotionCancelOptimisedAnimation?.(appearId, valueName);</span>
                    <span class="s1">removeSyncCheck();</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s0">return </span><span class="s1">removeSyncCheck;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">startAnimation = () =&gt; {</span>
        <span class="s1">readyAnimation.cancel();</span>
        <span class="s0">const </span><span class="s1">appearAnimation = startWaapiAnimation(element, name, keyframes, options);</span>
        <span class="s3">/**</span>
         <span class="s3">* Record the time of the first started animation. We call performance.now() once</span>
         <span class="s3">* here and once in handoff to ensure we're getting</span>
         <span class="s3">* close to a frame-locked time. This keeps all animations in sync.</span>
         <span class="s3">*/</span>
        <span class="s0">if </span><span class="s1">(startFrameTime === undefined) {</span>
            <span class="s1">startFrameTime = performance.now();</span>
        <span class="s1">}</span>
        <span class="s1">appearAnimation.startTime = startFrameTime;</span>
        <span class="s1">appearAnimationStore.set(storeId, {</span>
            <span class="s1">animation: appearAnimation,</span>
            <span class="s1">startTime: startFrameTime,</span>
        <span class="s1">});</span>
        <span class="s0">if </span><span class="s1">(onReady)</span>
            <span class="s1">onReady(appearAnimation);</span>
    <span class="s1">};</span>
    <span class="s1">appearComplete.set(id, </span><span class="s0">false</span><span class="s1">);</span>
    <span class="s0">if </span><span class="s1">(readyAnimation.ready) {</span>
        <span class="s1">readyAnimation.ready.then(startAnimation).catch(noop);</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">startAnimation();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ startOptimizedAppearAnimation };</span>
</pre>
</body>
</html>