<html>
<head>
<title>entrypoints.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
entrypoints.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Ivan Kopeykin @vankop 
*/</span>

<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s3">const </span><span class="s1">{ parseIdentifier } = require(</span><span class="s2">&quot;./identifier&quot;</span><span class="s1">);</span>

<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{string|(string|ConditionalMapping)[]} DirectMapping */</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{{[k: string]: MappingValue}} ConditionalMapping */</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{ConditionalMapping|DirectMapping|null} MappingValue */</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{Record&lt;string, MappingValue&gt;|ConditionalMapping|DirectMapping} ExportsField */</span>
<span class="s0">/** </span><span class="s4">@typedef </span><span class="s0">{Record&lt;string, MappingValue&gt;} ImportsField */</span>

<span class="s0">/**</span>
 <span class="s0">* Processing exports/imports field</span>
 <span class="s0">* </span><span class="s4">@callback </span><span class="s0">FieldProcessor</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} request request</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{Set&lt;string&gt;} conditionNames condition names</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{[string[], string | null]} resolved paths with used field</span>
 <span class="s0">*/</span>

<span class="s0">/* 
Example exports field: 
{ 
  &quot;.&quot;: &quot;./main.js&quot;, 
  &quot;./feature&quot;: { 
    &quot;browser&quot;: &quot;./feature-browser.js&quot;, 
    &quot;default&quot;: &quot;./feature.js&quot; 
  } 
} 
Terminology: 
 
Enhanced-resolve name keys (&quot;.&quot; and &quot;./feature&quot;) as exports field keys. 
 
If value is string or string[], mapping is called as a direct mapping 
and value called as a direct export. 
 
If value is key-value object, mapping is called as a conditional mapping 
and value called as a conditional export. 
 
Key in conditional mapping is called condition name. 
 
Conditional mapping nested in another conditional mapping is called nested mapping. 
 
---------- 
 
Example imports field: 
{ 
  &quot;#a&quot;: &quot;./main.js&quot;, 
  &quot;#moment&quot;: { 
    &quot;browser&quot;: &quot;./moment/index.js&quot;, 
    &quot;default&quot;: &quot;moment&quot; 
  }, 
  &quot;#moment/&quot;: { 
    &quot;browser&quot;: &quot;./moment/&quot;, 
    &quot;default&quot;: &quot;moment/&quot; 
  } 
} 
Terminology: 
 
Enhanced-resolve name keys (&quot;#a&quot; and &quot;#moment/&quot;, &quot;#moment&quot;) as imports field keys. 
 
If value is string or string[], mapping is called as a direct mapping 
and value called as a direct export. 
 
If value is key-value object, mapping is called as a conditional mapping 
and value called as a conditional export. 
 
Key in conditional mapping is called condition name. 
 
Conditional mapping nested in another conditional mapping is called nested mapping. 
 
*/</span>

<span class="s3">const </span><span class="s1">slashCode = </span><span class="s2">&quot;/&quot;</span><span class="s1">.charCodeAt(</span><span class="s5">0</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">dotCode = </span><span class="s2">&quot;.&quot;</span><span class="s1">.charCodeAt(</span><span class="s5">0</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">hashCode = </span><span class="s2">&quot;#&quot;</span><span class="s1">.charCodeAt(</span><span class="s5">0</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">patternRegEx = </span><span class="s6">/\*/g</span><span class="s1">;</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} a first string</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} b second string</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{number} compare result</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">patternKeyCompare(a, b) {</span>
	<span class="s3">const </span><span class="s1">aPatternIndex = a.indexOf(</span><span class="s2">&quot;*&quot;</span><span class="s1">);</span>
	<span class="s3">const </span><span class="s1">bPatternIndex = b.indexOf(</span><span class="s2">&quot;*&quot;</span><span class="s1">);</span>
	<span class="s3">const </span><span class="s1">baseLenA = aPatternIndex === -</span><span class="s5">1 </span><span class="s1">? a.length : aPatternIndex + </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s3">const </span><span class="s1">baseLenB = bPatternIndex === -</span><span class="s5">1 </span><span class="s1">? b.length : bPatternIndex + </span><span class="s5">1</span><span class="s1">;</span>

	<span class="s3">if </span><span class="s1">(baseLenA &gt; baseLenB) </span><span class="s3">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(baseLenB &gt; baseLenA) </span><span class="s3">return </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(aPatternIndex === -</span><span class="s5">1</span><span class="s1">) </span><span class="s3">return </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(bPatternIndex === -</span><span class="s5">1</span><span class="s1">) </span><span class="s3">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(a.length &gt; b.length) </span><span class="s3">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(b.length &gt; a.length) </span><span class="s3">return </span><span class="s5">1</span><span class="s1">;</span>

	<span class="s3">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Trying to match request to field</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} request request</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{ExportsField | ImportsField} field exports or import field</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{[MappingValue, string, boolean, boolean, string]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">findMatch(request, field) {</span>
	<span class="s3">if </span><span class="s1">(</span>
		<span class="s1">Object.prototype.hasOwnProperty.call(field, request) &amp;&amp;</span>
		<span class="s1">!request.includes(</span><span class="s2">&quot;*&quot;</span><span class="s1">) &amp;&amp;</span>
		<span class="s1">!request.endsWith(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
	<span class="s1">) {</span>
		<span class="s3">const </span><span class="s1">target = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{{[k: string]: MappingValue}} */ </span><span class="s1">(field)[request];</span>

		<span class="s3">return </span><span class="s1">[target, </span><span class="s2">&quot;&quot;</span><span class="s1">, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">, request];</span>
	<span class="s1">}</span>

	<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{string} */</span>
	<span class="s3">let </span><span class="s1">bestMatch = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
	<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{string|undefined} */</span>
	<span class="s3">let </span><span class="s1">bestMatchSubpath;</span>

	<span class="s3">const </span><span class="s1">keys = Object.getOwnPropertyNames(field);</span>

	<span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; keys.length; i++) {</span>
		<span class="s3">const </span><span class="s1">key = keys[i];</span>
		<span class="s3">const </span><span class="s1">patternIndex = key.indexOf(</span><span class="s2">&quot;*&quot;</span><span class="s1">);</span>

		<span class="s3">if </span><span class="s1">(patternIndex !== -</span><span class="s5">1 </span><span class="s1">&amp;&amp; request.startsWith(key.slice(</span><span class="s5">0</span><span class="s1">, patternIndex))) {</span>
			<span class="s3">const </span><span class="s1">patternTrailer = key.slice(patternIndex + </span><span class="s5">1</span><span class="s1">);</span>

			<span class="s3">if </span><span class="s1">(</span>
				<span class="s1">request.length &gt;= key.length &amp;&amp;</span>
				<span class="s1">request.endsWith(patternTrailer) &amp;&amp;</span>
				<span class="s1">patternKeyCompare(bestMatch, key) === </span><span class="s5">1 </span><span class="s1">&amp;&amp;</span>
				<span class="s1">key.lastIndexOf(</span><span class="s2">&quot;*&quot;</span><span class="s1">) === patternIndex</span>
			<span class="s1">) {</span>
				<span class="s1">bestMatch = key;</span>
				<span class="s1">bestMatchSubpath = request.slice(</span>
					<span class="s1">patternIndex,</span>
					<span class="s1">request.length - patternTrailer.length,</span>
				<span class="s1">);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s0">// For legacy `./foo/`</span>
		<span class="s3">else if </span><span class="s1">(</span>
			<span class="s1">key[key.length - </span><span class="s5">1</span><span class="s1">] === </span><span class="s2">&quot;/&quot; </span><span class="s1">&amp;&amp;</span>
			<span class="s1">request.startsWith(key) &amp;&amp;</span>
			<span class="s1">patternKeyCompare(bestMatch, key) === </span><span class="s5">1</span>
		<span class="s1">) {</span>
			<span class="s1">bestMatch = key;</span>
			<span class="s1">bestMatchSubpath = request.slice(key.length);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">if </span><span class="s1">(bestMatch === </span><span class="s2">&quot;&quot;</span><span class="s1">) </span><span class="s3">return null</span><span class="s1">;</span>

	<span class="s3">const </span><span class="s1">target = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{{[k: string]: MappingValue}} */ </span><span class="s1">(field)[bestMatch];</span>
	<span class="s3">const </span><span class="s1">isSubpathMapping = bestMatch.endsWith(</span><span class="s2">&quot;/&quot;</span><span class="s1">);</span>
	<span class="s3">const </span><span class="s1">isPattern = bestMatch.includes(</span><span class="s2">&quot;*&quot;</span><span class="s1">);</span>

	<span class="s3">return </span><span class="s1">[</span>
		<span class="s1">target,</span>
		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{string} */ </span><span class="s1">(bestMatchSubpath),</span>
		<span class="s1">isSubpathMapping,</span>
		<span class="s1">isPattern,</span>
		<span class="s1">bestMatch,</span>
	<span class="s1">];</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{ConditionalMapping | DirectMapping|null} mapping mapping</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{boolean} is conditional mapping</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">isConditionalMapping(mapping) {</span>
	<span class="s3">return </span><span class="s1">(</span>
		<span class="s1">mapping !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">mapping === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; !Array.isArray(mapping)</span>
	<span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{ConditionalMapping} conditionalMapping_ conditional mapping</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{Set&lt;string&gt;} conditionNames condition names</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{DirectMapping | null} direct mapping if found</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">conditionalMapping(conditionalMapping_, conditionNames) {</span>
	<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{[ConditionalMapping, string[], number][]} */</span>
	<span class="s3">const </span><span class="s1">lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), </span><span class="s5">0</span><span class="s1">]];</span>

	<span class="s1">loop: </span><span class="s3">while </span><span class="s1">(lookup.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
		<span class="s3">const </span><span class="s1">[mapping, conditions, j] = lookup[lookup.length - </span><span class="s5">1</span><span class="s1">];</span>

		<span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = j; i &lt; conditions.length; i++) {</span>
			<span class="s3">const </span><span class="s1">condition = conditions[i];</span>

			<span class="s3">if </span><span class="s1">(condition === </span><span class="s2">&quot;default&quot;</span><span class="s1">) {</span>
				<span class="s3">const </span><span class="s1">innerMapping = mapping[condition];</span>
				<span class="s0">// is nested</span>
				<span class="s3">if </span><span class="s1">(isConditionalMapping(innerMapping)) {</span>
					<span class="s3">const </span><span class="s1">conditionalMapping = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{ConditionalMapping} */ </span><span class="s1">(</span>
						<span class="s1">innerMapping</span>
					<span class="s1">);</span>
					<span class="s1">lookup[lookup.length - </span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] = i + </span><span class="s5">1</span><span class="s1">;</span>
					<span class="s1">lookup.push([conditionalMapping, Object.keys(conditionalMapping), </span><span class="s5">0</span><span class="s1">]);</span>
					<span class="s3">continue </span><span class="s1">loop;</span>
				<span class="s1">}</span>

				<span class="s3">return </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{DirectMapping} */ </span><span class="s1">(innerMapping);</span>
			<span class="s1">}</span>

			<span class="s3">if </span><span class="s1">(conditionNames.has(condition)) {</span>
				<span class="s3">const </span><span class="s1">innerMapping = mapping[condition];</span>
				<span class="s0">// is nested</span>
				<span class="s3">if </span><span class="s1">(isConditionalMapping(innerMapping)) {</span>
					<span class="s3">const </span><span class="s1">conditionalMapping = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{ConditionalMapping} */ </span><span class="s1">(</span>
						<span class="s1">innerMapping</span>
					<span class="s1">);</span>
					<span class="s1">lookup[lookup.length - </span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] = i + </span><span class="s5">1</span><span class="s1">;</span>
					<span class="s1">lookup.push([conditionalMapping, Object.keys(conditionalMapping), </span><span class="s5">0</span><span class="s1">]);</span>
					<span class="s3">continue </span><span class="s1">loop;</span>
				<span class="s1">}</span>

				<span class="s3">return </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{DirectMapping} */ </span><span class="s1">(innerMapping);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">lookup.pop();</span>
	<span class="s1">}</span>

	<span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string | undefined} remainingRequest remaining request when folder mapping, undefined for file mappings</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{boolean} isPattern true, if mapping is a pattern (contains &quot;*&quot;)</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{boolean} isSubpathMapping true, for subpath mappings</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} mappingTarget direct export</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{(d: string, f: boolean) =&gt; void} assert asserting direct value</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{string} mapping result</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">targetMapping(</span>
	<span class="s1">remainingRequest,</span>
	<span class="s1">isPattern,</span>
	<span class="s1">isSubpathMapping,</span>
	<span class="s1">mappingTarget,</span>
	<span class="s1">assert,</span>
<span class="s1">) {</span>
	<span class="s3">if </span><span class="s1">(remainingRequest === undefined) {</span>
		<span class="s1">assert(mappingTarget, </span><span class="s3">false</span><span class="s1">);</span>

		<span class="s3">return </span><span class="s1">mappingTarget;</span>
	<span class="s1">}</span>

	<span class="s3">if </span><span class="s1">(isSubpathMapping) {</span>
		<span class="s1">assert(mappingTarget, </span><span class="s3">true</span><span class="s1">);</span>

		<span class="s3">return </span><span class="s1">mappingTarget + remainingRequest;</span>
	<span class="s1">}</span>

	<span class="s1">assert(mappingTarget, </span><span class="s3">false</span><span class="s1">);</span>

	<span class="s3">let </span><span class="s1">result = mappingTarget;</span>

	<span class="s3">if </span><span class="s1">(isPattern) {</span>
		<span class="s1">result = result.replace(</span>
			<span class="s1">patternRegEx,</span>
			<span class="s1">remainingRequest.replace(</span><span class="s6">/\$/g</span><span class="s1">, </span><span class="s2">&quot;$$&quot;</span><span class="s1">),</span>
		<span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{boolean} isPattern true, if mapping is a pattern (contains &quot;*&quot;)</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{boolean} isSubpathMapping true, for subpath mappings</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{DirectMapping|null} mappingTarget direct export</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{Set&lt;string&gt;} conditionNames condition names</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{(d: string, f: boolean) =&gt; void} assert asserting direct value</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{string[]} mapping result</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">directMapping(</span>
	<span class="s1">remainingRequest,</span>
	<span class="s1">isPattern,</span>
	<span class="s1">isSubpathMapping,</span>
	<span class="s1">mappingTarget,</span>
	<span class="s1">conditionNames,</span>
	<span class="s1">assert,</span>
<span class="s1">) {</span>
	<span class="s3">if </span><span class="s1">(mappingTarget === </span><span class="s3">null</span><span class="s1">) </span><span class="s3">return </span><span class="s1">[];</span>

	<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">mappingTarget === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
		<span class="s3">return </span><span class="s1">[</span>
			<span class="s1">targetMapping(</span>
				<span class="s1">remainingRequest,</span>
				<span class="s1">isPattern,</span>
				<span class="s1">isSubpathMapping,</span>
				<span class="s1">mappingTarget,</span>
				<span class="s1">assert,</span>
			<span class="s1">),</span>
		<span class="s1">];</span>
	<span class="s1">}</span>

	<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{string[]} */</span>
	<span class="s3">const </span><span class="s1">targets = [];</span>

	<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">exp of mappingTarget) {</span>
		<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">exp === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
			<span class="s1">targets.push(</span>
				<span class="s1">targetMapping(</span>
					<span class="s1">remainingRequest,</span>
					<span class="s1">isPattern,</span>
					<span class="s1">isSubpathMapping,</span>
					<span class="s1">exp,</span>
					<span class="s1">assert,</span>
				<span class="s1">),</span>
			<span class="s1">);</span>
			<span class="s3">continue</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s3">const </span><span class="s1">mapping = conditionalMapping(exp, conditionNames);</span>
		<span class="s3">if </span><span class="s1">(!mapping) </span><span class="s3">continue</span><span class="s1">;</span>
		<span class="s3">const </span><span class="s1">innerExports = directMapping(</span>
			<span class="s1">remainingRequest,</span>
			<span class="s1">isPattern,</span>
			<span class="s1">isSubpathMapping,</span>
			<span class="s1">mapping,</span>
			<span class="s1">conditionNames,</span>
			<span class="s1">assert,</span>
		<span class="s1">);</span>
		<span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">innerExport of innerExports) {</span>
			<span class="s1">targets.push(innerExport);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">return </span><span class="s1">targets;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{ExportsField | ImportsField} field root</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{(s: string) =&gt; string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{(s: string) =&gt; string} assertRequest assertRequest</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{(s: string, f: boolean) =&gt; void} assertTarget assertTarget</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{FieldProcessor} field processor</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">createFieldProcessor(</span>
	<span class="s1">field,</span>
	<span class="s1">normalizeRequest,</span>
	<span class="s1">assertRequest,</span>
	<span class="s1">assertTarget,</span>
<span class="s1">) {</span>
	<span class="s3">return function </span><span class="s1">fieldProcessor(request, conditionNames) {</span>
		<span class="s1">request = assertRequest(request);</span>

		<span class="s3">const </span><span class="s1">match = findMatch(normalizeRequest(request), field);</span>

		<span class="s3">if </span><span class="s1">(match === </span><span class="s3">null</span><span class="s1">) </span><span class="s3">return </span><span class="s1">[[], </span><span class="s3">null</span><span class="s1">];</span>

		<span class="s3">const </span><span class="s1">[mapping, remainingRequest, isSubpathMapping, isPattern, usedField] =</span>
			<span class="s1">match;</span>

		<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{DirectMapping | null} */</span>
		<span class="s3">let </span><span class="s1">direct = </span><span class="s3">null</span><span class="s1">;</span>

		<span class="s3">if </span><span class="s1">(isConditionalMapping(mapping)) {</span>
			<span class="s1">direct = conditionalMapping(</span>
				<span class="s0">/** </span><span class="s4">@type </span><span class="s0">{ConditionalMapping} */ </span><span class="s1">(mapping),</span>
				<span class="s1">conditionNames,</span>
			<span class="s1">);</span>

			<span class="s0">// matching not found</span>
			<span class="s3">if </span><span class="s1">(direct === </span><span class="s3">null</span><span class="s1">) </span><span class="s3">return </span><span class="s1">[[], </span><span class="s3">null</span><span class="s1">];</span>
		<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
			<span class="s1">direct = </span><span class="s0">/** </span><span class="s4">@type </span><span class="s0">{DirectMapping} */ </span><span class="s1">(mapping);</span>
		<span class="s1">}</span>

		<span class="s3">return </span><span class="s1">[</span>
			<span class="s1">directMapping(</span>
				<span class="s1">remainingRequest,</span>
				<span class="s1">isPattern,</span>
				<span class="s1">isSubpathMapping,</span>
				<span class="s1">direct,</span>
				<span class="s1">conditionNames,</span>
				<span class="s1">assertTarget,</span>
			<span class="s1">),</span>
			<span class="s1">usedField,</span>
		<span class="s1">];</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} request request</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{string} updated request</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">assertExportsFieldRequest(request) {</span>
	<span class="s3">if </span><span class="s1">(request.charCodeAt(</span><span class="s5">0</span><span class="s1">) !== dotCode) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Request should be relative path and start with &quot;.&quot;'</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s3">if </span><span class="s1">(request.length === </span><span class="s5">1</span><span class="s1">) </span><span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
	<span class="s3">if </span><span class="s1">(request.charCodeAt(</span><span class="s5">1</span><span class="s1">) !== slashCode) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Request should be relative path and start with &quot;./&quot;'</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s3">if </span><span class="s1">(request.charCodeAt(request.length - </span><span class="s5">1</span><span class="s1">) === slashCode) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Only requesting file allowed&quot;</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s3">return </span><span class="s1">request.slice(</span><span class="s5">2</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{ExportsField} field exports field</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{ExportsField} normalized exports field</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">buildExportsField(field) {</span>
	<span class="s0">// handle syntax sugar, if exports field is direct mapping for &quot;.&quot;</span>
	<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">field === </span><span class="s2">&quot;string&quot; </span><span class="s1">|| Array.isArray(field)) {</span>
		<span class="s3">return </span><span class="s1">{ </span><span class="s2">&quot;.&quot;</span><span class="s1">: field };</span>
	<span class="s1">}</span>

	<span class="s3">const </span><span class="s1">keys = Object.keys(field);</span>

	<span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; keys.length; i++) {</span>
		<span class="s3">const </span><span class="s1">key = keys[i];</span>

		<span class="s3">if </span><span class="s1">(key.charCodeAt(</span><span class="s5">0</span><span class="s1">) !== dotCode) {</span>
			<span class="s0">// handle syntax sugar, if exports field is conditional mapping for &quot;.&quot;</span>
			<span class="s3">if </span><span class="s1">(i === </span><span class="s5">0</span><span class="s1">) {</span>
				<span class="s3">while </span><span class="s1">(i &lt; keys.length) {</span>
					<span class="s3">const </span><span class="s1">charCode = keys[i].charCodeAt(</span><span class="s5">0</span><span class="s1">);</span>
					<span class="s3">if </span><span class="s1">(charCode === dotCode || charCode === slashCode) {</span>
						<span class="s3">throw new </span><span class="s1">Error(</span>
							<span class="s2">`Exports field key should be relative path and start with &quot;.&quot; (key: </span><span class="s1">${JSON.stringify(</span>
								<span class="s1">key,</span>
							<span class="s1">)}</span><span class="s2">)`</span><span class="s1">,</span>
						<span class="s1">);</span>
					<span class="s1">}</span>
					<span class="s1">i++;</span>
				<span class="s1">}</span>

				<span class="s3">return </span><span class="s1">{ </span><span class="s2">&quot;.&quot;</span><span class="s1">: field };</span>
			<span class="s1">}</span>

			<span class="s3">throw new </span><span class="s1">Error(</span>
				<span class="s2">`Exports field key should be relative path and start with &quot;.&quot; (key: </span><span class="s1">${JSON.stringify(</span>
					<span class="s1">key,</span>
				<span class="s1">)}</span><span class="s2">)`</span><span class="s1">,</span>
			<span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s3">if </span><span class="s1">(key.length === </span><span class="s5">1</span><span class="s1">) {</span>
			<span class="s3">continue</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s3">if </span><span class="s1">(key.charCodeAt(</span><span class="s5">1</span><span class="s1">) !== slashCode) {</span>
			<span class="s3">throw new </span><span class="s1">Error(</span>
				<span class="s2">`Exports field key should be relative path and start with &quot;./&quot; (key: </span><span class="s1">${JSON.stringify(</span>
					<span class="s1">key,</span>
				<span class="s1">)}</span><span class="s2">)`</span><span class="s1">,</span>
			<span class="s1">);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">return </span><span class="s1">field;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} exp export target</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{boolean} expectFolder is folder expected</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">assertExportTarget(exp, expectFolder) {</span>
	<span class="s3">const </span><span class="s1">parsedIdentifier = parseIdentifier(exp);</span>

	<span class="s3">if </span><span class="s1">(!parsedIdentifier) {</span>
		<span class="s3">return</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s3">const </span><span class="s1">[relativePath] = parsedIdentifier;</span>
	<span class="s3">const </span><span class="s1">isFolder =</span>
		<span class="s1">relativePath.charCodeAt(relativePath.length - </span><span class="s5">1</span><span class="s1">) === slashCode;</span>

	<span class="s3">if </span><span class="s1">(isFolder !== expectFolder) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span>
			<span class="s1">expectFolder</span>
				<span class="s1">? </span><span class="s2">`Expecting folder to folder mapping. </span><span class="s1">${JSON.stringify(</span>
						<span class="s1">exp,</span>
					<span class="s1">)} </span><span class="s2">should end with &quot;/&quot;`</span>
				<span class="s1">: </span><span class="s2">`Expecting file to file mapping. </span><span class="s1">${JSON.stringify(</span>
						<span class="s1">exp,</span>
					<span class="s1">)} </span><span class="s2">should not end with &quot;/&quot;`</span><span class="s1">,</span>
		<span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{ExportsField} exportsField the exports field</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{FieldProcessor} process callback</span>
 <span class="s0">*/</span>
<span class="s1">module.exports.processExportsField = </span><span class="s3">function </span><span class="s1">processExportsField(</span>
	<span class="s1">exportsField,</span>
<span class="s1">) {</span>
	<span class="s3">return </span><span class="s1">createFieldProcessor(</span>
		<span class="s1">buildExportsField(exportsField),</span>
		<span class="s1">(request) =&gt; (request.length === </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">&quot;.&quot; </span><span class="s1">: </span><span class="s2">`./</span><span class="s1">${request}</span><span class="s2">`</span><span class="s1">),</span>
		<span class="s1">assertExportsFieldRequest,</span>
		<span class="s1">assertExportTarget,</span>
	<span class="s1">);</span>
<span class="s1">};</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} request request</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{string} updated request</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">assertImportsFieldRequest(request) {</span>
	<span class="s3">if </span><span class="s1">(request.charCodeAt(</span><span class="s5">0</span><span class="s1">) !== hashCode) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Request should start with &quot;#&quot;'</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s3">if </span><span class="s1">(request.length === </span><span class="s5">1</span><span class="s1">) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Request should have at least 2 characters&quot;</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s3">if </span><span class="s1">(request.charCodeAt(</span><span class="s5">1</span><span class="s1">) === slashCode) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Request should not start with &quot;#/&quot;'</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s3">if </span><span class="s1">(request.charCodeAt(request.length - </span><span class="s5">1</span><span class="s1">) === slashCode) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Only requesting file allowed&quot;</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s3">return </span><span class="s1">request.slice(</span><span class="s5">1</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{string} imp import target</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{boolean} expectFolder is folder expected</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s1">assertImportTarget(imp, expectFolder) {</span>
	<span class="s3">const </span><span class="s1">parsedIdentifier = parseIdentifier(imp);</span>

	<span class="s3">if </span><span class="s1">(!parsedIdentifier) {</span>
		<span class="s3">return</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s3">const </span><span class="s1">[relativePath] = parsedIdentifier;</span>
	<span class="s3">const </span><span class="s1">isFolder =</span>
		<span class="s1">relativePath.charCodeAt(relativePath.length - </span><span class="s5">1</span><span class="s1">) === slashCode;</span>

	<span class="s3">if </span><span class="s1">(isFolder !== expectFolder) {</span>
		<span class="s3">throw new </span><span class="s1">Error(</span>
			<span class="s1">expectFolder</span>
				<span class="s1">? </span><span class="s2">`Expecting folder to folder mapping. </span><span class="s1">${JSON.stringify(</span>
						<span class="s1">imp,</span>
					<span class="s1">)} </span><span class="s2">should end with &quot;/&quot;`</span>
				<span class="s1">: </span><span class="s2">`Expecting file to file mapping. </span><span class="s1">${JSON.stringify(</span>
						<span class="s1">imp,</span>
					<span class="s1">)} </span><span class="s2">should not end with &quot;/&quot;`</span><span class="s1">,</span>
		<span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@param </span><span class="s0">{ImportsField} importsField the exports field</span>
 <span class="s0">* </span><span class="s4">@returns </span><span class="s0">{FieldProcessor} process callback</span>
 <span class="s0">*/</span>
<span class="s1">module.exports.processImportsField = </span><span class="s3">function </span><span class="s1">processImportsField(</span>
	<span class="s1">importsField,</span>
<span class="s1">) {</span>
	<span class="s3">return </span><span class="s1">createFieldProcessor(</span>
		<span class="s1">importsField,</span>
		<span class="s1">(request) =&gt; </span><span class="s2">`#</span><span class="s1">${request}</span><span class="s2">`</span><span class="s1">,</span>
		<span class="s1">assertImportsFieldRequest,</span>
		<span class="s1">assertImportTarget,</span>
	<span class="s1">);</span>
<span class="s1">};</span>
</pre>
</body>
</html>