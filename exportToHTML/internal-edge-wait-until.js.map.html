<html>
<head>
<title>internal-edge-wait-until.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
internal-edge-wait-until.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/web/internal-edge-wait-until.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// An internal module to expose the </span><span class="s3">\&quot;</span><span class="s1">waitUntil</span><span class="s3">\&quot; </span><span class="s1">API to Edge SSR and Edge Route Handler functions.</span><span class="s3">\n</span><span class="s1">// This is highly experimental and subject to change.</span><span class="s3">\n\n</span><span class="s1">// We still need a global key to bypass Webpack's layering of modules.</span><span class="s3">\n</span><span class="s1">const GLOBAL_KEY = Symbol.for('__next_internal_waitUntil__')</span><span class="s3">\n\n</span><span class="s1">const state: {</span><span class="s3">\n  </span><span class="s1">waitUntilCounter: number</span><span class="s3">\n  </span><span class="s1">waitUntilResolve: () =&gt; void</span><span class="s3">\n  </span><span class="s1">waitUntilPromise: Promise&lt;void&gt; | null</span><span class="s3">\n</span><span class="s1">} =</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">globalThis[GLOBAL_KEY] ||</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">(globalThis[GLOBAL_KEY] = {</span><span class="s3">\n    </span><span class="s1">waitUntilCounter: 0,</span><span class="s3">\n    </span><span class="s1">waitUntilResolve: undefined,</span><span class="s3">\n    </span><span class="s1">waitUntilPromise: null,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">// No matter how many concurrent requests are being handled, we want to make sure</span><span class="s3">\n</span><span class="s1">// that the final promise is only resolved once all of the waitUntil promises have</span><span class="s3">\n</span><span class="s1">// settled.</span><span class="s3">\n</span><span class="s1">function resolveOnePromise() {</span><span class="s3">\n  </span><span class="s1">state.waitUntilCounter--</span><span class="s3">\n  </span><span class="s1">if (state.waitUntilCounter === 0) {</span><span class="s3">\n    </span><span class="s1">state.waitUntilResolve()</span><span class="s3">\n    </span><span class="s1">state.waitUntilPromise = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function internal_getCurrentFunctionWaitUntil() {</span><span class="s3">\n  </span><span class="s1">return state.waitUntilPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function internal_runWithWaitUntil&lt;T&gt;(fn: () =&gt; T): T {</span><span class="s3">\n  </span><span class="s1">const result = fn()</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">result &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof result === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'then' in result &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'finally' in result &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof result.then === 'function' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof result.finally === 'function'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!state.waitUntilCounter) {</span><span class="s3">\n      </span><span class="s1">// Create the promise for the next batch of waitUntil calls.</span><span class="s3">\n      </span><span class="s1">state.waitUntilPromise = new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n        </span><span class="s1">state.waitUntilResolve = resolve</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state.waitUntilCounter++</span><span class="s3">\n    </span><span class="s1">return result.finally(() =&gt; {</span><span class="s3">\n      </span><span class="s1">resolveOnePromise()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;internal_getCurrentFunctionWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;internal_runWithWaitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;GLOBAL_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntilCounter&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntilResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntilPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveOnePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;finally&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,iGAAiG;AACjG,qDAAqD;AAErD,sEAAsE;;;;;;;;;;;;;;;;IA4BtDA,oCAAoC;eAApCA;;IAIAC,yBAAyB;eAAzBA;;;AA/BhB,MAAMC,aAAaC,OAAOC,GAAG,CAAC;AAE9B,MAAMC,QAKJ,aAAa;AACbC,UAAU,CAACJ,WAAW,IACtB,aAAa;AACZI,CAAAA,UAAU,CAACJ,WAAW,GAAG;IACxBK,kBAAkB;IAClBC,kBAAkBC;IAClBC,kBAAkB;AACpB,CAAA;AAEF,iFAAiF;AACjF,kFAAkF;AAClF,WAAW;AACX,SAASC;IACPN,MAAME,gBAAgB;IACtB,IAAIF,MAAME,gBAAgB,KAAK,GAAG;QAChCF,MAAMG,gBAAgB;QACtBH,MAAMK,gBAAgB,GAAG;IAC3B;AACF;AAEO,SAASV;IACd,OAAOK,MAAMK,gBAAgB;AAC/B;AAEO,SAAST,0BAA6BW,EAAW;IACtD,MAAMC,SAASD;IACf,IACEC,UACA,OAAOA,WAAW,YAClB,UAAUA,UACV,aAAaA,UACb,OAAOA,OAAOC,IAAI,KAAK,cACvB,OAAOD,OAAOE,OAAO,KAAK,YAC1B;QACA,IAAI,CAACV,MAAME,gBAAgB,EAAE;YAC3B,4DAA4D;YAC5DF,MAAMK,gBAAgB,GAAG,IAAIM,QAAc,CAACC;gBAC1CZ,MAAMG,gBAAgB,GAAGS;YAC3B;QACF;QACAZ,MAAME,gBAAgB;QACtB,OAAOM,OAAOE,OAAO,CAAC;YACpBJ;QACF;IACF;IAEA,OAAOE;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>