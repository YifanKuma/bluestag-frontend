<html>
<head>
<title>LRUCache.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
LRUCache.js</font>
</center></td></tr></table>
<pre><span class="s0">// https://medium.com/dsinjs/implementing-lru-cache-in-javascript-94ba6755cda9</span>

<span class="s2">class </span><span class="s1">Node {</span>
  <span class="s1">constructor(key, value, next = </span><span class="s2">null</span><span class="s1">, prev = </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.key = key;</span>
    <span class="s2">this</span><span class="s1">.value = value;</span>
    <span class="s2">this</span><span class="s1">.next = next;</span>
    <span class="s2">this</span><span class="s1">.prev = prev;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">export default class </span><span class="s1">LRUCache {</span>
  <span class="s0">//set default limit of 10 if limit is not passed.</span>
  <span class="s1">constructor(limit = </span><span class="s3">10</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.size = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.limit = limit;</span>
    <span class="s2">this</span><span class="s1">.head = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.tail = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.cache = {};</span>
  <span class="s1">}</span>

  <span class="s0">// Write Node to head of LinkedList</span>
  <span class="s0">// update cache with Node key and Node reference</span>
  <span class="s1">put(key, value){</span>
    <span class="s2">this</span><span class="s1">.ensureLimit();</span>

    <span class="s2">if</span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.head){</span>
      <span class="s2">this</span><span class="s1">.head = </span><span class="s2">this</span><span class="s1">.tail = </span><span class="s2">new </span><span class="s1">Node(key, value);</span>
    <span class="s1">}</span><span class="s2">else</span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">node = </span><span class="s2">new </span><span class="s1">Node(key, value, </span><span class="s2">this</span><span class="s1">.head);</span>
      <span class="s2">this</span><span class="s1">.head.prev = node;</span>
      <span class="s2">this</span><span class="s1">.head = node;</span>
    <span class="s1">}</span>

    <span class="s0">//Update the cache map</span>
    <span class="s2">this</span><span class="s1">.cache[key] = </span><span class="s2">this</span><span class="s1">.head;</span>
    <span class="s2">this</span><span class="s1">.size++;</span>
  <span class="s1">}</span>

  <span class="s0">// Read from cache map and make that node as new Head of LinkedList</span>
  <span class="s1">get(key){</span>
    <span class="s2">if</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.cache[key]){</span>
      <span class="s2">const </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.cache[key].value;</span>

      <span class="s0">// node removed from it's position and cache</span>
      <span class="s2">this</span><span class="s1">.remove(key)</span>
      <span class="s0">// write node again to the head of LinkedList to make it most recently used</span>
      <span class="s2">this</span><span class="s1">.put(key, value);</span>

      <span class="s2">return </span><span class="s1">value;</span>
    <span class="s1">}</span>

    <span class="s1">console.log(</span><span class="s4">`Item not available in cache for key </span><span class="s1">${key}</span><span class="s4">`</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">ensureLimit(){</span>
    <span class="s2">if</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.size === </span><span class="s2">this</span><span class="s1">.limit){</span>
      <span class="s2">this</span><span class="s1">.remove(</span><span class="s2">this</span><span class="s1">.tail.key)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">remove(key){</span>
    <span class="s2">const </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.cache[key];</span>

    <span class="s2">if</span><span class="s1">(node.prev !== </span><span class="s2">null</span><span class="s1">){</span>
      <span class="s1">node.prev.next = node.next;</span>
    <span class="s1">}</span><span class="s2">else</span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.head = node.next;</span>
    <span class="s1">}</span>

    <span class="s2">if</span><span class="s1">(node.next !== </span><span class="s2">null</span><span class="s1">){</span>
      <span class="s1">node.next.prev = node.prev;</span>
    <span class="s1">}</span><span class="s2">else</span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.tail = node.prev</span>
    <span class="s1">}</span>

    <span class="s2">delete this</span><span class="s1">.cache[key];</span>
    <span class="s2">this</span><span class="s1">.size--;</span>
  <span class="s1">}</span>

  <span class="s1">clear() {</span>
    <span class="s2">this</span><span class="s1">.head = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.tail = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.size = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.cache = {};</span>
  <span class="s1">}</span>

  <span class="s0">// // Invokes the callback function with every node of the chain and the index of the node.</span>
  <span class="s0">// forEach(fn) {</span>
  <span class="s0">//   let node = this.head;</span>
  <span class="s0">//   let counter = 0;</span>
  <span class="s0">//   while (node) {</span>
  <span class="s0">//     fn(node, counter);</span>
  <span class="s0">//     node = node.next;</span>
  <span class="s0">//     counter++;</span>
  <span class="s0">//   }</span>
  <span class="s0">// }</span>

  <span class="s0">// // To iterate over LRU with a 'for...of' loop</span>
  <span class="s0">// *[Symbol.iterator]() {</span>
  <span class="s0">//   let node = this.head;</span>
  <span class="s0">//   while (node) {</span>
  <span class="s0">//     yield node;</span>
  <span class="s0">//     node = node.next;</span>
  <span class="s0">//   }</span>
  <span class="s0">// }</span>
<span class="s1">}</span></pre>
</body>
</html>