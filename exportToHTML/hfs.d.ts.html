<html>
<head>
<title>hfs.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hfs.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Error to represent when a method is missing on an impl.</span>
 <span class="s0">*/</span>
<span class="s2">export class </span><span class="s1">NoSuchMethodError </span><span class="s2">extends </span><span class="s1">Error {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string} methodName The name of the method that was missing.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor(methodName: string);</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Error to represent when a method is not supported on an impl. This happens</span>
 <span class="s0">* when a method on `Hfs` is called with one name and the corresponding method</span>
 <span class="s0">* on the impl has a different name. (Example: `text()` and `bytes()`.)</span>
 <span class="s0">*/</span>
<span class="s2">export class </span><span class="s1">MethodNotSupportedError </span><span class="s2">extends </span><span class="s1">Error {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string} methodName The name of the method that was missing.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor(methodName: string);</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Error to represent when an impl is already set.</span>
 <span class="s0">*/</span>
<span class="s2">export class </span><span class="s1">ImplAlreadySetError </span><span class="s2">extends </span><span class="s1">Error {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor();</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* A class representing a log entry.</span>
 <span class="s0">*/</span>
<span class="s2">export class </span><span class="s1">LogEntry {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string} type The type of log entry.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{any} [data] The data associated with the log entry.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor(type: string, data?: any);</span>
    <span class="s0">/**</span>
     <span class="s0">* The type of log entry.</span>
     <span class="s0">* </span><span class="s3">@type </span><span class="s0">{string}</span>
     <span class="s0">*/</span>
    <span class="s1">type: string;</span>
    <span class="s0">/**</span>
     <span class="s0">* The data associated with the log entry.</span>
     <span class="s0">* </span><span class="s3">@type </span><span class="s0">{any}</span>
     <span class="s0">*/</span>
    <span class="s1">data: any;</span>
    <span class="s0">/**</span>
     <span class="s0">* The time at which the log entry was created.</span>
     <span class="s0">* </span><span class="s3">@type </span><span class="s0">{number}</span>
     <span class="s0">*/</span>
    <span class="s1">timestamp: number;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* A class representing a file system utility library.</span>
 <span class="s0">* </span><span class="s3">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s2">export class </span><span class="s1">Hfs </span><span class="s2">implements </span><span class="s1">HfsImpl {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{object} options The options for the instance.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{HfsImpl} options.impl The implementation to use.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor({ impl }: {</span>
        <span class="s1">impl: HfsImpl;</span>
    <span class="s1">});</span>
    <span class="s0">/**</span>
     <span class="s0">* Starts a new log with the given name.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string} name The name of the log to start;</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{void}</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} When the log already exists.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the name is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">logStart(name: string): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Ends a log with the given name and returns the entries.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string} name The name of the log to end.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Array&lt;LogEntry&gt;} The entries in the log.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} When the log does not exist.</span>
     <span class="s0">*/</span>
    <span class="s1">logEnd(name: string): Array&lt;LogEntry&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Determines if the current implementation is the base implementation.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{boolean} True if the current implementation is the base implementation.</span>
     <span class="s0">*/</span>
    <span class="s1">isBaseImpl(): boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets the implementation for this instance.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{object} impl The implementation to use.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s1">setImpl(impl: object): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resets the implementation for this instance back to its original.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s1">resetImpl(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the given file and returns the contents as text. Assumes UTF-8 encoding.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The file to read.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;string|undefined&gt;} The contents of the file.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">text(filePath: string | URL): Promise&lt;string | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The file to read.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;any|undefined&gt;} The contents of the file as JSON.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{SyntaxError} When the file contents are not valid JSON.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">json(filePath: string | URL): Promise&lt;any | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the given file and returns the contents as an ArrayBuffer.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The file to read.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;ArrayBuffer|undefined&gt;} The contents of the file as an ArrayBuffer.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">* </span><span class="s3">@deprecated </span><span class="s0">Use bytes() instead.</span>
     <span class="s0">*/</span>
    <span class="s1">arrayBuffer(filePath: string | URL): Promise&lt;ArrayBuffer | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the given file and returns the contents as an Uint8Array.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The file to read.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;Uint8Array|undefined&gt;} The contents of the file as an Uint8Array.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">bytes(filePath: string | URL): Promise&lt;Uint8Array | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Writes the given data to the given file. Creates any necessary directories along the way.</span>
     <span class="s0">* If the data is a string, UTF-8 encoding is used.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The file to write.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|ArrayBuffer|ArrayBufferView} contents The data to write.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is written.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">write(filePath: string | URL, contents: string | ArrayBuffer | ArrayBufferView): Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Appends the given data to the given file. Creates any necessary directories along the way.</span>
     <span class="s0">* If the data is a string, UTF-8 encoding is used.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The file to append to.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|ArrayBuffer|ArrayBufferView} contents The data to append.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is appended to.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file contents are not a string or ArrayBuffer.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} When the file cannot be appended to.</span>
     <span class="s0">*/</span>
    <span class="s1">append(filePath: string | URL, contents: string | ArrayBuffer | ArrayBufferView): Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Determines if the given file exists.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The file to check.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;boolean&gt;} True if the file exists.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">isFile(filePath: string | URL): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Determines if the given directory exists.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} dirPath The directory to check.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;boolean&gt;} True if the directory exists.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">isDirectory(dirPath: string | URL): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the given directory.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} dirPath The directory to create.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the directory is created.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">createDirectory(dirPath: string | URL): Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Deletes the given file or empty directory.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The file to delete.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves when the file or</span>
     <span class="s0">*   directory is deleted, true if the file or directory is deleted, false</span>
     <span class="s0">*   if the file or directory does not exist.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">delete</span><span class="s1">(filePath: string | URL): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Deletes the given file or directory recursively.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} dirPath The directory to delete.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves when the file or</span>
     <span class="s0">*   directory is deleted, true if the file or directory is deleted, false</span>
     <span class="s0">*   if the file or directory does not exist.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s1">deleteAll(dirPath: string | URL): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a list of directory entries for the given path.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} dirPath The path to the directory to read.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{AsyncIterable&lt;HfsDirectoryEntry&gt;} A promise that resolves with the</span>
     <span class="s0">*   directory entries.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the directory path is not a string or URL.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} If the directory cannot be read.</span>
     <span class="s0">*/</span>
    <span class="s1">list(dirPath: string | URL): AsyncIterable&lt;HfsDirectoryEntry&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Walks a directory using a depth-first traversal and returns the entries</span>
     <span class="s0">* from the traversal.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} dirPath The path to the directory to walk.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{Object} [options] The options for the walk.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{(entry:HfsWalkEntry) =&gt; Promise&lt;boolean&gt;|boolean} [options.directoryFilter] A filter function to determine</span>
     <span class="s0">* 	if a directory's entries should be included in the walk.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{(entry:HfsWalkEntry) =&gt; Promise&lt;boolean&gt;|boolean} [options.entryFilter] A filter function to determine if</span>
     <span class="s0">* 	an entry should be included in the walk.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{AsyncIterable&lt;HfsWalkEntry&gt;} A promise that resolves with the</span>
     <span class="s0">* 	directory entries.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the directory path is not a string or URL.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} If the directory cannot be read.</span>
     <span class="s0">*/</span>
    <span class="s1">walk(dirPath: string | URL, { directoryFilter, entryFilter }?: {</span>
        <span class="s1">directoryFilter?: (entry: HfsWalkEntry) =&gt; Promise&lt;boolean&gt; | boolean;</span>
        <span class="s1">entryFilter?: (entry: HfsWalkEntry) =&gt; Promise&lt;boolean&gt; | boolean;</span>
    <span class="s1">}): AsyncIterable&lt;HfsWalkEntry&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the size of the given file.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;number&gt;} A promise that resolves with the size of the file.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the file path is not a string or URL.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
     <span class="s0">*/</span>
    <span class="s1">size(filePath: string | URL): Promise&lt;number&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the last modified timestamp of the given file or directory.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} fileOrDirPath The path to the file or directory.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;Date|undefined&gt;} A promise that resolves with the last modified date</span>
     <span class="s0">*  or undefined if the file or directory does not exist.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the path is not a string or URL.</span>
     <span class="s0">*/</span>
    <span class="s1">lastModified(fileOrDirPath: string | URL): Promise&lt;Date | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Copys a file from one location to another.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} source The path to the file to copy.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} destination The path to the new file.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is copied.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the file path is not a string or URL.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} If the file cannot be copied.</span>
     <span class="s0">*/</span>
    <span class="s1">copy(source: string | URL, destination: string | URL): Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Copies a file or directory from one location to another.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} source The path to the file or directory to copy.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} destination The path to copy the file or directory to.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file or directory is</span>
     <span class="s0">* copied.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the directory path is not a string or URL.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} If the directory cannot be copied.</span>
     <span class="s0">*/</span>
    <span class="s1">copyAll(source: string | URL, destination: string | URL): Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Moves a file from the source path to the destination path.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} source The location of the file to move.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} destination The destination of the file to move.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the move is complete.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the file or directory paths are not strings.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} If the file or directory cannot be moved.</span>
     <span class="s0">*/</span>
    <span class="s1">move(source: string | URL, destination: string | URL): Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Moves a file or directory from one location to another.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} source The path to the file or directory to move.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">{string|URL} destination The path to move the file or directory to.</span>
     <span class="s0">* </span><span class="s3">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file or directory is</span>
     <span class="s0">* moved.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the source is not a string or URL.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{TypeError} If the destination is not a string or URL.</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">{Error} If the file or directory cannot be moved.</span>
     <span class="s0">*/</span>
    <span class="s1">moveAll(source: string | URL, destination: string | URL): Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;;</span>
    <span class="s1">#private;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">type HfsImpl = </span><span class="s2">import</span><span class="s1">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s1">).HfsImpl;</span>
<span class="s2">export </span><span class="s1">type HfsDirectoryEntry = </span><span class="s2">import</span><span class="s1">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s1">).HfsDirectoryEntry;</span>
<span class="s2">export </span><span class="s1">type HfsWalkEntry = </span><span class="s2">import</span><span class="s1">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s1">).HfsWalkEntry;</span>
</pre>
</body>
</html>