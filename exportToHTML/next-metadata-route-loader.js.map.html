<html>
<head>
<title>next-metadata-route-loader.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-metadata-route-loader.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/build/webpack/loaders/next-metadata-route-loader.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type webpack from 'webpack'</span><span class="s3">\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import { imageExtMimeTypeMap } from '../../../lib/mime-type'</span><span class="s3">\n</span><span class="s1">import { getLoaderModuleNamedExports } from './utils'</span><span class="s3">\n\n</span><span class="s1">function errorOnBadHandler(resourcePath: string) {</span><span class="s3">\n  </span><span class="s1">return `</span><span class="s3">\n  </span><span class="s1">if (typeof handler !== 'function') {</span><span class="s3">\n    </span><span class="s1">throw new Error('Default export is missing in ${JSON.stringify(</span><span class="s3">\n      </span><span class="s1">resourcePath</span><span class="s3">\n    </span><span class="s1">)}')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* re-export the userland route configs */</span><span class="s3">\n</span><span class="s1">async function createReExportsCode(</span><span class="s3">\n  </span><span class="s1">resourcePath: string,</span><span class="s3">\n  </span><span class="s1">loaderContext: webpack.LoaderContext&lt;any&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const exportNames = await getLoaderModuleNamedExports(</span><span class="s3">\n    </span><span class="s1">resourcePath,</span><span class="s3">\n    </span><span class="s1">loaderContext</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">// Re-export configs but avoid conflicted exports</span><span class="s3">\n  </span><span class="s1">const reExportNames = exportNames.filter(</span><span class="s3">\n    </span><span class="s1">(name) =&gt; name !== 'default' &amp;&amp; name !== 'generateSitemaps'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return reExportNames.length &gt; 0</span><span class="s3">\n    </span><span class="s1">? `export { ${reExportNames.join(', ')} } from ${JSON.stringify(</span><span class="s3">\n        </span><span class="s1">resourcePath</span><span class="s3">\n      </span><span class="s1">)}</span><span class="s3">\\</span><span class="s1">n`</span><span class="s3">\n    </span><span class="s1">: ''</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const cacheHeader = {</span><span class="s3">\n  </span><span class="s1">none: 'no-cache, no-store',</span><span class="s3">\n  </span><span class="s1">longCache: 'public, immutable, no-transform, max-age=31536000',</span><span class="s3">\n  </span><span class="s1">revalidate: 'public, max-age=0, must-revalidate',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type MetadataRouteLoaderOptions = {</span><span class="s3">\n  </span><span class="s1">// Using separate argument to avoid json being parsed and hit error</span><span class="s3">\n  </span><span class="s1">// x-ref: https://github.com/vercel/next.js/pull/62615</span><span class="s3">\n  </span><span class="s1">filePath: string</span><span class="s3">\n  </span><span class="s1">isDynamicRouteExtension: '1' | '0'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getFilenameAndExtension(resourcePath: string) {</span><span class="s3">\n  </span><span class="s1">const filename = path.basename(resourcePath)</span><span class="s3">\n  </span><span class="s1">const [name, ext] = filename.split('.', 2)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">ext,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getContentType(resourcePath: string) {</span><span class="s3">\n  </span><span class="s1">let { name, ext } = getFilenameAndExtension(resourcePath)</span><span class="s3">\n  </span><span class="s1">if (ext === 'jpg') ext = 'jpeg'</span><span class="s3">\n\n  </span><span class="s1">if (name === 'favicon' &amp;&amp; ext === 'ico') return 'image/x-icon'</span><span class="s3">\n  </span><span class="s1">if (name === 'sitemap') return 'application/xml'</span><span class="s3">\n  </span><span class="s1">if (name === 'robots') return 'text/plain'</span><span class="s3">\n  </span><span class="s1">if (name === 'manifest') return 'application/manifest+json'</span><span class="s3">\n\n  </span><span class="s1">if (ext === 'png' || ext === 'jpeg' || ext === 'ico' || ext === 'svg') {</span><span class="s3">\n    </span><span class="s1">return imageExtMimeTypeMap[ext]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return 'text/plain'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function getStaticAssetRouteCode(</span><span class="s3">\n  </span><span class="s1">resourcePath: string,</span><span class="s3">\n  </span><span class="s1">fileBaseName: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const cache =</span><span class="s3">\n    </span><span class="s1">fileBaseName === 'favicon'</span><span class="s3">\n      </span><span class="s1">? 'public, max-age=0, must-revalidate'</span><span class="s3">\n      </span><span class="s1">: process.env.NODE_ENV !== 'production'</span><span class="s3">\n        </span><span class="s1">? cacheHeader.none</span><span class="s3">\n        </span><span class="s1">: cacheHeader.longCache</span><span class="s3">\n\n  </span><span class="s1">const isTwitter = fileBaseName === 'twitter-image'</span><span class="s3">\n  </span><span class="s1">const isOpenGraph = fileBaseName === 'opengraph-image'</span><span class="s3">\n  </span><span class="s1">// Twitter image file size limit is 5MB.</span><span class="s3">\n  </span><span class="s1">// General Open Graph image file size limit is 8MB.</span><span class="s3">\n  </span><span class="s1">// x-ref: https://developer.x.com/en/docs/x-for-websites/cards/overview/summary</span><span class="s3">\n  </span><span class="s1">// x-ref(facebook): https://developers.facebook.com/docs/sharing/webmasters/images</span><span class="s3">\n  </span><span class="s1">const fileSizeLimit = isTwitter ? 5 : 8</span><span class="s3">\n  </span><span class="s1">const imgName = isTwitter ? 'Twitter' : 'Open Graph'</span><span class="s3">\n\n  </span><span class="s1">const code = `</span><span class="s3">\\\n</span><span class="s1">/* static asset route */</span><span class="s3">\n</span><span class="s1">import { NextResponse } from 'next/server'</span><span class="s3">\n\n</span><span class="s1">const contentType = ${JSON.stringify(getContentType(resourcePath))}</span><span class="s3">\n</span><span class="s1">const buffer = Buffer.from(${JSON.stringify(</span><span class="s3">\n    </span><span class="s1">(await fs.promises.readFile(resourcePath)).toString('base64')</span><span class="s3">\n  </span><span class="s1">)}, 'base64'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">if (${isTwitter || isOpenGraph}) {</span><span class="s3">\n  </span><span class="s1">const fileSizeInMB = buffer.byteLength / 1024 / 1024</span><span class="s3">\n  </span><span class="s1">if (fileSizeInMB &gt; ${fileSizeLimit}) {</span><span class="s3">\n    </span><span class="s1">throw new Error('File size for ${imgName} image ${JSON.stringify(resourcePath)} exceeds ${fileSizeLimit}MB. ' +</span><span class="s3">\n    \\</span><span class="s1">`(Current: </span><span class="s3">\\</span><span class="s1">${fileSizeInMB.toFixed(2)}MB)</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">` +</span><span class="s3">\n    </span><span class="s1">'Read more: https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#image-files-jpg-png-gif'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function GET() {</span><span class="s3">\n  </span><span class="s1">return new NextResponse(buffer, {</span><span class="s3">\n    </span><span class="s1">headers: {</span><span class="s3">\n      </span><span class="s1">'Content-Type': contentType,</span><span class="s3">\n      </span><span class="s1">'Cache-Control': ${JSON.stringify(cache)},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const dynamic = 'force-static'</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">return code</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function getDynamicTextRouteCode(</span><span class="s3">\n  </span><span class="s1">resourcePath: string,</span><span class="s3">\n  </span><span class="s1">loaderContext: webpack.LoaderContext&lt;any&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return `</span><span class="s3">\\\n</span><span class="s1">/* dynamic asset route */</span><span class="s3">\n</span><span class="s1">import { NextResponse } from 'next/server'</span><span class="s3">\n</span><span class="s1">import handler from ${JSON.stringify(resourcePath)}</span><span class="s3">\n</span><span class="s1">import { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'</span><span class="s3">\n\n</span><span class="s1">const contentType = ${JSON.stringify(getContentType(resourcePath))}</span><span class="s3">\n</span><span class="s1">const fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}</span><span class="s3">\n\n</span><span class="s1">${errorOnBadHandler(resourcePath)}</span><span class="s3">\n</span><span class="s1">${await createReExportsCode(resourcePath, loaderContext)}</span><span class="s3">\n\n</span><span class="s1">export async function GET() {</span><span class="s3">\n  </span><span class="s1">const data = await handler()</span><span class="s3">\n  </span><span class="s1">const content = resolveRouteData(data, fileType)</span><span class="s3">\n\n  </span><span class="s1">return new NextResponse(content, {</span><span class="s3">\n    </span><span class="s1">headers: {</span><span class="s3">\n      </span><span class="s1">'Content-Type': contentType,</span><span class="s3">\n      </span><span class="s1">'Cache-Control': ${JSON.stringify(cacheHeader.revalidate)},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// &lt;metadata-image&gt;/[id]/route.js</span><span class="s3">\n</span><span class="s1">async function getDynamicImageRouteCode(</span><span class="s3">\n  </span><span class="s1">resourcePath: string,</span><span class="s3">\n  </span><span class="s1">loaderContext: webpack.LoaderContext&lt;any&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return `</span><span class="s3">\\\n</span><span class="s1">/* dynamic image route */</span><span class="s3">\n</span><span class="s1">import { NextResponse } from 'next/server'</span><span class="s3">\n</span><span class="s1">import * as userland from ${JSON.stringify(resourcePath)}</span><span class="s3">\n\n</span><span class="s1">const imageModule = { ...userland }</span><span class="s3">\n\n</span><span class="s1">const handler = imageModule.default</span><span class="s3">\n</span><span class="s1">const generateImageMetadata = imageModule.generateImageMetadata</span><span class="s3">\n\n</span><span class="s1">${errorOnBadHandler(resourcePath)}</span><span class="s3">\n</span><span class="s1">${await createReExportsCode(resourcePath, loaderContext)}</span><span class="s3">\n\n</span><span class="s1">export async function GET(_, ctx) {</span><span class="s3">\n  </span><span class="s1">const params = await ctx.params</span><span class="s3">\n  </span><span class="s1">const { __metadata_id__, ...rest } = params || {}</span><span class="s3">\n  </span><span class="s1">const restParams = params ? rest : undefined</span><span class="s3">\n  </span><span class="s1">const targetId = __metadata_id__</span><span class="s3">\n  </span><span class="s1">let id = undefined</span><span class="s3">\n  \n  </span><span class="s1">if (generateImageMetadata) {</span><span class="s3">\n    </span><span class="s1">const imageMetadata = await generateImageMetadata({ params: restParams })</span><span class="s3">\n    </span><span class="s1">id = imageMetadata.find((item) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n        </span><span class="s1">if (item?.id == null) {</span><span class="s3">\n          </span><span class="s1">throw new Error('id property is required for every item returned from generateImageMetadata')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return item.id.toString() === targetId</span><span class="s3">\n    </span><span class="s1">})?.id</span><span class="s3">\n    </span><span class="s1">if (id == null) {</span><span class="s3">\n      </span><span class="s1">return new NextResponse('Not Found', {</span><span class="s3">\n        </span><span class="s1">status: 404,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return handler({ params: restParams, id })</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function getDynamicSitemapRouteCode(</span><span class="s3">\n  </span><span class="s1">resourcePath: string,</span><span class="s3">\n  </span><span class="s1">loaderContext: webpack.LoaderContext&lt;any&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let staticGenerationCode = ''</span><span class="s3">\n\n  </span><span class="s1">const exportNames = await getLoaderModuleNamedExports(</span><span class="s3">\n    </span><span class="s1">resourcePath,</span><span class="s3">\n    </span><span class="s1">loaderContext</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const hasGenerateSitemaps = exportNames.includes('generateSitemaps')</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'production' &amp;&amp; hasGenerateSitemaps) {</span><span class="s3">\n    </span><span class="s1">staticGenerationCode = `</span><span class="s3">\\\n    </span><span class="s1">/* dynamic sitemap route */</span><span class="s3">\n    </span><span class="s1">export async function generateStaticParams() {</span><span class="s3">\n      </span><span class="s1">const sitemaps = await sitemapModule.generateSitemaps()</span><span class="s3">\n      </span><span class="s1">const params = []</span><span class="s3">\n\n      </span><span class="s1">for (const item of sitemaps) {</span><span class="s3">\n        </span><span class="s1">params.push({ __metadata_id__: item.id.toString() + '.xml' })</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return params</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const code = `</span><span class="s3">\\\n</span><span class="s1">import { NextResponse } from 'next/server'</span><span class="s3">\n</span><span class="s1">import * as userland from ${JSON.stringify(resourcePath)}</span><span class="s3">\n</span><span class="s1">import { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'</span><span class="s3">\n\n</span><span class="s1">const sitemapModule = { ...userland }</span><span class="s3">\n</span><span class="s1">const handler = sitemapModule.default</span><span class="s3">\n</span><span class="s1">const contentType = ${JSON.stringify(getContentType(resourcePath))}</span><span class="s3">\n</span><span class="s1">const fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}</span><span class="s3">\n\n</span><span class="s1">${errorOnBadHandler(resourcePath)}</span><span class="s3">\n</span><span class="s1">${await createReExportsCode(resourcePath, loaderContext)}</span><span class="s3">\n\n</span><span class="s1">export async function GET(_, ctx) {</span><span class="s3">\n  </span><span class="s1">const { __metadata_id__: id, ...params } = await ctx.params || {}</span><span class="s3">\n  </span><span class="s1">const hasXmlExtension = id ? id.endsWith('.xml') : false</span><span class="s3">\n\n  </span><span class="s1">if (id &amp;&amp; !hasXmlExtension) {</span><span class="s3">\n    </span><span class="s1">return new NextResponse('Not Found', {</span><span class="s3">\n      </span><span class="s1">status: 404,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; sitemapModule.generateSitemaps) {</span><span class="s3">\n    </span><span class="s1">const sitemaps = await sitemapModule.generateSitemaps()</span><span class="s3">\n    </span><span class="s1">for (const item of sitemaps) {</span><span class="s3">\n      </span><span class="s1">if (item?.id == null) {</span><span class="s3">\n        </span><span class="s1">throw new Error('id property is required for every item returned from generateSitemaps')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const targetId = id &amp;&amp; hasXmlExtension ? id.slice(0, -4) : undefined</span><span class="s3">\n\n  </span><span class="s1">const data = await handler({ id: targetId })</span><span class="s3">\n  </span><span class="s1">const content = resolveRouteData(data, fileType)</span><span class="s3">\n\n  </span><span class="s1">return new NextResponse(content, {</span><span class="s3">\n    </span><span class="s1">headers: {</span><span class="s3">\n      </span><span class="s1">'Content-Type': contentType,</span><span class="s3">\n      </span><span class="s1">'Cache-Control': ${JSON.stringify(cacheHeader.revalidate)},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">${staticGenerationCode}</span><span class="s3">\n</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">return code</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// When it's static route, it could be favicon.ico, sitemap.xml, robots.txt etc.</span><span class="s3">\n</span><span class="s1">// TODO-METADATA: improve the cache control strategy</span><span class="s3">\n</span><span class="s1">const nextMetadataRouterLoader: webpack.LoaderDefinitionFunction&lt;MetadataRouteLoaderOptions&gt; =</span><span class="s3">\n  </span><span class="s1">async function () {</span><span class="s3">\n    </span><span class="s1">const { isDynamicRouteExtension, filePath } = this.getOptions()</span><span class="s3">\n    </span><span class="s1">const { name: fileBaseName } = getFilenameAndExtension(filePath)</span><span class="s3">\n    </span><span class="s1">this.addDependency(filePath)</span><span class="s3">\n\n    </span><span class="s1">let code = ''</span><span class="s3">\n    </span><span class="s1">if (isDynamicRouteExtension === '1') {</span><span class="s3">\n      </span><span class="s1">if (fileBaseName === 'robots' || fileBaseName === 'manifest') {</span><span class="s3">\n        </span><span class="s1">code = await getDynamicTextRouteCode(filePath, this)</span><span class="s3">\n      </span><span class="s1">} else if (fileBaseName === 'sitemap') {</span><span class="s3">\n        </span><span class="s1">code = await getDynamicSitemapRouteCode(filePath, this)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">code = await getDynamicImageRouteCode(filePath, this)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">code = await getStaticAssetRouteCode(filePath, fileBaseName)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return code</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default nextMetadataRouterLoader</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getFilenameAndExtension&quot;</span><span class="s0">,</span><span class="s1">&quot;errorOnBadHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;resourcePath&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;createReExportsCode&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderContext&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNames&quot;</span><span class="s0">,</span><span class="s1">&quot;getLoaderModuleNamedExports&quot;</span><span class="s0">,</span><span class="s1">&quot;reExportNames&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;none&quot;</span><span class="s0">,</span><span class="s1">&quot;longCache&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;basename&quot;</span><span class="s0">,</span><span class="s1">&quot;ext&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;getContentType&quot;</span><span class="s0">,</span><span class="s1">&quot;imageExtMimeTypeMap&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticAssetRouteCode&quot;</span><span class="s0">,</span><span class="s1">&quot;fileBaseName&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;isTwitter&quot;</span><span class="s0">,</span><span class="s1">&quot;isOpenGraph&quot;</span><span class="s0">,</span><span class="s1">&quot;fileSizeLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;imgName&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicTextRouteCode&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicImageRouteCode&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicSitemapRouteCode&quot;</span><span class="s0">,</span><span class="s1">&quot;staticGenerationCode&quot;</span><span class="s0">,</span><span class="s1">&quot;hasGenerateSitemaps&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;nextMetadataRouterLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRouteExtension&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;getOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;addDependency&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>