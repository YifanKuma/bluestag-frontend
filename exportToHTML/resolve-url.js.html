<html>
<head>
<title>resolve-url.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve-url.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">getSocialImageMetadataBaseFallback: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">isStringOrURL: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">resolveAbsoluteUrlWithPathname: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">resolveRelativeUrl: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">resolveUrl: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">getSocialImageMetadataBaseFallback: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getSocialImageMetadataBaseFallback;</span>
    <span class="s1">},</span>
    <span class="s1">isStringOrURL: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">isStringOrURL;</span>
    <span class="s1">},</span>
    <span class="s1">resolveAbsoluteUrlWithPathname: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">resolveAbsoluteUrlWithPathname;</span>
    <span class="s1">},</span>
    <span class="s1">resolveRelativeUrl: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">resolveRelativeUrl;</span>
    <span class="s1">},</span>
    <span class="s1">resolveUrl: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">resolveUrl;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../../../shared/lib/isomorphic/path&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isStringOrURL(icon) {</span>
    <span class="s2">return typeof </span><span class="s1">icon === </span><span class="s0">'string' </span><span class="s1">|| icon </span><span class="s2">instanceof </span><span class="s1">URL;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createLocalMetadataBase() {</span>
    <span class="s4">// Check if experimental HTTPS is enabled</span>
    <span class="s2">const </span><span class="s1">isExperimentalHttps = Boolean(process.env.__NEXT_EXPERIMENTAL_HTTPS);</span>
    <span class="s2">const </span><span class="s1">protocol = isExperimentalHttps ? </span><span class="s0">'https' </span><span class="s1">: </span><span class="s0">'http'</span><span class="s1">;</span>
    <span class="s2">return new </span><span class="s1">URL(</span><span class="s0">`</span><span class="s1">${protocol}</span><span class="s0">://localhost:</span><span class="s1">${process.env.PORT || </span><span class="s3">3000</span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPreviewDeploymentUrl() {</span>
    <span class="s2">const </span><span class="s1">origin = process.env.VERCEL_BRANCH_URL || process.env.VERCEL_URL;</span>
    <span class="s2">return </span><span class="s1">origin ? </span><span class="s2">new </span><span class="s1">URL(</span><span class="s0">`https://</span><span class="s1">${origin}</span><span class="s0">`</span><span class="s1">) : undefined;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getProductionDeploymentUrl() {</span>
    <span class="s2">const </span><span class="s1">origin = process.env.VERCEL_PROJECT_PRODUCTION_URL;</span>
    <span class="s2">return </span><span class="s1">origin ? </span><span class="s2">new </span><span class="s1">URL(</span><span class="s0">`https://</span><span class="s1">${origin}</span><span class="s0">`</span><span class="s1">) : undefined;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSocialImageMetadataBaseFallback(metadataBase) {</span>
    <span class="s2">const </span><span class="s1">defaultMetadataBase = createLocalMetadataBase();</span>
    <span class="s2">const </span><span class="s1">previewDeploymentUrl = getPreviewDeploymentUrl();</span>
    <span class="s2">const </span><span class="s1">productionDeploymentUrl = getProductionDeploymentUrl();</span>
    <span class="s2">let </span><span class="s1">fallbackMetadataBase;</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
        <span class="s1">fallbackMetadataBase = defaultMetadataBase;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">fallbackMetadataBase = process.env.NODE_ENV === </span><span class="s0">'production' </span><span class="s1">&amp;&amp; previewDeploymentUrl &amp;&amp; process.env.VERCEL_ENV === </span><span class="s0">'preview' </span><span class="s1">? previewDeploymentUrl : metadataBase || productionDeploymentUrl || defaultMetadataBase;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">fallbackMetadataBase;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveUrl(url, metadataBase) {</span>
    <span class="s2">if </span><span class="s1">(url </span><span class="s2">instanceof </span><span class="s1">URL) </span><span class="s2">return </span><span class="s1">url;</span>
    <span class="s2">if </span><span class="s1">(!url) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s4">// If we can construct a URL instance from url, ignore metadataBase</span>
        <span class="s2">const </span><span class="s1">parsedUrl = </span><span class="s2">new </span><span class="s1">URL(url);</span>
        <span class="s2">return </span><span class="s1">parsedUrl;</span>
    <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{}</span>
    <span class="s2">if </span><span class="s1">(!metadataBase) {</span>
        <span class="s1">metadataBase = createLocalMetadataBase();</span>
    <span class="s1">}</span>
    <span class="s4">// Handle relative or absolute paths</span>
    <span class="s2">const </span><span class="s1">pathname = metadataBase.pathname || </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">joinedPath = _path.default.posix.join(pathname, url);</span>
    <span class="s2">return new </span><span class="s1">URL(joinedPath, metadataBase);</span>
<span class="s1">}</span>
<span class="s4">// Resolve with `pathname` if `url` is a relative path.</span>
<span class="s2">function </span><span class="s1">resolveRelativeUrl(url, pathname) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">url === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; url.startsWith(</span><span class="s0">'./'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">_path.default.posix.resolve(pathname, url);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">url;</span>
<span class="s1">}</span>
<span class="s4">// The regex is matching logic from packages/next/src/lib/load-custom-routes.ts</span>
<span class="s2">const </span><span class="s1">FILE_REGEX = </span><span class="s5">/^(?:\/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+))(\/?|$)/i</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">isFilePattern(pathname) {</span>
    <span class="s2">return </span><span class="s1">FILE_REGEX.test(pathname);</span>
<span class="s1">}</span>
<span class="s4">// Resolve `pathname` if `url` is a relative path the compose with `metadataBase`.</span>
<span class="s2">function </span><span class="s1">resolveAbsoluteUrlWithPathname(url, metadataBase, pathname, { trailingSlash }) {</span>
    <span class="s4">// Resolve url with pathname that always starts with `/`</span>
    <span class="s1">url = resolveRelativeUrl(url, pathname);</span>
    <span class="s4">// Convert string url or URL instance to absolute url string,</span>
    <span class="s4">// if there's case needs to be resolved with metadataBase</span>
    <span class="s2">let </span><span class="s1">resolvedUrl = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">result = metadataBase ? resolveUrl(url, metadataBase) : url;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">result === </span><span class="s0">'string'</span><span class="s1">) {</span>
        <span class="s1">resolvedUrl = result;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">resolvedUrl = result.pathname === </span><span class="s0">'/' </span><span class="s1">? result.origin : result.href;</span>
    <span class="s1">}</span>
    <span class="s4">// Add trailing slash if it's enabled for urls matches the condition</span>
    <span class="s4">// - Not external, same origin with metadataBase</span>
    <span class="s4">// - Doesn't have query</span>
    <span class="s2">if </span><span class="s1">(trailingSlash &amp;&amp; !resolvedUrl.endsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
        <span class="s2">let </span><span class="s1">isRelative = resolvedUrl.startsWith(</span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s2">let </span><span class="s1">hasQuery = resolvedUrl.includes(</span><span class="s0">'?'</span><span class="s1">);</span>
        <span class="s2">let </span><span class="s1">isExternal = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">isFileUrl = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!isRelative) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">parsedUrl = </span><span class="s2">new </span><span class="s1">URL(resolvedUrl);</span>
                <span class="s1">isExternal = metadataBase != </span><span class="s2">null </span><span class="s1">&amp;&amp; parsedUrl.origin !== metadataBase.origin;</span>
                <span class="s1">isFileUrl = isFilePattern(parsedUrl.pathname);</span>
            <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
                <span class="s4">// If it's not a valid URL, treat it as external</span>
                <span class="s1">isExternal = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s4">// Do not apply trailing slash for file like urls, aligning with the behavior with `trailingSlash`</span>
            <span class="s1">!isFileUrl &amp;&amp; !isExternal &amp;&amp; !hasQuery) </span><span class="s2">return </span><span class="s0">`</span><span class="s1">${resolvedUrl}</span><span class="s0">/`</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolvedUrl;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=resolve-url.js.map</span></pre>
</body>
</html>