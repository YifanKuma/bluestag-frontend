<html>
<head>
<title>fill-lazy-items-till-leaf-with-head.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fill-lazy-items-till-leaf-with-head.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">fillLazyItemsTillLeafWithHead;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_createroutercachekey = require(</span><span class="s0">&quot;./create-router-cache-key&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerreducertypes = require(</span><span class="s0">&quot;./router-reducer-types&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">fillLazyItemsTillLeafWithHead(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {</span>
    <span class="s2">const </span><span class="s1">isLastSegment = Object.keys(routerState[</span><span class="s3">1</span><span class="s1">]).length === </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(isLastSegment) {</span>
        <span class="s1">newCache.head = head;</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// Remove segment that we got data for so that it is filled in during rendering of rsc.</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">routerState[</span><span class="s3">1</span><span class="s1">]){</span>
        <span class="s2">const </span><span class="s1">parallelRouteState = routerState[</span><span class="s3">1</span><span class="s1">][key];</span>
        <span class="s2">const </span><span class="s1">segmentForParallelRoute = parallelRouteState[</span><span class="s3">0</span><span class="s1">];</span>
        <span class="s2">const </span><span class="s1">cacheKey = (</span><span class="s3">0</span><span class="s1">, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);</span>
        <span class="s4">// TODO: We should traverse the cacheNodeSeedData tree instead of the router</span>
        <span class="s4">// state tree. Ideally, they would always be the same shape, but because of</span>
        <span class="s4">// the loading.js pattern, cacheNodeSeedData sometimes only represents a</span>
        <span class="s4">// partial tree. That's why this node is sometimes null. Once PPR lands,</span>
        <span class="s4">// loading.js will no longer have special behavior and we can traverse the</span>
        <span class="s4">// data tree instead.</span>
        <span class="s4">//</span>
        <span class="s4">// We should also consider merging the router state tree and the data tree</span>
        <span class="s4">// in the response format, so that we don't have to send the keys twice.</span>
        <span class="s4">// Then the client can convert them into separate representations.</span>
        <span class="s2">const </span><span class="s1">parallelSeedData = cacheNodeSeedData !== </span><span class="s2">null </span><span class="s1">&amp;&amp; cacheNodeSeedData[</span><span class="s3">2</span><span class="s1">][key] !== undefined ? cacheNodeSeedData[</span><span class="s3">2</span><span class="s1">][key] : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(existingCache) {</span>
            <span class="s2">const </span><span class="s1">existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);</span>
            <span class="s2">if </span><span class="s1">(existingParallelRoutesCacheNode) {</span>
                <span class="s2">const </span><span class="s1">hasReusablePrefetch = (prefetchEntry == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: prefetchEntry.kind) === </span><span class="s0">'auto' </span><span class="s1">&amp;&amp; prefetchEntry.status === _routerreducertypes.PrefetchCacheEntryStatus.reusable;</span>
                <span class="s2">let </span><span class="s1">parallelRouteCacheNode = </span><span class="s2">new </span><span class="s1">Map(existingParallelRoutesCacheNode);</span>
                <span class="s2">const </span><span class="s1">existingCacheNode = parallelRouteCacheNode.get(cacheKey);</span>
                <span class="s2">let </span><span class="s1">newCacheNode;</span>
                <span class="s2">if </span><span class="s1">(parallelSeedData !== </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s4">// New data was sent from the server.</span>
                    <span class="s2">const </span><span class="s1">seedNode = parallelSeedData[</span><span class="s3">1</span><span class="s1">];</span>
                    <span class="s2">const </span><span class="s1">loading = parallelSeedData[</span><span class="s3">3</span><span class="s1">];</span>
                    <span class="s1">newCacheNode = {</span>
                        <span class="s1">lazyData: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">rsc: seedNode,</span>
                        <span class="s4">// This is a PPR-only field. When PPR is enabled, we shouldn't hit</span>
                        <span class="s4">// this path during a navigation, but until PPR is fully implemented</span>
                        <span class="s4">// yet it's possible the existing node does have a non-null</span>
                        <span class="s4">// `prefetchRsc`. As an incremental step, we'll just de-opt to the</span>
                        <span class="s4">// old behavior â€” no PPR value.</span>
                        <span class="s1">prefetchRsc: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">head: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">prefetchHead: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">loading,</span>
                        <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(existingCacheNode == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: existingCacheNode.parallelRoutes),</span>
                        <span class="s1">navigatedAt</span>
                    <span class="s1">};</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasReusablePrefetch &amp;&amp; existingCacheNode) {</span>
                    <span class="s4">// No new data was sent from the server, but the existing cache node</span>
                    <span class="s4">// was prefetched, so we should reuse that.</span>
                    <span class="s1">newCacheNode = {</span>
                        <span class="s1">lazyData: existingCacheNode.lazyData,</span>
                        <span class="s1">rsc: existingCacheNode.rsc,</span>
                        <span class="s4">// This is a PPR-only field. Unlike the previous branch, since we're</span>
                        <span class="s4">// just cloning the existing cache node, we might as well keep the</span>
                        <span class="s4">// PPR value, if it exists.</span>
                        <span class="s1">prefetchRsc: existingCacheNode.prefetchRsc,</span>
                        <span class="s1">head: existingCacheNode.head,</span>
                        <span class="s1">prefetchHead: existingCacheNode.prefetchHead,</span>
                        <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(existingCacheNode.parallelRoutes),</span>
                        <span class="s1">loading: existingCacheNode.loading</span>
                    <span class="s1">};</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// No data available for this node. This will trigger a lazy fetch</span>
                    <span class="s4">// during render.</span>
                    <span class="s1">newCacheNode = {</span>
                        <span class="s1">lazyData: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">rsc: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">prefetchRsc: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">head: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">prefetchHead: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(existingCacheNode == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: existingCacheNode.parallelRoutes),</span>
                        <span class="s1">loading: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">navigatedAt</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
                <span class="s4">// Overrides the cache key with the new cache node.</span>
                <span class="s1">parallelRouteCacheNode.set(cacheKey, newCacheNode);</span>
                <span class="s4">// Traverse deeper to apply the head / fill lazy items till the head.</span>
                <span class="s1">fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : </span><span class="s2">null</span><span class="s1">, head, prefetchEntry);</span>
                <span class="s1">newCache.parallelRoutes.set(key, parallelRouteCacheNode);</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">newCacheNode;</span>
        <span class="s2">if </span><span class="s1">(parallelSeedData !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s4">// New data was sent from the server.</span>
            <span class="s2">const </span><span class="s1">seedNode = parallelSeedData[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">loading = parallelSeedData[</span><span class="s3">3</span><span class="s1">];</span>
            <span class="s1">newCacheNode = {</span>
                <span class="s1">lazyData: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">rsc: seedNode,</span>
                <span class="s1">prefetchRsc: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">head: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchHead: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(),</span>
                <span class="s1">loading,</span>
                <span class="s1">navigatedAt</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// No data available for this node. This will trigger a lazy fetch</span>
            <span class="s4">// during render.</span>
            <span class="s1">newCacheNode = {</span>
                <span class="s1">lazyData: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">rsc: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchRsc: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">head: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchHead: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(),</span>
                <span class="s1">loading: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">navigatedAt</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">existingParallelRoutes = newCache.parallelRoutes.get(key);</span>
        <span class="s2">if </span><span class="s1">(existingParallelRoutes) {</span>
            <span class="s1">existingParallelRoutes.set(cacheKey, newCacheNode);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">newCache.parallelRoutes.set(key, </span><span class="s2">new </span><span class="s1">Map([</span>
                <span class="s1">[</span>
                    <span class="s1">cacheKey,</span>
                    <span class="s1">newCacheNode</span>
                <span class="s1">]</span>
            <span class="s1">]));</span>
        <span class="s1">}</span>
        <span class="s1">fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map</span></pre>
</body>
</html>