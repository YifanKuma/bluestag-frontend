<html>
<head>
<title>fsx.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fsx.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">The main file for the hfs package.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Nicholas C. Zakas</span>
 <span class="s0">*/</span>
<span class="s0">/** </span><span class="s1">@typedef</span><span class="s0">{import(&quot;@humanfs/types&quot;).HfsImpl} HfsImpl */</span>
<span class="s0">/** </span><span class="s1">@typedef</span><span class="s0">{import(&quot;@humanfs/types&quot;).HfsDirectoryEntry} HfsDirectoryEntry */</span>
<span class="s0">/**</span>
 <span class="s0">* Error to represent when a method is missing on an impl.</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">NoSuchMethodError </span><span class="s3">extends </span><span class="s2">Error {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method that was missing.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor(methodName: string);</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* Error to represent when an impl is already set.</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">ImplAlreadySetError </span><span class="s3">extends </span><span class="s2">Error {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor();</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* A class representing a log entry.</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">LogEntry {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} type The type of log entry.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} [data] The data associated with the log entry.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor(type: string, data?: any);</span>
    <span class="s0">/**</span>
     <span class="s0">* The time at which the log entry was created.</span>
     <span class="s0">* </span><span class="s1">@type </span><span class="s0">{number}</span>
     <span class="s0">*/</span>
    <span class="s2">timestamp: number;</span>
    <span class="s2">methodName: string;</span>
    <span class="s2">data: any;</span>
    <span class="s2">#private;</span>
<span class="s2">}</span>
<span class="s0">/**</span>
 <span class="s0">* A class representing a file system utility library.</span>
 <span class="s0">* </span><span class="s1">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">Hfs </span><span class="s3">implements </span><span class="s2">HfsImpl {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} options The options for the instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{HfsImpl} options.impl The implementation to use.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor({ impl }: {</span>
        <span class="s2">impl: HfsImpl;</span>
    <span class="s2">});</span>
    <span class="s0">/**</span>
     <span class="s0">* Starts a new log with the given name.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name The name of the log to start;</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} When the log already exists.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the name is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">logStart(name: string): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Ends a log with the given name and returns the entries.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name The name of the log to end.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;LogEntry&gt;} The entries in the log.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} When the log does not exist.</span>
     <span class="s0">*/</span>
    <span class="s2">logEnd(name: string): Array&lt;LogEntry&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Determines if the current implementation is the base implementation.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the current implementation is the base implementation.</span>
     <span class="s0">*/</span>
    <span class="s2">isBaseImpl(): boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets the implementation for this instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} impl The implementation to use.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">setImpl(impl: object): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resets the implementation for this instance back to its original.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">resetImpl(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the given file and returns the contents as text. Assumes UTF-8 encoding.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The file to read.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;string|undefined&gt;} The contents of the file.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">text(filePath: string): Promise&lt;string | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The file to read.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;any|undefined&gt;} The contents of the file as JSON.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{SyntaxError} When the file contents are not valid JSON.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">json(filePath: string): Promise&lt;any | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the given file and returns the contents as an ArrayBuffer.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The file to read.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;ArrayBuffer|undefined&gt;} The contents of the file as an ArrayBuffer.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">Use bytes() instead.</span>
     <span class="s0">*/</span>
    <span class="s2">arrayBuffer(filePath: string): Promise&lt;ArrayBuffer | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the given file and returns the contents as an Uint8Array.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The file to read.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;Uint8Array|undefined&gt;} The contents of the file as an Uint8Array.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">bytes(filePath: string): Promise&lt;Uint8Array | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Writes the given data to the given file. Creates any necessary directories along the way.</span>
     <span class="s0">* If the data is a string, UTF-8 encoding is used.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The file to write.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} contents The data to write.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is written.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">write(filePath: string, contents: any): Promise&lt;</span><span class="s3">void</span><span class="s2">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Determines if the given file exists.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The file to check.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} True if the file exists.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">isFile(filePath: string): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Determines if the given directory exists.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} dirPath The directory to check.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} True if the directory exists.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">isDirectory(dirPath: string): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the given directory.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} dirPath The directory to create.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the directory is created.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">createDirectory(dirPath: string): Promise&lt;</span><span class="s3">void</span><span class="s2">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Deletes the given file.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The file to delete.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is deleted.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s3">delete</span><span class="s2">(filePath: string): Promise&lt;</span><span class="s3">void</span><span class="s2">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Deletes the given directory.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} dirPath The directory to delete.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the directory is deleted.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
     <span class="s0">*/</span>
    <span class="s2">deleteAll(dirPath: string): Promise&lt;</span><span class="s3">void</span><span class="s2">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a list of directory entries for the given path.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} dirPath The path to the directory to read.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncIterable&lt;HfsDirectoryEntry&gt;} A promise that resolves with the</span>
     <span class="s0">*   directory entries.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the directory path is not a string.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the directory cannot be read.</span>
     <span class="s0">*/</span>
    <span class="s2">list(dirPath: string): AsyncIterable&lt;HfsDirectoryEntry&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the size of the given file.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;number&gt;} A promise that resolves with the size of the file.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
     <span class="s0">*/</span>
    <span class="s2">size(filePath: string): Promise&lt;number&gt;;</span>
    <span class="s2">#private;</span>
<span class="s2">}</span>
<span class="s3">export </span><span class="s2">type HfsImpl = </span><span class="s3">import</span><span class="s2">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s2">).HfsImpl;</span>
<span class="s3">export </span><span class="s2">type HfsDirectoryEntry = </span><span class="s3">import</span><span class="s2">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s2">).HfsDirectoryEntry;</span>
</pre>
</body>
</html>