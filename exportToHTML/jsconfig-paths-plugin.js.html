<html>
<head>
<title>jsconfig-paths-plugin.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
jsconfig-paths-plugin.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* This webpack resolver is largely based on TypeScript's &quot;paths&quot; handling</span>
 <span class="s0">* The TypeScript license can be found here:</span>
 <span class="s0">* https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt</span>
 <span class="s0">*/ </span><span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s4">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">JsConfigPathsPlugin: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">findBestPatternMatch: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">hasZeroOrOneAsteriskCharacter: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">isString: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">matchPatternOrExact: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">matchedText: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">pathIsRelative: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">patternText: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">tryParsePattern: </span><span class="s3">null</span>
<span class="s1">});</span>
<span class="s3">function </span><span class="s1">_export(target, all) {</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">name </span><span class="s3">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">JsConfigPathsPlugin: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">JsConfigPathsPlugin;</span>
    <span class="s1">},</span>
    <span class="s1">findBestPatternMatch: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">findBestPatternMatch;</span>
    <span class="s1">},</span>
    <span class="s1">hasZeroOrOneAsteriskCharacter: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">hasZeroOrOneAsteriskCharacter;</span>
    <span class="s1">},</span>
    <span class="s1">isString: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">isString;</span>
    <span class="s1">},</span>
    <span class="s1">matchPatternOrExact: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">matchPatternOrExact;</span>
    <span class="s1">},</span>
    <span class="s1">matchedText: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">matchedText;</span>
    <span class="s1">},</span>
    <span class="s1">pathIsRelative: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">pathIsRelative;</span>
    <span class="s1">},</span>
    <span class="s1">patternText: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">patternText;</span>
    <span class="s1">},</span>
    <span class="s1">tryParsePattern: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">tryParsePattern;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_path = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_debug = require(</span><span class="s2">&quot;next/dist/compiled/debug&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s3">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s3">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">log = (</span><span class="s4">0</span><span class="s1">, _debug.debug)(</span><span class="s2">'next:jsconfig-paths-plugin'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">asterisk = </span><span class="s4">0x2a</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">hasZeroOrOneAsteriskCharacter(str) {</span>
    <span class="s3">let </span><span class="s1">seenAsterisk = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; str.length; i++){</span>
        <span class="s3">if </span><span class="s1">(str.charCodeAt(i) === asterisk) {</span>
            <span class="s3">if </span><span class="s1">(!seenAsterisk) {</span>
                <span class="s1">seenAsterisk = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s0">// have already seen asterisk</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pathIsRelative(testPath) {</span>
    <span class="s3">return </span><span class="s5">/^\.\.?($|[\\/])/</span><span class="s1">.test(testPath);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">tryParsePattern(pattern) {</span>
    <span class="s0">// This should be verified outside of here and a proper error thrown.</span>
    <span class="s3">const </span><span class="s1">indexOfStar = pattern.indexOf(</span><span class="s2">'*'</span><span class="s1">);</span>
    <span class="s3">return </span><span class="s1">indexOfStar === -</span><span class="s4">1 </span><span class="s1">? undefined : {</span>
        <span class="s1">prefix: pattern.slice(</span><span class="s4">0</span><span class="s1">, indexOfStar),</span>
        <span class="s1">suffix: pattern.slice(indexOfStar + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isPatternMatch({ prefix, suffix }, candidate) {</span>
    <span class="s3">return </span><span class="s1">candidate.length &gt;= prefix.length + suffix.length &amp;&amp; candidate.startsWith(prefix) &amp;&amp; candidate.endsWith(suffix);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">findBestPatternMatch(values, getPattern, candidate) {</span>
    <span class="s3">let </span><span class="s1">matchedValue;</span>
    <span class="s0">// use length of prefix as betterness criteria</span>
    <span class="s3">let </span><span class="s1">longestMatchPrefixLength = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">v of values){</span>
        <span class="s3">const </span><span class="s1">pattern = getPattern(v);</span>
        <span class="s3">if </span><span class="s1">(isPatternMatch(pattern, candidate) &amp;&amp; pattern.prefix.length &gt; longestMatchPrefixLength) {</span>
            <span class="s1">longestMatchPrefixLength = pattern.prefix.length;</span>
            <span class="s1">matchedValue = v;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">matchedValue;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">matchPatternOrExact(patternStrings, candidate) {</span>
    <span class="s3">const </span><span class="s1">patterns = [];</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">patternString of patternStrings){</span>
        <span class="s3">if </span><span class="s1">(!hasZeroOrOneAsteriskCharacter(patternString)) </span><span class="s3">continue</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s1">pattern = tryParsePattern(patternString);</span>
        <span class="s3">if </span><span class="s1">(pattern) {</span>
            <span class="s1">patterns.push(pattern);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(patternString === candidate) {</span>
            <span class="s0">// pattern was matched as is - no need to search further</span>
            <span class="s3">return </span><span class="s1">patternString;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">findBestPatternMatch(patterns, (_)=&gt;_, candidate);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isString(text) {</span>
    <span class="s3">return typeof </span><span class="s1">text === </span><span class="s2">'string'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">matchedText(pattern, candidate) {</span>
    <span class="s3">return </span><span class="s1">candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">patternText({ prefix, suffix }) {</span>
    <span class="s3">return </span><span class="s2">`</span><span class="s1">${prefix}</span><span class="s2">*</span><span class="s1">${suffix}</span><span class="s2">`</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Calls the iterator function for each entry of the array</span>
 <span class="s0">* until the first result or error is reached</span>
 <span class="s0">*/ </span><span class="s3">function </span><span class="s1">forEachBail(array, iterator, callback) {</span>
    <span class="s3">if </span><span class="s1">(array.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">callback();</span>
    <span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">next = ()=&gt;{</span>
        <span class="s3">let </span><span class="s1">loop = undefined;</span>
        <span class="s1">iterator(array[i++], (err, result)=&gt;{</span>
            <span class="s3">if </span><span class="s1">(err || result !== undefined || i &gt;= array.length) {</span>
                <span class="s3">return </span><span class="s1">callback(err, result);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(loop === </span><span class="s3">false</span><span class="s1">) </span><span class="s3">while</span><span class="s1">(next());</span>
            <span class="s1">loop = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s3">if </span><span class="s1">(!loop) loop = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">loop;</span>
    <span class="s1">};</span>
    <span class="s3">while</span><span class="s1">(next());</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">NODE_MODULES_REGEX = </span><span class="s5">/node_modules/</span><span class="s1">;</span>
<span class="s3">class </span><span class="s1">JsConfigPathsPlugin {</span>
    <span class="s1">constructor(paths, resolvedBaseUrl){</span>
        <span class="s3">this</span><span class="s1">.paths = paths;</span>
        <span class="s3">this</span><span class="s1">.resolvedBaseUrl = resolvedBaseUrl;</span>
        <span class="s3">this</span><span class="s1">.jsConfigPlugin = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">log(</span><span class="s2">'tsconfig.json or jsconfig.json paths: %O'</span><span class="s1">, paths);</span>
        <span class="s1">log(</span><span class="s2">'resolved baseUrl: %s'</span><span class="s1">, resolvedBaseUrl);</span>
    <span class="s1">}</span>
    <span class="s1">apply(resolver) {</span>
        <span class="s3">const </span><span class="s1">target = resolver.ensureHook(</span><span class="s2">'resolve'</span><span class="s1">);</span>
        <span class="s1">resolver.getHook(</span><span class="s2">'described-resolve'</span><span class="s1">).tapAsync(</span><span class="s2">'JsConfigPathsPlugin'</span><span class="s1">, (request, resolveContext, callback)=&gt;{</span>
            <span class="s3">const </span><span class="s1">resolvedBaseUrl = </span><span class="s3">this</span><span class="s1">.resolvedBaseUrl;</span>
            <span class="s3">if </span><span class="s1">(resolvedBaseUrl === undefined) {</span>
                <span class="s3">return </span><span class="s1">callback();</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">paths = </span><span class="s3">this</span><span class="s1">.paths;</span>
            <span class="s3">const </span><span class="s1">pathsKeys = Object.keys(paths);</span>
            <span class="s0">// If no aliases are added bail out</span>
            <span class="s3">if </span><span class="s1">(pathsKeys.length === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">log(</span><span class="s2">'paths are empty, bailing out'</span><span class="s1">);</span>
                <span class="s3">return </span><span class="s1">callback();</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">moduleName = request.request;</span>
            <span class="s0">// Exclude node_modules from paths support (speeds up resolving)</span>
            <span class="s3">if </span><span class="s1">(request.path.match(NODE_MODULES_REGEX)) {</span>
                <span class="s1">log(</span><span class="s2">'skipping request as it is inside node_modules %s'</span><span class="s1">, moduleName);</span>
                <span class="s3">return </span><span class="s1">callback();</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(_path.default.posix.isAbsolute(moduleName) || process.platform === </span><span class="s2">'win32' </span><span class="s1">&amp;&amp; _path.default.win32.isAbsolute(moduleName)) {</span>
                <span class="s1">log(</span><span class="s2">'skipping request as it is an absolute path %s'</span><span class="s1">, moduleName);</span>
                <span class="s3">return </span><span class="s1">callback();</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(pathIsRelative(moduleName)) {</span>
                <span class="s1">log(</span><span class="s2">'skipping request as it is a relative path %s'</span><span class="s1">, moduleName);</span>
                <span class="s3">return </span><span class="s1">callback();</span>
            <span class="s1">}</span>
            <span class="s0">// log('starting to resolve request %s', moduleName)</span>
            <span class="s0">// If the module name does not match any of the patterns in `paths` we hand off resolving to webpack</span>
            <span class="s3">const </span><span class="s1">matchedPattern = matchPatternOrExact(pathsKeys, moduleName);</span>
            <span class="s3">if </span><span class="s1">(!matchedPattern) {</span>
                <span class="s1">log(</span><span class="s2">'moduleName did not match any paths pattern %s'</span><span class="s1">, moduleName);</span>
                <span class="s3">return </span><span class="s1">callback();</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">matchedStar = isString(matchedPattern) ? undefined : matchedText(matchedPattern, moduleName);</span>
            <span class="s3">const </span><span class="s1">matchedPatternText = isString(matchedPattern) ? matchedPattern : patternText(matchedPattern);</span>
            <span class="s3">let </span><span class="s1">triedPaths = [];</span>
            <span class="s1">forEachBail(paths[matchedPatternText], (subst, pathCallback)=&gt;{</span>
                <span class="s3">const </span><span class="s1">curPath = matchedStar ? subst.replace(</span><span class="s2">'*'</span><span class="s1">, matchedStar) : subst;</span>
                <span class="s0">// Ensure .d.ts is not matched</span>
                <span class="s3">if </span><span class="s1">(curPath.endsWith(</span><span class="s2">'.d.ts'</span><span class="s1">)) {</span>
                    <span class="s0">// try next path candidate</span>
                    <span class="s3">return </span><span class="s1">pathCallback();</span>
                <span class="s1">}</span>
                <span class="s3">const </span><span class="s1">candidate = _path.default.join(resolvedBaseUrl.baseUrl, curPath);</span>
                <span class="s3">const </span><span class="s1">obj = Object.assign({}, request, {</span>
                    <span class="s1">request: candidate</span>
                <span class="s1">});</span>
                <span class="s1">resolver.doResolve(target, obj, </span><span class="s2">`Aliased with tsconfig.json or jsconfig.json </span><span class="s1">${matchedPatternText} </span><span class="s2">to </span><span class="s1">${candidate}</span><span class="s2">`</span><span class="s1">, resolveContext, (resolverErr, resolverResult)=&gt;{</span>
                    <span class="s3">if </span><span class="s1">(resolverErr || resolverResult === undefined) {</span>
                        <span class="s1">triedPaths.push(candidate);</span>
                        <span class="s0">// try next path candidate</span>
                        <span class="s3">return </span><span class="s1">pathCallback();</span>
                    <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">pathCallback(resolverErr, resolverResult);</span>
                <span class="s1">});</span>
            <span class="s1">}, callback);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=jsconfig-paths-plugin.js.map</span></pre>
</body>
</html>