<html>
<head>
<title>extractNationalNumberFromPossiblyIncompleteNumber.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extractNationalNumberFromPossiblyIncompleteNumber.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Strips any national prefix (such as 0, 1) present in a</span>
 <span class="s0">* (possibly incomplete) number provided.</span>
 <span class="s0">* &quot;Carrier codes&quot; are only used  in Colombia and Brazil,</span>
 <span class="s0">* and only when dialing within those countries from a mobile phone to a fixed line number.</span>
 <span class="s0">* Sometimes it won't actually strip national prefix</span>
 <span class="s0">* and will instead prepend some digits to the `number`:</span>
 <span class="s0">* for example, when number `2345678` is passed with `VI` country selected,</span>
 <span class="s0">* it will return `{ number: &quot;3402345678&quot; }`, because `340` area code is prepended.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} number — National number digits.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} metadata — Metadata with country selected.</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">{object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.</span>
 <span class="s0">*/</span>
<span class="s3">export default function </span><span class="s2">extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {</span>
	<span class="s3">if </span><span class="s2">(number &amp;&amp; metadata.numberingPlan.nationalPrefixForParsing()) {</span>
		<span class="s0">// See METADATA.md for the description of</span>
		<span class="s0">// `national_prefix_for_parsing` and `national_prefix_transform_rule`.</span>
		<span class="s0">// Attempt to parse the first digits as a national prefix.</span>
		<span class="s3">const </span><span class="s2">prefixPattern = </span><span class="s3">new </span><span class="s2">RegExp(</span><span class="s4">'^(?:' </span><span class="s2">+ metadata.numberingPlan.nationalPrefixForParsing() + </span><span class="s4">')'</span><span class="s2">)</span>
		<span class="s3">const </span><span class="s2">prefixMatch = prefixPattern.exec(number)</span>
		<span class="s3">if </span><span class="s2">(prefixMatch) {</span>
			<span class="s3">let </span><span class="s2">nationalNumber</span>
			<span class="s3">let </span><span class="s2">carrierCode</span>
			<span class="s0">// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule</span>
			<span class="s0">// If a `national_prefix_for_parsing` has any &quot;capturing groups&quot;</span>
			<span class="s0">// then it means that the national (significant) number is equal to</span>
			<span class="s0">// those &quot;capturing groups&quot; transformed via `national_prefix_transform_rule`,</span>
			<span class="s0">// and nothing could be said about the actual national prefix:</span>
			<span class="s0">// what is it and was it even there.</span>
			<span class="s0">// If a `national_prefix_for_parsing` doesn't have any &quot;capturing groups&quot;,</span>
			<span class="s0">// then everything it matches is a national prefix.</span>
			<span class="s0">// To determine whether `national_prefix_for_parsing` matched any</span>
			<span class="s0">// &quot;capturing groups&quot;, the value of the result of calling `.exec()`</span>
			<span class="s0">// is looked at, and if it has non-undefined values where there're</span>
			<span class="s0">// &quot;capturing groups&quot; in the regular expression, then it means</span>
			<span class="s0">// that &quot;capturing groups&quot; have been matched.</span>
			<span class="s0">// It's not possible to tell whether there'll be any &quot;capturing gropus&quot;</span>
			<span class="s0">// before the matching process, because a `national_prefix_for_parsing`</span>
			<span class="s0">// could exhibit both behaviors.</span>
			<span class="s3">const </span><span class="s2">capturedGroupsCount = prefixMatch.length - </span><span class="s5">1</span>
			<span class="s3">const </span><span class="s2">hasCapturedGroups = capturedGroupsCount &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; prefixMatch[capturedGroupsCount]</span>
			<span class="s3">if </span><span class="s2">(metadata.nationalPrefixTransformRule() &amp;&amp; hasCapturedGroups) {</span>
				<span class="s2">nationalNumber = number.replace(</span>
					<span class="s2">prefixPattern,</span>
					<span class="s2">metadata.nationalPrefixTransformRule()</span>
				<span class="s2">)</span>
				<span class="s0">// If there's more than one captured group,</span>
				<span class="s0">// then carrier code is the second one.</span>
				<span class="s3">if </span><span class="s2">(capturedGroupsCount &gt; </span><span class="s5">1</span><span class="s2">) {</span>
					<span class="s2">carrierCode = prefixMatch[</span><span class="s5">1</span><span class="s2">]</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
			<span class="s0">// If there're no &quot;capturing groups&quot;,</span>
			<span class="s0">// or if there're &quot;capturing groups&quot; but no</span>
			<span class="s0">// `national_prefix_transform_rule`,</span>
			<span class="s0">// then just strip the national prefix from the number,</span>
			<span class="s0">// and possibly a carrier code.</span>
			<span class="s0">// Seems like there could be more.</span>
			<span class="s3">else </span><span class="s2">{</span>
				<span class="s0">// `prefixBeforeNationalNumber` is the whole substring matched by</span>
				<span class="s0">// the `national_prefix_for_parsing` regular expression.</span>
				<span class="s0">// There seem to be no guarantees that it's just a national prefix.</span>
				<span class="s0">// For example, if there's a carrier code, it's gonna be a</span>
				<span class="s0">// part of `prefixBeforeNationalNumber` too.</span>
				<span class="s3">const </span><span class="s2">prefixBeforeNationalNumber = prefixMatch[</span><span class="s5">0</span><span class="s2">]</span>
				<span class="s2">nationalNumber = number.slice(prefixBeforeNationalNumber.length)</span>
				<span class="s0">// If there's at least one captured group,</span>
				<span class="s0">// then carrier code is the first one.</span>
				<span class="s3">if </span><span class="s2">(hasCapturedGroups) {</span>
					<span class="s2">carrierCode = prefixMatch[</span><span class="s5">1</span><span class="s2">]</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
			<span class="s0">// Tries to guess whether a national prefix was present in the input.</span>
			<span class="s0">// This is not something copy-pasted from Google's library:</span>
			<span class="s0">// they don't seem to have an equivalent for that.</span>
			<span class="s0">// So this isn't an &quot;officially approved&quot; way of doing something like that.</span>
			<span class="s0">// But since there seems no other existing method, this library uses it.</span>
			<span class="s3">let </span><span class="s2">nationalPrefix</span>
			<span class="s3">if </span><span class="s2">(hasCapturedGroups) {</span>
				<span class="s3">const </span><span class="s2">possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[</span><span class="s5">1</span><span class="s2">])</span>
				<span class="s3">const </span><span class="s2">possibleNationalPrefix = number.slice(</span><span class="s5">0</span><span class="s2">, possiblePositionOfTheFirstCapturedGroup)</span>
				<span class="s0">// Example: an Argentinian (AR) phone number `0111523456789`.</span>
				<span class="s0">// `prefixMatch[0]` is `01115`, and `$1` is `11`,</span>
				<span class="s0">// and the rest of the phone number is `23456789`.</span>
				<span class="s0">// The national number is transformed via `9$1` to `91123456789`.</span>
				<span class="s0">// National prefix `0` is detected being present at the start.</span>
				<span class="s0">// if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {</span>
				<span class="s3">if </span><span class="s2">(possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {</span>
					<span class="s2">nationalPrefix = metadata.numberingPlan.nationalPrefix()</span>
				<span class="s2">}</span>
			<span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
				<span class="s2">nationalPrefix = prefixMatch[</span><span class="s5">0</span><span class="s2">]</span>
			<span class="s2">}</span>
			<span class="s3">return </span><span class="s2">{</span>
				<span class="s2">nationalNumber,</span>
				<span class="s2">nationalPrefix,</span>
				<span class="s2">carrierCode</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
	<span class="s2">}</span>
   <span class="s3">return </span><span class="s2">{</span>
   	<span class="s2">nationalNumber: number</span>
   <span class="s2">}</span>
<span class="s2">}</span></pre>
</body>
</html>