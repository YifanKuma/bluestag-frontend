<html>
<head>
<title>supports.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #264eff;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
supports.js</font>
</center></td></tr></table>
<pre><span class="s0">let </span><span class="s1">featureQueries = require(</span><span class="s2">'caniuse-lite/data/features/css-featurequeries.js'</span><span class="s1">)</span>
<span class="s0">let </span><span class="s1">feature = require(</span><span class="s2">'caniuse-lite/dist/unpacker/feature'</span><span class="s1">)</span>
<span class="s0">let </span><span class="s1">{ parse } = require(</span><span class="s2">'postcss'</span><span class="s1">)</span>

<span class="s0">let </span><span class="s1">brackets = require(</span><span class="s2">'./brackets'</span><span class="s1">)</span>
<span class="s0">let </span><span class="s1">Browsers = require(</span><span class="s2">'./browsers'</span><span class="s1">)</span>
<span class="s0">let </span><span class="s1">utils = require(</span><span class="s2">'./utils'</span><span class="s1">)</span>
<span class="s0">let </span><span class="s1">Value = require(</span><span class="s2">'./value'</span><span class="s1">)</span>

<span class="s0">let </span><span class="s1">data = feature(featureQueries)</span>

<span class="s0">let </span><span class="s1">supported = []</span>
<span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">browser </span><span class="s0">in </span><span class="s1">data.stats) {</span>
  <span class="s0">let </span><span class="s1">versions = data.stats[browser]</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">version </span><span class="s0">in </span><span class="s1">versions) {</span>
    <span class="s0">let </span><span class="s1">support = versions[version]</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s3">/y/</span><span class="s1">.test(support)) {</span>
      <span class="s1">supported.push(browser + </span><span class="s2">' ' </span><span class="s1">+ version)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">class </span><span class="s1">Supports {</span>
  <span class="s1">constructor(Prefixes, all) {</span>
    <span class="s0">this</span><span class="s1">.Prefixes = Prefixes</span>
    <span class="s0">this</span><span class="s1">.all = all</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Add prefixes</span>
   <span class="s4">*/</span>
  <span class="s1">add(nodes, all) {</span>
    <span class="s0">return </span><span class="s1">nodes.map(i =&gt; {</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isProp(i)) {</span>
        <span class="s0">let </span><span class="s1">prefixed = </span><span class="s0">this</span><span class="s1">.prefixed(i[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">(prefixed.length &gt; </span><span class="s5">1</span><span class="s1">) {</span>
          <span class="s0">return this</span><span class="s1">.convert(prefixed)</span>
        <span class="s1">}</span>

        <span class="s0">return </span><span class="s1">i</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">i === </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s0">return this</span><span class="s1">.add(i, all)</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">i</span>
    <span class="s1">})</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Clean brackets with one child</span>
   <span class="s4">*/</span>
  <span class="s1">cleanBrackets(nodes) {</span>
    <span class="s0">return </span><span class="s1">nodes.map(i =&gt; {</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">i !== </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">i</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(i.length === </span><span class="s5">1 </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">i[</span><span class="s5">0</span><span class="s1">] === </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s0">return this</span><span class="s1">.cleanBrackets(i[</span><span class="s5">0</span><span class="s1">])</span>
      <span class="s1">}</span>

      <span class="s0">return this</span><span class="s1">.cleanBrackets(i)</span>
    <span class="s1">})</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Add &quot; or &quot; between properties and convert it to brackets format</span>
   <span class="s4">*/</span>
  <span class="s1">convert(progress) {</span>
    <span class="s0">let </span><span class="s1">result = [</span><span class="s2">''</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i of progress) {</span>
      <span class="s1">result.push([</span><span class="s2">`</span><span class="s1">${i.prop}</span><span class="s2">: </span><span class="s1">${i.value}</span><span class="s2">`</span><span class="s1">])</span>
      <span class="s1">result.push(</span><span class="s2">' or '</span><span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s1">result[result.length - </span><span class="s5">1</span><span class="s1">] = </span><span class="s2">''</span>
    <span class="s0">return </span><span class="s1">result</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Check global options</span>
   <span class="s4">*/</span>
  <span class="s1">disabled(node) {</span>
    <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.all.options.grid) {</span>
      <span class="s0">if </span><span class="s1">(node.prop === </span><span class="s2">'display' </span><span class="s1">&amp;&amp; node.value.includes(</span><span class="s2">'grid'</span><span class="s1">)) {</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(node.prop.includes(</span><span class="s2">'grid'</span><span class="s1">) || node.prop === </span><span class="s2">'justify-items'</span><span class="s1">) {</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.all.options.flexbox === </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(node.prop === </span><span class="s2">'display' </span><span class="s1">&amp;&amp; node.value.includes(</span><span class="s2">'flex'</span><span class="s1">)) {</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>
      <span class="s0">let </span><span class="s1">other = [</span><span class="s2">'order'</span><span class="s1">, </span><span class="s2">'justify-content'</span><span class="s1">, </span><span class="s2">'align-items'</span><span class="s1">, </span><span class="s2">'align-content'</span><span class="s1">]</span>
      <span class="s0">if </span><span class="s1">(node.prop.includes(</span><span class="s2">'flex'</span><span class="s1">) || other.includes(node.prop)) {</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">return false</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Return true if prefixed property has no unprefixed</span>
   <span class="s4">*/</span>
  <span class="s1">isHack(all, unprefixed) {</span>
    <span class="s0">let </span><span class="s1">check = </span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">`(</span><span class="s6">\\</span><span class="s2">(|</span><span class="s6">\\</span><span class="s2">s)</span><span class="s1">${utils.escapeRegexp(unprefixed)}</span><span class="s2">:`</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">!check.test(all)</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Return true if brackets node is &quot;not&quot; word</span>
   <span class="s4">*/</span>
  <span class="s1">isNot(node) {</span>
    <span class="s0">return typeof </span><span class="s1">node === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; </span><span class="s3">/not\s*/i</span><span class="s1">.test(node)</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Return true if brackets node is &quot;or&quot; word</span>
   <span class="s4">*/</span>
  <span class="s1">isOr(node) {</span>
    <span class="s0">return typeof </span><span class="s1">node === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; </span><span class="s3">/\s*or\s*/i</span><span class="s1">.test(node)</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Return true if brackets node is (prop: value)</span>
   <span class="s4">*/</span>
  <span class="s1">isProp(node) {</span>
    <span class="s0">return </span><span class="s1">(</span>
      <span class="s0">typeof </span><span class="s1">node === </span><span class="s2">'object' </span><span class="s1">&amp;&amp;</span>
      <span class="s1">node.length === </span><span class="s5">1 </span><span class="s1">&amp;&amp;</span>
      <span class="s0">typeof </span><span class="s1">node[</span><span class="s5">0</span><span class="s1">] === </span><span class="s2">'string'</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Compress value functions into a string nodes</span>
   <span class="s4">*/</span>
  <span class="s1">normalize(nodes) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">nodes !== </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s1">nodes</span>
    <span class="s1">}</span>

    <span class="s1">nodes = nodes.filter(i =&gt; i !== </span><span class="s2">''</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">nodes[</span><span class="s5">0</span><span class="s1">] === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s0">let </span><span class="s1">firstNode = nodes[</span><span class="s5">0</span><span class="s1">].trim()</span>

      <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">firstNode.includes(</span><span class="s2">':'</span><span class="s1">) ||</span>
        <span class="s1">firstNode === </span><span class="s2">'selector' </span><span class="s1">||</span>
        <span class="s1">firstNode === </span><span class="s2">'not selector'</span>
      <span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">[brackets.stringify(nodes)]</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">nodes.map(i =&gt; </span><span class="s0">this</span><span class="s1">.normalize(i))</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Parse string into declaration property and value</span>
   <span class="s4">*/</span>
  <span class="s1">parse(str) {</span>
    <span class="s0">let </span><span class="s1">parts = str.split(</span><span class="s2">':'</span><span class="s1">)</span>
    <span class="s0">let </span><span class="s1">prop = parts[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0">let </span><span class="s1">value = parts[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">(!value) value = </span><span class="s2">''</span>
    <span class="s0">return </span><span class="s1">[prop.trim(), value.trim()]</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Return array of Declaration with all necessary prefixes</span>
   <span class="s4">*/</span>
  <span class="s1">prefixed(str) {</span>
    <span class="s0">let </span><span class="s1">rule = </span><span class="s0">this</span><span class="s1">.virtual(str)</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.disabled(rule.first)) {</span>
      <span class="s0">return </span><span class="s1">rule.nodes</span>
    <span class="s1">}</span>

    <span class="s0">let </span><span class="s1">result = { warn: () =&gt; </span><span class="s0">null </span><span class="s1">}</span>

    <span class="s0">let </span><span class="s1">prefixer = </span><span class="s0">this</span><span class="s1">.prefixer().add[rule.first.prop]</span>
    <span class="s1">prefixer &amp;&amp; prefixer.process &amp;&amp; prefixer.process(rule.first, result)</span>

    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">decl of rule.nodes) {</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">value of </span><span class="s0">this</span><span class="s1">.prefixer().values(</span><span class="s2">'add'</span><span class="s1">, rule.first.prop)) {</span>
        <span class="s1">value.process(decl)</span>
      <span class="s1">}</span>
      <span class="s1">Value.save(</span><span class="s0">this</span><span class="s1">.all, decl)</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">rule.nodes</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Return prefixer only with @supports supported browsers</span>
   <span class="s4">*/</span>
  <span class="s1">prefixer() {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.prefixerCache) {</span>
      <span class="s0">return this</span><span class="s1">.prefixerCache</span>
    <span class="s1">}</span>

    <span class="s0">let </span><span class="s1">filtered = </span><span class="s0">this</span><span class="s1">.all.browsers.selected.filter(i =&gt; {</span>
      <span class="s0">return </span><span class="s1">supported.includes(i)</span>
    <span class="s1">})</span>

    <span class="s0">let </span><span class="s1">browsers = </span><span class="s0">new </span><span class="s1">Browsers(</span>
      <span class="s0">this</span><span class="s1">.all.browsers.data,</span>
      <span class="s1">filtered,</span>
      <span class="s0">this</span><span class="s1">.all.options</span>
    <span class="s1">)</span>
    <span class="s0">this</span><span class="s1">.prefixerCache = </span><span class="s0">new this</span><span class="s1">.Prefixes(</span>
      <span class="s0">this</span><span class="s1">.all.data,</span>
      <span class="s1">browsers,</span>
      <span class="s0">this</span><span class="s1">.all.options</span>
    <span class="s1">)</span>
    <span class="s0">return this</span><span class="s1">.prefixerCache</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Add prefixed declaration</span>
   <span class="s4">*/</span>
  <span class="s1">process(rule) {</span>
    <span class="s0">let </span><span class="s1">ast = brackets.parse(rule.params)</span>
    <span class="s1">ast = </span><span class="s0">this</span><span class="s1">.normalize(ast)</span>
    <span class="s1">ast = </span><span class="s0">this</span><span class="s1">.remove(ast, rule.params)</span>
    <span class="s1">ast = </span><span class="s0">this</span><span class="s1">.add(ast, rule.params)</span>
    <span class="s1">ast = </span><span class="s0">this</span><span class="s1">.cleanBrackets(ast)</span>
    <span class="s1">rule.params = brackets.stringify(ast)</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Remove all unnecessary prefixes</span>
   <span class="s4">*/</span>
  <span class="s1">remove(nodes, all) {</span>
    <span class="s0">let </span><span class="s1">i = </span><span class="s5">0</span>
    <span class="s0">while </span><span class="s1">(i &lt; nodes.length) {</span>
      <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">!</span><span class="s0">this</span><span class="s1">.isNot(nodes[i - </span><span class="s5">1</span><span class="s1">]) &amp;&amp;</span>
        <span class="s0">this</span><span class="s1">.isProp(nodes[i]) &amp;&amp;</span>
        <span class="s0">this</span><span class="s1">.isOr(nodes[i + </span><span class="s5">1</span><span class="s1">])</span>
      <span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.toRemove(nodes[i][</span><span class="s5">0</span><span class="s1">], all)) {</span>
          <span class="s1">nodes.splice(i, </span><span class="s5">2</span><span class="s1">)</span>
          <span class="s0">continue</span>
        <span class="s1">}</span>

        <span class="s1">i += </span><span class="s5">2</span>
        <span class="s0">continue</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">nodes[i] === </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s1">nodes[i] = </span><span class="s0">this</span><span class="s1">.remove(nodes[i], all)</span>
      <span class="s1">}</span>

      <span class="s1">i += </span><span class="s5">1</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">nodes</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Return true if we need to remove node</span>
   <span class="s4">*/</span>
  <span class="s1">toRemove(str, all) {</span>
    <span class="s0">let </span><span class="s1">[prop, value] = </span><span class="s0">this</span><span class="s1">.parse(str)</span>
    <span class="s0">let </span><span class="s1">unprefixed = </span><span class="s0">this</span><span class="s1">.all.unprefixed(prop)</span>

    <span class="s0">let </span><span class="s1">cleaner = </span><span class="s0">this</span><span class="s1">.all.cleaner()</span>

    <span class="s0">if </span><span class="s1">(</span>
      <span class="s1">cleaner.remove[prop] &amp;&amp;</span>
      <span class="s1">cleaner.remove[prop].remove &amp;&amp;</span>
      <span class="s1">!</span><span class="s0">this</span><span class="s1">.isHack(all, unprefixed)</span>
    <span class="s1">) {</span>
      <span class="s0">return true</span>
    <span class="s1">}</span>

    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">checker of cleaner.values(</span><span class="s2">'remove'</span><span class="s1">, unprefixed)) {</span>
      <span class="s0">if </span><span class="s1">(checker.check(value)) {</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">return false</span>
  <span class="s1">}</span>

  <span class="s4">/**</span>
   <span class="s4">* Create virtual rule to process it by prefixer</span>
   <span class="s4">*/</span>
  <span class="s1">virtual(str) {</span>
    <span class="s0">let </span><span class="s1">[prop, value] = </span><span class="s0">this</span><span class="s1">.parse(str)</span>
    <span class="s0">let </span><span class="s1">rule = parse(</span><span class="s2">'a{}'</span><span class="s1">).first</span>
    <span class="s1">rule.append({ prop, raws: { before: </span><span class="s2">'' </span><span class="s1">}, value })</span>
    <span class="s0">return </span><span class="s1">rule</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">module.exports = Supports</span>
</pre>
</body>
</html>