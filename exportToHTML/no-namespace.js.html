<html>
<head>
<title>no-namespace.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-namespace.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>




<span class="s2">var </span><span class="s1">_minimatch = require(</span><span class="s0">'minimatch'</span><span class="s1">);</span><span class="s2">var </span><span class="s1">_minimatch2 = _interopRequireDefault(_minimatch);</span>
<span class="s2">var </span><span class="s1">_contextCompat = require(</span><span class="s0">'eslint-module-utils/contextCompat'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_docsUrl = require(</span><span class="s0">'../docsUrl'</span><span class="s1">);</span><span class="s2">var </span><span class="s1">_docsUrl2 = _interopRequireDefault(_docsUrl);</span><span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s0">'default'</span><span class="s1">: obj };}</span>

<span class="s3">/**</span>
                                                                                                                                                                                       <span class="s3">* </span><span class="s4">@param </span><span class="s3">{MemberExpression} memberExpression</span>
                                                                                                                                                                                       <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} the name of the member in the object expression, e.g. the `x` in `namespace.x`</span>
                                                                                                                                                                                       <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getMemberPropertyName(memberExpression) {</span>
  <span class="s2">return </span><span class="s1">memberExpression.property.type === </span><span class="s0">'Identifier' </span><span class="s1">?</span>
  <span class="s1">memberExpression.property.name :</span>
  <span class="s1">memberExpression.property.value;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ScopeManager} scopeManager</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ASTNode} node</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Set&lt;string&gt;}</span>
   <span class="s3">*/ /**</span>
       <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Rule to disallow namespace import</span>
       <span class="s3">* </span><span class="s4">@author </span><span class="s3">Radek Benkel</span>
       <span class="s3">*/</span><span class="s2">function </span><span class="s1">getVariableNamesInScope(scopeManager, node) {</span><span class="s2">var </span><span class="s1">currentNode = node;</span><span class="s2">var </span><span class="s1">scope = scopeManager.acquire(currentNode);</span>
  <span class="s2">while </span><span class="s1">(scope == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">currentNode = currentNode.parent;</span>
    <span class="s1">scope = scopeManager.acquire(currentNode, </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">return new </span><span class="s1">Set(scope.variables.concat(scope.upper.variables).map(</span><span class="s2">function </span><span class="s1">(variable) {</span><span class="s2">return </span><span class="s1">variable.name;}));</span>
<span class="s1">}</span>

<span class="s3">/**</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">{*} names</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">{*} nameConflicts</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">{*} namespaceName</span>
   <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">generateLocalNames(names, nameConflicts, namespaceName) {</span>
  <span class="s2">var </span><span class="s1">localNames = {};</span>
  <span class="s1">names.forEach(</span><span class="s2">function </span><span class="s1">(name) {</span>
    <span class="s2">var </span><span class="s1">localName = </span><span class="s2">void </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(!nameConflicts[name].has(name)) {</span>
      <span class="s1">localName = name;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!nameConflicts[name].has(String(namespaceName) + </span><span class="s0">'_' </span><span class="s1">+ String(name))) {</span>
      <span class="s1">localName = String(namespaceName) + </span><span class="s0">'_' </span><span class="s1">+ String(name);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s5">1</span><span class="s1">; i &lt; Infinity; i++) {</span>
        <span class="s2">if </span><span class="s1">(!nameConflicts[name].has(String(namespaceName) + </span><span class="s0">'_' </span><span class="s1">+ String(name) + </span><span class="s0">'_' </span><span class="s1">+ String(i))) {</span>
          <span class="s1">localName = String(namespaceName) + </span><span class="s0">'_' </span><span class="s1">+ String(name) + </span><span class="s0">'_' </span><span class="s1">+ String(i);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">localNames[name] = localName;</span>
  <span class="s1">});</span>
  <span class="s2">return </span><span class="s1">localNames;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Identifier[]} namespaceIdentifiers</span>
   <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if the namespace variable is more than just a glorified constant</span>
   <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">usesNamespaceAsObject(namespaceIdentifiers) {</span>
  <span class="s2">return </span><span class="s1">!namespaceIdentifiers.every(</span><span class="s2">function </span><span class="s1">(identifier) {</span>
    <span class="s2">var </span><span class="s1">parent = identifier.parent;</span>

    <span class="s3">// `namespace.x` or `namespace['x']`</span>
    <span class="s2">return </span><span class="s1">(</span>
      <span class="s1">parent &amp;&amp;</span>
      <span class="s1">parent.type === </span><span class="s0">'MemberExpression' </span><span class="s1">&amp;&amp; (</span>
      <span class="s1">parent.property.type === </span><span class="s0">'Identifier' </span><span class="s1">|| parent.property.type === </span><span class="s0">'Literal'</span><span class="s1">));</span>

  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">module.exports = {</span>
  <span class="s1">meta: {</span>
    <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
    <span class="s1">docs: {</span>
      <span class="s1">category: </span><span class="s0">'Style guide'</span><span class="s1">,</span>
      <span class="s1">description: </span><span class="s0">'Forbid namespace (a.k.a. &quot;wildcard&quot; `*`) imports.'</span><span class="s1">,</span>
      <span class="s1">url: (</span><span class="s5">0</span><span class="s1">, _docsUrl2[</span><span class="s0">'default'</span><span class="s1">])(</span><span class="s0">'no-namespace'</span><span class="s1">) },</span>

    <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
    <span class="s1">schema: [{</span>
      <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
      <span class="s1">properties: {</span>
        <span class="s1">ignore: {</span>
          <span class="s1">type: </span><span class="s0">'array'</span><span class="s1">,</span>
          <span class="s1">items: {</span>
            <span class="s1">type: </span><span class="s0">'string' </span><span class="s1">},</span>

          <span class="s1">uniqueItems: </span><span class="s2">true </span><span class="s1">} } }] },</span>





  <span class="s1">create: </span><span class="s2">function </span><span class="s1">() {</span><span class="s2">function </span><span class="s1">create(context) {</span>
      <span class="s2">var </span><span class="s1">firstOption = context.options[</span><span class="s5">0</span><span class="s1">] || {};</span>
      <span class="s2">var </span><span class="s1">ignoreGlobs = firstOption.ignore;</span>

      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">ImportNamespaceSpecifier: </span><span class="s2">function </span><span class="s1">() {</span><span class="s2">function </span><span class="s1">ImportNamespaceSpecifier(node) {</span>
            <span class="s2">if </span><span class="s1">(ignoreGlobs &amp;&amp; ignoreGlobs.find(</span><span class="s2">function </span><span class="s1">(glob) {</span><span class="s2">return </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, _minimatch2[</span><span class="s0">'default'</span><span class="s1">])(node.parent.source.value, glob, { matchBase: </span><span class="s2">true </span><span class="s1">});})) {</span>
              <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">var </span><span class="s1">scopeVariables = (</span><span class="s5">0</span><span class="s1">, _contextCompat.getScope)(context, node).variables;</span>
            <span class="s2">var </span><span class="s1">namespaceVariable = scopeVariables.find(</span><span class="s2">function </span><span class="s1">(variable) {</span><span class="s2">return </span><span class="s1">variable.defs[</span><span class="s5">0</span><span class="s1">].node === node;});</span>
            <span class="s2">var </span><span class="s1">namespaceReferences = namespaceVariable.references;</span>
            <span class="s2">var </span><span class="s1">namespaceIdentifiers = namespaceReferences.map(</span><span class="s2">function </span><span class="s1">(reference) {</span><span class="s2">return </span><span class="s1">reference.identifier;});</span>
            <span class="s2">var </span><span class="s1">canFix = namespaceIdentifiers.length &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; !usesNamespaceAsObject(namespaceIdentifiers);</span>

            <span class="s1">context.report({</span>
              <span class="s1">node: node,</span>
              <span class="s1">message: </span><span class="s0">'Unexpected namespace import.'</span><span class="s1">,</span>
              <span class="s1">fix: canFix &amp;&amp; </span><span class="s2">function </span><span class="s1">(fixer) {</span><span class="s2">var </span><span class="s1">_getSourceCode =</span>
                <span class="s1">(</span><span class="s5">0</span><span class="s1">, _contextCompat.getSourceCode)(context),scopeManager = _getSourceCode.scopeManager;</span>
                <span class="s2">var </span><span class="s1">fixes = [];</span>

                <span class="s3">// Pass 1: Collect variable names that are already in scope for each reference we want</span>
                <span class="s3">// to transform, so that we can be sure that we choose non-conflicting import names</span>
                <span class="s2">var </span><span class="s1">importNameConflicts = {};</span>
                <span class="s1">namespaceIdentifiers.forEach(</span><span class="s2">function </span><span class="s1">(identifier) {</span>
                  <span class="s2">var </span><span class="s1">parent = identifier.parent;</span>
                  <span class="s2">if </span><span class="s1">(parent &amp;&amp; parent.type === </span><span class="s0">'MemberExpression'</span><span class="s1">) {</span>
                    <span class="s2">var </span><span class="s1">importName = getMemberPropertyName(parent);</span>
                    <span class="s2">var </span><span class="s1">localConflicts = getVariableNamesInScope(scopeManager, parent);</span>
                    <span class="s2">if </span><span class="s1">(!importNameConflicts[importName]) {</span>
                      <span class="s1">importNameConflicts[importName] = localConflicts;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                      <span class="s1">localConflicts.forEach(</span><span class="s2">function </span><span class="s1">(c) {</span><span class="s2">return </span><span class="s1">importNameConflicts[importName].add(c);});</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>
                <span class="s1">});</span>

                <span class="s3">// Choose new names for each import</span>
                <span class="s2">var </span><span class="s1">importNames = Object.keys(importNameConflicts);</span>
                <span class="s2">var </span><span class="s1">importLocalNames = generateLocalNames(</span>
                <span class="s1">importNames,</span>
                <span class="s1">importNameConflicts,</span>
                <span class="s1">namespaceVariable.name);</span>


                <span class="s3">// Replace the ImportNamespaceSpecifier with a list of ImportSpecifiers</span>
                <span class="s2">var </span><span class="s1">namedImportSpecifiers = importNames.map(</span><span class="s2">function </span><span class="s1">(importName) {</span><span class="s2">return </span><span class="s1">importName === importLocalNames[importName] ?</span>
                  <span class="s1">importName : String(</span>
                  <span class="s1">importName) + </span><span class="s0">' as ' </span><span class="s1">+ String(importLocalNames[importName]);});</span>

                <span class="s1">fixes.push(fixer.replaceText(node, </span><span class="s0">'{ ' </span><span class="s1">+ String(namedImportSpecifiers.join(</span><span class="s0">', '</span><span class="s1">)) + </span><span class="s0">' }'</span><span class="s1">));</span>

                <span class="s3">// Pass 2: Replace references to the namespace with references to the named imports</span>
                <span class="s1">namespaceIdentifiers.forEach(</span><span class="s2">function </span><span class="s1">(identifier) {</span>
                  <span class="s2">var </span><span class="s1">parent = identifier.parent;</span>
                  <span class="s2">if </span><span class="s1">(parent &amp;&amp; parent.type === </span><span class="s0">'MemberExpression'</span><span class="s1">) {</span>
                    <span class="s2">var </span><span class="s1">importName = getMemberPropertyName(parent);</span>
                    <span class="s1">fixes.push(fixer.replaceText(parent, importLocalNames[importName]));</span>
                  <span class="s1">}</span>
                <span class="s1">});</span>

                <span class="s2">return </span><span class="s1">fixes;</span>
              <span class="s1">} });</span>

          <span class="s1">}</span><span class="s2">return </span><span class="s1">ImportNamespaceSpecifier;}() };</span>

    <span class="s1">}</span><span class="s2">return </span><span class="s1">create;}() };</span>
<span class="s3">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9uby1uYW1lc3BhY2UuanMiXSwibmFtZXMiOlsiZ2V0TWVtYmVyUHJvcGVydHlOYW1lIiwibWVtYmVyRXhwcmVzc2lvbiIsInByb3BlcnR5IiwidHlwZSIsIm5hbWUiLCJ2YWx1ZSIsImdldFZhcmlhYmxlTmFtZXNJblNjb3BlIiwic2NvcGVNYW5hZ2VyIiwibm9kZSIsImN1cnJlbnROb2RlIiwic2NvcGUiLCJhY3F1aXJlIiwicGFyZW50IiwiU2V0IiwidmFyaWFibGVzIiwiY29uY2F0IiwidXBwZXIiLCJtYXAiLCJ2YXJpYWJsZSIsImdlbmVyYXRlTG9jYWxOYW1lcyIsIm5hbWVzIiwibmFtZUNvbmZsaWN0cyIsIm5hbWVzcGFjZU5hbWUiLCJsb2NhbE5hbWVzIiwiZm9yRWFjaCIsImxvY2FsTmFtZSIsImhhcyIsImkiLCJJbmZpbml0eSIsInVzZXNOYW1lc3BhY2VBc09iamVjdCIsIm5hbWVzcGFjZUlkZW50aWZpZXJzIiwiZXZlcnkiLCJpZGVudGlmaWVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1ldGEiLCJkb2NzIiwiY2F0ZWdvcnkiLCJkZXNjcmlwdGlvbiIsInVybCIsImZpeGFibGUiLCJzY2hlbWEiLCJwcm9wZXJ0aWVzIiwiaWdub3JlIiwiaXRlbXMiLCJ1bmlxdWVJdGVtcyIsImNyZWF0ZSIsImNvbnRleHQiLCJmaXJzdE9wdGlvbiIsIm9wdGlvbnMiLCJpZ25vcmVHbG9icyIsIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciIsImZpbmQiLCJnbG9iIiwic291cmNlIiwibWF0Y2hCYXNlIiwic2NvcGVWYXJpYWJsZXMiLCJuYW1lc3BhY2VWYXJpYWJsZSIsImRlZnMiLCJuYW1lc3BhY2VSZWZlcmVuY2VzIiwicmVmZXJlbmNlcyIsInJlZmVyZW5jZSIsImNhbkZpeCIsImxlbmd0aCIsInJlcG9ydCIsIm1lc3NhZ2UiLCJmaXgiLCJmaXhlciIsImZpeGVzIiwiaW1wb3J0TmFtZUNvbmZsaWN0cyIsImltcG9ydE5hbWUiLCJsb2NhbENvbmZsaWN0cyIsImMiLCJhZGQiLCJpbXBvcnROYW1lcyIsIk9iamVjdCIsImtleXMiLCJpbXBvcnRMb2NhbE5hbWVzIiwibmFtZWRJbXBvcnRTcGVjaWZpZXJzIiwicHVzaCIsInJlcGxhY2VUZXh0Iiwiam9pbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFLQSxzQztBQUNBOztBQUVBLHFDOztBQUVBOzs7O0FBSUEsU0FBU0EscUJBQVQsQ0FBK0JDLGdCQUEvQixFQUFpRDtBQUMvQyxTQUFPQSxpQkFBaUJDLFFBQWpCLENBQTBCQyxJQUExQixLQUFtQyxZQUFuQztBQUNIRixtQkFBaUJDLFFBQWpCLENBQTBCRSxJQUR2QjtBQUVISCxtQkFBaUJDLFFBQWpCLENBQTBCRyxLQUY5QjtBQUdEOztBQUVEOzs7O01BcEJBOzs7U0F5QkEsU0FBU0MsdUJBQVQsQ0FBaUNDLFlBQWpDLEVBQStDQyxJQUEvQyxFQUFxRCxDQUNuRCxJQUFJQyxjQUFjRCxJQUFsQixDQUNBLElBQUlFLFFBQVFILGFBQWFJLE9BQWIsQ0FBcUJGLFdBQXJCLENBQVo7QUFDQSxTQUFPQyxTQUFTLElBQWhCLEVBQXNCO0FBQ3BCRCxrQkFBY0EsWUFBWUcsTUFBMUI7QUFDQUYsWUFBUUgsYUFBYUksT0FBYixDQUFxQkYsV0FBckIsRUFBa0MsSUFBbEMsQ0FBUjtBQUNEO0FBQ0QsU0FBTyxJQUFJSSxHQUFKLENBQVFILE1BQU1JLFNBQU4sQ0FBZ0JDLE1BQWhCLENBQXVCTCxNQUFNTSxLQUFOLENBQVlGLFNBQW5DLEVBQThDRyxHQUE5QyxDQUFrRCxVQUFDQyxRQUFELFVBQWNBLFNBQVNkLElBQXZCLEVBQWxELENBQVIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTZSxrQkFBVCxDQUE0QkMsS0FBNUIsRUFBbUNDLGFBQW5DLEVBQWtEQyxhQUFsRCxFQUFpRTtBQUMvRCxNQUFNQyxhQUFhLEVBQW5CO0FBQ0FILFFBQU1JLE9BQU4sQ0FBYyxVQUFDcEIsSUFBRCxFQUFVO0FBQ3RCLFFBQUlxQixrQkFBSjtBQUNBLFFBQUksQ0FBQ0osY0FBY2pCLElBQWQsRUFBb0JzQixHQUFwQixDQUF3QnRCLElBQXhCLENBQUwsRUFBb0M7QUFDbENxQixrQkFBWXJCLElBQVo7QUFDRCxLQUZELE1BRU8sSUFBSSxDQUFDaUIsY0FBY2pCLElBQWQsRUFBb0JzQixHQUFwQixRQUEyQkosYUFBM0IsaUJBQTRDbEIsSUFBNUMsRUFBTCxFQUEwRDtBQUMvRHFCLHlCQUFlSCxhQUFmLGlCQUFnQ2xCLElBQWhDO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsV0FBSyxJQUFJdUIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJQyxRQUFwQixFQUE4QkQsR0FBOUIsRUFBbUM7QUFDakMsWUFBSSxDQUFDTixjQUFjakIsSUFBZCxFQUFvQnNCLEdBQXBCLFFBQTJCSixhQUEzQixpQkFBNENsQixJQUE1QyxpQkFBb0R1QixDQUFwRCxFQUFMLEVBQStEO0FBQzdERiw2QkFBZUgsYUFBZixpQkFBZ0NsQixJQUFoQyxpQkFBd0N1QixDQUF4QztBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0RKLGVBQVduQixJQUFYLElBQW1CcUIsU0FBbkI7QUFDRCxHQWZEO0FBZ0JBLFNBQU9GLFVBQVA7QUFDRDs7QUFFRDs7OztBQUlBLFNBQVNNLHFCQUFULENBQStCQyxvQkFBL0IsRUFBcUQ7QUFDbkQsU0FBTyxDQUFDQSxxQkFBcUJDLEtBQXJCLENBQTJCLFVBQUNDLFVBQUQsRUFBZ0I7QUFDakQsUUFBTXBCLFNBQVNvQixXQUFXcEIsTUFBMUI7O0FBRUE7QUFDQTtBQUNFQTtBQUNHQSxhQUFPVCxJQUFQLEtBQWdCLGtCQURuQjtBQUVJUyxhQUFPVixRQUFQLENBQWdCQyxJQUFoQixLQUF5QixZQUF6QixJQUF5Q1MsT0FBT1YsUUFBUCxDQUFnQkMsSUFBaEIsS0FBeUIsU0FGdEUsQ0FERjs7QUFLRCxHQVRPLENBQVI7QUFVRDs7QUFFRDhCLE9BQU9DLE9BQVAsR0FBaUI7QUFDZkMsUUFBTTtBQUNKaEMsVUFBTSxZQURGO0FBRUppQyxVQUFNO0FBQ0pDLGdCQUFVLGFBRE47QUFFSkMsbUJBQWEsbURBRlQ7QUFHSkMsV0FBSywwQkFBUSxjQUFSLENBSEQsRUFGRjs7QUFPSkMsYUFBUyxNQVBMO0FBUUpDLFlBQVEsQ0FBQztBQUNQdEMsWUFBTSxRQURDO0FBRVB1QyxrQkFBWTtBQUNWQyxnQkFBUTtBQUNOeEMsZ0JBQU0sT0FEQTtBQUVOeUMsaUJBQU87QUFDTHpDLGtCQUFNLFFBREQsRUFGRDs7QUFLTjBDLHVCQUFhLElBTFAsRUFERSxFQUZMLEVBQUQsQ0FSSixFQURTOzs7Ozs7QUF1QmZDLFFBdkJlLCtCQXVCUkMsT0F2QlEsRUF1QkM7QUFDZCxVQUFNQyxjQUFjRCxRQUFRRSxPQUFSLENBQWdCLENBQWhCLEtBQXNCLEVBQTFDO0FBQ0EsVUFBTUMsY0FBY0YsWUFBWUwsTUFBaEM7O0FBRUEsYUFBTztBQUNMUSxnQ0FESyxpREFDb0IzQyxJQURwQixFQUMwQjtBQUM3QixnQkFBSTBDLGVBQWVBLFlBQVlFLElBQVosQ0FBaUIsVUFBQ0MsSUFBRCxVQUFVLDRCQUFVN0MsS0FBS0ksTUFBTCxDQUFZMEMsTUFBWixDQUFtQmpELEtBQTdCLEVBQW9DZ0QsSUFBcEMsRUFBMEMsRUFBRUUsV0FBVyxJQUFiLEVBQTFDLENBQVYsRUFBakIsQ0FBbkIsRUFBK0c7QUFDN0c7QUFDRDs7QUFFRCxnQkFBTUMsaUJBQWlCLDZCQUFTVCxPQUFULEVBQWtCdkMsSUFBbEIsRUFBd0JNLFNBQS9DO0FBQ0EsZ0JBQU0yQyxvQkFBb0JELGVBQWVKLElBQWYsQ0FBb0IsVUFBQ2xDLFFBQUQsVUFBY0EsU0FBU3dDLElBQVQsQ0FBYyxDQUFkLEVBQWlCbEQsSUFBakIsS0FBMEJBLElBQXhDLEVBQXBCLENBQTFCO0FBQ0EsZ0JBQU1tRCxzQkFBc0JGLGtCQUFrQkcsVUFBOUM7QUFDQSxnQkFBTTlCLHVCQUF1QjZCLG9CQUFvQjFDLEdBQXBCLENBQXdCLFVBQUM0QyxTQUFELFVBQWVBLFVBQVU3QixVQUF6QixFQUF4QixDQUE3QjtBQUNBLGdCQUFNOEIsU0FBU2hDLHFCQUFxQmlDLE1BQXJCLEdBQThCLENBQTlCLElBQW1DLENBQUNsQyxzQkFBc0JDLG9CQUF0QixDQUFuRDs7QUFFQWlCLG9CQUFRaUIsTUFBUixDQUFlO0FBQ2J4RCx3QkFEYTtBQUVieUQscURBRmE7QUFHYkMsbUJBQUtKLFVBQVcsVUFBQ0ssS0FBRCxFQUFXO0FBQ0Esa0RBQWNwQixPQUFkLENBREEsQ0FDakJ4QyxZQURpQixrQkFDakJBLFlBRGlCO0FBRXpCLG9CQUFNNkQsUUFBUSxFQUFkOztBQUVBO0FBQ0E7QUFDQSxvQkFBTUMsc0JBQXNCLEVBQTVCO0FBQ0F2QyxxQ0FBcUJOLE9BQXJCLENBQTZCLFVBQUNRLFVBQUQsRUFBZ0I7QUFDM0Msc0JBQU1wQixTQUFTb0IsV0FBV3BCLE1BQTFCO0FBQ0Esc0JBQUlBLFVBQVVBLE9BQU9ULElBQVAsS0FBZ0Isa0JBQTlCLEVBQWtEO0FBQ2hELHdCQUFNbUUsYUFBYXRFLHNCQUFzQlksTUFBdEIsQ0FBbkI7QUFDQSx3QkFBTTJELGlCQUFpQmpFLHdCQUF3QkMsWUFBeEIsRUFBc0NLLE1BQXRDLENBQXZCO0FBQ0Esd0JBQUksQ0FBQ3lELG9CQUFvQkMsVUFBcEIsQ0FBTCxFQUFzQztBQUNwQ0QsMENBQW9CQyxVQUFwQixJQUFrQ0MsY0FBbEM7QUFDRCxxQkFGRCxNQUVPO0FBQ0xBLHFDQUFlL0MsT0FBZixDQUF1QixVQUFDZ0QsQ0FBRCxVQUFPSCxvQkFBb0JDLFVBQXBCLEVBQWdDRyxHQUFoQyxDQUFvQ0QsQ0FBcEMsQ0FBUCxFQUF2QjtBQUNEO0FBQ0Y7QUFDRixpQkFYRDs7QUFhQTtBQUNBLG9CQUFNRSxjQUFjQyxPQUFPQyxJQUFQLENBQVlQLG1CQUFaLENBQXBCO0FBQ0Esb0JBQU1RLG1CQUFtQjFEO0FBQ3ZCdUQsMkJBRHVCO0FBRXZCTCxtQ0FGdUI7QUFHdkJaLGtDQUFrQnJELElBSEssQ0FBekI7OztBQU1BO0FBQ0Esb0JBQU0wRSx3QkFBd0JKLFlBQVl6RCxHQUFaLENBQWdCLFVBQUNxRCxVQUFELFVBQWdCQSxlQUFlTyxpQkFBaUJQLFVBQWpCLENBQWY7QUFDMURBLDRCQUQwRDtBQUV2REEsNEJBRnVELG9CQUV0Q08saUJBQWlCUCxVQUFqQixDQUZzQyxDQUFoQixFQUFoQixDQUE5Qjs7QUFJQUYsc0JBQU1XLElBQU4sQ0FBV1osTUFBTWEsV0FBTixDQUFrQnhFLElBQWxCLGdCQUE2QnNFLHNCQUFzQkcsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBN0IsU0FBWDs7QUFFQTtBQUNBbkQscUNBQXFCTixPQUFyQixDQUE2QixVQUFDUSxVQUFELEVBQWdCO0FBQzNDLHNCQUFNcEIsU0FBU29CLFdBQVdwQixNQUExQjtBQUNBLHNCQUFJQSxVQUFVQSxPQUFPVCxJQUFQLEtBQWdCLGtCQUE5QixFQUFrRDtBQUNoRCx3QkFBTW1FLGFBQWF0RSxzQkFBc0JZLE1BQXRCLENBQW5CO0FBQ0F3RCwwQkFBTVcsSUFBTixDQUFXWixNQUFNYSxXQUFOLENBQWtCcEUsTUFBbEIsRUFBMEJpRSxpQkFBaUJQLFVBQWpCLENBQTFCLENBQVg7QUFDRDtBQUNGLGlCQU5EOztBQVFBLHVCQUFPRixLQUFQO0FBQ0QsZUFoRFksRUFBZjs7QUFrREQsV0E5REkscUNBQVA7O0FBZ0VELEtBM0ZjLG1CQUFqQiIsImZpbGUiOiJuby1uYW1lc3BhY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUnVsZSB0byBkaXNhbGxvdyBuYW1lc3BhY2UgaW1wb3J0XG4gKiBAYXV0aG9yIFJhZGVrIEJlbmtlbFxuICovXG5cbmltcG9ydCBtaW5pbWF0Y2ggZnJvbSAnbWluaW1hdGNoJztcbmltcG9ydCB7IGdldFNjb3BlLCBnZXRTb3VyY2VDb2RlIH0gZnJvbSAnZXNsaW50LW1vZHVsZS11dGlscy9jb250ZXh0Q29tcGF0JztcblxuaW1wb3J0IGRvY3NVcmwgZnJvbSAnLi4vZG9jc1VybCc7XG5cbi8qKlxuICogQHBhcmFtIHtNZW1iZXJFeHByZXNzaW9ufSBtZW1iZXJFeHByZXNzaW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgbWVtYmVyIGluIHRoZSBvYmplY3QgZXhwcmVzc2lvbiwgZS5nLiB0aGUgYHhgIGluIGBuYW1lc3BhY2UueGBcbiAqL1xuZnVuY3Rpb24gZ2V0TWVtYmVyUHJvcGVydHlOYW1lKG1lbWJlckV4cHJlc3Npb24pIHtcbiAgcmV0dXJuIG1lbWJlckV4cHJlc3Npb24ucHJvcGVydHkudHlwZSA9PT0gJ0lkZW50aWZpZXInXG4gICAgPyBtZW1iZXJFeHByZXNzaW9uLnByb3BlcnR5Lm5hbWVcbiAgICA6IG1lbWJlckV4cHJlc3Npb24ucHJvcGVydHkudmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY29wZU1hbmFnZXJ9IHNjb3BlTWFuYWdlclxuICogQHBhcmFtIHtBU1ROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVOYW1lc0luU2NvcGUoc2NvcGVNYW5hZ2VyLCBub2RlKSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gIGxldCBzY29wZSA9IHNjb3BlTWFuYWdlci5hY3F1aXJlKGN1cnJlbnROb2RlKTtcbiAgd2hpbGUgKHNjb3BlID09IG51bGwpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcbiAgICBzY29wZSA9IHNjb3BlTWFuYWdlci5hY3F1aXJlKGN1cnJlbnROb2RlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gbmV3IFNldChzY29wZS52YXJpYWJsZXMuY29uY2F0KHNjb3BlLnVwcGVyLnZhcmlhYmxlcykubWFwKCh2YXJpYWJsZSkgPT4gdmFyaWFibGUubmFtZSkpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IG5hbWVzXG4gKiBAcGFyYW0geyp9IG5hbWVDb25mbGljdHNcbiAqIEBwYXJhbSB7Kn0gbmFtZXNwYWNlTmFtZVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUxvY2FsTmFtZXMobmFtZXMsIG5hbWVDb25mbGljdHMsIG5hbWVzcGFjZU5hbWUpIHtcbiAgY29uc3QgbG9jYWxOYW1lcyA9IHt9O1xuICBuYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgbGV0IGxvY2FsTmFtZTtcbiAgICBpZiAoIW5hbWVDb25mbGljdHNbbmFtZV0uaGFzKG5hbWUpKSB7XG4gICAgICBsb2NhbE5hbWUgPSBuYW1lO1xuICAgIH0gZWxzZSBpZiAoIW5hbWVDb25mbGljdHNbbmFtZV0uaGFzKGAke25hbWVzcGFjZU5hbWV9XyR7bmFtZX1gKSkge1xuICAgICAgbG9jYWxOYW1lID0gYCR7bmFtZXNwYWNlTmFtZX1fJHtuYW1lfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgSW5maW5pdHk7IGkrKykge1xuICAgICAgICBpZiAoIW5hbWVDb25mbGljdHNbbmFtZV0uaGFzKGAke25hbWVzcGFjZU5hbWV9XyR7bmFtZX1fJHtpfWApKSB7XG4gICAgICAgICAgbG9jYWxOYW1lID0gYCR7bmFtZXNwYWNlTmFtZX1fJHtuYW1lfV8ke2l9YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsb2NhbE5hbWVzW25hbWVdID0gbG9jYWxOYW1lO1xuICB9KTtcbiAgcmV0dXJuIGxvY2FsTmFtZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtJZGVudGlmaWVyW119IG5hbWVzcGFjZUlkZW50aWZpZXJzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBuYW1lc3BhY2UgdmFyaWFibGUgaXMgbW9yZSB0aGFuIGp1c3QgYSBnbG9yaWZpZWQgY29uc3RhbnRcbiAqL1xuZnVuY3Rpb24gdXNlc05hbWVzcGFjZUFzT2JqZWN0KG5hbWVzcGFjZUlkZW50aWZpZXJzKSB7XG4gIHJldHVybiAhbmFtZXNwYWNlSWRlbnRpZmllcnMuZXZlcnkoKGlkZW50aWZpZXIpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBpZGVudGlmaWVyLnBhcmVudDtcblxuICAgIC8vIGBuYW1lc3BhY2UueGAgb3IgYG5hbWVzcGFjZVsneCddYFxuICAgIHJldHVybiAoXG4gICAgICBwYXJlbnRcbiAgICAgICYmIHBhcmVudC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbidcbiAgICAgICYmIChwYXJlbnQucHJvcGVydHkudHlwZSA9PT0gJ0lkZW50aWZpZXInIHx8IHBhcmVudC5wcm9wZXJ0eS50eXBlID09PSAnTGl0ZXJhbCcpXG4gICAgKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtZXRhOiB7XG4gICAgdHlwZTogJ3N1Z2dlc3Rpb24nLFxuICAgIGRvY3M6IHtcbiAgICAgIGNhdGVnb3J5OiAnU3R5bGUgZ3VpZGUnLFxuICAgICAgZGVzY3JpcHRpb246ICdGb3JiaWQgbmFtZXNwYWNlIChhLmsuYS4gXCJ3aWxkY2FyZFwiIGAqYCkgaW1wb3J0cy4nLFxuICAgICAgdXJsOiBkb2NzVXJsKCduby1uYW1lc3BhY2UnKSxcbiAgICB9LFxuICAgIGZpeGFibGU6ICdjb2RlJyxcbiAgICBzY2hlbWE6IFt7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgaWdub3JlOiB7XG4gICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfV0sXG4gIH0sXG5cbiAgY3JlYXRlKGNvbnRleHQpIHtcbiAgICBjb25zdCBmaXJzdE9wdGlvbiA9IGNvbnRleHQub3B0aW9uc1swXSB8fCB7fTtcbiAgICBjb25zdCBpZ25vcmVHbG9icyA9IGZpcnN0T3B0aW9uLmlnbm9yZTtcblxuICAgIHJldHVybiB7XG4gICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSkge1xuICAgICAgICBpZiAoaWdub3JlR2xvYnMgJiYgaWdub3JlR2xvYnMuZmluZCgoZ2xvYikgPT4gbWluaW1hdGNoKG5vZGUucGFyZW50LnNvdXJjZS52YWx1ZSwgZ2xvYiwgeyBtYXRjaEJhc2U6IHRydWUgfSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NvcGVWYXJpYWJsZXMgPSBnZXRTY29wZShjb250ZXh0LCBub2RlKS52YXJpYWJsZXM7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZVZhcmlhYmxlID0gc2NvcGVWYXJpYWJsZXMuZmluZCgodmFyaWFibGUpID0+IHZhcmlhYmxlLmRlZnNbMF0ubm9kZSA9PT0gbm9kZSk7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZVJlZmVyZW5jZXMgPSBuYW1lc3BhY2VWYXJpYWJsZS5yZWZlcmVuY2VzO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2VJZGVudGlmaWVycyA9IG5hbWVzcGFjZVJlZmVyZW5jZXMubWFwKChyZWZlcmVuY2UpID0+IHJlZmVyZW5jZS5pZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgY2FuRml4ID0gbmFtZXNwYWNlSWRlbnRpZmllcnMubGVuZ3RoID4gMCAmJiAhdXNlc05hbWVzcGFjZUFzT2JqZWN0KG5hbWVzcGFjZUlkZW50aWZpZXJzKTtcblxuICAgICAgICBjb250ZXh0LnJlcG9ydCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5leHBlY3RlZCBuYW1lc3BhY2UgaW1wb3J0LmAsXG4gICAgICAgICAgZml4OiBjYW5GaXggJiYgKChmaXhlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzY29wZU1hbmFnZXIgfSA9IGdldFNvdXJjZUNvZGUoY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBmaXhlcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBQYXNzIDE6IENvbGxlY3QgdmFyaWFibGUgbmFtZXMgdGhhdCBhcmUgYWxyZWFkeSBpbiBzY29wZSBmb3IgZWFjaCByZWZlcmVuY2Ugd2Ugd2FudFxuICAgICAgICAgICAgLy8gdG8gdHJhbnNmb3JtLCBzbyB0aGF0IHdlIGNhbiBiZSBzdXJlIHRoYXQgd2UgY2hvb3NlIG5vbi1jb25mbGljdGluZyBpbXBvcnQgbmFtZXNcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydE5hbWVDb25mbGljdHMgPSB7fTtcbiAgICAgICAgICAgIG5hbWVzcGFjZUlkZW50aWZpZXJzLmZvckVhY2goKGlkZW50aWZpZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaWRlbnRpZmllci5wYXJlbnQ7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltcG9ydE5hbWUgPSBnZXRNZW1iZXJQcm9wZXJ0eU5hbWUocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbENvbmZsaWN0cyA9IGdldFZhcmlhYmxlTmFtZXNJblNjb3BlKHNjb3BlTWFuYWdlciwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWltcG9ydE5hbWVDb25mbGljdHNbaW1wb3J0TmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIGltcG9ydE5hbWVDb25mbGljdHNbaW1wb3J0TmFtZV0gPSBsb2NhbENvbmZsaWN0cztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbG9jYWxDb25mbGljdHMuZm9yRWFjaCgoYykgPT4gaW1wb3J0TmFtZUNvbmZsaWN0c1tpbXBvcnROYW1lXS5hZGQoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENob29zZSBuZXcgbmFtZXMgZm9yIGVhY2ggaW1wb3J0XG4gICAgICAgICAgICBjb25zdCBpbXBvcnROYW1lcyA9IE9iamVjdC5rZXlzKGltcG9ydE5hbWVDb25mbGljdHMpO1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0TG9jYWxOYW1lcyA9IGdlbmVyYXRlTG9jYWxOYW1lcyhcbiAgICAgICAgICAgICAgaW1wb3J0TmFtZXMsXG4gICAgICAgICAgICAgIGltcG9ydE5hbWVDb25mbGljdHMsXG4gICAgICAgICAgICAgIG5hbWVzcGFjZVZhcmlhYmxlLm5hbWUsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgd2l0aCBhIGxpc3Qgb2YgSW1wb3J0U3BlY2lmaWVyc1xuICAgICAgICAgICAgY29uc3QgbmFtZWRJbXBvcnRTcGVjaWZpZXJzID0gaW1wb3J0TmFtZXMubWFwKChpbXBvcnROYW1lKSA9PiBpbXBvcnROYW1lID09PSBpbXBvcnRMb2NhbE5hbWVzW2ltcG9ydE5hbWVdXG4gICAgICAgICAgICAgID8gaW1wb3J0TmFtZVxuICAgICAgICAgICAgICA6IGAke2ltcG9ydE5hbWV9IGFzICR7aW1wb3J0TG9jYWxOYW1lc1tpbXBvcnROYW1lXX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpeGVzLnB1c2goZml4ZXIucmVwbGFjZVRleHQobm9kZSwgYHsgJHtuYW1lZEltcG9ydFNwZWNpZmllcnMuam9pbignLCAnKX0gfWApKTtcblxuICAgICAgICAgICAgLy8gUGFzcyAyOiBSZXBsYWNlIHJlZmVyZW5jZXMgdG8gdGhlIG5hbWVzcGFjZSB3aXRoIHJlZmVyZW5jZXMgdG8gdGhlIG5hbWVkIGltcG9ydHNcbiAgICAgICAgICAgIG5hbWVzcGFjZUlkZW50aWZpZXJzLmZvckVhY2goKGlkZW50aWZpZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaWRlbnRpZmllci5wYXJlbnQ7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltcG9ydE5hbWUgPSBnZXRNZW1iZXJQcm9wZXJ0eU5hbWUocGFyZW50KTtcbiAgICAgICAgICAgICAgICBmaXhlcy5wdXNoKGZpeGVyLnJlcGxhY2VUZXh0KHBhcmVudCwgaW1wb3J0TG9jYWxOYW1lc1tpbXBvcnROYW1lXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpeGVzO1xuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG4iXX0=</span></pre>
</body>
</html>