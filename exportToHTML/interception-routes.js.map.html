<html>
<head>
<title>interception-routes.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interception-routes.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../../src/shared/lib/router/utils/interception-routes.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { normalizeAppPath } from './app-paths'</span><span class="s3">\n\n</span><span class="s1">// order matters here, the first match will be used</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_MARKERS = [</span><span class="s3">\n  </span><span class="s1">'(..)(..)',</span><span class="s3">\n  </span><span class="s1">'(.)',</span><span class="s3">\n  </span><span class="s1">'(..)',</span><span class="s3">\n  </span><span class="s1">'(...)',</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteAppPath(path: string): boolean {</span><span class="s3">\n  </span><span class="s1">// TODO-APP: add more serious validation</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">path</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n      </span><span class="s1">.find((segment) =&gt;</span><span class="s3">\n        </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n      </span><span class="s1">) !== undefined</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractInterceptionRouteInformation(path: string) {</span><span class="s3">\n  </span><span class="s1">let interceptingRoute: string | undefined,</span><span class="s3">\n    </span><span class="s1">marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,</span><span class="s3">\n    </span><span class="s1">interceptedRoute: string | undefined</span><span class="s3">\n\n  </span><span class="s1">for (const segment of path.split('/')) {</span><span class="s3">\n    </span><span class="s1">marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n    </span><span class="s1">if (marker) {</span><span class="s3">\n      </span><span class="s1">;[interceptingRoute, interceptedRoute] = path.split(marker, 2)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!interceptingRoute || !marker || !interceptedRoute) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid interception route: ${path}. Must be in the format /&lt;intercepting route&gt;/(..|...|..)(..)/&lt;intercepted route&gt;`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -&gt; /feed</span><span class="s3">\n\n  </span><span class="s1">switch (marker) {</span><span class="s3">\n    </span><span class="s1">case '(.)':</span><span class="s3">\n      </span><span class="s1">// (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = `/${interceptedRoute}`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = interceptingRoute + '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)':</span><span class="s3">\n      </span><span class="s1">// (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">interceptedRoute = interceptingRoute</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">.slice(0, -1)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(...)':</span><span class="s3">\n      </span><span class="s1">// (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route</span><span class="s3">\n      </span><span class="s1">interceptedRoute = '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)(..)':</span><span class="s3">\n      </span><span class="s1">// (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route</span><span class="s3">\n\n      </span><span class="s1">const splitInterceptingRoute = interceptingRoute.split('/')</span><span class="s3">\n      </span><span class="s1">if (splitInterceptingRoute.length &lt;= 2) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">interceptedRoute = splitInterceptingRoute</span><span class="s3">\n        </span><span class="s1">.slice(0, -2)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: unexpected marker')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { interceptingRoute, interceptedRoute }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;extractInterceptionRouteInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;marker&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;splitInterceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;IAGaA,0BAA0B;eAA1BA;;IAkBGC,mCAAmC;eAAnCA;;IAXAC,0BAA0B;eAA1BA;;;0BAViB;AAG1B,MAAMF,6BAA6B;IACxC;IACA;IACA;IACA;CACD;AAEM,SAASE,2BAA2BC,IAAY;IACrD,wCAAwC;IACxC,OACEA,KACGC,KAAK,CAAC,KACNC,IAAI,CAAC,CAACC,UACLN,2BAA2BK,IAAI,CAAC,CAACE,IAAMD,QAAQE,UAAU,CAACD,SACtDE;AAEZ;AAEO,SAASR,oCAAoCE,IAAY;IAC9D,IAAIO,mBACFC,QACAC;IAEF,KAAK,MAAMN,WAAWH,KAAKC,KAAK,CAAC,KAAM;QACrCO,SAASX,2BAA2BK,IAAI,CAAC,CAACE,IAAMD,QAAQE,UAAU,CAACD;QACnE,IAAII,QAAQ;;YACT,CAACD,mBAAmBE,iBAAiB,GAAGT,KAAKC,KAAK,CAACO,QAAQ;YAC5D;QACF;IACF;IAEA,IAAI,CAACD,qBAAqB,CAACC,UAAU,CAACC,kBAAkB;QACtD,MAAM,qBAEL,CAFK,IAAIC,MACR,AAAC,iCAA8BV,OAAK,sFADhC,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEAO,oBAAoBI,IAAAA,0BAAgB,EAACJ,mBAAmB,iDAAiD;;IAEzG,OAAQC;QACN,KAAK;YACH,oIAAoI;YACpI,IAAID,sBAAsB,KAAK;gBAC7BE,mBAAmB,AAAC,MAAGA;YACzB,OAAO;gBACLA,mBAAmBF,oBAAoB,MAAME;YAC/C;YACA;QACF,KAAK;YACH,uHAAuH;YACvH,IAAIF,sBAAsB,KAAK;gBAC7B,MAAM,qBAEL,CAFK,IAAIG,MACR,AAAC,iCAA8BV,OAAK,iEADhC,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF;YACAS,mBAAmBF,kBAChBN,KAAK,CAAC,KACNW,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACJ,kBACPK,IAAI,CAAC;YACR;QACF,KAAK;YACH,kIAAkI;YAClIL,mBAAmB,MAAMA;YACzB;QACF,KAAK;YACH,iIAAiI;YAEjI,MAAMM,yBAAyBR,kBAAkBN,KAAK,CAAC;YACvD,IAAIc,uBAAuBC,MAAM,IAAI,GAAG;gBACtC,MAAM,qBAEL,CAFK,IAAIN,MACR,AAAC,iCAA8BV,OAAK,oEADhC,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF;YAEAS,mBAAmBM,uBAChBH,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACJ,kBACPK,IAAI,CAAC;YACR;QACF;YACE,MAAM,qBAAyC,CAAzC,IAAIJ,MAAM,iCAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAAwC;IAClD;IAEA,OAAO;QAAEH;QAAmBE;IAAiB;AAC/C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>