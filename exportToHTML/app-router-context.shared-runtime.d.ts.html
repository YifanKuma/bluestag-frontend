<html>
<head>
<title>app-router-context.shared-runtime.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-router-context.shared-runtime.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { FetchServerResponseResult } from </span><span class="s2">'../../client/components/router-reducer/fetch-server-response'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FocusAndScrollRef, PrefetchKind } from </span><span class="s2">'../../client/components/router-reducer/router-reducer-types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FlightRouterState, FlightSegmentPath } from </span><span class="s2">'../../server/app-render/types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">React from </span><span class="s2">'react'</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">type ChildSegmentMap = Map&lt;string, CacheNode&gt;;</span>
<span class="s3">/**</span>
 <span class="s3">* Cache node used in app-router / layout-router.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">type CacheNode = ReadyCacheNode | LazyCacheNode;</span>
<span class="s0">export </span><span class="s1">type LoadingModuleData = [React.JSX.Element, React.ReactNode, React.ReactNode] | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s3">/** viewport metadata node */</span>
<span class="s0">export </span><span class="s1">type HeadData = React.ReactNode;</span>
<span class="s0">export </span><span class="s1">type LazyCacheNode = {</span>
    <span class="s3">/**</span>
     <span class="s3">* When rsc is null, this is a lazily-initialized cache node.</span>
     <span class="s3">*</span>
     <span class="s3">* If the app attempts to render it, it triggers a lazy data fetch,</span>
     <span class="s3">* postpones the render, and schedules an update to a new tree.</span>
     <span class="s3">*</span>
     <span class="s3">* TODO: This mechanism should not be used when PPR is enabled, though it</span>
     <span class="s3">* currently is in some cases until we've implemented partial</span>
     <span class="s3">* segment fetching.</span>
     <span class="s3">*/</span>
    <span class="s1">rsc: </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* A prefetched version of the segment data. See explanation in corresponding</span>
     <span class="s3">* field of ReadyCacheNode (below).</span>
     <span class="s3">*</span>
     <span class="s3">* Since LazyCacheNode mostly only exists in the non-PPR implementation, this</span>
     <span class="s3">* will usually be null, but it could have been cloned from a previous</span>
     <span class="s3">* CacheNode that was created by the PPR implementation. Eventually we want</span>
     <span class="s3">* to migrate everything away from LazyCacheNode entirely.</span>
     <span class="s3">*/</span>
    <span class="s1">prefetchRsc: React.ReactNode;</span>
    <span class="s3">/**</span>
     <span class="s3">* A pending response for the lazy data fetch. If this is not present</span>
     <span class="s3">* during render, it is lazily created.</span>
     <span class="s3">*/</span>
    <span class="s1">lazyData: Promise&lt;FetchServerResponseResult&gt; | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">prefetchHead: HeadData | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">head: HeadData;</span>
    <span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Child parallel routes.</span>
     <span class="s3">*/</span>
    <span class="s1">parallelRoutes: Map&lt;string, ChildSegmentMap&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* The timestamp of the navigation that last updated the CacheNode's data. If</span>
     <span class="s3">* a CacheNode is reused from a previous navigation, this value is not</span>
     <span class="s3">* updated. Used to track the staleness of the data.</span>
     <span class="s3">*/</span>
    <span class="s1">navigatedAt: number;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">type ReadyCacheNode = {</span>
    <span class="s3">/**</span>
     <span class="s3">* When rsc is not null, it represents the RSC data for the</span>
     <span class="s3">* corresponding segment.</span>
     <span class="s3">*</span>
     <span class="s3">* `null` is a valid React Node but because segment data is always a</span>
     <span class="s3">* &lt;LayoutRouter&gt; component, we can use `null` to represent empty.</span>
     <span class="s3">*</span>
     <span class="s3">* TODO: For additional type safety, update this type to</span>
     <span class="s3">* Exclude&lt;React.ReactNode, null&gt;. Need to update createEmptyCacheNode to</span>
     <span class="s3">* accept rsc as an argument, or just inline the callers.</span>
     <span class="s3">*/</span>
    <span class="s1">rsc: React.ReactNode;</span>
    <span class="s3">/**</span>
     <span class="s3">* Represents a static version of the segment that can be shown immediately,</span>
     <span class="s3">* and may or may not contain dynamic holes. It's prefetched before a</span>
     <span class="s3">* navigation occurs.</span>
     <span class="s3">*</span>
     <span class="s3">* During rendering, we will choose whether to render `rsc` or `prefetchRsc`</span>
     <span class="s3">* with `useDeferredValue`. As with the `rsc` field, a value of `null` means</span>
     <span class="s3">* no value was provided. In this case, the LayoutRouter will go straight to</span>
     <span class="s3">* rendering the `rsc` value; if that one is also missing, it will suspend and</span>
     <span class="s3">* trigger a lazy fetch.</span>
     <span class="s3">*/</span>
    <span class="s1">prefetchRsc: React.ReactNode;</span>
    <span class="s3">/**</span>
     <span class="s3">* There should never be a lazy data request in this case.</span>
     <span class="s3">*/</span>
    <span class="s1">lazyData: </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">prefetchHead: HeadData | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">head: HeadData;</span>
    <span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;;</span>
    <span class="s1">parallelRoutes: Map&lt;string, ChildSegmentMap&gt;;</span>
    <span class="s1">navigatedAt: number;</span>
<span class="s1">};</span>
<span class="s0">export interface </span><span class="s1">NavigateOptions {</span>
    <span class="s1">scroll?: boolean;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">PrefetchOptions {</span>
    <span class="s1">kind: PrefetchKind;</span>
    <span class="s1">onInvalidate?: () =&gt; </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">AppRouterInstance {</span>
    <span class="s3">/**</span>
     <span class="s3">* Navigate to the previous history entry.</span>
     <span class="s3">*/</span>
    <span class="s1">back(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Navigate to the next history entry.</span>
     <span class="s3">*/</span>
    <span class="s1">forward(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Refresh the current page.</span>
     <span class="s3">*/</span>
    <span class="s1">refresh(): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Navigate to the provided href.</span>
     <span class="s3">* Pushes a new history entry.</span>
     <span class="s3">*/</span>
    <span class="s1">push(href: string, options?: NavigateOptions): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Navigate to the provided href.</span>
     <span class="s3">* Replaces the current history entry.</span>
     <span class="s3">*/</span>
    <span class="s1">replace(href: string, options?: NavigateOptions): </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Prefetch the provided href.</span>
     <span class="s3">*/</span>
    <span class="s1">prefetch(href: string, options?: PrefetchOptions): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">AppRouterContext: React.Context&lt;AppRouterInstance | </span><span class="s0">null</span><span class="s1">&gt;;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">LayoutRouterContext: React.Context&lt;{</span>
    <span class="s1">parentTree: FlightRouterState;</span>
    <span class="s1">parentCacheNode: CacheNode;</span>
    <span class="s1">parentSegmentPath: FlightSegmentPath | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">url: string;</span>
<span class="s1">} | </span><span class="s0">null</span><span class="s1">&gt;;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">GlobalLayoutRouterContext: React.Context&lt;{</span>
    <span class="s1">tree: FlightRouterState;</span>
    <span class="s1">focusAndScrollRef: FocusAndScrollRef;</span>
    <span class="s1">nextUrl: string | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">}&gt;;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">TemplateContext: React.Context&lt;React.ReactNode&gt;;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">MissingSlotContext: React.Context&lt;Set&lt;string&gt;&gt;;</span>
</pre>
</body>
</html>