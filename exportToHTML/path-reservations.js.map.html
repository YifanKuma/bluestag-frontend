<html>
<head>
<title>path-reservations.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
path-reservations.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;path-reservations.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path-reservations.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// A path exclusive reservation system</span><span class="s3">\n</span><span class="s1">// reserve([list, of, paths], fn)</span><span class="s3">\n</span><span class="s1">// When the fn is first in line for all its paths, it</span><span class="s3">\n</span><span class="s1">// is called with a cb that clears the reservation.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Used by async unpack to avoid clobbering paths in use,</span><span class="s3">\n</span><span class="s1">// while still allowing maximal safe parallelization.</span><span class="s3">\n\n</span><span class="s1">import { join } from 'node:path'</span><span class="s3">\n</span><span class="s1">import { normalizeUnicode } from './normalize-unicode.js'</span><span class="s3">\n</span><span class="s1">import { stripTrailingSlashes } from './strip-trailing-slashes.js'</span><span class="s3">\n\n</span><span class="s1">const platform =</span><span class="s3">\n  </span><span class="s1">process.env.TESTING_TAR_FAKE_PLATFORM || process.platform</span><span class="s3">\n</span><span class="s1">const isWindows = platform === 'win32'</span><span class="s3">\n\n</span><span class="s1">export type Reservation = {</span><span class="s3">\n  </span><span class="s1">paths: string[]</span><span class="s3">\n  </span><span class="s1">dirs: Set&lt;string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type Handler = (clear: () =&gt; void) =&gt; void</span><span class="s3">\n\n</span><span class="s1">// return a set of parent dirs for a given path</span><span class="s3">\n</span><span class="s1">// '/a/b/c/d' -&gt; ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']</span><span class="s3">\n</span><span class="s1">const getDirs = (path: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">const dirs = path</span><span class="s3">\n    </span><span class="s1">.split('/')</span><span class="s3">\n    </span><span class="s1">.slice(0, -1)</span><span class="s3">\n    </span><span class="s1">.reduce((set: string[], path) =&gt; {</span><span class="s3">\n      </span><span class="s1">const s = set[set.length - 1]</span><span class="s3">\n      </span><span class="s1">if (s !== undefined) {</span><span class="s3">\n        </span><span class="s1">path = join(s, path)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">set.push(path || '/')</span><span class="s3">\n      </span><span class="s1">return set</span><span class="s3">\n    </span><span class="s1">}, [])</span><span class="s3">\n  </span><span class="s1">return dirs</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class PathReservations {</span><span class="s3">\n  </span><span class="s1">// path =&gt; [function or Set]</span><span class="s3">\n  </span><span class="s1">// A Set object means a directory reservation</span><span class="s3">\n  </span><span class="s1">// A fn is a direct reservation on that path</span><span class="s3">\n  </span><span class="s1">#queues = new Map&lt;string, (Handler | Set&lt;Handler&gt;)[]&gt;()</span><span class="s3">\n\n  </span><span class="s1">// fn =&gt; {paths:[path,...], dirs:[path, ...]}</span><span class="s3">\n  </span><span class="s1">#reservations = new Map&lt;Handler, Reservation&gt;()</span><span class="s3">\n\n  </span><span class="s1">// functions currently running</span><span class="s3">\n  </span><span class="s1">#running = new Set&lt;Handler&gt;()</span><span class="s3">\n\n  </span><span class="s1">reserve(paths: string[], fn: Handler) {</span><span class="s3">\n    </span><span class="s1">paths =</span><span class="s3">\n      </span><span class="s1">isWindows ?</span><span class="s3">\n        </span><span class="s1">['win32 parallelization disabled']</span><span class="s3">\n      </span><span class="s1">: paths.map(p =&gt; {</span><span class="s3">\n          </span><span class="s1">// don't need normPath, because we skip this entirely for windows</span><span class="s3">\n          </span><span class="s1">return stripTrailingSlashes(</span><span class="s3">\n            </span><span class="s1">join(normalizeUnicode(p)),</span><span class="s3">\n          </span><span class="s1">).toLowerCase()</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const dirs = new Set&lt;string&gt;(</span><span class="s3">\n      </span><span class="s1">paths.map(path =&gt; getDirs(path)).reduce((a, b) =&gt; a.concat(b)),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.#reservations.set(fn, { dirs, paths })</span><span class="s3">\n    </span><span class="s1">for (const p of paths) {</span><span class="s3">\n      </span><span class="s1">const q = this.#queues.get(p)</span><span class="s3">\n      </span><span class="s1">if (!q) {</span><span class="s3">\n        </span><span class="s1">this.#queues.set(p, [fn])</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">q.push(fn)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const dir of dirs) {</span><span class="s3">\n      </span><span class="s1">const q = this.#queues.get(dir)</span><span class="s3">\n      </span><span class="s1">if (!q) {</span><span class="s3">\n        </span><span class="s1">this.#queues.set(dir, [new Set([fn])])</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const l = q[q.length - 1]</span><span class="s3">\n        </span><span class="s1">if (l instanceof Set) {</span><span class="s3">\n          </span><span class="s1">l.add(fn)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">q.push(new Set([fn]))</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.#run(fn)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// return the queues for each path the function cares about</span><span class="s3">\n  </span><span class="s1">// fn =&gt; {paths, dirs}</span><span class="s3">\n  </span><span class="s1">#getQueues(fn: Handler): {</span><span class="s3">\n    </span><span class="s1">paths: Handler[][]</span><span class="s3">\n    </span><span class="s1">dirs: (Handler | Set&lt;Handler&gt;)[][]</span><span class="s3">\n  </span><span class="s1">} {</span><span class="s3">\n    </span><span class="s1">const res = this.#reservations.get(fn)</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!res) {</span><span class="s3">\n      </span><span class="s1">throw new Error('function does not have any path reservations')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">paths: res.paths.map((path: string) =&gt;</span><span class="s3">\n        </span><span class="s1">this.#queues.get(path),</span><span class="s3">\n      </span><span class="s1">) as Handler[][],</span><span class="s3">\n      </span><span class="s1">dirs: [...res.dirs].map(path =&gt; this.#queues.get(path)) as (</span><span class="s3">\n        </span><span class="s1">| Handler</span><span class="s3">\n        </span><span class="s1">| Set&lt;Handler&gt;</span><span class="s3">\n      </span><span class="s1">)[][],</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// check if fn is first in line for all its paths, and is</span><span class="s3">\n  </span><span class="s1">// included in the first set for all its dir queues</span><span class="s3">\n  </span><span class="s1">check(fn: Handler) {</span><span class="s3">\n    </span><span class="s1">const { paths, dirs } = this.#getQueues(fn)</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">paths.every(q =&gt; q &amp;&amp; q[0] === fn) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">dirs.every(q =&gt; q &amp;&amp; q[0] instanceof Set &amp;&amp; q[0].has(fn))</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// run the function if it's first in line and not already running</span><span class="s3">\n  </span><span class="s1">#run(fn: Handler) {</span><span class="s3">\n    </span><span class="s1">if (this.#running.has(fn) || !this.check(fn)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.#running.add(fn)</span><span class="s3">\n    </span><span class="s1">fn(() =&gt; this.#clear(fn))</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">#clear(fn: Handler) {</span><span class="s3">\n    </span><span class="s1">if (!this.#running.has(fn)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const res = this.#reservations.get(fn)</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!res) {</span><span class="s3">\n      </span><span class="s1">throw new Error('invalid reservation')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">const { paths, dirs } = res</span><span class="s3">\n\n    </span><span class="s1">const next = new Set&lt;Handler&gt;()</span><span class="s3">\n    </span><span class="s1">for (const path of paths) {</span><span class="s3">\n      </span><span class="s1">const q = this.#queues.get(path)</span><span class="s3">\n      </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n      </span><span class="s1">if (!q || q?.[0] !== fn) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n      </span><span class="s1">const q0 = q[1]</span><span class="s3">\n      </span><span class="s1">if (!q0) {</span><span class="s3">\n        </span><span class="s1">this.#queues.delete(path)</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">q.shift()</span><span class="s3">\n      </span><span class="s1">if (typeof q0 === 'function') {</span><span class="s3">\n        </span><span class="s1">next.add(q0)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">for (const f of q0) {</span><span class="s3">\n          </span><span class="s1">next.add(f)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const dir of dirs) {</span><span class="s3">\n      </span><span class="s1">const q = this.#queues.get(dir)</span><span class="s3">\n      </span><span class="s1">const q0 = q?.[0]</span><span class="s3">\n      </span><span class="s1">/* c8 ignore next - type safety only */</span><span class="s3">\n      </span><span class="s1">if (!q || !(q0 instanceof Set)) continue</span><span class="s3">\n      </span><span class="s1">if (q0.size === 1 &amp;&amp; q.length === 1) {</span><span class="s3">\n        </span><span class="s1">this.#queues.delete(dir)</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">} else if (q0.size === 1) {</span><span class="s3">\n        </span><span class="s1">q.shift()</span><span class="s3">\n        </span><span class="s1">// next one must be a function,</span><span class="s3">\n        </span><span class="s1">// or else the Set would've been reused</span><span class="s3">\n        </span><span class="s1">const n = q[0]</span><span class="s3">\n        </span><span class="s1">if (typeof n === 'function') {</span><span class="s3">\n          </span><span class="s1">next.add(n)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">q0.delete(fn)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.#running.delete(fn)</span><span class="s3">\n    </span><span class="s1">next.forEach(fn =&gt; this.#run(fn))</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>