<html>
<head>
<title>ast-spec.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ast-spec.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**********************************************</span>
 <span class="s0">*      DO NOT MODIFY THIS FILE MANUALLY      *</span>
 <span class="s0">*                                            *</span>
 <span class="s0">*  THIS FILE HAS BEEN COPIED FROM ast-spec.  *</span>
 <span class="s0">* ANY CHANGES WILL BE LOST ON THE NEXT BUILD *</span>
 <span class="s0">*                                            *</span>
 <span class="s0">*   MAKE CHANGES TO ast-spec AND THEN RUN    *</span>
 <span class="s0">*                 yarn build                 *</span>
 <span class="s0">**********************************************/</span>
<span class="s2">import </span><span class="s1">type { SyntaxKind } from </span><span class="s3">'typescript'</span><span class="s1">;</span>
<span class="s2">export </span><span class="s1">declare type Accessibility = </span><span class="s3">'private' </span><span class="s1">| </span><span class="s3">'protected' </span><span class="s1">| </span><span class="s3">'public'</span><span class="s1">;</span>
<span class="s2">export </span><span class="s1">declare type AccessorProperty = AccessorPropertyComputedName | AccessorPropertyNonComputedName;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">AccessorPropertyComputedName </span><span class="s2">extends </span><span class="s1">PropertyDefinitionComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.AccessorProperty;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">AccessorPropertyNonComputedName </span><span class="s2">extends </span><span class="s1">PropertyDefinitionNonComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.AccessorProperty;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ArrayExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ArrayExpression;</span>
    <span class="s0">/**</span>
     <span class="s0">* an element will be `null` in the case of a sparse array: `[1, ,3]`</span>
     <span class="s0">*/</span>
    <span class="s1">elements: (Expression | SpreadElement | </span><span class="s2">null</span><span class="s1">)[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ArrayPattern </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ArrayPattern;</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s1">elements: (DestructuringPattern | </span><span class="s2">null</span><span class="s1">)[];</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ArrowFunctionExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ArrowFunctionExpression;</span>
    <span class="s1">async: boolean;</span>
    <span class="s1">body: BlockStatement | Expression;</span>
    <span class="s1">expression: boolean;</span>
    <span class="s1">generator: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">id: </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">params: Parameter[];</span>
    <span class="s1">returnType: TSTypeAnnotation | undefined;</span>
    <span class="s1">typeParameters: TSTypeParameterDeclaration | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">AssignmentExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.AssignmentExpression;</span>
    <span class="s1">left: Expression;</span>
    <span class="s1">operator: ValueOf&lt;AssignmentOperatorToText&gt;;</span>
    <span class="s1">right: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">AssignmentOperatorToText {</span>
    <span class="s1">[SyntaxKind.AmpersandAmpersandEqualsToken]: </span><span class="s3">'&amp;&amp;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AmpersandEqualsToken]: </span><span class="s3">'&amp;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AsteriskAsteriskEqualsToken]: </span><span class="s3">'**='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AsteriskEqualsToken]: </span><span class="s3">'*='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.BarBarEqualsToken]: </span><span class="s3">'||='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.BarEqualsToken]: </span><span class="s3">'|='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.CaretEqualsToken]: </span><span class="s3">'^='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.EqualsToken]: </span><span class="s3">'='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanGreaterThanEqualsToken]: </span><span class="s3">'&gt;&gt;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: </span><span class="s3">'&gt;&gt;&gt;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.LessThanLessThanEqualsToken]: </span><span class="s3">'&lt;&lt;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.MinusEqualsToken]: </span><span class="s3">'-='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.PercentEqualsToken]: </span><span class="s3">'%='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.PlusEqualsToken]: </span><span class="s3">'+='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.QuestionQuestionEqualsToken]: </span><span class="s3">'??='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.SlashEqualsToken]: </span><span class="s3">'/='</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">AssignmentPattern </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.AssignmentPattern;</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s1">left: BindingName;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">right: Expression;</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">enum </span><span class="s1">AST_NODE_TYPES {</span>
    <span class="s1">AccessorProperty = </span><span class="s3">&quot;AccessorProperty&quot;</span><span class="s1">,</span>
    <span class="s1">ArrayExpression = </span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s1">,</span>
    <span class="s1">ArrayPattern = </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s1">,</span>
    <span class="s1">ArrowFunctionExpression = </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s1">,</span>
    <span class="s1">AssignmentExpression = </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s1">,</span>
    <span class="s1">AssignmentPattern = </span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s1">,</span>
    <span class="s1">AwaitExpression = </span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s1">,</span>
    <span class="s1">BinaryExpression = </span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s1">,</span>
    <span class="s1">BlockStatement = </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s1">,</span>
    <span class="s1">BreakStatement = </span><span class="s3">&quot;BreakStatement&quot;</span><span class="s1">,</span>
    <span class="s1">CallExpression = </span><span class="s3">&quot;CallExpression&quot;</span><span class="s1">,</span>
    <span class="s1">CatchClause = </span><span class="s3">&quot;CatchClause&quot;</span><span class="s1">,</span>
    <span class="s1">ChainExpression = </span><span class="s3">&quot;ChainExpression&quot;</span><span class="s1">,</span>
    <span class="s1">ClassBody = </span><span class="s3">&quot;ClassBody&quot;</span><span class="s1">,</span>
    <span class="s1">ClassDeclaration = </span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">ClassExpression = </span><span class="s3">&quot;ClassExpression&quot;</span><span class="s1">,</span>
    <span class="s1">ConditionalExpression = </span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s1">,</span>
    <span class="s1">ContinueStatement = </span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s1">,</span>
    <span class="s1">DebuggerStatement = </span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s1">,</span>
    <span class="s1">Decorator = </span><span class="s3">&quot;Decorator&quot;</span><span class="s1">,</span>
    <span class="s1">DoWhileStatement = </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s1">,</span>
    <span class="s1">EmptyStatement = </span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s1">,</span>
    <span class="s1">ExportAllDeclaration = </span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">ExportDefaultDeclaration = </span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">ExportNamedDeclaration = </span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">ExportSpecifier = </span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s1">,</span>
    <span class="s1">ExpressionStatement = </span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s1">,</span>
    <span class="s1">ForInStatement = </span><span class="s3">&quot;ForInStatement&quot;</span><span class="s1">,</span>
    <span class="s1">ForOfStatement = </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s1">,</span>
    <span class="s1">ForStatement = </span><span class="s3">&quot;ForStatement&quot;</span><span class="s1">,</span>
    <span class="s1">FunctionDeclaration = </span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">FunctionExpression = </span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s1">,</span>
    <span class="s1">Identifier = </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">,</span>
    <span class="s1">IfStatement = </span><span class="s3">&quot;IfStatement&quot;</span><span class="s1">,</span>
    <span class="s1">ImportAttribute = </span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s1">,</span>
    <span class="s1">ImportDeclaration = </span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">ImportDefaultSpecifier = </span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s1">,</span>
    <span class="s1">ImportExpression = </span><span class="s3">&quot;ImportExpression&quot;</span><span class="s1">,</span>
    <span class="s1">ImportNamespaceSpecifier = </span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s1">,</span>
    <span class="s1">ImportSpecifier = </span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s1">,</span>
    <span class="s1">JSXAttribute = </span><span class="s3">&quot;JSXAttribute&quot;</span><span class="s1">,</span>
    <span class="s1">JSXClosingElement = </span><span class="s3">&quot;JSXClosingElement&quot;</span><span class="s1">,</span>
    <span class="s1">JSXClosingFragment = </span><span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s1">,</span>
    <span class="s1">JSXElement = </span><span class="s3">&quot;JSXElement&quot;</span><span class="s1">,</span>
    <span class="s1">JSXEmptyExpression = </span><span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s1">,</span>
    <span class="s1">JSXExpressionContainer = </span><span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s1">,</span>
    <span class="s1">JSXFragment = </span><span class="s3">&quot;JSXFragment&quot;</span><span class="s1">,</span>
    <span class="s1">JSXIdentifier = </span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s1">,</span>
    <span class="s1">JSXMemberExpression = </span><span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s1">,</span>
    <span class="s1">JSXNamespacedName = </span><span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s1">,</span>
    <span class="s1">JSXOpeningElement = </span><span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s1">,</span>
    <span class="s1">JSXOpeningFragment = </span><span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s1">,</span>
    <span class="s1">JSXSpreadAttribute = </span><span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s1">,</span>
    <span class="s1">JSXSpreadChild = </span><span class="s3">&quot;JSXSpreadChild&quot;</span><span class="s1">,</span>
    <span class="s1">JSXText = </span><span class="s3">&quot;JSXText&quot;</span><span class="s1">,</span>
    <span class="s1">LabeledStatement = </span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s1">,</span>
    <span class="s1">Literal = </span><span class="s3">&quot;Literal&quot;</span><span class="s1">,</span>
    <span class="s1">LogicalExpression = </span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s1">,</span>
    <span class="s1">MemberExpression = </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s1">,</span>
    <span class="s1">MetaProperty = </span><span class="s3">&quot;MetaProperty&quot;</span><span class="s1">,</span>
    <span class="s1">MethodDefinition = </span><span class="s3">&quot;MethodDefinition&quot;</span><span class="s1">,</span>
    <span class="s1">NewExpression = </span><span class="s3">&quot;NewExpression&quot;</span><span class="s1">,</span>
    <span class="s1">ObjectExpression = </span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s1">,</span>
    <span class="s1">ObjectPattern = </span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s1">,</span>
    <span class="s1">PrivateIdentifier = </span><span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s1">,</span>
    <span class="s1">Program = </span><span class="s3">&quot;Program&quot;</span><span class="s1">,</span>
    <span class="s1">Property = </span><span class="s3">&quot;Property&quot;</span><span class="s1">,</span>
    <span class="s1">PropertyDefinition = </span><span class="s3">&quot;PropertyDefinition&quot;</span><span class="s1">,</span>
    <span class="s1">RestElement = </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">,</span>
    <span class="s1">ReturnStatement = </span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s1">,</span>
    <span class="s1">SequenceExpression = </span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s1">,</span>
    <span class="s1">SpreadElement = </span><span class="s3">&quot;SpreadElement&quot;</span><span class="s1">,</span>
    <span class="s1">StaticBlock = </span><span class="s3">&quot;StaticBlock&quot;</span><span class="s1">,</span>
    <span class="s1">Super = </span><span class="s3">&quot;Super&quot;</span><span class="s1">,</span>
    <span class="s1">SwitchCase = </span><span class="s3">&quot;SwitchCase&quot;</span><span class="s1">,</span>
    <span class="s1">SwitchStatement = </span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s1">,</span>
    <span class="s1">TaggedTemplateExpression = </span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s1">,</span>
    <span class="s1">TemplateElement = </span><span class="s3">&quot;TemplateElement&quot;</span><span class="s1">,</span>
    <span class="s1">TemplateLiteral = </span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s1">,</span>
    <span class="s1">ThisExpression = </span><span class="s3">&quot;ThisExpression&quot;</span><span class="s1">,</span>
    <span class="s1">ThrowStatement = </span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s1">,</span>
    <span class="s1">TryStatement = </span><span class="s3">&quot;TryStatement&quot;</span><span class="s1">,</span>
    <span class="s1">UnaryExpression = </span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s1">,</span>
    <span class="s1">UpdateExpression = </span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s1">,</span>
    <span class="s1">VariableDeclaration = </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">VariableDeclarator = </span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s1">,</span>
    <span class="s1">WhileStatement = </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s1">,</span>
    <span class="s1">WithStatement = </span><span class="s3">&quot;WithStatement&quot;</span><span class="s1">,</span>
    <span class="s1">YieldExpression = </span><span class="s3">&quot;YieldExpression&quot;</span><span class="s1">,</span>
    <span class="s1">TSAbstractAccessorProperty = </span><span class="s3">&quot;TSAbstractAccessorProperty&quot;</span><span class="s1">,</span>
    <span class="s1">TSAbstractKeyword = </span><span class="s3">&quot;TSAbstractKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSAbstractMethodDefinition = </span><span class="s3">&quot;TSAbstractMethodDefinition&quot;</span><span class="s1">,</span>
    <span class="s1">TSAbstractPropertyDefinition = </span><span class="s3">&quot;TSAbstractPropertyDefinition&quot;</span><span class="s1">,</span>
    <span class="s1">TSAnyKeyword = </span><span class="s3">&quot;TSAnyKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSArrayType = </span><span class="s3">&quot;TSArrayType&quot;</span><span class="s1">,</span>
    <span class="s1">TSAsExpression = </span><span class="s3">&quot;TSAsExpression&quot;</span><span class="s1">,</span>
    <span class="s1">TSAsyncKeyword = </span><span class="s3">&quot;TSAsyncKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSBigIntKeyword = </span><span class="s3">&quot;TSBigIntKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSBooleanKeyword = </span><span class="s3">&quot;TSBooleanKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSCallSignatureDeclaration = </span><span class="s3">&quot;TSCallSignatureDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSClassImplements = </span><span class="s3">&quot;TSClassImplements&quot;</span><span class="s1">,</span>
    <span class="s1">TSConditionalType = </span><span class="s3">&quot;TSConditionalType&quot;</span><span class="s1">,</span>
    <span class="s1">TSConstructorType = </span><span class="s3">&quot;TSConstructorType&quot;</span><span class="s1">,</span>
    <span class="s1">TSConstructSignatureDeclaration = </span><span class="s3">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSDeclareFunction = </span><span class="s3">&quot;TSDeclareFunction&quot;</span><span class="s1">,</span>
    <span class="s1">TSDeclareKeyword = </span><span class="s3">&quot;TSDeclareKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSEmptyBodyFunctionExpression = </span><span class="s3">&quot;TSEmptyBodyFunctionExpression&quot;</span><span class="s1">,</span>
    <span class="s1">TSEnumBody = </span><span class="s3">&quot;TSEnumBody&quot;</span><span class="s1">,</span>
    <span class="s1">TSEnumDeclaration = </span><span class="s3">&quot;TSEnumDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSEnumMember = </span><span class="s3">&quot;TSEnumMember&quot;</span><span class="s1">,</span>
    <span class="s1">TSExportAssignment = </span><span class="s3">&quot;TSExportAssignment&quot;</span><span class="s1">,</span>
    <span class="s1">TSExportKeyword = </span><span class="s3">&quot;TSExportKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSExternalModuleReference = </span><span class="s3">&quot;TSExternalModuleReference&quot;</span><span class="s1">,</span>
    <span class="s1">TSFunctionType = </span><span class="s3">&quot;TSFunctionType&quot;</span><span class="s1">,</span>
    <span class="s1">TSImportEqualsDeclaration = </span><span class="s3">&quot;TSImportEqualsDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSImportType = </span><span class="s3">&quot;TSImportType&quot;</span><span class="s1">,</span>
    <span class="s1">TSIndexedAccessType = </span><span class="s3">&quot;TSIndexedAccessType&quot;</span><span class="s1">,</span>
    <span class="s1">TSIndexSignature = </span><span class="s3">&quot;TSIndexSignature&quot;</span><span class="s1">,</span>
    <span class="s1">TSInferType = </span><span class="s3">&quot;TSInferType&quot;</span><span class="s1">,</span>
    <span class="s1">TSInstantiationExpression = </span><span class="s3">&quot;TSInstantiationExpression&quot;</span><span class="s1">,</span>
    <span class="s1">TSInterfaceBody = </span><span class="s3">&quot;TSInterfaceBody&quot;</span><span class="s1">,</span>
    <span class="s1">TSInterfaceDeclaration = </span><span class="s3">&quot;TSInterfaceDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSInterfaceHeritage = </span><span class="s3">&quot;TSInterfaceHeritage&quot;</span><span class="s1">,</span>
    <span class="s1">TSIntersectionType = </span><span class="s3">&quot;TSIntersectionType&quot;</span><span class="s1">,</span>
    <span class="s1">TSIntrinsicKeyword = </span><span class="s3">&quot;TSIntrinsicKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSLiteralType = </span><span class="s3">&quot;TSLiteralType&quot;</span><span class="s1">,</span>
    <span class="s1">TSMappedType = </span><span class="s3">&quot;TSMappedType&quot;</span><span class="s1">,</span>
    <span class="s1">TSMethodSignature = </span><span class="s3">&quot;TSMethodSignature&quot;</span><span class="s1">,</span>
    <span class="s1">TSModuleBlock = </span><span class="s3">&quot;TSModuleBlock&quot;</span><span class="s1">,</span>
    <span class="s1">TSModuleDeclaration = </span><span class="s3">&quot;TSModuleDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSNamedTupleMember = </span><span class="s3">&quot;TSNamedTupleMember&quot;</span><span class="s1">,</span>
    <span class="s1">TSNamespaceExportDeclaration = </span><span class="s3">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSNeverKeyword = </span><span class="s3">&quot;TSNeverKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSNonNullExpression = </span><span class="s3">&quot;TSNonNullExpression&quot;</span><span class="s1">,</span>
    <span class="s1">TSNullKeyword = </span><span class="s3">&quot;TSNullKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSNumberKeyword = </span><span class="s3">&quot;TSNumberKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSObjectKeyword = </span><span class="s3">&quot;TSObjectKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSOptionalType = </span><span class="s3">&quot;TSOptionalType&quot;</span><span class="s1">,</span>
    <span class="s1">TSParameterProperty = </span><span class="s3">&quot;TSParameterProperty&quot;</span><span class="s1">,</span>
    <span class="s1">TSPrivateKeyword = </span><span class="s3">&quot;TSPrivateKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSPropertySignature = </span><span class="s3">&quot;TSPropertySignature&quot;</span><span class="s1">,</span>
    <span class="s1">TSProtectedKeyword = </span><span class="s3">&quot;TSProtectedKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSPublicKeyword = </span><span class="s3">&quot;TSPublicKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSQualifiedName = </span><span class="s3">&quot;TSQualifiedName&quot;</span><span class="s1">,</span>
    <span class="s1">TSReadonlyKeyword = </span><span class="s3">&quot;TSReadonlyKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSRestType = </span><span class="s3">&quot;TSRestType&quot;</span><span class="s1">,</span>
    <span class="s1">TSSatisfiesExpression = </span><span class="s3">&quot;TSSatisfiesExpression&quot;</span><span class="s1">,</span>
    <span class="s1">TSStaticKeyword = </span><span class="s3">&quot;TSStaticKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSStringKeyword = </span><span class="s3">&quot;TSStringKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSSymbolKeyword = </span><span class="s3">&quot;TSSymbolKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSTemplateLiteralType = </span><span class="s3">&quot;TSTemplateLiteralType&quot;</span><span class="s1">,</span>
    <span class="s1">TSThisType = </span><span class="s3">&quot;TSThisType&quot;</span><span class="s1">,</span>
    <span class="s1">TSTupleType = </span><span class="s3">&quot;TSTupleType&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeAliasDeclaration = </span><span class="s3">&quot;TSTypeAliasDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeAnnotation = </span><span class="s3">&quot;TSTypeAnnotation&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeAssertion = </span><span class="s3">&quot;TSTypeAssertion&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeLiteral = </span><span class="s3">&quot;TSTypeLiteral&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeOperator = </span><span class="s3">&quot;TSTypeOperator&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeParameter = </span><span class="s3">&quot;TSTypeParameter&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeParameterDeclaration = </span><span class="s3">&quot;TSTypeParameterDeclaration&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeParameterInstantiation = </span><span class="s3">&quot;TSTypeParameterInstantiation&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypePredicate = </span><span class="s3">&quot;TSTypePredicate&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeQuery = </span><span class="s3">&quot;TSTypeQuery&quot;</span><span class="s1">,</span>
    <span class="s1">TSTypeReference = </span><span class="s3">&quot;TSTypeReference&quot;</span><span class="s1">,</span>
    <span class="s1">TSUndefinedKeyword = </span><span class="s3">&quot;TSUndefinedKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSUnionType = </span><span class="s3">&quot;TSUnionType&quot;</span><span class="s1">,</span>
    <span class="s1">TSUnknownKeyword = </span><span class="s3">&quot;TSUnknownKeyword&quot;</span><span class="s1">,</span>
    <span class="s1">TSVoidKeyword = </span><span class="s3">&quot;TSVoidKeyword&quot;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">enum </span><span class="s1">AST_TOKEN_TYPES {</span>
    <span class="s1">Boolean = </span><span class="s3">&quot;Boolean&quot;</span><span class="s1">,</span>
    <span class="s1">Identifier = </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">,</span>
    <span class="s1">JSXIdentifier = </span><span class="s3">&quot;JSXIdentifier&quot;</span><span class="s1">,</span>
    <span class="s1">PrivateIdentifier = </span><span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s1">,</span>
    <span class="s1">JSXText = </span><span class="s3">&quot;JSXText&quot;</span><span class="s1">,</span>
    <span class="s1">Keyword = </span><span class="s3">&quot;Keyword&quot;</span><span class="s1">,</span>
    <span class="s1">Null = </span><span class="s3">&quot;Null&quot;</span><span class="s1">,</span>
    <span class="s1">Numeric = </span><span class="s3">&quot;Numeric&quot;</span><span class="s1">,</span>
    <span class="s1">Punctuator = </span><span class="s3">&quot;Punctuator&quot;</span><span class="s1">,</span>
    <span class="s1">RegularExpression = </span><span class="s3">&quot;RegularExpression&quot;</span><span class="s1">,</span>
    <span class="s1">String = </span><span class="s3">&quot;String&quot;</span><span class="s1">,</span>
    <span class="s1">Template = </span><span class="s3">&quot;Template&quot;</span><span class="s1">,</span>
    <span class="s1">Block = </span><span class="s3">&quot;Block&quot;</span><span class="s1">,</span>
    <span class="s1">Line = </span><span class="s3">&quot;Line&quot;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">AwaitExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.AwaitExpression;</span>
    <span class="s1">argument: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BaseNode </span><span class="s2">extends </span><span class="s1">NodeOrTokenData {</span>
    <span class="s1">type: AST_NODE_TYPES;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">BaseToken </span><span class="s2">extends </span><span class="s1">NodeOrTokenData {</span>
    <span class="s1">type: AST_TOKEN_TYPES;</span>
    <span class="s1">value: string;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BigIntLiteral </span><span class="s2">extends </span><span class="s1">LiteralBase {</span>
    <span class="s1">bigint: string;</span>
    <span class="s1">value: bigint | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BinaryExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.BinaryExpression;</span>
    <span class="s1">left: Expression | PrivateIdentifier;</span>
    <span class="s1">operator: ValueOf&lt;BinaryOperatorToText&gt;;</span>
    <span class="s1">right: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BinaryOperatorToText {</span>
    <span class="s1">[SyntaxKind.AmpersandAmpersandToken]: </span><span class="s3">'&amp;&amp;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AmpersandToken]: </span><span class="s3">'&amp;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AsteriskAsteriskToken]: </span><span class="s3">'**'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AsteriskToken]: </span><span class="s3">'*'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.BarBarToken]: </span><span class="s3">'||'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.BarToken]: </span><span class="s3">'|'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.CaretToken]: </span><span class="s3">'^'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.EqualsEqualsEqualsToken]: </span><span class="s3">'==='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.EqualsEqualsToken]: </span><span class="s3">'=='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.ExclamationEqualsEqualsToken]: </span><span class="s3">'!=='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.ExclamationEqualsToken]: </span><span class="s3">'!='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanEqualsToken]: </span><span class="s3">'&gt;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: </span><span class="s3">'&gt;&gt;&gt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanGreaterThanToken]: </span><span class="s3">'&gt;&gt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanToken]: </span><span class="s3">'&gt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.InKeyword]: </span><span class="s3">'in'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.InstanceOfKeyword]: </span><span class="s3">'instanceof'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.LessThanEqualsToken]: </span><span class="s3">'&lt;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.LessThanLessThanToken]: </span><span class="s3">'&lt;&lt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.LessThanToken]: </span><span class="s3">'&lt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.MinusToken]: </span><span class="s3">'-'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.PercentToken]: </span><span class="s3">'%'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.PlusToken]: </span><span class="s3">'+'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.SlashToken]: </span><span class="s3">'/'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type BindingName = BindingPattern | Identifier;</span>
<span class="s2">export </span><span class="s1">declare type BindingPattern = ArrayPattern | ObjectPattern;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BlockComment </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Block;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BlockStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.BlockStatement;</span>
    <span class="s1">body: Statement[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BooleanLiteral </span><span class="s2">extends </span><span class="s1">LiteralBase {</span>
    <span class="s1">raw: </span><span class="s3">'false' </span><span class="s1">| </span><span class="s3">'true'</span><span class="s1">;</span>
    <span class="s1">value: boolean;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BooleanToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Boolean;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BreakStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.BreakStatement;</span>
    <span class="s1">label: Identifier | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">CallExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.CallExpression;</span>
    <span class="s1">arguments: CallExpressionArgument[];</span>
    <span class="s1">callee: Expression;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type CallExpressionArgument = Expression | SpreadElement;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">CatchClause </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.CatchClause;</span>
    <span class="s1">body: BlockStatement;</span>
    <span class="s1">param: BindingName | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ChainElement = CallExpression | MemberExpression | TSNonNullExpression;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ChainExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ChainExpression;</span>
    <span class="s1">expression: ChainElement;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">ClassBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the class is an abstract class.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* abstract class Foo {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">abstract: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The class body.</span>
     <span class="s0">*/</span>
    <span class="s1">body: ClassBody;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the class has been `declare`d:</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* declare class Foo {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declare: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The decorators declared for the class.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* @deco</span>
     <span class="s0">* class Foo {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The class's name.</span>
     <span class="s0">* - For a `ClassExpression` this may be `null` if the name is omitted.</span>
     <span class="s0">* - For a `ClassDeclaration` this may be `null` if and only if the parent is</span>
     <span class="s0">*   an `ExportDefaultDeclaration`.</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The implemented interfaces for the class.</span>
     <span class="s0">*/</span>
    <span class="s2">implements</span><span class="s1">: TSClassImplements[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The super class this class extends.</span>
     <span class="s0">*/</span>
    <span class="s1">superClass: LeftHandSideExpression | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameters passed to the superClass.</span>
     <span class="s0">*/</span>
    <span class="s1">superTypeArguments: TSTypeParameterInstantiation | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameters declared for the class.</span>
     <span class="s0">*/</span>
    <span class="s1">typeParameters: TSTypeParameterDeclaration | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ClassBody </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ClassBody;</span>
    <span class="s1">body: ClassElement[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ClassDeclaration = ClassDeclarationWithName | ClassDeclarationWithOptionalName;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">ClassDeclarationBase </span><span class="s2">extends </span><span class="s1">ClassBase {</span>
    <span class="s1">type: AST_NODE_TYPES.ClassDeclaration;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* A normal class declaration:</span>
 <span class="s0">* ```</span>
 <span class="s0">* class A {}</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ClassDeclarationWithName </span><span class="s2">extends </span><span class="s1">ClassDeclarationBase {</span>
    <span class="s1">id: Identifier;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Default-exported class declarations have optional names:</span>
 <span class="s0">* ```</span>
 <span class="s0">* export default class {}</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ClassDeclarationWithOptionalName </span><span class="s2">extends </span><span class="s1">ClassDeclarationBase {</span>
    <span class="s1">id: Identifier | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ClassElement = AccessorProperty | MethodDefinition | PropertyDefinition | StaticBlock | TSAbstractAccessorProperty | TSAbstractMethodDefinition | TSAbstractPropertyDefinition | TSIndexSignature;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ClassExpression </span><span class="s2">extends </span><span class="s1">ClassBase {</span>
    <span class="s1">type: AST_NODE_TYPES.ClassExpression;</span>
    <span class="s1">abstract: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">ClassMethodDefinitionNonComputedNameBase </span><span class="s2">extends </span><span class="s1">MethodDefinitionBase {</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">key: ClassPropertyNameNonComputed;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">ClassPropertyDefinitionNonComputedNameBase </span><span class="s2">extends </span><span class="s1">PropertyDefinitionBase {</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">key: ClassPropertyNameNonComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ClassPropertyNameNonComputed = PrivateIdentifier | PropertyNameNonComputed;</span>
<span class="s2">export </span><span class="s1">declare type Comment = BlockComment | LineComment;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ConditionalExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ConditionalExpression;</span>
    <span class="s1">alternate: Expression;</span>
    <span class="s1">consequent: Expression;</span>
    <span class="s1">test: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ConstDeclaration </span><span class="s2">extends </span><span class="s1">LetOrConstOrVarDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* In a `declare const` declaration, the declarators may have initializers, but</span>
     <span class="s0">* not definite assignment assertions. Each declarator cannot have both an</span>
     <span class="s0">* initializer and a type annotation.</span>
     <span class="s0">*</span>
     <span class="s0">* Even if the declaration has no `declare`, it may still be ambient and have</span>
     <span class="s0">* no initializer.</span>
     <span class="s0">*/</span>
    <span class="s1">declarations: VariableDeclaratorMaybeInit[];</span>
    <span class="s1">kind: </span><span class="s3">'const'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ContinueStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ContinueStatement;</span>
    <span class="s1">label: Identifier | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">DebuggerStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.DebuggerStatement;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s4">@deprecated</span>
 <span class="s0">* Note that this is neither up to date nor fully correct.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type DeclarationStatement = ClassDeclaration | ClassExpression | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | FunctionDeclaration | TSDeclareFunction | TSEnumDeclaration | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSNamespaceExportDeclaration | TSTypeAliasDeclaration;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">Decorator </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.Decorator;</span>
    <span class="s1">expression: LeftHandSideExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type DefaultExportDeclarations = ClassDeclarationWithOptionalName | Expression | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;</span>
<span class="s2">export </span><span class="s1">declare type DestructuringPattern = ArrayPattern | AssignmentPattern | Identifier | MemberExpression | ObjectPattern | RestElement;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">DoWhileStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.DoWhileStatement;</span>
    <span class="s1">body: Statement;</span>
    <span class="s1">test: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">EmptyStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.EmptyStatement;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type EntityName = Identifier | ThisExpression | TSQualifiedName;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportAllDeclaration </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ExportAllDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The assertions declared for the export.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* export * from 'mod' assert \{ type: 'json' \};</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Replaced with {</span><span class="s4">@link </span><span class="s0">`attributes`}.</span>
     <span class="s0">*/</span>
    <span class="s1">assertions: ImportAttribute[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The attributes declared for the export.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* export * from 'mod' with \{ type: 'json' \};</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">attributes: ImportAttribute[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The name for the exported items (`as X`). `null` if no name is assigned.</span>
     <span class="s0">*/</span>
    <span class="s1">exported: Identifier | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the export.</span>
     <span class="s0">*/</span>
    <span class="s1">exportKind: ExportKind;</span>
    <span class="s0">/**</span>
     <span class="s0">* The source module being exported from.</span>
     <span class="s0">*/</span>
    <span class="s1">source: StringLiteral;</span>
<span class="s1">}</span>
<span class="s1">declare type ExportAndImportKind = </span><span class="s3">'type' </span><span class="s1">| </span><span class="s3">'value'</span><span class="s1">;</span>
<span class="s2">export </span><span class="s1">declare type ExportDeclaration = DefaultExportDeclarations | NamedExportDeclarations;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportDefaultDeclaration </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ExportDefaultDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The declaration being exported.</span>
     <span class="s0">*/</span>
    <span class="s1">declaration: DefaultExportDeclarations;</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the export. Always `value` for default exports.</span>
     <span class="s0">*/</span>
    <span class="s1">exportKind: </span><span class="s3">'value'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">declare type ExportKind = ExportAndImportKind;</span>
<span class="s2">export </span><span class="s1">declare type ExportNamedDeclaration = ExportNamedDeclarationWithoutSourceWithMultiple | ExportNamedDeclarationWithoutSourceWithSingle | ExportNamedDeclarationWithSource;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportNamedDeclarationBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ExportNamedDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The assertions declared for the export.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* export { foo } from 'mod' assert \{ type: 'json' \};</span>
     <span class="s0">* ```</span>
     <span class="s0">* This will be an empty array if `source` is `null`</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Replaced with {</span><span class="s4">@link </span><span class="s0">`attributes`}.</span>
     <span class="s0">*/</span>
    <span class="s1">assertions: ImportAttribute[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The attributes declared for the export.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* export { foo } from 'mod' with \{ type: 'json' \};</span>
     <span class="s0">* ```</span>
     <span class="s0">* This will be an empty array if `source` is `null`</span>
     <span class="s0">*/</span>
    <span class="s1">attributes: ImportAttribute[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The exported declaration.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* export const x = 1;</span>
     <span class="s0">* ```</span>
     <span class="s0">* This will be `null` if `source` is not `null`, or if there are `specifiers`</span>
     <span class="s0">*/</span>
    <span class="s1">declaration: NamedExportDeclarations | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the export.</span>
     <span class="s0">*/</span>
    <span class="s1">exportKind: ExportKind;</span>
    <span class="s0">/**</span>
     <span class="s0">* The source module being exported from.</span>
     <span class="s0">*/</span>
    <span class="s1">source: StringLiteral | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The specifiers being exported.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* export { a, b };</span>
     <span class="s0">* ```</span>
     <span class="s0">* This will be an empty array if `declaration` is not `null`</span>
     <span class="s0">*/</span>
    <span class="s1">specifiers: ExportSpecifier[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ExportNamedDeclarationWithoutSource = ExportNamedDeclarationWithoutSourceWithMultiple | ExportNamedDeclarationWithoutSourceWithSingle;</span>
<span class="s0">/**</span>
 <span class="s0">* Exporting names from the current module.</span>
 <span class="s0">* ```</span>
 <span class="s0">* export {};</span>
 <span class="s0">* export { a, b };</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportNamedDeclarationWithoutSourceWithMultiple </span><span class="s2">extends </span><span class="s1">ExportNamedDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* This will always be an empty array.</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Replaced with {</span><span class="s4">@link </span><span class="s0">`attributes`}.</span>
     <span class="s0">*/</span>
    <span class="s1">assertions: ImportAttribute[];</span>
    <span class="s0">/**</span>
     <span class="s0">* This will always be an empty array.</span>
     <span class="s0">*/</span>
    <span class="s1">attributes: ImportAttribute[];</span>
    <span class="s1">declaration: </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">source: </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">specifiers: ExportSpecifierWithIdentifierLocal[];</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Exporting a single named declaration.</span>
 <span class="s0">* ```</span>
 <span class="s0">* export const x = 1;</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportNamedDeclarationWithoutSourceWithSingle </span><span class="s2">extends </span><span class="s1">ExportNamedDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* This will always be an empty array.</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Replaced with {</span><span class="s4">@link </span><span class="s0">`attributes`}.</span>
     <span class="s0">*/</span>
    <span class="s1">assertions: ImportAttribute[];</span>
    <span class="s0">/**</span>
     <span class="s0">* This will always be an empty array.</span>
     <span class="s0">*/</span>
    <span class="s1">attributes: ImportAttribute[];</span>
    <span class="s1">declaration: NamedExportDeclarations;</span>
    <span class="s1">source: </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This will always be an empty array.</span>
     <span class="s0">*/</span>
    <span class="s1">specifiers: ExportSpecifierWithIdentifierLocal[];</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Export names from another module.</span>
 <span class="s0">* ```</span>
 <span class="s0">* export { a, b } from 'mod';</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportNamedDeclarationWithSource </span><span class="s2">extends </span><span class="s1">ExportNamedDeclarationBase {</span>
    <span class="s1">declaration: </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">source: StringLiteral;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ExportSpecifier = ExportSpecifierWithIdentifierLocal | ExportSpecifierWithStringOrLiteralLocal;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportSpecifierBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ExportSpecifier;</span>
    <span class="s1">exported: Identifier | StringLiteral;</span>
    <span class="s1">exportKind: ExportKind;</span>
    <span class="s1">local: Identifier | StringLiteral;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportSpecifierWithIdentifierLocal </span><span class="s2">extends </span><span class="s1">ExportSpecifierBase {</span>
    <span class="s1">local: Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExportSpecifierWithStringOrLiteralLocal </span><span class="s2">extends </span><span class="s1">ExportSpecifierBase {</span>
    <span class="s1">local: Identifier | StringLiteral;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type Expression = ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AwaitExpression | BinaryExpression | CallExpression | ChainExpression | ClassExpression | ConditionalExpression | FunctionExpression | Identifier | ImportExpression | JSXElement | JSXFragment | LiteralExpression | LogicalExpression | MemberExpression | MetaProperty | NewExpression | ObjectExpression | ObjectPattern | SequenceExpression | Super | TaggedTemplateExpression | TemplateLiteral | ThisExpression | TSAsExpression | TSInstantiationExpression | TSNonNullExpression | TSSatisfiesExpression | TSTypeAssertion | UnaryExpression | UpdateExpression | YieldExpression;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ExpressionStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ExpressionStatement;</span>
    <span class="s1">directive: string | undefined;</span>
    <span class="s1">expression: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ForInitialiser = Expression | LetOrConstOrVarDeclaration;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ForInStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ForInStatement;</span>
    <span class="s1">body: Statement;</span>
    <span class="s1">left: ForInitialiser;</span>
    <span class="s1">right: Expression;</span>
<span class="s1">}</span>
<span class="s1">declare type ForOfInitialiser = Expression | LetOrConstOrVarDeclaration | UsingInForOfDeclaration;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ForOfStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ForOfStatement;</span>
    <span class="s2">await</span><span class="s1">: boolean;</span>
    <span class="s1">body: Statement;</span>
    <span class="s1">left: ForOfInitialiser;</span>
    <span class="s1">right: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ForStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ForStatement;</span>
    <span class="s1">body: Statement;</span>
    <span class="s1">init: Expression | ForInitialiser | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">test: Expression | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">update: Expression | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">FunctionBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the function is async:</span>
     <span class="s0">* ```</span>
     <span class="s0">* async function foo() {}</span>
     <span class="s0">* const x = async function () {}</span>
     <span class="s0">* const x = async () =&gt; {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">async: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The body of the function.</span>
     <span class="s0">* - For an `ArrowFunctionExpression` this may be an `Expression` or `BlockStatement`.</span>
     <span class="s0">* - For a `FunctionDeclaration` or `FunctionExpression` this is always a `BlockStatement`.</span>
     <span class="s0">* - For a `TSDeclareFunction` this is always `undefined`.</span>
     <span class="s0">* - For a `TSEmptyBodyFunctionExpression` this is always `null`.</span>
     <span class="s0">*/</span>
    <span class="s1">body: BlockStatement | Expression | </span><span class="s2">null </span><span class="s1">| undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* This is only `true` if and only if the node is a `TSDeclareFunction` and it has `declare`:</span>
     <span class="s0">* ```</span>
     <span class="s0">* declare function foo() {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declare: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* This is only ever `true` if and only the node is an `ArrowFunctionExpression` and the body</span>
     <span class="s0">* is an expression:</span>
     <span class="s0">* ```</span>
     <span class="s0">* (() =&gt; 1)</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">expression: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the function is a generator function:</span>
     <span class="s0">* ```</span>
     <span class="s0">* function *foo() {}</span>
     <span class="s0">* const x = function *() {}</span>
     <span class="s0">* ```</span>
     <span class="s0">* This is always `false` for arrow functions as they cannot be generators.</span>
     <span class="s0">*/</span>
    <span class="s1">generator: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The function's name.</span>
     <span class="s0">* - For an `ArrowFunctionExpression` this is always `null`.</span>
     <span class="s0">* - For a `FunctionExpression` this may be `null` if the name is omitted.</span>
     <span class="s0">* - For a `FunctionDeclaration` or `TSDeclareFunction` this may be `null` if</span>
     <span class="s0">*   and only if the parent is an `ExportDefaultDeclaration`.</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The list of parameters declared for the function.</span>
     <span class="s0">*/</span>
    <span class="s1">params: Parameter[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The return type annotation for the function.</span>
     <span class="s0">*/</span>
    <span class="s1">returnType: TSTypeAnnotation | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameter declaration for the function.</span>
     <span class="s0">*/</span>
    <span class="s1">typeParameters: TSTypeParameterDeclaration | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type FunctionDeclaration = FunctionDeclarationWithName | FunctionDeclarationWithOptionalName;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">FunctionDeclarationBase </span><span class="s2">extends </span><span class="s1">FunctionBase {</span>
    <span class="s1">type: AST_NODE_TYPES.FunctionDeclaration;</span>
    <span class="s1">body: BlockStatement;</span>
    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* A normal function declaration:</span>
 <span class="s0">* ```</span>
 <span class="s0">* function f() {}</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">FunctionDeclarationWithName </span><span class="s2">extends </span><span class="s1">FunctionDeclarationBase {</span>
    <span class="s1">id: Identifier;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Default-exported function declarations have optional names:</span>
 <span class="s0">* ```</span>
 <span class="s0">* export default function () {}</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">FunctionDeclarationWithOptionalName </span><span class="s2">extends </span><span class="s1">FunctionDeclarationBase {</span>
    <span class="s1">id: Identifier | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">FunctionExpression </span><span class="s2">extends </span><span class="s1">FunctionBase {</span>
    <span class="s1">type: AST_NODE_TYPES.FunctionExpression;</span>
    <span class="s1">body: BlockStatement;</span>
    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type FunctionLike = ArrowFunctionExpression | FunctionDeclaration | FunctionExpression | TSDeclareFunction | TSEmptyBodyFunctionExpression;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">Identifier </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.Identifier;</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s1">name: string;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">IdentifierToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">IfStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.IfStatement;</span>
    <span class="s1">alternate: Statement | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">consequent: Statement;</span>
    <span class="s1">test: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ImportAttribute </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ImportAttribute;</span>
    <span class="s1">key: Identifier | Literal;</span>
    <span class="s1">value: Literal;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ImportClause = ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ImportDeclaration </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ImportDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The assertions declared for the export.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* import * from 'mod' assert \{ type: 'json' \};</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Replaced with {</span><span class="s4">@link </span><span class="s0">`attributes`}.</span>
     <span class="s0">*/</span>
    <span class="s1">assertions: ImportAttribute[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The attributes declared for the export.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* import * from 'mod' with \{ type: 'json' \};</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">attributes: ImportAttribute[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the import.</span>
     <span class="s0">*/</span>
    <span class="s1">importKind: ImportKind;</span>
    <span class="s0">/**</span>
     <span class="s0">* The source module being imported from.</span>
     <span class="s0">*/</span>
    <span class="s1">source: StringLiteral;</span>
    <span class="s0">/**</span>
     <span class="s0">* The specifiers being imported.</span>
     <span class="s0">* If this is an empty array then either there are no specifiers:</span>
     <span class="s0">* ```</span>
     <span class="s0">* import {} from 'mod';</span>
     <span class="s0">* ```</span>
     <span class="s0">* Or it is a side-effect import:</span>
     <span class="s0">* ```</span>
     <span class="s0">* import 'mod';</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">specifiers: ImportClause[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ImportDefaultSpecifier </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ImportDefaultSpecifier;</span>
    <span class="s1">local: Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ImportExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ImportExpression;</span>
    <span class="s0">/**</span>
     <span class="s0">* The attributes declared for the dynamic import.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* import('mod', \{ assert: \{ type: 'json' \} \});</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Replaced with {</span><span class="s4">@link </span><span class="s0">`options`}.</span>
     <span class="s0">*/</span>
    <span class="s1">attributes: Expression | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The options bag declared for the dynamic import.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* import('mod', \{ assert: \{ type: 'json' \} \});</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">options: Expression | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">source: Expression;</span>
<span class="s1">}</span>
<span class="s1">declare type ImportKind = ExportAndImportKind;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ImportNamespaceSpecifier </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ImportNamespaceSpecifier;</span>
    <span class="s1">local: Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ImportSpecifier </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ImportSpecifier;</span>
    <span class="s1">imported: Identifier | StringLiteral;</span>
    <span class="s1">importKind: ImportKind;</span>
    <span class="s1">local: Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type IterationStatement = DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | WhileStatement;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXAttribute </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXAttribute;</span>
    <span class="s1">name: JSXIdentifier | JSXNamespacedName;</span>
    <span class="s1">value: JSXElement | JSXExpression | Literal | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type JSXChild = JSXElement | JSXExpression | JSXFragment | JSXText;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXClosingElement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXClosingElement;</span>
    <span class="s1">name: JSXTagNameExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXClosingFragment </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXClosingFragment;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXElement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXElement;</span>
    <span class="s1">children: JSXChild[];</span>
    <span class="s1">closingElement: JSXClosingElement | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">openingElement: JSXOpeningElement;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXEmptyExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXEmptyExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type JSXExpression = JSXExpressionContainer | JSXSpreadChild;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXExpressionContainer </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXExpressionContainer;</span>
    <span class="s1">expression: Expression | JSXEmptyExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXFragment </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXFragment;</span>
    <span class="s1">children: JSXChild[];</span>
    <span class="s1">closingFragment: JSXClosingFragment;</span>
    <span class="s1">openingFragment: JSXOpeningFragment;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXIdentifier </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXIdentifier;</span>
    <span class="s1">name: string;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXIdentifierToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.JSXIdentifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXMemberExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXMemberExpression;</span>
    <span class="s1">object: JSXTagNameExpression;</span>
    <span class="s1">property: JSXIdentifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXNamespacedName </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXNamespacedName;</span>
    <span class="s1">name: JSXIdentifier;</span>
    <span class="s1">namespace: JSXIdentifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXOpeningElement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXOpeningElement;</span>
    <span class="s1">attributes: (JSXAttribute | JSXSpreadAttribute)[];</span>
    <span class="s1">name: JSXTagNameExpression;</span>
    <span class="s1">selfClosing: boolean;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXOpeningFragment </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXOpeningFragment;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXSpreadAttribute </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXSpreadAttribute;</span>
    <span class="s1">argument: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXSpreadChild </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXSpreadChild;</span>
    <span class="s1">expression: Expression | JSXEmptyExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type JSXTagNameExpression = JSXIdentifier | JSXMemberExpression | JSXNamespacedName;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXText </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.JSXText;</span>
    <span class="s1">raw: string;</span>
    <span class="s1">value: string;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">JSXTextToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.JSXText;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">KeywordToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Keyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LabeledStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.LabeledStatement;</span>
    <span class="s1">body: Statement;</span>
    <span class="s1">label: Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type LeftHandSideExpression = ArrayExpression | ArrayPattern | ArrowFunctionExpression | CallExpression | ClassExpression | FunctionExpression | Identifier | JSXElement | JSXFragment | LiteralExpression | MemberExpression | MetaProperty | ObjectExpression | ObjectPattern | SequenceExpression | Super | TaggedTemplateExpression | ThisExpression | TSAsExpression | TSNonNullExpression | TSTypeAssertion;</span>
<span class="s2">export </span><span class="s1">declare type LetOrConstOrVarDeclaration = ConstDeclaration | LetOrVarDeclaredDeclaration | LetOrVarNonDeclaredDeclaration;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">LetOrConstOrVarDeclarationBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.VariableDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The variables declared by this declaration.</span>
     <span class="s0">* Always non-empty.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* let x;</span>
     <span class="s0">* let y, z;</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declarations: LetOrConstOrVarDeclarator[];</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the declaration is `declare`d</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* declare const x = 1;</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declare: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The keyword used to declare the variable(s)</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* const x = 1;</span>
     <span class="s0">* let y = 2;</span>
     <span class="s0">* var z = 3;</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">kind: </span><span class="s3">'const' </span><span class="s1">| </span><span class="s3">'let' </span><span class="s1">| </span><span class="s3">'var'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type LetOrConstOrVarDeclarator = VariableDeclaratorDefiniteAssignment | VariableDeclaratorMaybeInit | VariableDeclaratorNoInit;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LetOrVarDeclaredDeclaration </span><span class="s2">extends </span><span class="s1">LetOrConstOrVarDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* In a `declare let` declaration, the declarators must not have definite assignment</span>
     <span class="s0">* assertions or initializers.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* using x = 1;</span>
     <span class="s0">* using y =1, z = 2;</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declarations: VariableDeclaratorNoInit[];</span>
    <span class="s1">declare: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">kind: </span><span class="s3">'let' </span><span class="s1">| </span><span class="s3">'var'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LetOrVarNonDeclaredDeclaration </span><span class="s2">extends </span><span class="s1">LetOrConstOrVarDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* In a `let`/`var` declaration, the declarators may have definite assignment</span>
     <span class="s0">* assertions or initializers, but not both.</span>
     <span class="s0">*/</span>
    <span class="s1">declarations: (VariableDeclaratorDefiniteAssignment | VariableDeclaratorMaybeInit)[];</span>
    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">kind: </span><span class="s3">'let' </span><span class="s1">| </span><span class="s3">'var'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LineComment </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Line;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type Literal = BigIntLiteral | BooleanLiteral | NullLiteral | NumberLiteral | RegExpLiteral | StringLiteral;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">LiteralBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.Literal;</span>
    <span class="s1">raw: string;</span>
    <span class="s1">value: bigint | boolean | number | string | RegExp | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type LiteralExpression = Literal | TemplateLiteral;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LogicalExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.LogicalExpression;</span>
    <span class="s1">left: Expression;</span>
    <span class="s1">operator: </span><span class="s3">'&amp;&amp;' </span><span class="s1">| </span><span class="s3">'??' </span><span class="s1">| </span><span class="s3">'||'</span><span class="s1">;</span>
    <span class="s1">right: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type MemberExpression = MemberExpressionComputedName | MemberExpressionNonComputedName;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">MemberExpressionBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">computed: boolean;</span>
    <span class="s1">object: Expression;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">property: Expression | Identifier | PrivateIdentifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MemberExpressionComputedName </span><span class="s2">extends </span><span class="s1">MemberExpressionBase {</span>
    <span class="s1">type: AST_NODE_TYPES.MemberExpression;</span>
    <span class="s1">computed: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">property: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MemberExpressionNonComputedName </span><span class="s2">extends </span><span class="s1">MemberExpressionBase {</span>
    <span class="s1">type: AST_NODE_TYPES.MemberExpression;</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">property: Identifier | PrivateIdentifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MetaProperty </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.MetaProperty;</span>
    <span class="s1">meta: Identifier;</span>
    <span class="s1">property: Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type MethodDefinition = MethodDefinitionComputedName | MethodDefinitionNonComputedName;</span>
<span class="s0">/** this should not be directly used - instead use MethodDefinitionComputedNameBase or MethodDefinitionNonComputedNameBase */</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">MethodDefinitionBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">accessibility: Accessibility | undefined;</span>
    <span class="s1">computed: boolean;</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s1">key: PropertyName;</span>
    <span class="s1">kind: </span><span class="s3">'constructor' </span><span class="s1">| </span><span class="s3">'get' </span><span class="s1">| </span><span class="s3">'method' </span><span class="s1">| </span><span class="s3">'set'</span><span class="s1">;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">override: boolean;</span>
    <span class="s2">static</span><span class="s1">: boolean;</span>
    <span class="s1">value: FunctionExpression | TSEmptyBodyFunctionExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MethodDefinitionComputedName </span><span class="s2">extends </span><span class="s1">MethodDefinitionComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.MethodDefinition;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">MethodDefinitionComputedNameBase </span><span class="s2">extends </span><span class="s1">MethodDefinitionBase {</span>
    <span class="s1">computed: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MethodDefinitionNonComputedName </span><span class="s2">extends </span><span class="s1">ClassMethodDefinitionNonComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.MethodDefinition;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">MethodDefinitionNonComputedNameBase </span><span class="s2">extends </span><span class="s1">MethodDefinitionBase {</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameNonComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type NamedExportDeclarations = ClassDeclarationWithName | ClassDeclarationWithOptionalName | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">NewExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.NewExpression;</span>
    <span class="s1">arguments: CallExpressionArgument[];</span>
    <span class="s1">callee: Expression;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type Node = AccessorProperty | ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BlockStatement | BreakStatement | CallExpression | CatchClause | ChainExpression | ClassBody | ClassDeclaration | ClassExpression | ConditionalExpression | ContinueStatement | DebuggerStatement | Decorator | DoWhileStatement | EmptyStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | Identifier | IfStatement | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportExpression | ImportNamespaceSpecifier | ImportSpecifier | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | Literal | LogicalExpression | MemberExpression | MetaProperty | MethodDefinition | NewExpression | ObjectExpression | ObjectPattern | PrivateIdentifier | Program | Property | PropertyDefinition | RestElement | ReturnStatement | SequenceExpression | SpreadElement | StaticBlock | Super | SwitchCase | SwitchStatement | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThrowStatement | TryStatement | TSAbstractAccessorProperty | TSAbstractKeyword | TSAbstractMethodDefinition | TSAbstractPropertyDefinition | TSAnyKeyword | TSArrayType | TSAsExpression | TSAsyncKeyword | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSClassImplements | TSConditionalType | TSConstructorType | TSConstructSignatureDeclaration | TSDeclareFunction | TSDeclareKeyword | TSEmptyBodyFunctionExpression | TSEnumBody | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExportKeyword | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexedAccessType | TSIndexSignature | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSInterfaceHeritage | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSPrivateKeyword | TSPropertySignature | TSProtectedKeyword | TSPublicKeyword | TSQualifiedName | TSReadonlyKeyword | TSRestType | TSSatisfiesExpression | TSStaticKeyword | TSStringKeyword | TSSymbolKeyword | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | UnaryExpression | UpdateExpression | VariableDeclaration | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">NodeOrTokenData {</span>
    <span class="s1">type: string;</span>
    <span class="s0">/**</span>
     <span class="s0">* The source location information of the node.</span>
     <span class="s0">*</span>
     <span class="s0">* The loc property is defined as nullable by ESTree, but ESLint requires this property.</span>
     <span class="s0">*/</span>
    <span class="s1">loc: SourceLocation;</span>
    <span class="s1">range: Range;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">NullLiteral </span><span class="s2">extends </span><span class="s1">LiteralBase {</span>
    <span class="s1">raw: </span><span class="s3">'null'</span><span class="s1">;</span>
    <span class="s1">value: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">NullToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Null;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">NumberLiteral </span><span class="s2">extends </span><span class="s1">LiteralBase {</span>
    <span class="s1">value: number;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">NumericToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Numeric;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ObjectExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ObjectExpression;</span>
    <span class="s1">properties: ObjectLiteralElement[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ObjectLiteralElement = Property | SpreadElement;</span>
<span class="s2">export </span><span class="s1">declare type ObjectLiteralElementLike = ObjectLiteralElement;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ObjectPattern </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ObjectPattern;</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">properties: (Property | RestElement)[];</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type OptionalRangeAndLoc&lt;T&gt; = {</span>
    <span class="s1">loc?: SourceLocation;</span>
    <span class="s1">range?: Range;</span>
<span class="s1">} &amp; Pick&lt;T, Exclude&lt;keyof T, </span><span class="s3">'loc' </span><span class="s1">| </span><span class="s3">'range'</span><span class="s1">&gt;&gt;;</span>
<span class="s2">export </span><span class="s1">declare type Parameter = ArrayPattern | AssignmentPattern | Identifier | ObjectPattern | RestElement | TSParameterProperty;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">Position {</span>
    <span class="s0">/**</span>
     <span class="s0">* Column number on the line (0-indexed)</span>
     <span class="s0">*/</span>
    <span class="s1">column: number;</span>
    <span class="s0">/**</span>
     <span class="s0">* Line number (1-indexed)</span>
     <span class="s0">*/</span>
    <span class="s1">line: number;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type PrimaryExpression = ArrayExpression | ArrayPattern | ClassExpression | FunctionExpression | Identifier | JSXElement | JSXFragment | JSXOpeningElement | LiteralExpression | MetaProperty | ObjectExpression | ObjectPattern | Super | TemplateLiteral | ThisExpression | TSNullKeyword;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PrivateIdentifier </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.PrivateIdentifier;</span>
    <span class="s1">name: string;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PrivateIdentifierToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.PrivateIdentifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">Program </span><span class="s2">extends </span><span class="s1">NodeOrTokenData {</span>
    <span class="s1">type: AST_NODE_TYPES.Program;</span>
    <span class="s1">body: ProgramStatement[];</span>
    <span class="s1">comments: Comment[] | undefined;</span>
    <span class="s1">sourceType: </span><span class="s3">'module' </span><span class="s1">| </span><span class="s3">'script'</span><span class="s1">;</span>
    <span class="s1">tokens: Token[] | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type ProgramStatement = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | Statement | TSImportEqualsDeclaration | TSNamespaceExportDeclaration;</span>
<span class="s2">export </span><span class="s1">declare type Property = PropertyComputedName | PropertyNonComputedName;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">PropertyBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.Property;</span>
    <span class="s1">computed: boolean;</span>
    <span class="s1">key: PropertyName;</span>
    <span class="s1">kind: </span><span class="s3">'get' </span><span class="s1">| </span><span class="s3">'init' </span><span class="s1">| </span><span class="s3">'set'</span><span class="s1">;</span>
    <span class="s1">method: boolean;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">shorthand: boolean;</span>
    <span class="s1">value: AssignmentPattern | BindingName | Expression | TSEmptyBodyFunctionExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PropertyComputedName </span><span class="s2">extends </span><span class="s1">PropertyBase {</span>
    <span class="s1">computed: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type PropertyDefinition = PropertyDefinitionComputedName | PropertyDefinitionNonComputedName;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">PropertyDefinitionBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">accessibility: Accessibility | undefined;</span>
    <span class="s1">computed: boolean;</span>
    <span class="s1">declare: boolean;</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s1">definite: boolean;</span>
    <span class="s1">key: PropertyName;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">override: boolean;</span>
    <span class="s1">readonly: boolean;</span>
    <span class="s2">static</span><span class="s1">: boolean;</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | undefined;</span>
    <span class="s1">value: Expression | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PropertyDefinitionComputedName </span><span class="s2">extends </span><span class="s1">PropertyDefinitionComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.PropertyDefinition;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">PropertyDefinitionComputedNameBase </span><span class="s2">extends </span><span class="s1">PropertyDefinitionBase {</span>
    <span class="s1">computed: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PropertyDefinitionNonComputedName </span><span class="s2">extends </span><span class="s1">ClassPropertyDefinitionNonComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.PropertyDefinition;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">PropertyDefinitionNonComputedNameBase </span><span class="s2">extends </span><span class="s1">PropertyDefinitionBase {</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameNonComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type PropertyName = ClassPropertyNameNonComputed | PropertyNameComputed | PropertyNameNonComputed;</span>
<span class="s2">export </span><span class="s1">declare type PropertyNameComputed = Expression;</span>
<span class="s2">export </span><span class="s1">declare type PropertyNameNonComputed = Identifier | NumberLiteral | StringLiteral;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PropertyNonComputedName </span><span class="s2">extends </span><span class="s1">PropertyBase {</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameNonComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PunctuatorToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Punctuator;</span>
    <span class="s1">value: ValueOf&lt;PunctuatorTokenToText&gt;;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PunctuatorTokenToText </span><span class="s2">extends </span><span class="s1">AssignmentOperatorToText {</span>
    <span class="s1">[SyntaxKind.AmpersandAmpersandToken]: </span><span class="s3">'&amp;&amp;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AmpersandToken]: </span><span class="s3">'&amp;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AsteriskAsteriskToken]: </span><span class="s3">'**'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AsteriskToken]: </span><span class="s3">'*'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.AtToken]: </span><span class="s3">'@'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.BacktickToken]: </span><span class="s3">'`'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.BarBarToken]: </span><span class="s3">'||'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.BarToken]: </span><span class="s3">'|'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.CaretToken]: </span><span class="s3">'^'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.CloseBraceToken]: </span><span class="s3">'}'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.CloseBracketToken]: </span><span class="s3">']'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.CloseParenToken]: </span><span class="s3">')'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.ColonToken]: </span><span class="s3">':'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.CommaToken]: </span><span class="s3">','</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.DotDotDotToken]: </span><span class="s3">'...'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.DotToken]: </span><span class="s3">'.'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.EqualsEqualsEqualsToken]: </span><span class="s3">'==='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.EqualsEqualsToken]: </span><span class="s3">'=='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.EqualsGreaterThanToken]: </span><span class="s3">'=&gt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.ExclamationEqualsEqualsToken]: </span><span class="s3">'!=='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.ExclamationEqualsToken]: </span><span class="s3">'!='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.ExclamationToken]: </span><span class="s3">'!'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanEqualsToken]: </span><span class="s3">'&gt;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: </span><span class="s3">'&gt;&gt;&gt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanGreaterThanToken]: </span><span class="s3">'&gt;&gt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.GreaterThanToken]: </span><span class="s3">'&gt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.HashToken]: </span><span class="s3">'#'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.LessThanEqualsToken]: </span><span class="s3">'&lt;='</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.LessThanLessThanToken]: </span><span class="s3">'&lt;&lt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.LessThanSlashToken]: </span><span class="s3">'&lt;/'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.LessThanToken]: </span><span class="s3">'&lt;'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.MinusMinusToken]: </span><span class="s3">'--'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.MinusToken]: </span><span class="s3">'-'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.OpenBraceToken]: </span><span class="s3">'{'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.OpenBracketToken]: </span><span class="s3">'['</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.OpenParenToken]: </span><span class="s3">'('</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.PercentToken]: </span><span class="s3">'%'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.PlusPlusToken]: </span><span class="s3">'++'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.PlusToken]: </span><span class="s3">'+'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.QuestionDotToken]: </span><span class="s3">'?.'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.QuestionQuestionToken]: </span><span class="s3">'??'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.QuestionToken]: </span><span class="s3">'?'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.SemicolonToken]: </span><span class="s3">';'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.SlashToken]: </span><span class="s3">'/'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.TildeToken]: </span><span class="s3">'~'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* An array of two numbers.</span>
 <span class="s0">* Both numbers are a 0-based index which is the position in the array of source code characters.</span>
 <span class="s0">* The first is the start position of the node, the second is the end position of the node.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type Range = [number, number];</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">RegExpLiteral </span><span class="s2">extends </span><span class="s1">LiteralBase {</span>
    <span class="s1">regex: {</span>
        <span class="s1">flags: string;</span>
        <span class="s1">pattern: string;</span>
    <span class="s1">};</span>
    <span class="s1">value: RegExp | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">RegularExpressionToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.RegularExpression;</span>
    <span class="s1">regex: {</span>
        <span class="s1">flags: string;</span>
        <span class="s1">pattern: string;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">RestElement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.RestElement;</span>
    <span class="s1">argument: DestructuringPattern;</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | undefined;</span>
    <span class="s1">value: AssignmentPattern | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ReturnStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ReturnStatement;</span>
    <span class="s1">argument: Expression | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">SequenceExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.SequenceExpression;</span>
    <span class="s1">expressions: Expression[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">SourceLocation {</span>
    <span class="s0">/**</span>
     <span class="s0">* The position of the first character after the parsed source region</span>
     <span class="s0">*/</span>
    <span class="s1">end: Position;</span>
    <span class="s0">/**</span>
     <span class="s0">* The position of the first character of the parsed source region</span>
     <span class="s0">*/</span>
    <span class="s1">start: Position;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">SpreadElement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.SpreadElement;</span>
    <span class="s1">argument: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type Statement = BlockStatement | BreakStatement | ClassDeclarationWithName | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclarationWithName | IfStatement | ImportDeclaration | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | TSDeclareFunction | TSEnumDeclaration | TSExportAssignment | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSNamespaceExportDeclaration | TSTypeAliasDeclaration | VariableDeclaration | WhileStatement | WithStatement;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">StaticBlock </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.StaticBlock;</span>
    <span class="s1">body: Statement[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">StringLiteral </span><span class="s2">extends </span><span class="s1">LiteralBase {</span>
    <span class="s1">value: string;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">StringToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.String;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">Super </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.Super;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">SwitchCase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.SwitchCase;</span>
    <span class="s1">consequent: Statement[];</span>
    <span class="s1">test: Expression | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">SwitchStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.SwitchStatement;</span>
    <span class="s1">cases: SwitchCase[];</span>
    <span class="s1">discriminant: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TaggedTemplateExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TaggedTemplateExpression;</span>
    <span class="s1">quasi: TemplateLiteral;</span>
    <span class="s1">tag: Expression;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TemplateElement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TemplateElement;</span>
    <span class="s1">tail: boolean;</span>
    <span class="s1">value: {</span>
        <span class="s1">cooked: string;</span>
        <span class="s1">raw: string;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TemplateLiteral </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TemplateLiteral;</span>
    <span class="s1">expressions: Expression[];</span>
    <span class="s1">quasis: TemplateElement[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TemplateToken </span><span class="s2">extends </span><span class="s1">BaseToken {</span>
    <span class="s1">type: AST_TOKEN_TYPES.Template;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ThisExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ThisExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ThrowStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.ThrowStatement;</span>
    <span class="s1">argument: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type Token = BooleanToken | Comment | IdentifierToken | JSXIdentifierToken | JSXTextToken | KeywordToken | NullToken | NumericToken | PrivateIdentifierToken | PunctuatorToken | RegularExpressionToken | StringToken | TemplateToken;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TryStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TryStatement;</span>
    <span class="s1">block: BlockStatement;</span>
    <span class="s1">finalizer: BlockStatement | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">handler: CatchClause | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSAbstractAccessorProperty = TSAbstractAccessorPropertyComputedName | TSAbstractAccessorPropertyNonComputedName;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAbstractAccessorPropertyComputedName </span><span class="s2">extends </span><span class="s1">PropertyDefinitionComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAbstractAccessorProperty;</span>
    <span class="s1">value: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAbstractAccessorPropertyNonComputedName </span><span class="s2">extends </span><span class="s1">PropertyDefinitionNonComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAbstractAccessorProperty;</span>
    <span class="s1">value: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAbstractKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAbstractKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSAbstractMethodDefinition = TSAbstractMethodDefinitionComputedName | TSAbstractMethodDefinitionNonComputedName;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAbstractMethodDefinitionComputedName </span><span class="s2">extends </span><span class="s1">MethodDefinitionComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAbstractMethodDefinition;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAbstractMethodDefinitionNonComputedName </span><span class="s2">extends </span><span class="s1">MethodDefinitionNonComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAbstractMethodDefinition;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSAbstractPropertyDefinition = TSAbstractPropertyDefinitionComputedName | TSAbstractPropertyDefinitionNonComputedName;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAbstractPropertyDefinitionComputedName </span><span class="s2">extends </span><span class="s1">PropertyDefinitionComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAbstractPropertyDefinition;</span>
    <span class="s1">value: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAbstractPropertyDefinitionNonComputedName </span><span class="s2">extends </span><span class="s1">PropertyDefinitionNonComputedNameBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAbstractPropertyDefinition;</span>
    <span class="s1">value: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAnyKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAnyKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSArrayType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSArrayType;</span>
    <span class="s1">elementType: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAsExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAsExpression;</span>
    <span class="s1">expression: Expression;</span>
    <span class="s1">typeAnnotation: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSAsyncKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSAsyncKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSBigIntKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSBigIntKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSBooleanKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSBooleanKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSCallSignatureDeclaration </span><span class="s2">extends </span><span class="s1">TSFunctionSignatureBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSCallSignatureDeclaration;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSClassImplements </span><span class="s2">extends </span><span class="s1">TSHeritageBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSClassImplements;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSConditionalType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSConditionalType;</span>
    <span class="s1">checkType: TypeNode;</span>
    <span class="s1">extendsType: TypeNode;</span>
    <span class="s1">falseType: TypeNode;</span>
    <span class="s1">trueType: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSConstructorType </span><span class="s2">extends </span><span class="s1">TSFunctionSignatureBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSConstructorType;</span>
    <span class="s1">abstract: boolean;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSConstructSignatureDeclaration </span><span class="s2">extends </span><span class="s1">TSFunctionSignatureBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSConstructSignatureDeclaration;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSDeclareFunction = TSDeclareFunctionNoDeclare | TSDeclareFunctionWithDeclare;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSDeclareFunctionBase </span><span class="s2">extends </span><span class="s1">FunctionBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSDeclareFunction;</span>
    <span class="s0">/**</span>
     <span class="s0">* TS1183: An implementation cannot be declared in ambient contexts.</span>
     <span class="s0">*/</span>
    <span class="s1">body: undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the declaration has `declare` modifier.</span>
     <span class="s0">*/</span>
    <span class="s1">declare: boolean;</span>
    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Function declaration without the `declare` keyword:</span>
 <span class="s0">* ```</span>
 <span class="s0">* function foo(): void;</span>
 <span class="s0">* ```</span>
 <span class="s0">* This can either be an overload signature or a declaration in an ambient context</span>
 <span class="s0">* (e.g. `declare module`)</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSDeclareFunctionNoDeclare </span><span class="s2">extends </span><span class="s1">TSDeclareFunctionBase {</span>
    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* - TS1221: Generators are not allowed in an ambient context.</span>
     <span class="s0">* - TS1222: An overload signature cannot be declared as a generator.</span>
     <span class="s0">*/</span>
    <span class="s1">generator: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Function declaration with the `declare` keyword:</span>
 <span class="s0">* ```</span>
 <span class="s0">* declare function foo(): void;</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSDeclareFunctionWithDeclare </span><span class="s2">extends </span><span class="s1">TSDeclareFunctionBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* TS1040: 'async' modifier cannot be used in an ambient context.</span>
     <span class="s0">*/</span>
    <span class="s1">async: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">declare: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* TS1221: Generators are not allowed in an ambient context.</span>
     <span class="s0">*/</span>
    <span class="s1">generator: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSDeclareKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSDeclareKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSEmptyBodyFunctionExpression </span><span class="s2">extends </span><span class="s1">FunctionBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSEmptyBodyFunctionExpression;</span>
    <span class="s1">body: </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">id: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSEnumBody </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSEnumBody;</span>
    <span class="s1">members: TSEnumMember[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSEnumDeclaration </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSEnumDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The body of the enum.</span>
     <span class="s0">*/</span>
    <span class="s1">body: TSEnumBody;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether this is a `const` enum.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* const enum Foo {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s2">const</span><span class="s1">: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether this is a `declare`d enum.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* declare enum Foo {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declare: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The enum name.</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier;</span>
    <span class="s0">/**</span>
     <span class="s0">* The enum members.</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Use {</span><span class="s4">@link </span><span class="s0">body} instead.</span>
     <span class="s0">*/</span>
    <span class="s1">members: TSEnumMember[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSEnumMember </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSEnumMember;</span>
    <span class="s1">id: Identifier | StringLiteral;</span>
    <span class="s1">initializer: Expression | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">the enum member is always non-computed.</span>
     <span class="s0">*/</span>
    <span class="s1">computed: boolean;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSExportAssignment </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSExportAssignment;</span>
    <span class="s1">expression: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSExportKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSExportKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSExternalModuleReference </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSExternalModuleReference;</span>
    <span class="s1">expression: StringLiteral;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSFunctionSignatureBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">params: Parameter[];</span>
    <span class="s1">returnType: TSTypeAnnotation | undefined;</span>
    <span class="s1">typeParameters: TSTypeParameterDeclaration | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSFunctionType </span><span class="s2">extends </span><span class="s1">TSFunctionSignatureBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSFunctionType;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSHeritageBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">expression: Expression;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSImportEqualsDeclaration = TSImportEqualsNamespaceDeclaration | TSImportEqualsRequireDeclaration;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSImportEqualsDeclarationBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSImportEqualsDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The locally imported name.</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier;</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the import. Always `'value'` unless `moduleReference` is a</span>
     <span class="s0">* `TSExternalModuleReference`.</span>
     <span class="s0">*/</span>
    <span class="s1">importKind: ImportKind;</span>
    <span class="s0">/**</span>
     <span class="s0">* The value being aliased.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* import F1 = A;</span>
     <span class="s0">* import F2 = A.B.C;</span>
     <span class="s0">* import F3 = require('mod');</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">moduleReference: Identifier | TSExternalModuleReference | TSQualifiedName;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSImportEqualsNamespaceDeclaration </span><span class="s2">extends </span><span class="s1">TSImportEqualsDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the import.</span>
     <span class="s0">*/</span>
    <span class="s1">importKind: </span><span class="s3">'value'</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The value being aliased.</span>
     <span class="s0">* ```</span>
     <span class="s0">* import F1 = A;</span>
     <span class="s0">* import F2 = A.B.C;</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">moduleReference: Identifier | TSQualifiedName;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSImportEqualsRequireDeclaration </span><span class="s2">extends </span><span class="s1">TSImportEqualsDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the import.</span>
     <span class="s0">*/</span>
    <span class="s1">importKind: ImportKind;</span>
    <span class="s0">/**</span>
     <span class="s0">* The value being aliased.</span>
     <span class="s0">* ```</span>
     <span class="s0">* import F3 = require('mod');</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">moduleReference: TSExternalModuleReference;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSImportType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSImportType;</span>
    <span class="s1">argument: TypeNode;</span>
    <span class="s1">options: ObjectExpression | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">qualifier: EntityName | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSIndexedAccessType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSIndexedAccessType;</span>
    <span class="s1">indexType: TypeNode;</span>
    <span class="s1">objectType: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSIndexSignature </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSIndexSignature;</span>
    <span class="s1">accessibility: Accessibility | undefined;</span>
    <span class="s1">parameters: Parameter[];</span>
    <span class="s1">readonly: boolean;</span>
    <span class="s2">static</span><span class="s1">: boolean;</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSInferType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSInferType;</span>
    <span class="s1">typeParameter: TSTypeParameter;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSInstantiationExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSInstantiationExpression;</span>
    <span class="s1">expression: Expression;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSInterfaceBody </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSInterfaceBody;</span>
    <span class="s1">body: TypeElement[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSInterfaceDeclaration </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSInterfaceDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The body of the interface</span>
     <span class="s0">*/</span>
    <span class="s1">body: TSInterfaceBody;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the interface was `declare`d</span>
     <span class="s0">*/</span>
    <span class="s1">declare: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The types this interface `extends`</span>
     <span class="s0">*/</span>
    <span class="s2">extends</span><span class="s1">: TSInterfaceHeritage[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The name of this interface</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameters declared for the interface. Empty declaration</span>
     <span class="s0">* (`&lt;&gt;`) is different from no declaration.</span>
     <span class="s0">*/</span>
    <span class="s1">typeParameters: TSTypeParameterDeclaration | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSInterfaceHeritage </span><span class="s2">extends </span><span class="s1">TSHeritageBase {</span>
    <span class="s1">type: AST_NODE_TYPES.TSInterfaceHeritage;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSIntersectionType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSIntersectionType;</span>
    <span class="s1">types: TypeNode[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSIntrinsicKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSIntrinsicKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSLiteralType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSLiteralType;</span>
    <span class="s1">literal: LiteralExpression | UnaryExpression | UpdateExpression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSMappedType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSMappedType;</span>
    <span class="s1">constraint: TypeNode;</span>
    <span class="s1">key: Identifier;</span>
    <span class="s1">nameType: TypeNode | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">optional: boolean | </span><span class="s3">'+' </span><span class="s1">| </span><span class="s3">'-' </span><span class="s1">| undefined;</span>
    <span class="s1">readonly: boolean | </span><span class="s3">'+' </span><span class="s1">| </span><span class="s3">'-' </span><span class="s1">| undefined;</span>
    <span class="s1">typeAnnotation: TypeNode | undefined;</span>
    <span class="s0">/** </span><span class="s4">@deprecated </span><span class="s0">Use {</span><span class="s4">@link </span><span class="s0">`constraint`} and {</span><span class="s4">@link </span><span class="s0">`key`} instead. */</span>
    <span class="s1">typeParameter: TSTypeParameter;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSMethodSignature = TSMethodSignatureComputedName | TSMethodSignatureNonComputedName;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSMethodSignatureBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSMethodSignature;</span>
    <span class="s1">accessibility: Accessibility | undefined;</span>
    <span class="s1">computed: boolean;</span>
    <span class="s1">key: PropertyName;</span>
    <span class="s1">kind: </span><span class="s3">'get' </span><span class="s1">| </span><span class="s3">'method' </span><span class="s1">| </span><span class="s3">'set'</span><span class="s1">;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">params: Parameter[];</span>
    <span class="s1">readonly: boolean;</span>
    <span class="s1">returnType: TSTypeAnnotation | undefined;</span>
    <span class="s2">static</span><span class="s1">: boolean;</span>
    <span class="s1">typeParameters: TSTypeParameterDeclaration | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSMethodSignatureComputedName </span><span class="s2">extends </span><span class="s1">TSMethodSignatureBase {</span>
    <span class="s1">computed: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSMethodSignatureNonComputedName </span><span class="s2">extends </span><span class="s1">TSMethodSignatureBase {</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameNonComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSModuleBlock </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSModuleBlock;</span>
    <span class="s1">body: ProgramStatement[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSModuleDeclaration = TSModuleDeclarationGlobal | TSModuleDeclarationModule | TSModuleDeclarationNamespace;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSModuleDeclarationBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSModuleDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The body of the module.</span>
     <span class="s0">* This can only be `undefined` for the code `declare module 'mod';`</span>
     <span class="s0">*/</span>
    <span class="s1">body?: TSModuleBlock;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the module is `declare`d</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* declare namespace F {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declare: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether this is a global declaration</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* declare global {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@deprecated </span><span class="s0">Use {</span><span class="s4">@link </span><span class="s0">kind} instead</span>
     <span class="s0">*/</span>
    <span class="s1">global: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The name of the module</span>
     <span class="s0">* ```</span>
     <span class="s0">* namespace A {}</span>
     <span class="s0">* namespace A.B.C {}</span>
     <span class="s0">* module 'a' {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier | Literal | TSQualifiedName;</span>
    <span class="s0">/**</span>
     <span class="s0">* The keyword used to define this module declaration</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* namespace Foo {}</span>
     <span class="s0">* ^^^^^^^^^</span>
     <span class="s0">*</span>
     <span class="s0">* module 'foo' {}</span>
     <span class="s0">* ^^^^^^</span>
     <span class="s0">*</span>
     <span class="s0">* global {}</span>
     <span class="s0">* ^^^^^^</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">kind: TSModuleDeclarationKind;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSModuleDeclarationGlobal </span><span class="s2">extends </span><span class="s1">TSModuleDeclarationBase {</span>
    <span class="s1">body: TSModuleBlock;</span>
    <span class="s0">/**</span>
     <span class="s0">* This will always be an Identifier with name `global`</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier;</span>
    <span class="s1">kind: </span><span class="s3">'global'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSModuleDeclarationKind = </span><span class="s3">'global' </span><span class="s1">| </span><span class="s3">'module' </span><span class="s1">| </span><span class="s3">'namespace'</span><span class="s1">;</span>
<span class="s2">export </span><span class="s1">declare type TSModuleDeclarationModule = TSModuleDeclarationModuleWithIdentifierId | TSModuleDeclarationModuleWithStringId;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSModuleDeclarationModuleBase </span><span class="s2">extends </span><span class="s1">TSModuleDeclarationBase {</span>
    <span class="s1">kind: </span><span class="s3">'module'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* The legacy module declaration, replaced with namespace declarations.</span>
 <span class="s0">* ```</span>
 <span class="s0">* module A {}</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSModuleDeclarationModuleWithIdentifierId </span><span class="s2">extends </span><span class="s1">TSModuleDeclarationModuleBase {</span>
    <span class="s1">body: TSModuleBlock;</span>
    <span class="s1">id: Identifier;</span>
    <span class="s1">kind: </span><span class="s3">'module'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSModuleDeclarationModuleWithStringId = TSModuleDeclarationModuleWithStringIdDeclared | TSModuleDeclarationModuleWithStringIdNotDeclared;</span>
<span class="s0">/**</span>
 <span class="s0">* A string module declaration that is declared:</span>
 <span class="s0">* ```</span>
 <span class="s0">* declare module 'foo' {}</span>
 <span class="s0">* declare module 'foo';</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSModuleDeclarationModuleWithStringIdDeclared </span><span class="s2">extends </span><span class="s1">TSModuleDeclarationModuleBase {</span>
    <span class="s1">body?: TSModuleBlock;</span>
    <span class="s1">declare: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">id: StringLiteral;</span>
    <span class="s1">kind: </span><span class="s3">'module'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* A string module declaration that is not declared:</span>
 <span class="s0">* ```</span>
 <span class="s0">* module 'foo' {}</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSModuleDeclarationModuleWithStringIdNotDeclared </span><span class="s2">extends </span><span class="s1">TSModuleDeclarationModuleBase {</span>
    <span class="s1">body: TSModuleBlock;</span>
    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">id: StringLiteral;</span>
    <span class="s1">kind: </span><span class="s3">'module'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSModuleDeclarationNamespace </span><span class="s2">extends </span><span class="s1">TSModuleDeclarationBase {</span>
    <span class="s1">body: TSModuleBlock;</span>
    <span class="s1">id: Identifier | TSQualifiedName;</span>
    <span class="s1">kind: </span><span class="s3">'namespace'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSNamedTupleMember </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSNamedTupleMember;</span>
    <span class="s1">elementType: TypeNode;</span>
    <span class="s1">label: Identifier;</span>
    <span class="s1">optional: boolean;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* For the following declaration:</span>
 <span class="s0">* ```</span>
 <span class="s0">* export as namespace X;</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSNamespaceExportDeclaration </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSNamespaceExportDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* The name of the global variable that's exported as namespace</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSNeverKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSNeverKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSNonNullExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSNonNullExpression;</span>
    <span class="s1">expression: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSNullKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSNullKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSNumberKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSNumberKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSObjectKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSObjectKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSOptionalType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSOptionalType;</span>
    <span class="s1">typeAnnotation: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSParameterProperty </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSParameterProperty;</span>
    <span class="s1">accessibility: Accessibility | undefined;</span>
    <span class="s1">decorators: Decorator[];</span>
    <span class="s1">override: boolean;</span>
    <span class="s1">parameter: AssignmentPattern | BindingName | RestElement;</span>
    <span class="s1">readonly: boolean;</span>
    <span class="s2">static</span><span class="s1">: boolean;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSPrivateKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSPrivateKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSPropertySignature = TSPropertySignatureComputedName | TSPropertySignatureNonComputedName;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSPropertySignatureBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSPropertySignature;</span>
    <span class="s1">accessibility: Accessibility | undefined;</span>
    <span class="s1">computed: boolean;</span>
    <span class="s1">key: PropertyName;</span>
    <span class="s1">optional: boolean;</span>
    <span class="s1">readonly: boolean;</span>
    <span class="s2">static</span><span class="s1">: boolean;</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSPropertySignatureComputedName </span><span class="s2">extends </span><span class="s1">TSPropertySignatureBase {</span>
    <span class="s1">computed: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSPropertySignatureNonComputedName </span><span class="s2">extends </span><span class="s1">TSPropertySignatureBase {</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">key: PropertyNameNonComputed;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSProtectedKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSProtectedKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSPublicKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSPublicKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSQualifiedName </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSQualifiedName;</span>
    <span class="s1">left: EntityName;</span>
    <span class="s1">right: Identifier;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSReadonlyKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSReadonlyKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSRestType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSRestType;</span>
    <span class="s1">typeAnnotation: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSSatisfiesExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSSatisfiesExpression;</span>
    <span class="s1">expression: Expression;</span>
    <span class="s1">typeAnnotation: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSStaticKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSStaticKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSStringKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSStringKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSSymbolKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSSymbolKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTemplateLiteralType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTemplateLiteralType;</span>
    <span class="s1">quasis: TemplateElement[];</span>
    <span class="s1">types: TypeNode[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSThisType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSThisType;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTupleType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTupleType;</span>
    <span class="s1">elementTypes: TypeNode[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeAliasDeclaration </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeAliasDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the type was `declare`d.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* declare type T = 1;</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declare: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The name of the type.</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier;</span>
    <span class="s0">/**</span>
     <span class="s0">* The &quot;value&quot; (type) of the declaration</span>
     <span class="s0">*/</span>
    <span class="s1">typeAnnotation: TypeNode;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameters declared for the type. Empty declaration</span>
     <span class="s0">* (`&lt;&gt;`) is different from no declaration.</span>
     <span class="s0">*/</span>
    <span class="s1">typeParameters: TSTypeParameterDeclaration | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeAnnotation </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeAnnotation;</span>
    <span class="s1">typeAnnotation: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeAssertion </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeAssertion;</span>
    <span class="s1">expression: Expression;</span>
    <span class="s1">typeAnnotation: TypeNode;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeLiteral </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeLiteral;</span>
    <span class="s1">members: TypeElement[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeOperator </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeOperator;</span>
    <span class="s1">operator: </span><span class="s3">'keyof' </span><span class="s1">| </span><span class="s3">'readonly' </span><span class="s1">| </span><span class="s3">'unique'</span><span class="s1">;</span>
    <span class="s1">typeAnnotation: TypeNode | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeParameter </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeParameter;</span>
    <span class="s2">const</span><span class="s1">: boolean;</span>
    <span class="s1">constraint: TypeNode | undefined;</span>
    <span class="s2">default</span><span class="s1">: TypeNode | undefined;</span>
    <span class="s2">in</span><span class="s1">: boolean;</span>
    <span class="s1">name: Identifier;</span>
    <span class="s1">out: boolean;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeParameterDeclaration </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeParameterDeclaration;</span>
    <span class="s1">params: TSTypeParameter[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeParameterInstantiation </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeParameterInstantiation;</span>
    <span class="s1">params: TypeNode[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypePredicate </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypePredicate;</span>
    <span class="s1">asserts: boolean;</span>
    <span class="s1">parameterName: Identifier | TSThisType;</span>
    <span class="s1">typeAnnotation: TSTypeAnnotation | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeQuery </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeQuery;</span>
    <span class="s1">exprName: EntityName | TSImportType;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation | undefined;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSTypeReference </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSTypeReference;</span>
    <span class="s1">typeArguments: TSTypeParameterInstantiation | undefined;</span>
    <span class="s1">typeName: EntityName;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TSUnaryExpression = AwaitExpression | LeftHandSideExpression | UnaryExpression | UpdateExpression;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSUndefinedKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSUndefinedKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSUnionType </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSUnionType;</span>
    <span class="s1">types: TypeNode[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSUnknownKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSUnknownKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TSVoidKeyword </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.TSVoidKeyword;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type TypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSIndexSignature | TSMethodSignature | TSPropertySignature;</span>
<span class="s2">export </span><span class="s1">declare type TypeNode = TSAbstractKeyword | TSAnyKeyword | TSArrayType | TSAsyncKeyword | TSBigIntKeyword | TSBooleanKeyword | TSConditionalType | TSConstructorType | TSDeclareKeyword | TSExportKeyword | TSFunctionType | TSImportType | TSIndexedAccessType | TSInferType | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSNamedTupleMember | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSPrivateKeyword | TSProtectedKeyword | TSPublicKeyword | TSQualifiedName | TSReadonlyKeyword | TSRestType | TSStaticKeyword | TSStringKeyword | TSSymbolKeyword | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeLiteral | TSTypeOperator | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">UnaryExpression </span><span class="s2">extends </span><span class="s1">UnaryExpressionBase {</span>
    <span class="s1">type: AST_NODE_TYPES.UnaryExpression;</span>
    <span class="s1">operator: </span><span class="s3">'!' </span><span class="s1">| </span><span class="s3">'+' </span><span class="s1">| </span><span class="s3">'-' </span><span class="s1">| </span><span class="s3">'delete' </span><span class="s1">| </span><span class="s3">'typeof' </span><span class="s1">| </span><span class="s3">'void' </span><span class="s1">| </span><span class="s3">'~'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">UnaryExpressionBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">argument: Expression;</span>
    <span class="s1">operator: string;</span>
    <span class="s1">prefix: boolean;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">UpdateExpression </span><span class="s2">extends </span><span class="s1">UnaryExpressionBase {</span>
    <span class="s1">type: AST_NODE_TYPES.UpdateExpression;</span>
    <span class="s1">operator: </span><span class="s3">'++' </span><span class="s1">| </span><span class="s3">'--'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type UsingDeclaration = UsingInForOfDeclaration | UsingInNormalContextDeclaration;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">UsingDeclarationBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.VariableDeclaration;</span>
    <span class="s0">/**</span>
     <span class="s0">* This value will always be `false`</span>
     <span class="s0">* because 'declare' modifier cannot appear on a 'using' declaration.</span>
     <span class="s0">*/</span>
    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The keyword used to declare the variable(s)</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* using x = 1;</span>
     <span class="s0">* await using y = 2;</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">kind: </span><span class="s3">'await using' </span><span class="s1">| </span><span class="s3">'using'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare type UsingDeclarator = UsingInForOfDeclarator | UsingInNormalContextDeclarator;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">UsingInForOfDeclaration </span><span class="s2">extends </span><span class="s1">UsingDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* The variables declared by this declaration.</span>
     <span class="s0">* Always has exactly one element.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* for (using x of y) {}</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declarations: [UsingInForOfDeclarator];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">UsingInForOfDeclarator </span><span class="s2">extends </span><span class="s1">VariableDeclaratorBase {</span>
    <span class="s1">definite: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">id: Identifier;</span>
    <span class="s1">init: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">UsingInNormalContextDeclaration </span><span class="s2">extends </span><span class="s1">UsingDeclarationBase {</span>
    <span class="s0">/**</span>
     <span class="s0">* The variables declared by this declaration.</span>
     <span class="s0">* Always non-empty.</span>
     <span class="s0">* </span><span class="s4">@example</span>
     <span class="s0">* ```ts</span>
     <span class="s0">* using x = 1;</span>
     <span class="s0">* using y = 1, z = 2;</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">declarations: UsingInNormalContextDeclarator[];</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">UsingInNormalContextDeclarator </span><span class="s2">extends </span><span class="s1">VariableDeclaratorBase {</span>
    <span class="s1">definite: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">id: Identifier;</span>
    <span class="s1">init: Expression;</span>
<span class="s1">}</span>
<span class="s1">declare type ValueOf&lt;T&gt; = T[keyof T];</span>
<span class="s2">export </span><span class="s1">declare type VariableDeclaration = LetOrConstOrVarDeclaration | UsingDeclaration;</span>
<span class="s2">export </span><span class="s1">declare type VariableDeclarator = LetOrConstOrVarDeclarator | UsingDeclarator;</span>
<span class="s1">declare </span><span class="s2">interface </span><span class="s1">VariableDeclaratorBase </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.VariableDeclarator;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether there's definite assignment assertion (`let x!: number`).</span>
     <span class="s0">* If `true`, then: `id` must be an identifier with a type annotation,</span>
     <span class="s0">* `init` must be `null`, and the declarator must be a `var`/`let` declarator.</span>
     <span class="s0">*/</span>
    <span class="s1">definite: boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* The name(s) of the variable(s).</span>
     <span class="s0">*/</span>
    <span class="s1">id: BindingName;</span>
    <span class="s0">/**</span>
     <span class="s0">* The initializer expression of the variable. Must be present for `const` unless</span>
     <span class="s0">* in a `declare const`.</span>
     <span class="s0">*/</span>
    <span class="s1">init: Expression | </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">VariableDeclaratorDefiniteAssignment </span><span class="s2">extends </span><span class="s1">VariableDeclaratorBase {</span>
    <span class="s1">definite: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The name of the variable. Must have a type annotation.</span>
     <span class="s0">*/</span>
    <span class="s1">id: Identifier;</span>
    <span class="s1">init: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">VariableDeclaratorMaybeInit </span><span class="s2">extends </span><span class="s1">VariableDeclaratorBase {</span>
    <span class="s1">definite: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">VariableDeclaratorNoInit </span><span class="s2">extends </span><span class="s1">VariableDeclaratorBase {</span>
    <span class="s1">definite: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">init: </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">WhileStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.WhileStatement;</span>
    <span class="s1">body: Statement;</span>
    <span class="s1">test: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">WithStatement </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.WithStatement;</span>
    <span class="s1">body: Statement;</span>
    <span class="s1">object: Expression;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">YieldExpression </span><span class="s2">extends </span><span class="s1">BaseNode {</span>
    <span class="s1">type: AST_NODE_TYPES.YieldExpression;</span>
    <span class="s1">argument: Expression | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">delegate: boolean;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">{};</span>
</pre>
</body>
</html>