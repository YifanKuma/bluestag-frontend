<html>
<head>
<title>analyzeChain.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
analyzeChain.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || (</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">ownKeys = </span><span class="s2">function</span><span class="s1">(o) {</span>
        <span class="s1">ownKeys = Object.getOwnPropertyNames || </span><span class="s2">function </span><span class="s1">(o) {</span>
            <span class="s2">var </span><span class="s1">ar = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">o) </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;</span>
            <span class="s2">return </span><span class="s1">ar;</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">ownKeys(o);</span>
    <span class="s1">};</span>
    <span class="s2">return function </span><span class="s1">(mod) {</span>
        <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
        <span class="s2">var </span><span class="s1">result = {};</span>
        <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k = ownKeys(mod), i = </span><span class="s3">0</span><span class="s1">; i &lt; k.length; i++) </span><span class="s2">if </span><span class="s1">(k[i] !== </span><span class="s0">&quot;default&quot;</span><span class="s1">) __createBinding(result, mod, k[i]);</span>
        <span class="s1">__setModuleDefault(result, mod);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>
<span class="s1">})();</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.analyzeChain = analyzeChain;</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ts_api_utils_1 = require(</span><span class="s0">&quot;ts-api-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../../util&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">checkNullishAndReport_1 = require(</span><span class="s0">&quot;./checkNullishAndReport&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">compareNodes_1 = require(</span><span class="s0">&quot;./compareNodes&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">gatherLogicalOperands_1 = require(</span><span class="s0">&quot;./gatherLogicalOperands&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">includesType(parserServices, node, typeFlagIn) {</span>
    <span class="s2">const </span><span class="s1">typeFlag = typeFlagIn | ts.TypeFlags.Any | ts.TypeFlags.Unknown;</span>
    <span class="s2">const </span><span class="s1">types = (</span><span class="s3">0</span><span class="s1">, ts_api_utils_1.unionConstituents)(parserServices.getTypeAtLocation(node));</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">type of types) {</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isTypeFlagSet)(type, typeFlag)) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">analyzeAndChainOperand = (parserServices, operand, index, chain) =&gt; {</span>
    <span class="s2">switch </span><span class="s1">(operand.comparisonType) {</span>
        <span class="s2">case </span><span class="s1">gatherLogicalOperands_1.NullishComparisonType.Boolean: {</span>
            <span class="s2">const </span><span class="s1">nextOperand = chain.at(index + </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(nextOperand?.comparisonType ===</span>
                <span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualNull &amp;&amp;</span>
                <span class="s1">operand.comparedName.type === utils_1.AST_NODE_TYPES.Identifier) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[operand];</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotEqualNullOrUndefined:</span>
            <span class="s2">return </span><span class="s1">[operand];</span>
        <span class="s2">case </span><span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualNull: {</span>
            <span class="s4">// handle `x !== null &amp;&amp; x !== undefined`</span>
            <span class="s2">const </span><span class="s1">nextOperand = chain.at(index + </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(nextOperand?.comparisonType ===</span>
                <span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined &amp;&amp;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===</span>
                    <span class="s1">compareNodes_1.NodeComparisonResult.Equal) {</span>
                <span class="s2">return </span><span class="s1">[operand, nextOperand];</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(includesType(parserServices, operand.comparedName, ts.TypeFlags.Undefined)) {</span>
                <span class="s4">// we know the next operand is not an `undefined` check and that this</span>
                <span class="s4">// operand includes `undefined` - which means that making this an</span>
                <span class="s4">// optional chain would change the runtime behavior of the expression</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[operand];</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined: {</span>
            <span class="s4">// handle `x !== undefined &amp;&amp; x !== null`</span>
            <span class="s2">const </span><span class="s1">nextOperand = chain.at(index + </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(nextOperand?.comparisonType ===</span>
                <span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualNull &amp;&amp;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===</span>
                    <span class="s1">compareNodes_1.NodeComparisonResult.Equal) {</span>
                <span class="s2">return </span><span class="s1">[operand, nextOperand];</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(includesType(parserServices, operand.comparedName, ts.TypeFlags.Null)) {</span>
                <span class="s4">// we know the next operand is not a `null` check and that this</span>
                <span class="s4">// operand includes `null` - which means that making this an</span>
                <span class="s4">// optional chain would change the runtime behavior of the expression</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[operand];</span>
        <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">analyzeOrChainOperand = (parserServices, operand, index, chain) =&gt; {</span>
    <span class="s2">switch </span><span class="s1">(operand.comparisonType) {</span>
        <span class="s2">case </span><span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotBoolean:</span>
        <span class="s2">case </span><span class="s1">gatherLogicalOperands_1.NullishComparisonType.EqualNullOrUndefined:</span>
            <span class="s2">return </span><span class="s1">[operand];</span>
        <span class="s2">case </span><span class="s1">gatherLogicalOperands_1.NullishComparisonType.StrictEqualNull: {</span>
            <span class="s4">// handle `x === null || x === undefined`</span>
            <span class="s2">const </span><span class="s1">nextOperand = chain.at(index + </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(nextOperand?.comparisonType ===</span>
                <span class="s1">gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined &amp;&amp;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===</span>
                    <span class="s1">compareNodes_1.NodeComparisonResult.Equal) {</span>
                <span class="s2">return </span><span class="s1">[operand, nextOperand];</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(includesType(parserServices, operand.comparedName, ts.TypeFlags.Undefined)) {</span>
                <span class="s4">// we know the next operand is not an `undefined` check and that this</span>
                <span class="s4">// operand includes `undefined` - which means that making this an</span>
                <span class="s4">// optional chain would change the runtime behavior of the expression</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[operand];</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s1">gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined: {</span>
            <span class="s4">// handle `x === undefined || x === null`</span>
            <span class="s2">const </span><span class="s1">nextOperand = chain.at(index + </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(nextOperand?.comparisonType === gatherLogicalOperands_1.NullishComparisonType.StrictEqualNull &amp;&amp;</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===</span>
                    <span class="s1">compareNodes_1.NodeComparisonResult.Equal) {</span>
                <span class="s2">return </span><span class="s1">[operand, nextOperand];</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(includesType(parserServices, operand.comparedName, ts.TypeFlags.Null)) {</span>
                <span class="s4">// we know the next operand is not a `null` check and that this</span>
                <span class="s4">// operand includes `null` - which means that making this an</span>
                <span class="s4">// optional chain would change the runtime behavior of the expression</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[operand];</span>
        <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">};</span>
<span class="s4">/**</span>
 <span class="s4">* Returns the range that needs to be reported from the chain.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">chain The chain of logical expressions.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">boundary The boundary range that the range to report cannot fall outside.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">sourceCode The source code to get tokens.</span>
 <span class="s4">* </span><span class="s5">@returns </span><span class="s4">The range to report.</span>
 <span class="s4">*/</span>
<span class="s2">function </span><span class="s1">getReportRange(chain, boundary, sourceCode) {</span>
    <span class="s2">const </span><span class="s1">leftNode = chain[</span><span class="s3">0</span><span class="s1">].node;</span>
    <span class="s2">const </span><span class="s1">rightNode = chain[chain.length - </span><span class="s3">1</span><span class="s1">].node;</span>
    <span class="s2">let </span><span class="s1">leftMost = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(sourceCode.getFirstToken(leftNode), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'any token'</span><span class="s1">, leftNode.type));</span>
    <span class="s2">let </span><span class="s1">rightMost = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(sourceCode.getLastToken(rightNode), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'any token'</span><span class="s1">, rightNode.type));</span>
    <span class="s2">while </span><span class="s1">(leftMost.range[</span><span class="s3">0</span><span class="s1">] &gt; boundary[</span><span class="s3">0</span><span class="s1">]) {</span>
        <span class="s2">const </span><span class="s1">token = sourceCode.getTokenBefore(leftMost);</span>
        <span class="s2">if </span><span class="s1">(!token || !(</span><span class="s3">0</span><span class="s1">, util_1.isOpeningParenToken)(token) || token.range[</span><span class="s3">0</span><span class="s1">] &lt; boundary[</span><span class="s3">0</span><span class="s1">]) {</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">leftMost = token;</span>
    <span class="s1">}</span>
    <span class="s2">while </span><span class="s1">(rightMost.range[</span><span class="s3">1</span><span class="s1">] &lt; boundary[</span><span class="s3">1</span><span class="s1">]) {</span>
        <span class="s2">const </span><span class="s1">token = sourceCode.getTokenAfter(rightMost);</span>
        <span class="s2">if </span><span class="s1">(!token || !(</span><span class="s3">0</span><span class="s1">, util_1.isClosingParenToken)(token) || token.range[</span><span class="s3">1</span><span class="s1">] &gt; boundary[</span><span class="s3">1</span><span class="s1">]) {</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">rightMost = token;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[leftMost.range[</span><span class="s3">0</span><span class="s1">], rightMost.range[</span><span class="s3">1</span><span class="s1">]];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getReportDescriptor(sourceCode, parserServices, node, operator, options, chain) {</span>
    <span class="s2">const </span><span class="s1">lastOperand = chain[chain.length - </span><span class="s3">1</span><span class="s1">];</span>
    <span class="s2">let </span><span class="s1">useSuggestionFixer;</span>
    <span class="s2">if </span><span class="s1">(options.allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing ===</span>
        <span class="s2">true</span><span class="s1">) {</span>
        <span class="s4">// user has opted-in to the unsafe behavior</span>
        <span class="s1">useSuggestionFixer = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// optional chain specifically will union `undefined` into the final type</span>
    <span class="s4">// so we need to make sure that there is at least one operand that includes</span>
    <span class="s4">// `undefined`, or else we're going to change the final type - which is</span>
    <span class="s4">// unsafe and might cause downstream type errors.</span>
    <span class="s2">else if </span><span class="s1">(lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.EqualNullOrUndefined ||</span>
        <span class="s1">lastOperand.comparisonType ===</span>
            <span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotEqualNullOrUndefined ||</span>
        <span class="s1">lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined ||</span>
        <span class="s1">lastOperand.comparisonType ===</span>
            <span class="s1">gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined ||</span>
        <span class="s1">(operator === </span><span class="s0">'||' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.NotBoolean)) {</span>
        <span class="s4">// we know the last operand is an equality check - so the change in types</span>
        <span class="s4">// DOES NOT matter and will not change the runtime result or cause a type</span>
        <span class="s4">// check error</span>
        <span class="s1">useSuggestionFixer = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">useSuggestionFixer = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">operand of chain) {</span>
            <span class="s2">if </span><span class="s1">(includesType(parserServices, operand.node, ts.TypeFlags.Undefined)) {</span>
                <span class="s1">useSuggestionFixer = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// TODO - we could further reduce the false-positive rate of this check by</span>
        <span class="s4">//        checking for cases where the change in types don't matter like</span>
        <span class="s4">//        the test location of an if/while/etc statement.</span>
        <span class="s4">//        but it's quite complex to do this without false-negatives, so</span>
        <span class="s4">//        for now we'll just be over-eager with our matching.</span>
        <span class="s4">//</span>
        <span class="s4">//        it's MUCH better to false-positive here and only provide a</span>
        <span class="s4">//        suggestion fixer, rather than false-negative and autofix to</span>
        <span class="s4">//        broken code.</span>
    <span class="s1">}</span>
    <span class="s4">// In its most naive form we could just slap `?.` for every single part of the</span>
    <span class="s4">// chain. However this would be undesirable because it'd create unnecessary</span>
    <span class="s4">// conditions in the user's code where there were none before - and it would</span>
    <span class="s4">// cause errors with rules like our `no-unnecessary-condition`.</span>
    <span class="s4">//</span>
    <span class="s4">// Instead we want to include the minimum number of `?.` required to correctly</span>
    <span class="s4">// unify the code into a single chain. Naively you might think that we can</span>
    <span class="s4">// just take the final operand add `?.` after the locations from the previous</span>
    <span class="s4">// operands - however this won't be correct either because earlier operands</span>
    <span class="s4">// can include a necessary `?.` that's not needed or included in a later</span>
    <span class="s4">// operand.</span>
    <span class="s4">//</span>
    <span class="s4">// So instead what we need to do is to start at the first operand and</span>
    <span class="s4">// iteratively diff it against the next operand, and add the difference to the</span>
    <span class="s4">// first operand.</span>
    <span class="s4">//</span>
    <span class="s4">// eg</span>
    <span class="s4">// `foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz?.bam &amp;&amp; foo.bar.baz.bam()`</span>
    <span class="s4">// 1) `foo`</span>
    <span class="s4">// 2) diff(`foo`, `foo.bar`) = `.bar`</span>
    <span class="s4">// 3) result = `foo?.bar`</span>
    <span class="s4">// 4) diff(`foo.bar`, `foo.bar.baz?.bam`) = `.baz?.bam`</span>
    <span class="s4">// 5) result = `foo?.bar?.baz?.bam`</span>
    <span class="s4">// 6) diff(`foo.bar.baz?.bam`, `foo.bar.baz.bam()`) = `()`</span>
    <span class="s4">// 7) result = `foo?.bar?.baz?.bam?.()`</span>
    <span class="s2">const </span><span class="s1">parts = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">current of chain) {</span>
        <span class="s2">const </span><span class="s1">nextOperand = flattenChainExpression(sourceCode, current.comparedName);</span>
        <span class="s2">const </span><span class="s1">diff = nextOperand.slice(parts.length);</span>
        <span class="s2">if </span><span class="s1">(diff.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(parts.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s4">// we need to make the first operand of the diff optional so it matches the</span>
                <span class="s4">// logic before merging</span>
                <span class="s4">// foo.bar &amp;&amp; foo.bar.baz</span>
                <span class="s4">// diff = .baz</span>
                <span class="s4">// result = foo.bar?.baz</span>
                <span class="s1">diff[</span><span class="s3">0</span><span class="s1">].optional = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(...diff);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">newCode = parts</span>
        <span class="s1">.map(part =&gt; {</span>
        <span class="s2">let </span><span class="s1">str = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(part.optional) {</span>
            <span class="s1">str += </span><span class="s0">'?.'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(part.nonNull) {</span>
                <span class="s1">str += </span><span class="s0">'!'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(part.requiresDot) {</span>
                <span class="s1">str += </span><span class="s0">'.'</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(part.precedence !== util_1.OperatorPrecedence.Invalid &amp;&amp;</span>
            <span class="s1">part.precedence &lt; util_1.OperatorPrecedence.Member) {</span>
            <span class="s1">str += </span><span class="s0">`(</span><span class="s1">${part.text}</span><span class="s0">)`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">str += part.text;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">str;</span>
    <span class="s1">})</span>
        <span class="s1">.join(</span><span class="s0">''</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(lastOperand.node.type === utils_1.AST_NODE_TYPES.BinaryExpression) {</span>
        <span class="s4">// retain the ending comparison for cases like</span>
        <span class="s4">// x &amp;&amp; x.a != null</span>
        <span class="s4">// x &amp;&amp; typeof x.a !== 'undefined'</span>
        <span class="s2">const </span><span class="s1">operator = lastOperand.node.operator;</span>
        <span class="s2">const </span><span class="s1">{ left, right } = (() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(lastOperand.isYoda) {</span>
                <span class="s2">const </span><span class="s1">unaryOperator = lastOperand.node.right.type === utils_1.AST_NODE_TYPES.UnaryExpression</span>
                    <span class="s1">? </span><span class="s0">`</span><span class="s1">${lastOperand.node.right.operator} </span><span class="s0">`</span>
                    <span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">left: sourceCode.getText(lastOperand.node.left),</span>
                    <span class="s1">right: unaryOperator + newCode,</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">unaryOperator = lastOperand.node.left.type === utils_1.AST_NODE_TYPES.UnaryExpression</span>
                <span class="s1">? </span><span class="s0">`</span><span class="s1">${lastOperand.node.left.operator} </span><span class="s0">`</span>
                <span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">left: unaryOperator + newCode,</span>
                <span class="s1">right: sourceCode.getText(lastOperand.node.right),</span>
            <span class="s1">};</span>
        <span class="s1">})();</span>
        <span class="s1">newCode = </span><span class="s0">`</span><span class="s1">${left} ${operator} ${right}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.NotBoolean) {</span>
        <span class="s1">newCode = </span><span class="s0">`!</span><span class="s1">${newCode}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">reportRange = getReportRange(chain, node.range, sourceCode);</span>
    <span class="s2">const </span><span class="s1">fix = fixer =&gt; fixer.replaceTextRange(reportRange, newCode);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">loc: {</span>
            <span class="s1">end: sourceCode.getLocFromIndex(reportRange[</span><span class="s3">1</span><span class="s1">]),</span>
            <span class="s1">start: sourceCode.getLocFromIndex(reportRange[</span><span class="s3">0</span><span class="s1">]),</span>
        <span class="s1">},</span>
        <span class="s1">messageId: </span><span class="s0">'preferOptionalChain'</span><span class="s1">,</span>
        <span class="s1">...(</span><span class="s3">0</span><span class="s1">, util_1.getFixOrSuggest)({</span>
            <span class="s1">fixOrSuggest: useSuggestionFixer ? </span><span class="s0">'suggest' </span><span class="s1">: </span><span class="s0">'fix'</span><span class="s1">,</span>
            <span class="s1">suggestion: {</span>
                <span class="s1">fix,</span>
                <span class="s1">messageId: </span><span class="s0">'optionalChainSuggest'</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">}),</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">flattenChainExpression(sourceCode, node) {</span>
        <span class="s2">switch </span><span class="s1">(node.type) {</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ChainExpression:</span>
                <span class="s2">return </span><span class="s1">flattenChainExpression(sourceCode, node.expression);</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.CallExpression: {</span>
                <span class="s2">const </span><span class="s1">argumentsText = (() =&gt; {</span>
                    <span class="s2">const </span><span class="s1">closingParenToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(sourceCode.getLastToken(node), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'closing parenthesis'</span><span class="s1">, node.type));</span>
                    <span class="s2">const </span><span class="s1">openingParenToken = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(sourceCode.getFirstTokenBetween(node.typeArguments ?? node.callee, closingParenToken, util_1.isOpeningParenToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'opening parenthesis'</span><span class="s1">, node.type));</span>
                    <span class="s2">return </span><span class="s1">sourceCode.text.substring(openingParenToken.range[</span><span class="s3">0</span><span class="s1">], closingParenToken.range[</span><span class="s3">1</span><span class="s1">]);</span>
                <span class="s1">})();</span>
                <span class="s2">const </span><span class="s1">typeArgumentsText = (() =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(node.typeArguments == </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">sourceCode.getText(node.typeArguments);</span>
                <span class="s1">})();</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s1">...flattenChainExpression(sourceCode, node.callee),</span>
                    <span class="s1">{</span>
                        <span class="s1">nonNull: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">optional: node.optional,</span>
                        <span class="s4">// no precedence for this</span>
                        <span class="s1">precedence: util_1.OperatorPrecedence.Invalid,</span>
                        <span class="s1">requiresDot: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">text: typeArgumentsText + argumentsText,</span>
                    <span class="s1">},</span>
                <span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MemberExpression: {</span>
                <span class="s2">const </span><span class="s1">propertyText = sourceCode.getText(node.property);</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s1">...flattenChainExpression(sourceCode, node.object),</span>
                    <span class="s1">{</span>
                        <span class="s1">nonNull: node.object.type === utils_1.AST_NODE_TYPES.TSNonNullExpression,</span>
                        <span class="s1">optional: node.optional,</span>
                        <span class="s1">precedence: node.computed</span>
                            <span class="s1">? </span><span class="s4">// computed is already wrapped in [] so no need to wrap in () as well</span>
                                <span class="s1">util_1.OperatorPrecedence.Invalid</span>
                            <span class="s1">: (</span><span class="s3">0</span><span class="s1">, util_1.getOperatorPrecedenceForNode)(node.property),</span>
                        <span class="s1">requiresDot: !node.computed,</span>
                        <span class="s1">text: node.computed ? </span><span class="s0">`[</span><span class="s1">${propertyText}</span><span class="s0">]` </span><span class="s1">: propertyText,</span>
                    <span class="s1">},</span>
                <span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSNonNullExpression:</span>
                <span class="s2">return </span><span class="s1">flattenChainExpression(sourceCode, node.expression);</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s1">{</span>
                        <span class="s1">nonNull: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">precedence: (</span><span class="s3">0</span><span class="s1">, util_1.getOperatorPrecedenceForNode)(node),</span>
                        <span class="s1">requiresDot: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">text: sourceCode.getText(node),</span>
                    <span class="s1">},</span>
                <span class="s1">];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">analyzeChain(context, parserServices, options, node, operator, chain) {</span>
    <span class="s4">// need at least 2 operands in a chain for it to be a chain</span>
    <span class="s2">if </span><span class="s1">(chain.length &lt;= </span><span class="s3">1 </span><span class="s1">||</span>
        <span class="s4">/* istanbul ignore next -- previous checks make this unreachable, but keep it for exhaustiveness check */</span>
        <span class="s1">operator === </span><span class="s0">'??'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">analyzeOperand = (() =&gt; {</span>
        <span class="s2">switch </span><span class="s1">(operator) {</span>
            <span class="s2">case </span><span class="s0">'&amp;&amp;'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">analyzeAndChainOperand;</span>
            <span class="s2">case </span><span class="s0">'||'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">analyzeOrChainOperand;</span>
        <span class="s1">}</span>
    <span class="s1">})();</span>
    <span class="s4">// Things like x !== null &amp;&amp; x !== undefined have two nodes, but they are</span>
    <span class="s4">// one logical unit here, so we'll allow them to be grouped.</span>
    <span class="s2">let </span><span class="s1">subChain = [];</span>
    <span class="s2">const </span><span class="s1">maybeReportThenReset = (newChainSeed) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(subChain.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">subChainFlat = subChain.flat();</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, checkNullishAndReport_1.checkNullishAndReport)(context, parserServices, options, subChainFlat.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">).map(({ node }) =&gt; node), getReportDescriptor(context.sourceCode, parserServices, node, operator, options, subChainFlat));</span>
        <span class="s1">}</span>
        <span class="s4">// we've reached the end of a chain of logical expressions</span>
        <span class="s4">// i.e. the current operand doesn't belong to the previous chain.</span>
        <span class="s4">//</span>
        <span class="s4">// we don't want to throw away the current operand otherwise we will skip it</span>
        <span class="s4">// and that can cause us to miss chains. So instead we seed the new chain</span>
        <span class="s4">// with the current operand</span>
        <span class="s4">//</span>
        <span class="s4">// eg this means we can catch cases like:</span>
        <span class="s4">//     unrelated != null &amp;&amp; foo != null &amp;&amp; foo.bar != null;</span>
        <span class="s4">//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ first &quot;chain&quot;</span>
        <span class="s4">//                          ^^^^^^^^^^^ newChainSeed</span>
        <span class="s4">//                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ second chain</span>
        <span class="s1">subChain = newChainSeed ? [newChainSeed] : [];</span>
    <span class="s1">};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; chain.length; i += </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">lastOperand = subChain.flat().at(-</span><span class="s3">1</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">operand = chain[i];</span>
        <span class="s2">const </span><span class="s1">validatedOperands = analyzeOperand(parserServices, operand, i, chain);</span>
        <span class="s2">if </span><span class="s1">(!validatedOperands) {</span>
            <span class="s4">// TODO - #7170</span>
            <span class="s4">// check if the name is a superset/equal - if it is, then it likely</span>
            <span class="s4">// intended to be part of the chain and something we should include in the</span>
            <span class="s4">// report, eg</span>
            <span class="s4">//     foo == null || foo.bar;</span>
            <span class="s4">//     ^^^^^^^^^^^ valid OR chain</span>
            <span class="s4">//                    ^^^^^^^ invalid OR chain logical, but still part of</span>
            <span class="s4">//                            the chain for combination purposes</span>
            <span class="s1">maybeReportThenReset();</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// in case multiple operands were consumed - make sure to correctly increment the index</span>
        <span class="s1">i += validatedOperands.length - </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">currentOperand = validatedOperands[</span><span class="s3">0</span><span class="s1">];</span>
        <span class="s2">if </span><span class="s1">(lastOperand) {</span>
            <span class="s2">const </span><span class="s1">comparisonResult = (</span><span class="s3">0</span><span class="s1">, compareNodes_1.compareNodes)(lastOperand.comparedName, </span>
            <span class="s4">// purposely inspect and push the last operand because the prior operands don't matter</span>
            <span class="s4">// this also means we won't false-positive in cases like</span>
            <span class="s4">// foo !== null &amp;&amp; foo !== undefined</span>
            <span class="s1">validatedOperands[validatedOperands.length - </span><span class="s3">1</span><span class="s1">].comparedName);</span>
            <span class="s2">if </span><span class="s1">(comparisonResult === compareNodes_1.NodeComparisonResult.Subset) {</span>
                <span class="s4">// the operands are comparable, so we can continue searching</span>
                <span class="s1">subChain.push(currentOperand);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(comparisonResult === compareNodes_1.NodeComparisonResult.Invalid) {</span>
                <span class="s1">maybeReportThenReset(validatedOperands);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// purposely don't push this case because the node is a no-op and if</span>
                <span class="s4">// we consider it then we might report on things like</span>
                <span class="s4">// foo &amp;&amp; foo</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">subChain.push(currentOperand);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// check the leftovers</span>
    <span class="s1">maybeReportThenReset();</span>
<span class="s1">}</span>
</pre>
</body>
</html>