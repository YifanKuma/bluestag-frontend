<html>
<head>
<title>app-router-instance.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-router-instance.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/client/components/app-router-instance.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">type AppRouterState,</span><span class="s3">\n  </span><span class="s1">type ReducerActions,</span><span class="s3">\n  </span><span class="s1">type ReducerState,</span><span class="s3">\n  </span><span class="s1">ACTION_REFRESH,</span><span class="s3">\n  </span><span class="s1">ACTION_SERVER_ACTION,</span><span class="s3">\n  </span><span class="s1">ACTION_NAVIGATE,</span><span class="s3">\n  </span><span class="s1">ACTION_RESTORE,</span><span class="s3">\n  </span><span class="s1">type NavigateAction,</span><span class="s3">\n  </span><span class="s1">ACTION_HMR_REFRESH,</span><span class="s3">\n  </span><span class="s1">PrefetchKind,</span><span class="s3">\n  </span><span class="s1">ACTION_PREFETCH,</span><span class="s3">\n</span><span class="s1">} from './router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { reducer } from './router-reducer/router-reducer'</span><span class="s3">\n</span><span class="s1">import { startTransition } from 'react'</span><span class="s3">\n</span><span class="s1">import { isThenable } from '../../shared/lib/is-thenable'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">FetchStrategy,</span><span class="s3">\n  </span><span class="s1">prefetch as prefetchWithSegmentCache,</span><span class="s3">\n  </span><span class="s1">type PrefetchTaskFetchStrategy,</span><span class="s3">\n</span><span class="s1">} from './segment-cache'</span><span class="s3">\n</span><span class="s1">import { dispatchAppRouterAction } from './use-action-queue'</span><span class="s3">\n</span><span class="s1">import { addBasePath } from '../add-base-path'</span><span class="s3">\n</span><span class="s1">import { createPrefetchURL, isExternalURL } from './app-router'</span><span class="s3">\n</span><span class="s1">import { prefetchReducer } from './router-reducer/reducers/prefetch-reducer'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">AppRouterInstance,</span><span class="s3">\n  </span><span class="s1">NavigateOptions,</span><span class="s3">\n  </span><span class="s1">PrefetchOptions,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { setLinkForCurrentNavigation, type LinkInstance } from './links'</span><span class="s3">\n</span><span class="s1">import type { FlightRouterState } from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { ClientInstrumentationHooks } from '../app-index'</span><span class="s3">\n</span><span class="s1">import type { GlobalErrorComponent } from './builtin/global-error'</span><span class="s3">\n\n</span><span class="s1">export type DispatchStatePromise = React.Dispatch&lt;ReducerState&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppRouterActionQueue = {</span><span class="s3">\n  </span><span class="s1">state: AppRouterState</span><span class="s3">\n  </span><span class="s1">dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =&gt; void</span><span class="s3">\n  </span><span class="s1">action: (state: AppRouterState, action: ReducerActions) =&gt; ReducerState</span><span class="s3">\n\n  </span><span class="s1">onRouterTransitionStart:</span><span class="s3">\n    </span><span class="s1">| ((url: string, type: 'push' | 'replace' | 'traverse') =&gt; void)</span><span class="s3">\n    </span><span class="s1">| null</span><span class="s3">\n\n  </span><span class="s1">pending: ActionQueueNode | null</span><span class="s3">\n  </span><span class="s1">needsRefresh?: boolean</span><span class="s3">\n  </span><span class="s1">last: ActionQueueNode | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type GlobalErrorState = [</span><span class="s3">\n  </span><span class="s1">GlobalError: GlobalErrorComponent,</span><span class="s3">\n  </span><span class="s1">styles: React.ReactNode,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type ActionQueueNode = {</span><span class="s3">\n  </span><span class="s1">payload: ReducerActions</span><span class="s3">\n  </span><span class="s1">next: ActionQueueNode | null</span><span class="s3">\n  </span><span class="s1">resolve: (value: ReducerState) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (err: Error) =&gt; void</span><span class="s3">\n  </span><span class="s1">discarded?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function runRemainingActions(</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue,</span><span class="s3">\n  </span><span class="s1">setState: DispatchStatePromise</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (actionQueue.pending !== null) {</span><span class="s3">\n    </span><span class="s1">actionQueue.pending = actionQueue.pending.next</span><span class="s3">\n    </span><span class="s1">if (actionQueue.pending !== null) {</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n      </span><span class="s1">runAction({</span><span class="s3">\n        </span><span class="s1">actionQueue,</span><span class="s3">\n        </span><span class="s1">action: actionQueue.pending,</span><span class="s3">\n        </span><span class="s1">setState,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// No more actions are pending, check if a refresh is needed</span><span class="s3">\n      </span><span class="s1">if (actionQueue.needsRefresh) {</span><span class="s3">\n        </span><span class="s1">actionQueue.needsRefresh = false</span><span class="s3">\n        </span><span class="s1">actionQueue.dispatch(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">type: ACTION_REFRESH,</span><span class="s3">\n            </span><span class="s1">origin: window.location.origin,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">setState</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function runAction({</span><span class="s3">\n  </span><span class="s1">actionQueue,</span><span class="s3">\n  </span><span class="s1">action,</span><span class="s3">\n  </span><span class="s1">setState,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue</span><span class="s3">\n  </span><span class="s1">action: ActionQueueNode</span><span class="s3">\n  </span><span class="s1">setState: DispatchStatePromise</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const prevState = actionQueue.state</span><span class="s3">\n\n  </span><span class="s1">actionQueue.pending = action</span><span class="s3">\n\n  </span><span class="s1">const payload = action.payload</span><span class="s3">\n  </span><span class="s1">const actionResult = actionQueue.action(prevState, payload)</span><span class="s3">\n\n  </span><span class="s1">function handleResult(nextState: AppRouterState) {</span><span class="s3">\n    </span><span class="s1">// if we discarded this action, the state should also be discarded</span><span class="s3">\n    </span><span class="s1">if (action.discarded) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">actionQueue.state = nextState</span><span class="s3">\n\n    </span><span class="s1">runRemainingActions(actionQueue, setState)</span><span class="s3">\n    </span><span class="s1">action.resolve(nextState)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the action is a promise, set up a callback to resolve it</span><span class="s3">\n  </span><span class="s1">if (isThenable(actionResult)) {</span><span class="s3">\n    </span><span class="s1">actionResult.then(handleResult, (err) =&gt; {</span><span class="s3">\n      </span><span class="s1">runRemainingActions(actionQueue, setState)</span><span class="s3">\n      </span><span class="s1">action.reject(err)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">handleResult(actionResult)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function dispatchAction(</span><span class="s3">\n  </span><span class="s1">actionQueue: AppRouterActionQueue,</span><span class="s3">\n  </span><span class="s1">payload: ReducerActions,</span><span class="s3">\n  </span><span class="s1">setState: DispatchStatePromise</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let resolvers: {</span><span class="s3">\n    </span><span class="s1">resolve: (value: ReducerState) =&gt; void</span><span class="s3">\n    </span><span class="s1">reject: (reason: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">} = { resolve: setState, reject: () =&gt; {} }</span><span class="s3">\n\n  </span><span class="s1">// most of the action types are async with the exception of restore</span><span class="s3">\n  </span><span class="s1">// it's important that restore is handled quickly since it's fired on the popstate event</span><span class="s3">\n  </span><span class="s1">// and we don't want to add any delay on a back/forward nav</span><span class="s3">\n  </span><span class="s1">// this only creates a promise for the async actions</span><span class="s3">\n  </span><span class="s1">if (payload.type !== ACTION_RESTORE) {</span><span class="s3">\n    </span><span class="s1">// Create the promise and assign the resolvers to the object.</span><span class="s3">\n    </span><span class="s1">const deferredPromise = new Promise&lt;AppRouterState&gt;((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">resolvers = { resolve, reject }</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">// we immediately notify React of the pending promise -- the resolver is attached to the action node</span><span class="s3">\n      </span><span class="s1">// and will be called when the associated action promise resolves</span><span class="s3">\n      </span><span class="s1">setState(deferredPromise)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const newAction: ActionQueueNode = {</span><span class="s3">\n    </span><span class="s1">payload,</span><span class="s3">\n    </span><span class="s1">next: null,</span><span class="s3">\n    </span><span class="s1">resolve: resolvers.resolve,</span><span class="s3">\n    </span><span class="s1">reject: resolvers.reject,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if the queue is empty</span><span class="s3">\n  </span><span class="s1">if (actionQueue.pending === null) {</span><span class="s3">\n    </span><span class="s1">// The queue is empty, so add the action and start it immediately</span><span class="s3">\n    </span><span class="s1">// Mark this action as the last in the queue</span><span class="s3">\n    </span><span class="s1">actionQueue.last = newAction</span><span class="s3">\n\n    </span><span class="s1">runAction({</span><span class="s3">\n      </span><span class="s1">actionQueue,</span><span class="s3">\n      </span><span class="s1">action: newAction,</span><span class="s3">\n      </span><span class="s1">setState,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">payload.type === ACTION_NAVIGATE ||</span><span class="s3">\n    </span><span class="s1">payload.type === ACTION_RESTORE</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Navigations (including back/forward) take priority over any pending actions.</span><span class="s3">\n    </span><span class="s1">// Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.</span><span class="s3">\n    </span><span class="s1">actionQueue.pending.discarded = true</span><span class="s3">\n\n    </span><span class="s1">// The rest of the current queue should still execute after this navigation.</span><span class="s3">\n    </span><span class="s1">// (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)</span><span class="s3">\n    </span><span class="s1">newAction.next = actionQueue.pending.next</span><span class="s3">\n\n    </span><span class="s1">// if the pending action was a server action, mark the queue as needing a refresh once events are processed</span><span class="s3">\n    </span><span class="s1">if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {</span><span class="s3">\n      </span><span class="s1">actionQueue.needsRefresh = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">runAction({</span><span class="s3">\n      </span><span class="s1">actionQueue,</span><span class="s3">\n      </span><span class="s1">action: newAction,</span><span class="s3">\n      </span><span class="s1">setState,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// The queue is not empty, so add the action to the end of the queue</span><span class="s3">\n    </span><span class="s1">// It will be started by runRemainingActions after the previous action finishes</span><span class="s3">\n    </span><span class="s1">if (actionQueue.last !== null) {</span><span class="s3">\n      </span><span class="s1">actionQueue.last.next = newAction</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">actionQueue.last = newAction</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let globalActionQueue: AppRouterActionQueue | null = null</span><span class="s3">\n\n</span><span class="s1">export function createMutableActionQueue(</span><span class="s3">\n  </span><span class="s1">initialState: AppRouterState,</span><span class="s3">\n  </span><span class="s1">instrumentationHooks: ClientInstrumentationHooks | null</span><span class="s3">\n</span><span class="s1">): AppRouterActionQueue {</span><span class="s3">\n  </span><span class="s1">const actionQueue: AppRouterActionQueue = {</span><span class="s3">\n    </span><span class="s1">state: initialState,</span><span class="s3">\n    </span><span class="s1">dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =&gt;</span><span class="s3">\n      </span><span class="s1">dispatchAction(actionQueue, payload, setState),</span><span class="s3">\n    </span><span class="s1">action: async (state: AppRouterState, action: ReducerActions) =&gt; {</span><span class="s3">\n      </span><span class="s1">const result = reducer(state, action)</span><span class="s3">\n      </span><span class="s1">return result</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">pending: null,</span><span class="s3">\n    </span><span class="s1">last: null,</span><span class="s3">\n    </span><span class="s1">onRouterTransitionStart:</span><span class="s3">\n      </span><span class="s1">instrumentationHooks !== null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof instrumentationHooks.onRouterTransitionStart === 'function'</span><span class="s3">\n        </span><span class="s1">? // This profiling hook will be called at the start of every navigation.</span><span class="s3">\n          </span><span class="s1">instrumentationHooks.onRouterTransitionStart</span><span class="s3">\n        </span><span class="s1">: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof window !== 'undefined') {</span><span class="s3">\n    </span><span class="s1">// The action queue is lazily created on hydration, but after that point</span><span class="s3">\n    </span><span class="s1">// it doesn't change. So we can store it in a global rather than pass</span><span class="s3">\n    </span><span class="s1">// it around everywhere via props/context.</span><span class="s3">\n    </span><span class="s1">if (globalActionQueue !== null) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Internal Next.js Error: createMutableActionQueue was called more ' +</span><span class="s3">\n          </span><span class="s1">'than once'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">globalActionQueue = actionQueue</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return actionQueue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getCurrentAppRouterState(): AppRouterState | null {</span><span class="s3">\n  </span><span class="s1">return globalActionQueue !== null ? globalActionQueue.state : null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getAppRouterActionQueue(): AppRouterActionQueue {</span><span class="s3">\n  </span><span class="s1">if (globalActionQueue === null) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Internal Next.js error: Router action dispatched before initialization.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return globalActionQueue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getProfilingHookForOnNavigationStart() {</span><span class="s3">\n  </span><span class="s1">if (globalActionQueue !== null) {</span><span class="s3">\n    </span><span class="s1">return globalActionQueue.onRouterTransitionStart</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function dispatchNavigateAction(</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">navigateType: NavigateAction['navigateType'],</span><span class="s3">\n  </span><span class="s1">shouldScroll: boolean,</span><span class="s3">\n  </span><span class="s1">linkInstanceRef: LinkInstance | null</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// TODO: This stuff could just go into the reducer. Leaving as-is for now</span><span class="s3">\n  </span><span class="s1">// since we're about to rewrite all the router reducer stuff anyway.</span><span class="s3">\n  </span><span class="s1">const url = new URL(addBasePath(href), location.href)</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {</span><span class="s3">\n    </span><span class="s1">window.next.__pendingUrl = url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">setLinkForCurrentNavigation(linkInstanceRef)</span><span class="s3">\n\n  </span><span class="s1">const onRouterTransitionStart = getProfilingHookForOnNavigationStart()</span><span class="s3">\n  </span><span class="s1">if (onRouterTransitionStart !== null) {</span><span class="s3">\n    </span><span class="s1">onRouterTransitionStart(href, navigateType)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n    </span><span class="s1">type: ACTION_NAVIGATE,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">isExternalUrl: isExternalURL(url),</span><span class="s3">\n    </span><span class="s1">locationSearch: location.search,</span><span class="s3">\n    </span><span class="s1">shouldScroll,</span><span class="s3">\n    </span><span class="s1">navigateType,</span><span class="s3">\n    </span><span class="s1">allowAliasing: true,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function dispatchTraverseAction(</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const onRouterTransitionStart = getProfilingHookForOnNavigationStart()</span><span class="s3">\n  </span><span class="s1">if (onRouterTransitionStart !== null) {</span><span class="s3">\n    </span><span class="s1">onRouterTransitionStart(href, 'traverse')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n    </span><span class="s1">type: ACTION_RESTORE,</span><span class="s3">\n    </span><span class="s1">url: new URL(href),</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The app router that is exposed through `useRouter`. These are public API</span><span class="s3">\n </span><span class="s1">* methods. Internal Next.js code should call the lower level methods directly</span><span class="s3">\n </span><span class="s1">* (although there's lots of existing code that doesn't do that).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const publicAppRouterInstance: AppRouterInstance = {</span><span class="s3">\n  </span><span class="s1">back: () =&gt; window.history.back(),</span><span class="s3">\n  </span><span class="s1">forward: () =&gt; window.history.forward(),</span><span class="s3">\n  </span><span class="s1">prefetch: process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? // Unlike the old implementation, the Segment Cache doesn't store its</span><span class="s3">\n      </span><span class="s1">// data in the router reducer state; it writes into a global mutable</span><span class="s3">\n      </span><span class="s1">// cache. So we don't need to dispatch an action.</span><span class="s3">\n      </span><span class="s1">(href: string, options?: PrefetchOptions) =&gt; {</span><span class="s3">\n        </span><span class="s1">const actionQueue = getAppRouterActionQueue()</span><span class="s3">\n        </span><span class="s1">const prefetchKind = options?.kind ?? PrefetchKind.AUTO</span><span class="s3">\n\n        </span><span class="s1">// We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.</span><span class="s3">\n        </span><span class="s1">// This will be possible when we update its API to not take a PrefetchKind.</span><span class="s3">\n        </span><span class="s1">let fetchStrategy: PrefetchTaskFetchStrategy</span><span class="s3">\n        </span><span class="s1">switch (prefetchKind) {</span><span class="s3">\n          </span><span class="s1">case PrefetchKind.AUTO: {</span><span class="s3">\n            </span><span class="s1">// We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.</span><span class="s3">\n            </span><span class="s1">fetchStrategy = FetchStrategy.PPR</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case PrefetchKind.FULL: {</span><span class="s3">\n            </span><span class="s1">fetchStrategy = FetchStrategy.Full</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case PrefetchKind.TEMPORARY: {</span><span class="s3">\n            </span><span class="s1">// This concept doesn't exist in the segment cache implementation.</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">default: {</span><span class="s3">\n            </span><span class="s1">prefetchKind satisfies never</span><span class="s3">\n            </span><span class="s1">// Despite typescript thinking that this can't happen,</span><span class="s3">\n            </span><span class="s1">// we might get an unexpected value from user code.</span><span class="s3">\n            </span><span class="s1">// We don't know what they want, but we know they want a prefetch,</span><span class="s3">\n            </span><span class="s1">// so use the default.</span><span class="s3">\n            </span><span class="s1">fetchStrategy = FetchStrategy.PPR</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">prefetchWithSegmentCache(</span><span class="s3">\n          </span><span class="s1">href,</span><span class="s3">\n          </span><span class="s1">actionQueue.state.nextUrl,</span><span class="s3">\n          </span><span class="s1">actionQueue.state.tree,</span><span class="s3">\n          </span><span class="s1">fetchStrategy,</span><span class="s3">\n          </span><span class="s1">options?.onInvalidate ?? null</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: (href: string, options?: PrefetchOptions) =&gt; {</span><span class="s3">\n        </span><span class="s1">// Use the old prefetch implementation.</span><span class="s3">\n        </span><span class="s1">const actionQueue = getAppRouterActionQueue()</span><span class="s3">\n        </span><span class="s1">const url = createPrefetchURL(href)</span><span class="s3">\n        </span><span class="s1">if (url !== null) {</span><span class="s3">\n          </span><span class="s1">// The prefetch reducer doesn't actually update any state or</span><span class="s3">\n          </span><span class="s1">// trigger a rerender. It just writes to a mutable cache. So we</span><span class="s3">\n          </span><span class="s1">// shouldn't bother calling setState/dispatch; we can just re-run</span><span class="s3">\n          </span><span class="s1">// the reducer directly using the current state.</span><span class="s3">\n          </span><span class="s1">// TODO: Refactor this away from a </span><span class="s3">\&quot;</span><span class="s1">reducer</span><span class="s3">\&quot; </span><span class="s1">so it's</span><span class="s3">\n          </span><span class="s1">// less confusing.</span><span class="s3">\n          </span><span class="s1">prefetchReducer(actionQueue.state, {</span><span class="s3">\n            </span><span class="s1">type: ACTION_PREFETCH,</span><span class="s3">\n            </span><span class="s1">url,</span><span class="s3">\n            </span><span class="s1">kind: options?.kind ?? PrefetchKind.FULL,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">replace: (href: string, options?: NavigateOptions) =&gt; {</span><span class="s3">\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">push: (href: string, options?: NavigateOptions) =&gt; {</span><span class="s3">\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">refresh: () =&gt; {</span><span class="s3">\n    </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n        </span><span class="s1">type: ACTION_REFRESH,</span><span class="s3">\n        </span><span class="s1">origin: window.location.origin,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">hmrRefresh: () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'development') {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'hmrRefresh can only be used in development mode. Please use refresh instead.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n        </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n          </span><span class="s1">type: ACTION_HMR_REFRESH,</span><span class="s3">\n          </span><span class="s1">origin: window.location.origin,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Exists for debugging purposes. Don't use in application code.</span><span class="s3">\n</span><span class="s1">if (typeof window !== 'undefined' &amp;&amp; window.next) {</span><span class="s3">\n  </span><span class="s1">window.next.router = publicAppRouterInstance</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createMutableActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchNavigateAction&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchTraverseAction&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentAppRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;publicAppRouterInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;runRemainingActions&quot;</span><span class="s0">,</span><span class="s1">&quot;actionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;runAction&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;needsRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatch&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;prevState&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;actionResult&quot;</span><span class="s0">,</span><span class="s1">&quot;handleResult&quot;</span><span class="s0">,</span><span class="s1">&quot;nextState&quot;</span><span class="s0">,</span><span class="s1">&quot;discarded&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;isThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchAction&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvers&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_RESTORE&quot;</span><span class="s0">,</span><span class="s1">&quot;deferredPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;newAction&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_NAVIGATE&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_ACTION&quot;</span><span class="s0">,</span><span class="s1">&quot;globalActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;initialState&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;reducer&quot;</span><span class="s0">,</span><span class="s1">&quot;onRouterTransitionStart&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppRouterActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;getProfilingHookForOnNavigationStart&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateType&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;linkInstanceRef&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;addBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_APP_NAV_FAIL_HANDLING&quot;</span><span class="s0">,</span><span class="s1">&quot;__pendingUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;setLinkForCurrentNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchAppRouterAction&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternalURL&quot;</span><span class="s0">,</span><span class="s1">&quot;locationSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;allowAliasing&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;back&quot;</span><span class="s0">,</span><span class="s1">&quot;history&quot;</span><span class="s0">,</span><span class="s1">&quot;forward&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;PPR&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;Full&quot;</span><span class="s0">,</span><span class="s1">&quot;TEMPORARY&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchWithSegmentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;onInvalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchURL&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchReducer&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_PREFETCH&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;scroll&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;refresh&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_HMR_REFRESH&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>