<html>
<head>
<title>collect-build-traces.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
collect-build-traces.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;collectBuildTraces&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">collectBuildTraces;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_trace = require(</span><span class="s0">&quot;../trace&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nexttraceentrypointsplugin = require(</span><span class="s0">&quot;./webpack/plugins/next-trace-entrypoints-plugin&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_promises = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;fs/promises&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_nonnullable = require(</span><span class="s0">&quot;../lib/non-nullable&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ciinfo = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../server/ci-info&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_debug = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/debug&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_picomatch = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;next/dist/compiled/picomatch&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_requirehook = require(</span><span class="s0">&quot;../server/require-hook&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nft = require(</span><span class="s0">&quot;next/dist/compiled/@vercel/nft&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_normalizepagepath = require(</span><span class="s0">&quot;../shared/lib/page-path/normalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_iserror = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../lib/is-error&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">debug = (</span><span class="s4">0</span><span class="s1">, _debug.default)(</span><span class="s0">'next:build:build-traces'</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">shouldIgnore(file, serverIgnoreFn, reasons, cachedIgnoreFiles, children = </span><span class="s2">new </span><span class="s1">Set()) {</span>
    <span class="s2">if </span><span class="s1">(cachedIgnoreFiles.has(file)) {</span>
        <span class="s2">return </span><span class="s1">cachedIgnoreFiles.get(file);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(serverIgnoreFn(file)) {</span>
        <span class="s1">cachedIgnoreFiles.set(file, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">children.add(file);</span>
    <span class="s2">const </span><span class="s1">reason = reasons.get(file);</span>
    <span class="s2">if </span><span class="s1">(!reason || reason.parents.size === </span><span class="s4">0 </span><span class="s1">|| reason.type.includes(</span><span class="s0">'initial'</span><span class="s1">)) {</span>
        <span class="s1">cachedIgnoreFiles.set(file, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// if all parents are ignored the child file</span>
    <span class="s3">// should be ignored as well</span>
    <span class="s2">let </span><span class="s1">allParentsIgnored = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">parent of reason.parents.values()){</span>
        <span class="s2">if </span><span class="s1">(!children.has(parent)) {</span>
            <span class="s1">children.add(parent);</span>
            <span class="s2">if </span><span class="s1">(!shouldIgnore(parent, serverIgnoreFn, reasons, cachedIgnoreFiles, children)) {</span>
                <span class="s1">allParentsIgnored = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">cachedIgnoreFiles.set(file, allParentsIgnored);</span>
    <span class="s2">return </span><span class="s1">allParentsIgnored;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">collectBuildTraces({ dir, config, distDir, edgeRuntimeRoutes, staticPages, nextBuildSpan = </span><span class="s2">new </span><span class="s1">_trace.Span({</span>
    <span class="s1">name: </span><span class="s0">'build'</span>
<span class="s1">}), hasSsrAmpPages, buildTraceContext, outputFileTracingRoot, isTurbopack }) {</span>
    <span class="s2">const </span><span class="s1">startTime = Date.now();</span>
    <span class="s1">debug(</span><span class="s0">'starting build traces'</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">{ outputFileTracingIncludes = {}, outputFileTracingExcludes = {} } = config;</span>
    <span class="s2">const </span><span class="s1">excludeGlobKeys = Object.keys(outputFileTracingExcludes);</span>
    <span class="s2">const </span><span class="s1">includeGlobKeys = Object.keys(outputFileTracingIncludes);</span>
    <span class="s2">await </span><span class="s1">nextBuildSpan.traceChild(</span><span class="s0">'node-file-trace-build'</span><span class="s1">, {</span>
        <span class="s1">isTurbotrace: </span><span class="s0">'false'</span>
    <span class="s1">}).traceAsyncFn(async ()=&gt;{</span>
        <span class="s2">const </span><span class="s1">nextServerTraceOutput = _path.default.join(distDir, </span><span class="s0">'next-server.js.nft.json'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">nextMinimalTraceOutput = _path.default.join(distDir, </span><span class="s0">'next-minimal-server.js.nft.json'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">root = outputFileTracingRoot;</span>
        <span class="s3">// Under standalone mode, we need to trace the extra IPC server and</span>
        <span class="s3">// worker files.</span>
        <span class="s2">const </span><span class="s1">isStandalone = config.output === </span><span class="s0">'standalone'</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">sharedEntriesSet = Object.keys(_requirehook.defaultOverrides).map((value)=&gt;require.resolve(value, {</span>
                <span class="s1">paths: [</span>
                    <span class="s1">require.resolve(</span><span class="s0">'next/dist/server/require-hook'</span><span class="s1">)</span>
                <span class="s1">]</span>
            <span class="s1">}));</span>
        <span class="s2">const </span><span class="s1">{ cacheHandler } = config;</span>
        <span class="s2">const </span><span class="s1">{ cacheHandlers } = config.experimental;</span>
        <span class="s3">// ensure we trace any dependencies needed for custom</span>
        <span class="s3">// incremental cache handler</span>
        <span class="s2">if </span><span class="s1">(cacheHandler) {</span>
            <span class="s1">sharedEntriesSet.push(require.resolve(_path.default.isAbsolute(cacheHandler) ? cacheHandler : _path.default.join(dir, cacheHandler)));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(cacheHandlers) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">handlerPath of Object.values(cacheHandlers)){</span>
                <span class="s2">if </span><span class="s1">(handlerPath) {</span>
                    <span class="s1">sharedEntriesSet.push(require.resolve(_path.default.isAbsolute(handlerPath) ? handlerPath : _path.default.join(dir, handlerPath)));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">serverEntries = [</span>
            <span class="s1">...sharedEntriesSet,</span>
            <span class="s1">...isStandalone ? [</span>
                <span class="s1">require.resolve(</span><span class="s0">'next/dist/server/lib/start-server'</span><span class="s1">),</span>
                <span class="s1">require.resolve(</span><span class="s0">'next/dist/server/next'</span><span class="s1">),</span>
                <span class="s1">require.resolve(</span><span class="s0">'next/dist/server/require-hook'</span><span class="s1">)</span>
            <span class="s1">] : [],</span>
            <span class="s1">require.resolve(</span><span class="s0">'next/dist/server/next-server'</span><span class="s1">)</span>
        <span class="s1">].filter(Boolean);</span>
        <span class="s2">const </span><span class="s1">minimalServerEntries = [</span>
            <span class="s1">...sharedEntriesSet,</span>
            <span class="s1">require.resolve(</span><span class="s0">'next/dist/compiled/next-server/server.runtime.prod'</span><span class="s1">)</span>
        <span class="s1">].filter(Boolean);</span>
        <span class="s2">const </span><span class="s1">additionalIgnores = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">glob of excludeGlobKeys){</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _picomatch.default)(glob)(</span><span class="s0">'next-server'</span><span class="s1">)) {</span>
                <span class="s1">outputFileTracingExcludes[glob].forEach((exclude)=&gt;{</span>
                    <span class="s1">additionalIgnores.add(exclude);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">makeIgnoreFn = (ignores)=&gt;{</span>
            <span class="s3">// pre compile the ignore globs</span>
            <span class="s2">const </span><span class="s1">isMatch = (</span><span class="s4">0</span><span class="s1">, _picomatch.default)(ignores, {</span>
                <span class="s1">contains: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">dot: </span><span class="s2">true</span>
            <span class="s1">});</span>
            <span class="s2">return </span><span class="s1">(pathname)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(_path.default.isAbsolute(pathname) &amp;&amp; !pathname.startsWith(root)) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">isMatch(pathname);</span>
            <span class="s1">};</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">sharedIgnores = [</span>
            <span class="s0">'**/next/dist/compiled/next-server/**/*.dev.js'</span><span class="s1">,</span>
            <span class="s1">...isStandalone ? [] : [</span>
                <span class="s0">'**/next/dist/compiled/jest-worker/**/*'</span>
            <span class="s1">],</span>
            <span class="s0">'**/next/dist/compiled/webpack/*'</span><span class="s1">,</span>
            <span class="s0">'**/node_modules/webpack5/**/*'</span><span class="s1">,</span>
            <span class="s0">'**/next/dist/server/lib/route-resolver*'</span><span class="s1">,</span>
            <span class="s0">'next/dist/compiled/semver/semver/**/*.js'</span><span class="s1">,</span>
            <span class="s1">..._ciinfo.hasNextSupport ? [</span>
                <span class="s3">// only ignore image-optimizer code when</span>
                <span class="s3">// this is being handled outside of next-server</span>
                <span class="s0">'**/next/dist/server/image-optimizer.js'</span>
            <span class="s1">] : [],</span>
            <span class="s1">...!hasSsrAmpPages ? [</span>
                <span class="s0">'**/next/dist/compiled/@ampproject/toolbox-optimizer/**/*'</span>
            <span class="s1">] : [],</span>
            <span class="s1">...isStandalone ? [] : _nexttraceentrypointsplugin.TRACE_IGNORES,</span>
            <span class="s1">...additionalIgnores</span>
        <span class="s1">];</span>
        <span class="s2">const </span><span class="s1">sharedIgnoresFn = makeIgnoreFn(sharedIgnores);</span>
        <span class="s2">const </span><span class="s1">serverIgnores = [</span>
            <span class="s1">...sharedIgnores,</span>
            <span class="s0">'**/node_modules/react{,-dom,-dom-server-turbopack}/**/*.development.js'</span><span class="s1">,</span>
            <span class="s0">'**/*.d.ts'</span><span class="s1">,</span>
            <span class="s0">'**/*.map'</span><span class="s1">,</span>
            <span class="s0">'**/next/dist/pages/**/*'</span><span class="s1">,</span>
            <span class="s1">..._ciinfo.hasNextSupport ? [</span>
                <span class="s0">'**/node_modules/sharp/**/*'</span><span class="s1">,</span>
                <span class="s0">'**/@img/sharp-libvips*/**/*'</span>
            <span class="s1">] : []</span>
        <span class="s1">].filter(_nonnullable.nonNullable);</span>
        <span class="s2">const </span><span class="s1">serverIgnoreFn = makeIgnoreFn(serverIgnores);</span>
        <span class="s2">const </span><span class="s1">minimalServerIgnores = [</span>
            <span class="s1">...serverIgnores,</span>
            <span class="s0">'**/next/dist/compiled/edge-runtime/**/*'</span><span class="s1">,</span>
            <span class="s0">'**/next/dist/server/web/sandbox/**/*'</span><span class="s1">,</span>
            <span class="s0">'**/next/dist/server/post-process.js'</span>
        <span class="s1">];</span>
        <span class="s2">const </span><span class="s1">minimalServerIgnoreFn = makeIgnoreFn(minimalServerIgnores);</span>
        <span class="s2">const </span><span class="s1">routesIgnores = [</span>
            <span class="s1">...sharedIgnores,</span>
            <span class="s3">// server chunks are provided via next-trace-entrypoints-plugin plugin</span>
            <span class="s3">// as otherwise all chunks are traced here and included for all pages</span>
            <span class="s3">// whether they are needed or not</span>
            <span class="s0">'**/.next/server/chunks/**'</span><span class="s1">,</span>
            <span class="s0">'**/next/dist/server/optimize-amp.js'</span><span class="s1">,</span>
            <span class="s0">'**/next/dist/server/post-process.js'</span>
        <span class="s1">].filter(_nonnullable.nonNullable);</span>
        <span class="s2">const </span><span class="s1">routeIgnoreFn = makeIgnoreFn(routesIgnores);</span>
        <span class="s2">const </span><span class="s1">serverTracedFiles = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">const </span><span class="s1">minimalServerTracedFiles = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">function </span><span class="s1">addToTracedFiles(base, file, dest) {</span>
            <span class="s1">dest.add(_path.default.relative(distDir, _path.default.join(base, file)).replace(</span><span class="s5">/\\/g</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isStandalone) {</span>
            <span class="s1">addToTracedFiles(</span><span class="s0">''</span><span class="s1">, require.resolve(</span><span class="s0">'next/dist/compiled/jest-worker/processChild'</span><span class="s1">), serverTracedFiles);</span>
            <span class="s1">addToTracedFiles(</span><span class="s0">''</span><span class="s1">, require.resolve(</span><span class="s0">'next/dist/compiled/jest-worker/threadChild'</span><span class="s1">), serverTracedFiles);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isTurbopack) {</span>
            <span class="s1">addToTracedFiles(distDir, </span><span class="s0">'./package.json'</span><span class="s1">, serverTracedFiles);</span>
            <span class="s1">addToTracedFiles(distDir, </span><span class="s0">'./package.json'</span><span class="s1">, minimalServerTracedFiles);</span>
        <span class="s1">}</span>
        <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_buildTraceContext_chunksTrace;</span>
            <span class="s2">const </span><span class="s1">chunksToTrace = [</span>
                <span class="s1">...(buildTraceContext == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_buildTraceContext_chunksTrace = buildTraceContext.chunksTrace) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _buildTraceContext_chunksTrace.action.input) || [],</span>
                <span class="s1">...serverEntries,</span>
                <span class="s1">...minimalServerEntries</span>
            <span class="s1">];</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _nft.nodeFileTrace)(chunksToTrace, {</span>
                <span class="s1">base: outputFileTracingRoot,</span>
                <span class="s1">processCwd: dir,</span>
                <span class="s1">mixedModules: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">async readFile (p) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s2">return await </span><span class="s1">_promises.default.readFile(p, </span><span class="s0">'utf8'</span><span class="s1">);</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _iserror.default)(e) &amp;&amp; (e.code === </span><span class="s0">'ENOENT' </span><span class="s1">|| e.code === </span><span class="s0">'EISDIR'</span><span class="s1">)) {</span>
                            <span class="s3">// since tracing runs in parallel with static generation server</span>
                            <span class="s3">// files might be removed from that step so tolerate ENOENT</span>
                            <span class="s3">// errors gracefully</span>
                            <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">throw </span><span class="s1">e;</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s1">async readlink (p) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s2">return await </span><span class="s1">_promises.default.readlink(p);</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _iserror.default)(e) &amp;&amp; (e.code === </span><span class="s0">'EINVAL' </span><span class="s1">|| e.code === </span><span class="s0">'ENOENT' </span><span class="s1">|| e.code === </span><span class="s0">'UNKNOWN'</span><span class="s1">)) {</span>
                            <span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">throw </span><span class="s1">e;</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s1">async stat (p) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s2">return await </span><span class="s1">_promises.default.stat(p);</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _iserror.default)(e) &amp;&amp; (e.code === </span><span class="s0">'ENOENT' </span><span class="s1">|| e.code === </span><span class="s0">'ENOTDIR'</span><span class="s1">)) {</span>
                            <span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">throw </span><span class="s1">e;</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s3">// handle shared ignores at top-level as it</span>
                <span class="s3">// avoids over-tracing when we don't need to</span>
                <span class="s3">// and speeds up total trace time</span>
                <span class="s1">ignore (p) {</span>
                    <span class="s2">if </span><span class="s1">(sharedIgnoresFn(p)) {</span>
                        <span class="s2">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// if a chunk is attempting to be traced that isn't</span>
                    <span class="s3">// in our initial list we need to ignore it to prevent</span>
                    <span class="s3">// over tracing as webpack needs to be the source of</span>
                    <span class="s3">// truth for which chunks should be included for each entry</span>
                    <span class="s2">if </span><span class="s1">(p.includes(</span><span class="s0">'.next/server/chunks'</span><span class="s1">) &amp;&amp; !chunksToTrace.includes(_path.default.join(outputFileTracingRoot, p))) {</span>
                        <span class="s2">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">reasons = result.reasons;</span>
            <span class="s2">const </span><span class="s1">fileList = result.fileList;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of result.esmFileList){</span>
                <span class="s1">fileList.add(file);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">parentFilesMap = (</span><span class="s4">0</span><span class="s1">, _nexttraceentrypointsplugin.getFilesMapFromReasons)(fileList, reasons);</span>
            <span class="s2">const </span><span class="s1">cachedLookupIgnore = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">const </span><span class="s1">cachedLookupIgnoreMinimal = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[entries, tracedFiles] of [</span>
                <span class="s1">[</span>
                    <span class="s1">serverEntries,</span>
                    <span class="s1">serverTracedFiles</span>
                <span class="s1">],</span>
                <span class="s1">[</span>
                    <span class="s1">minimalServerEntries,</span>
                    <span class="s1">minimalServerTracedFiles</span>
                <span class="s1">]</span>
            <span class="s1">]){</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of entries){</span>
                    <span class="s2">var </span><span class="s1">_parentFilesMap_get;</span>
                    <span class="s2">const </span><span class="s1">curFiles = [</span>
                        <span class="s1">...((_parentFilesMap_get = parentFilesMap.get(_path.default.relative(outputFileTracingRoot, file))) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _parentFilesMap_get.keys()) || []</span>
                    <span class="s1">];</span>
                    <span class="s1">tracedFiles.add(_path.default.relative(distDir, file).replace(</span><span class="s5">/\\/g</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">));</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">curFile of curFiles || []){</span>
                        <span class="s2">const </span><span class="s1">filePath = _path.default.join(outputFileTracingRoot, curFile);</span>
                        <span class="s2">if </span><span class="s1">(!shouldIgnore(curFile, tracedFiles === minimalServerTracedFiles ? minimalServerIgnoreFn : serverIgnoreFn, reasons, tracedFiles === minimalServerTracedFiles ? cachedLookupIgnoreMinimal : cachedLookupIgnore)) {</span>
                            <span class="s1">tracedFiles.add(_path.default.relative(distDir, filePath).replace(</span><span class="s5">/\\/g</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">));</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ entryNameFilesMap } = (buildTraceContext == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: buildTraceContext.chunksTrace) || {};</span>
            <span class="s2">const </span><span class="s1">cachedLookupIgnoreRoutes = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">await </span><span class="s1">Promise.all([</span>
                <span class="s1">...entryNameFilesMap ? Object.entries(entryNameFilesMap) : </span><span class="s2">new </span><span class="s1">Map()</span>
            <span class="s1">].map(async ([entryName, entryNameFiles])=&gt;{</span>
                <span class="s2">const </span><span class="s1">isApp = entryName.startsWith(</span><span class="s0">'app/'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">isPages = entryName.startsWith(</span><span class="s0">'pages/'</span><span class="s1">);</span>
                <span class="s2">let </span><span class="s1">route = entryName;</span>
                <span class="s2">if </span><span class="s1">(isApp) {</span>
                    <span class="s1">route = (</span><span class="s4">0</span><span class="s1">, _apppaths.normalizeAppPath)(route.substring(</span><span class="s0">'app'</span><span class="s1">.length));</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(isPages) {</span>
                    <span class="s1">route = (</span><span class="s4">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(route.substring(</span><span class="s0">'pages'</span><span class="s1">.length));</span>
                <span class="s1">}</span>
                <span class="s3">// we don't need to trace for automatically statically optimized</span>
                <span class="s3">// pages as they don't have server bundles, note there is</span>
                <span class="s3">// the caveat with flying shuttle mode as it needs this for</span>
                <span class="s3">// detecting changed entries</span>
                <span class="s2">if </span><span class="s1">(staticPages.includes(route)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">entryOutputPath = _path.default.join(distDir, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">`</span><span class="s1">${entryName}</span><span class="s0">.js`</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">traceOutputPath = </span><span class="s0">`</span><span class="s1">${entryOutputPath}</span><span class="s0">.nft.json`</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">existingTrace = JSON.parse(</span><span class="s2">await </span><span class="s1">_promises.default.readFile(traceOutputPath, </span><span class="s0">'utf8'</span><span class="s1">));</span>
                <span class="s2">const </span><span class="s1">traceOutputDir = _path.default.dirname(traceOutputPath);</span>
                <span class="s2">const </span><span class="s1">curTracedFiles = </span><span class="s2">new </span><span class="s1">Set();</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of [</span>
                    <span class="s1">...entryNameFiles,</span>
                    <span class="s1">entryOutputPath</span>
                <span class="s1">]){</span>
                    <span class="s2">var </span><span class="s1">_parentFilesMap_get;</span>
                    <span class="s2">const </span><span class="s1">curFiles = [</span>
                        <span class="s1">...((_parentFilesMap_get = parentFilesMap.get(_path.default.relative(outputFileTracingRoot, file))) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _parentFilesMap_get.keys()) || []</span>
                    <span class="s1">];</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">curFile of curFiles || []){</span>
                        <span class="s2">if </span><span class="s1">(!shouldIgnore(curFile, routeIgnoreFn, reasons, cachedLookupIgnoreRoutes)) {</span>
                            <span class="s2">const </span><span class="s1">filePath = _path.default.join(outputFileTracingRoot, curFile);</span>
                            <span class="s2">const </span><span class="s1">outputFile = _path.default.relative(traceOutputDir, filePath).replace(</span><span class="s5">/\\/g</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">);</span>
                            <span class="s1">curTracedFiles.add(outputFile);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of existingTrace.files || []){</span>
                    <span class="s1">curTracedFiles.add(file);</span>
                <span class="s1">}</span>
                <span class="s2">await </span><span class="s1">_promises.default.writeFile(traceOutputPath, JSON.stringify({</span>
                    <span class="s1">...existingTrace,</span>
                    <span class="s1">files: [</span>
                        <span class="s1">...curTracedFiles</span>
                    <span class="s1">].sort()</span>
                <span class="s1">}));</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">moduleTypes = [</span>
            <span class="s0">'app-page'</span><span class="s1">,</span>
            <span class="s0">'pages'</span>
        <span class="s1">];</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">type of moduleTypes){</span>
            <span class="s2">const </span><span class="s1">modulePath = require.resolve(</span><span class="s0">`next/dist/server/route-modules/</span><span class="s1">${type}</span><span class="s0">/module.compiled`</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">relativeModulePath = _path.default.relative(root, modulePath);</span>
            <span class="s2">const </span><span class="s1">contextDir = _path.default.join(_path.default.dirname(modulePath), </span><span class="s0">'vendored'</span><span class="s1">, </span><span class="s0">'contexts'</span><span class="s1">);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">item of (</span><span class="s2">await </span><span class="s1">_promises.default.readdir(contextDir))){</span>
                <span class="s2">const </span><span class="s1">itemPath = _path.default.relative(root, _path.default.join(contextDir, item));</span>
                <span class="s2">if </span><span class="s1">(!serverIgnoreFn(itemPath)) {</span>
                    <span class="s1">addToTracedFiles(root, itemPath, serverTracedFiles);</span>
                    <span class="s1">addToTracedFiles(root, itemPath, minimalServerTracedFiles);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">addToTracedFiles(root, relativeModulePath, serverTracedFiles);</span>
            <span class="s1">addToTracedFiles(root, relativeModulePath, minimalServerTracedFiles);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">serverTracedFilesSorted = Array.from(serverTracedFiles);</span>
        <span class="s1">serverTracedFilesSorted.sort();</span>
        <span class="s2">const </span><span class="s1">minimalServerTracedFilesSorted = Array.from(minimalServerTracedFiles);</span>
        <span class="s1">minimalServerTracedFilesSorted.sort();</span>
        <span class="s2">await </span><span class="s1">Promise.all([</span>
            <span class="s1">_promises.default.writeFile(nextServerTraceOutput, JSON.stringify({</span>
                <span class="s1">version: </span><span class="s4">1</span><span class="s1">,</span>
                <span class="s1">files: serverTracedFilesSorted</span>
            <span class="s1">})),</span>
            <span class="s1">_promises.default.writeFile(nextMinimalTraceOutput, JSON.stringify({</span>
                <span class="s1">version: </span><span class="s4">1</span><span class="s1">,</span>
                <span class="s1">files: minimalServerTracedFilesSorted</span>
            <span class="s1">}))</span>
        <span class="s1">]);</span>
    <span class="s1">});</span>
    <span class="s3">// apply outputFileTracingIncludes/outputFileTracingExcludes after runTurbotrace</span>
    <span class="s2">const </span><span class="s1">includeExcludeSpan = nextBuildSpan.traceChild(</span><span class="s0">'apply-include-excludes'</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">includeExcludeSpan.traceAsyncFn(async ()=&gt;{</span>
        <span class="s2">const </span><span class="s1">globOrig = require(</span><span class="s0">'next/dist/compiled/glob'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">glob = (pattern)=&gt;{</span>
            <span class="s2">return new </span><span class="s1">Promise((resolve, reject)=&gt;{</span>
                <span class="s1">globOrig(pattern, {</span>
                    <span class="s1">cwd: dir,</span>
                    <span class="s1">nodir: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">dot: </span><span class="s2">true</span>
                <span class="s1">}, (err, files)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(err) {</span>
                        <span class="s2">return </span><span class="s1">reject(err);</span>
                    <span class="s1">}</span>
                    <span class="s1">resolve(files);</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">{ entryNameFilesMap } = (buildTraceContext == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: buildTraceContext.chunksTrace) || {};</span>
        <span class="s2">await </span><span class="s1">Promise.all([</span>
            <span class="s1">...entryNameFilesMap ? Object.entries(entryNameFilesMap) : </span><span class="s2">new </span><span class="s1">Map()</span>
        <span class="s1">].map(async ([entryName])=&gt;{</span>
            <span class="s2">const </span><span class="s1">isApp = entryName.startsWith(</span><span class="s0">'app/'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">isPages = entryName.startsWith(</span><span class="s0">'pages/'</span><span class="s1">);</span>
            <span class="s2">let </span><span class="s1">route = entryName;</span>
            <span class="s2">if </span><span class="s1">(isApp) {</span>
                <span class="s1">route = (</span><span class="s4">0</span><span class="s1">, _apppaths.normalizeAppPath)(entryName);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isPages) {</span>
                <span class="s1">route = (</span><span class="s4">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(entryName);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(staticPages.includes(route)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// edge routes have no trace files</span>
            <span class="s2">if </span><span class="s1">(edgeRuntimeRoutes.hasOwnProperty(route)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">combinedIncludes = </span><span class="s2">new </span><span class="s1">Set();</span>
            <span class="s2">const </span><span class="s1">combinedExcludes = </span><span class="s2">new </span><span class="s1">Set();</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">curGlob of includeGlobKeys){</span>
                <span class="s2">const </span><span class="s1">isMatch = (</span><span class="s4">0</span><span class="s1">, _picomatch.default)(curGlob, {</span>
                    <span class="s1">dot: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">contains: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(isMatch(route)) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">include of outputFileTracingIncludes[curGlob]){</span>
                        <span class="s1">combinedIncludes.add(include.replace(</span><span class="s5">/\\/g</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">curGlob of excludeGlobKeys){</span>
                <span class="s2">const </span><span class="s1">isMatch = (</span><span class="s4">0</span><span class="s1">, _picomatch.default)(curGlob, {</span>
                    <span class="s1">dot: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">contains: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(isMatch(route)) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exclude of outputFileTracingExcludes[curGlob]){</span>
                        <span class="s1">combinedExcludes.add(exclude);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!(combinedIncludes == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: combinedIncludes.size) &amp;&amp; !(combinedExcludes == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: combinedExcludes.size)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">traceFile = _path.default.join(distDir, </span><span class="s0">`server`</span><span class="s1">, </span><span class="s0">`</span><span class="s1">${entryName}</span><span class="s0">.js.nft.json`</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">pageDir = _path.default.dirname(traceFile);</span>
            <span class="s2">const </span><span class="s1">traceContent = JSON.parse(</span><span class="s2">await </span><span class="s1">_promises.default.readFile(traceFile, </span><span class="s0">'utf8'</span><span class="s1">));</span>
            <span class="s2">const </span><span class="s1">includes = [];</span>
            <span class="s2">const </span><span class="s1">resolvedTraceIncludes = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">if </span><span class="s1">(combinedIncludes == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: combinedIncludes.size) {</span>
                <span class="s2">await </span><span class="s1">Promise.all([</span>
                    <span class="s1">...combinedIncludes</span>
                <span class="s1">].map(async (includeGlob)=&gt;{</span>
                    <span class="s2">const </span><span class="s1">results = </span><span class="s2">await </span><span class="s1">glob(includeGlob);</span>
                    <span class="s2">const </span><span class="s1">resolvedInclude = resolvedTraceIncludes.get(includeGlob) || [</span>
                        <span class="s1">...results.map((file)=&gt;{</span>
                            <span class="s2">return </span><span class="s1">_path.default.relative(pageDir, _path.default.join(dir, file));</span>
                        <span class="s1">})</span>
                    <span class="s1">];</span>
                    <span class="s1">includes.push(...resolvedInclude);</span>
                    <span class="s1">resolvedTraceIncludes.set(includeGlob, resolvedInclude);</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">combined = </span><span class="s2">new </span><span class="s1">Set([</span>
                <span class="s1">...traceContent.files,</span>
                <span class="s1">...includes</span>
            <span class="s1">]);</span>
            <span class="s2">if </span><span class="s1">(combinedExcludes == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: combinedExcludes.size) {</span>
                <span class="s2">const </span><span class="s1">resolvedGlobs = [</span>
                    <span class="s1">...combinedExcludes</span>
                <span class="s1">].map((exclude)=&gt;_path.default.join(dir, exclude));</span>
                <span class="s3">// pre compile before forEach</span>
                <span class="s2">const </span><span class="s1">isMatch = (</span><span class="s4">0</span><span class="s1">, _picomatch.default)(resolvedGlobs, {</span>
                    <span class="s1">dot: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">contains: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s1">combined.forEach((file)=&gt;{</span>
                    <span class="s2">if </span><span class="s1">(isMatch(_path.default.join(pageDir, file))) {</span>
                        <span class="s1">combined.delete(file);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">// overwrite trace file with custom includes/excludes</span>
            <span class="s2">await </span><span class="s1">_promises.default.writeFile(traceFile, JSON.stringify({</span>
                <span class="s1">version: traceContent.version,</span>
                <span class="s1">files: [</span>
                    <span class="s1">...combined</span>
                <span class="s1">]</span>
            <span class="s1">}));</span>
        <span class="s1">}));</span>
    <span class="s1">});</span>
    <span class="s1">debug(</span><span class="s0">`finished build tracing </span><span class="s1">${Date.now() - startTime}</span><span class="s0">ms`</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=collect-build-traces.js.map</span></pre>
</body>
</html>