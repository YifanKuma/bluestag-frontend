<html>
<head>
<title>react-server-dom-webpack-server.edge.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-server-dom-webpack-server.edge.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@license </span><span class="s0">React</span>
 <span class="s0">* react-server-dom-webpack-server.edge.development.js</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>
<span class="s3">&quot;production&quot; </span><span class="s2">!== process.env.NODE_ENV &amp;&amp;</span>
  <span class="s2">(</span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">function </span><span class="s2">voidHandler() {}</span>
    <span class="s4">function </span><span class="s2">getIteratorFn(maybeIterable) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== maybeIterable || </span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">maybeIterable)</span>
        <span class="s4">return null</span><span class="s2">;</span>
      <span class="s2">maybeIterable =</span>
        <span class="s2">(MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span>
        <span class="s2">maybeIterable[</span><span class="s3">&quot;@@iterator&quot;</span><span class="s2">];</span>
      <span class="s4">return </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">maybeIterable ? maybeIterable : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">_defineProperty(obj, key, value) {</span>
      <span class="s2">a: </span><span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">== </span><span class="s4">typeof </span><span class="s2">key &amp;&amp; key) {</span>
        <span class="s4">var </span><span class="s2">e = key[Symbol.toPrimitive];</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== e) {</span>
          <span class="s2">key = e.call(key, </span><span class="s3">&quot;string&quot;</span><span class="s2">);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">!= </span><span class="s4">typeof </span><span class="s2">key) </span><span class="s4">break </span><span class="s2">a;</span>
          <span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;@@toPrimitive must return a primitive value.&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s2">key = String(key);</span>
      <span class="s2">}</span>
      <span class="s2">key = </span><span class="s3">&quot;symbol&quot; </span><span class="s2">== </span><span class="s4">typeof </span><span class="s2">key ? key : key + </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
      <span class="s2">key </span><span class="s4">in </span><span class="s2">obj</span>
        <span class="s2">? Object.defineProperty(obj, key, {</span>
            <span class="s2">value: value,</span>
            <span class="s2">enumerable: !</span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">configurable: !</span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">writable: !</span><span class="s5">0</span>
          <span class="s2">})</span>
        <span class="s2">: (obj[key] = value);</span>
      <span class="s4">return </span><span class="s2">obj;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">handleErrorInNextTick(error) {</span>
      <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">throw </span><span class="s2">error;</span>
      <span class="s2">});</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">writeChunkAndReturn(destination, chunk) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== chunk.byteLength)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">2048 </span><span class="s2">&lt; chunk.byteLength)</span>
          <span class="s5">0 </span><span class="s2">&lt; writtenBytes &amp;&amp;</span>
            <span class="s2">(destination.enqueue(</span>
              <span class="s4">new </span><span class="s2">Uint8Array(currentView.buffer, </span><span class="s5">0</span><span class="s2">, writtenBytes)</span>
            <span class="s2">),</span>
            <span class="s2">(currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">)),</span>
            <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">)),</span>
            <span class="s2">destination.enqueue(chunk);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">allowableBytes = currentView.length - writtenBytes;</span>
          <span class="s2">allowableBytes &lt; chunk.byteLength &amp;&amp;</span>
            <span class="s2">(</span><span class="s5">0 </span><span class="s2">=== allowableBytes</span>
              <span class="s2">? destination.enqueue(currentView)</span>
              <span class="s2">: (currentView.set(</span>
                  <span class="s2">chunk.subarray(</span><span class="s5">0</span><span class="s2">, allowableBytes),</span>
                  <span class="s2">writtenBytes</span>
                <span class="s2">),</span>
                <span class="s2">destination.enqueue(currentView),</span>
                <span class="s2">(chunk = chunk.subarray(allowableBytes))),</span>
            <span class="s2">(currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">)),</span>
            <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">));</span>
          <span class="s2">currentView.set(chunk, writtenBytes);</span>
          <span class="s2">writtenBytes += chunk.byteLength;</span>
        <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">completeWriting(destination) {</span>
      <span class="s2">currentView &amp;&amp;</span>
        <span class="s5">0 </span><span class="s2">&lt; writtenBytes &amp;&amp;</span>
        <span class="s2">(destination.enqueue(</span>
          <span class="s4">new </span><span class="s2">Uint8Array(currentView.buffer, </span><span class="s5">0</span><span class="s2">, writtenBytes)</span>
        <span class="s2">),</span>
        <span class="s2">(currentView = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">stringToChunk(content) {</span>
      <span class="s4">return </span><span class="s2">textEncoder.encode(content);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">byteLengthOfChunk(chunk) {</span>
      <span class="s4">return </span><span class="s2">chunk.byteLength;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">closeWithError(destination, error) {</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">destination.error</span>
        <span class="s2">? destination.error(error)</span>
        <span class="s2">: destination.close();</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">isClientReference(reference) {</span>
      <span class="s4">return </span><span class="s2">reference.$$typeof === CLIENT_REFERENCE_TAG$1;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">registerClientReferenceImpl(proxyImplementation, id, async) {</span>
      <span class="s4">return </span><span class="s2">Object.defineProperties(proxyImplementation, {</span>
        <span class="s2">$$typeof: { value: CLIENT_REFERENCE_TAG$1 },</span>
        <span class="s2">$$id: { value: id },</span>
        <span class="s2">$$async: { value: async }</span>
      <span class="s2">});</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">bind() {</span>
      <span class="s4">var </span><span class="s2">newFn = FunctionBind.apply(</span><span class="s4">this</span><span class="s2">, arguments);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.$$typeof === SERVER_REFERENCE_TAG) {</span>
        <span class="s4">null </span><span class="s2">!= arguments[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
          <span class="s2">console.error(</span>
            <span class="s3">'Cannot bind &quot;this&quot; of a Server Action. Pass null or undefined as the first argument to .bind().'</span>
          <span class="s2">);</span>
        <span class="s4">var </span><span class="s2">args = ArraySlice.call(arguments, </span><span class="s5">1</span><span class="s2">),</span>
          <span class="s2">$$typeof = { value: SERVER_REFERENCE_TAG },</span>
          <span class="s2">$$id = { value: </span><span class="s4">this</span><span class="s2">.$$id };</span>
        <span class="s2">args = { value: </span><span class="s4">this</span><span class="s2">.$$bound ? </span><span class="s4">this</span><span class="s2">.$$bound.concat(args) : args };</span>
        <span class="s4">return </span><span class="s2">Object.defineProperties(newFn, {</span>
          <span class="s2">$$typeof: $$typeof,</span>
          <span class="s2">$$id: $$id,</span>
          <span class="s2">$$bound: args,</span>
          <span class="s2">$$location: { value: </span><span class="s4">this</span><span class="s2">.$$location, configurable: !</span><span class="s5">0 </span><span class="s2">},</span>
          <span class="s2">bind: { value: bind, configurable: !</span><span class="s5">0 </span><span class="s2">}</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">newFn;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">getReference(target, name) {</span>
      <span class="s4">switch </span><span class="s2">(name) {</span>
        <span class="s4">case </span><span class="s3">&quot;$$typeof&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.$$typeof;</span>
        <span class="s4">case </span><span class="s3">&quot;$$id&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.$$id;</span>
        <span class="s4">case </span><span class="s3">&quot;$$async&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.$$async;</span>
        <span class="s4">case </span><span class="s3">&quot;name&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.name;</span>
        <span class="s4">case </span><span class="s3">&quot;defaultProps&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;_debugInfo&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">Symbol.toPrimitive:</span>
          <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toPrimitive];</span>
        <span class="s4">case </span><span class="s2">Symbol.toStringTag:</span>
          <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toStringTag];</span>
        <span class="s4">case </span><span class="s3">&quot;__esModule&quot;</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">moduleId = target.$$id;</span>
          <span class="s2">target.default = registerClientReferenceImpl(</span>
            <span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;Attempted to call the default export of &quot; </span><span class="s2">+</span>
                  <span class="s2">moduleId +</span>
                  <span class="s3">&quot; from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.&quot;</span>
              <span class="s2">);</span>
            <span class="s2">},</span>
            <span class="s2">target.$$id + </span><span class="s3">&quot;#&quot;</span><span class="s2">,</span>
            <span class="s2">target.$$async</span>
          <span class="s2">);</span>
          <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;then&quot;</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(target.then) </span><span class="s4">return </span><span class="s2">target.then;</span>
          <span class="s4">if </span><span class="s2">(target.$$async) </span><span class="s4">return</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">clientReference = registerClientReferenceImpl(</span>
              <span class="s2">{},</span>
              <span class="s2">target.$$id,</span>
              <span class="s2">!</span><span class="s5">0</span>
            <span class="s2">),</span>
            <span class="s2">proxy = </span><span class="s4">new </span><span class="s2">Proxy(clientReference, proxyHandlers$1);</span>
          <span class="s2">target.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
          <span class="s2">target.value = proxy;</span>
          <span class="s4">return </span><span class="s2">(target.then = registerClientReferenceImpl(</span>
            <span class="s4">function </span><span class="s2">(resolve) {</span>
              <span class="s4">return </span><span class="s2">Promise.resolve(resolve(proxy));</span>
            <span class="s2">},</span>
            <span class="s2">target.$$id + </span><span class="s3">&quot;#then&quot;</span><span class="s2">,</span>
            <span class="s2">!</span><span class="s5">1</span>
          <span class="s2">));</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">name)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.&quot;</span>
        <span class="s2">);</span>
      <span class="s2">clientReference = target[name];</span>
      <span class="s2">clientReference ||</span>
        <span class="s2">((clientReference = registerClientReferenceImpl(</span>
          <span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">throw </span><span class="s2">Error(</span>
              <span class="s3">&quot;Attempted to call &quot; </span><span class="s2">+</span>
                <span class="s2">String(name) +</span>
                <span class="s3">&quot;() from the server but &quot; </span><span class="s2">+</span>
                <span class="s2">String(name) +</span>
                <span class="s3">&quot; is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.&quot;</span>
            <span class="s2">);</span>
          <span class="s2">},</span>
          <span class="s2">target.$$id + </span><span class="s3">&quot;#&quot; </span><span class="s2">+ name,</span>
          <span class="s2">target.$$async</span>
        <span class="s2">)),</span>
        <span class="s2">Object.defineProperty(clientReference, </span><span class="s3">&quot;name&quot;</span><span class="s2">, { value: name }),</span>
        <span class="s2">(clientReference = target[name] =</span>
          <span class="s4">new </span><span class="s2">Proxy(clientReference, deepProxyHandlers)));</span>
      <span class="s4">return </span><span class="s2">clientReference;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">resolveClientReferenceMetadata(config, clientReference) {</span>
      <span class="s4">var </span><span class="s2">modulePath = clientReference.$$id,</span>
        <span class="s2">name = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s2">resolvedModuleData = config[modulePath];</span>
      <span class="s4">if </span><span class="s2">(resolvedModuleData) name = resolvedModuleData.name;</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">idx = modulePath.lastIndexOf(</span><span class="s3">&quot;#&quot;</span><span class="s2">);</span>
        <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== idx &amp;&amp;</span>
          <span class="s2">((name = modulePath.slice(idx + </span><span class="s5">1</span><span class="s2">)),</span>
          <span class="s2">(resolvedModuleData = config[modulePath.slice(</span><span class="s5">0</span><span class="s2">, idx)]));</span>
        <span class="s4">if </span><span class="s2">(!resolvedModuleData)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">'Could not find the module &quot;' </span><span class="s2">+</span>
              <span class="s2">modulePath +</span>
              <span class="s3">'&quot; in the React Client Manifest. This is probably a bug in the React Server Components bundler.'</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(!</span><span class="s5">0 </span><span class="s2">=== resolvedModuleData.async &amp;&amp; !</span><span class="s5">0 </span><span class="s2">=== clientReference.$$async)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">'The module &quot;' </span><span class="s2">+</span>
            <span class="s2">modulePath +</span>
            <span class="s3">'&quot; is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'</span>
        <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0 </span><span class="s2">=== resolvedModuleData.async || !</span><span class="s5">0 </span><span class="s2">=== clientReference.$$async</span>
        <span class="s2">? [resolvedModuleData.id, resolvedModuleData.chunks, name, </span><span class="s5">1</span><span class="s2">]</span>
        <span class="s2">: [resolvedModuleData.id, resolvedModuleData.chunks, name];</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">trimOptions(options) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== options) </span><span class="s4">return null</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">hasProperties = !</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">trimmed = {},</span>
        <span class="s2">key;</span>
      <span class="s4">for </span><span class="s2">(key </span><span class="s4">in </span><span class="s2">options)</span>
        <span class="s4">null </span><span class="s2">!= options[key] &amp;&amp;</span>
          <span class="s2">((hasProperties = !</span><span class="s5">0</span><span class="s2">), (trimmed[key] = options[key]));</span>
      <span class="s4">return </span><span class="s2">hasProperties ? trimmed : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">collectStackTracePrivate(error, structuredStackTrace) {</span>
      <span class="s2">error = [];</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = framesToSkip; i &lt; structuredStackTrace.length; i++) {</span>
        <span class="s4">var </span><span class="s2">callSite = structuredStackTrace[i],</span>
          <span class="s2">name = callSite.getFunctionName() || </span><span class="s3">&quot;&lt;anonymous&gt;&quot;</span><span class="s2">;</span>
        <span class="s4">if </span><span class="s2">(name.includes(</span><span class="s3">&quot;react_stack_bottom_frame&quot;</span><span class="s2">)) </span><span class="s4">break</span><span class="s2">;</span>
        <span class="s4">else if </span><span class="s2">(callSite.isNative())</span>
          <span class="s2">(callSite = callSite.isAsync()),</span>
            <span class="s2">error.push([name, </span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, callSite]);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">if </span><span class="s2">(callSite.isConstructor()) name = </span><span class="s3">&quot;new &quot; </span><span class="s2">+ name;</span>
          <span class="s4">else if </span><span class="s2">(!callSite.isToplevel()) {</span>
            <span class="s4">var </span><span class="s2">callSite$jscomp$0 = callSite;</span>
            <span class="s2">name = callSite$jscomp$0.getTypeName();</span>
            <span class="s4">var </span><span class="s2">methodName = callSite$jscomp$0.getMethodName();</span>
            <span class="s2">callSite$jscomp$0 = callSite$jscomp$0.getFunctionName();</span>
            <span class="s4">var </span><span class="s2">result = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
            <span class="s2">callSite$jscomp$0</span>
              <span class="s2">? (name &amp;&amp;</span>
                  <span class="s2">identifierRegExp.test(callSite$jscomp$0) &amp;&amp;</span>
                  <span class="s2">callSite$jscomp$0 !== name &amp;&amp;</span>
                  <span class="s2">(result += name + </span><span class="s3">&quot;.&quot;</span><span class="s2">),</span>
                <span class="s2">(result += callSite$jscomp$0),</span>
                <span class="s2">!methodName ||</span>
                  <span class="s2">callSite$jscomp$0 === methodName ||</span>
                  <span class="s2">callSite$jscomp$0.endsWith(</span><span class="s3">&quot;.&quot; </span><span class="s2">+ methodName) ||</span>
                  <span class="s2">callSite$jscomp$0.endsWith(</span><span class="s3">&quot; &quot; </span><span class="s2">+ methodName) ||</span>
                  <span class="s2">(result += </span><span class="s3">&quot; [as &quot; </span><span class="s2">+ methodName + </span><span class="s3">&quot;]&quot;</span><span class="s2">))</span>
              <span class="s2">: (name &amp;&amp; (result += name + </span><span class="s3">&quot;.&quot;</span><span class="s2">),</span>
                <span class="s2">(result = methodName</span>
                  <span class="s2">? result + methodName</span>
                  <span class="s2">: result + </span><span class="s3">&quot;&lt;anonymous&gt;&quot;</span><span class="s2">));</span>
            <span class="s2">name = result;</span>
          <span class="s2">}</span>
          <span class="s3">&quot;&lt;anonymous&gt;&quot; </span><span class="s2">=== name &amp;&amp; (name = </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
          <span class="s2">methodName = callSite.getScriptNameOrSourceURL() || </span><span class="s3">&quot;&lt;anonymous&gt;&quot;</span><span class="s2">;</span>
          <span class="s3">&quot;&lt;anonymous&gt;&quot; </span><span class="s2">=== methodName &amp;&amp;</span>
            <span class="s2">((methodName = </span><span class="s3">&quot;&quot;</span><span class="s2">),</span>
            <span class="s2">callSite.isEval() &amp;&amp;</span>
              <span class="s2">(callSite$jscomp$0 = callSite.getEvalOrigin()) &amp;&amp;</span>
              <span class="s2">(methodName = callSite$jscomp$0.toString() + </span><span class="s3">&quot;, &lt;anonymous&gt;&quot;</span><span class="s2">));</span>
          <span class="s2">callSite$jscomp$0 = callSite.getLineNumber() || </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">result = callSite.getColumnNumber() || </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">enclosingLine =</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">callSite.getEnclosingLineNumber</span>
                <span class="s2">? callSite.getEnclosingLineNumber() || </span><span class="s5">0</span>
                <span class="s2">: </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">enclosingCol =</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">callSite.getEnclosingColumnNumber</span>
                <span class="s2">? callSite.getEnclosingColumnNumber() || </span><span class="s5">0</span>
                <span class="s2">: </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">callSite = callSite.isAsync();</span>
          <span class="s2">error.push([</span>
            <span class="s2">name,</span>
            <span class="s2">methodName,</span>
            <span class="s2">callSite$jscomp$0,</span>
            <span class="s2">result,</span>
            <span class="s2">enclosingLine,</span>
            <span class="s2">enclosingCol,</span>
            <span class="s2">callSite</span>
          <span class="s2">]);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">collectedStackTrace = error;</span>
      <span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">collectStackTrace(error, structuredStackTrace) {</span>
      <span class="s2">collectStackTracePrivate(error, structuredStackTrace);</span>
      <span class="s2">error = (error.name || </span><span class="s3">&quot;Error&quot;</span><span class="s2">) + </span><span class="s3">&quot;: &quot; </span><span class="s2">+ (error.message || </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; structuredStackTrace.length; i++)</span>
        <span class="s2">error += </span><span class="s3">&quot;</span><span class="s6">\n    </span><span class="s3">at &quot; </span><span class="s2">+ structuredStackTrace[i].toString();</span>
      <span class="s4">return </span><span class="s2">error;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">parseStackTrace(error, skipFrames) {</span>
      <span class="s4">var </span><span class="s2">existing = stackTraceCache.get(error);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existing) </span><span class="s4">return </span><span class="s2">existing;</span>
      <span class="s2">collectedStackTrace = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">framesToSkip = skipFrames;</span>
      <span class="s2">existing = Error.prepareStackTrace;</span>
      <span class="s2">Error.prepareStackTrace = collectStackTrace;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">stack = String(error.stack);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">Error.prepareStackTrace = existing;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== collectedStackTrace)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(stack = collectedStackTrace),</span>
          <span class="s2">(collectedStackTrace = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">stackTraceCache.set(error, stack),</span>
          <span class="s2">stack</span>
        <span class="s2">);</span>
      <span class="s2">stack.startsWith(</span><span class="s3">&quot;Error: react-stack-top-frame</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">(stack = stack.slice(</span><span class="s5">29</span><span class="s2">));</span>
      <span class="s2">existing = stack.indexOf(</span><span class="s3">&quot;react_stack_bottom_frame&quot;</span><span class="s2">);</span>
      <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== existing &amp;&amp; (existing = stack.lastIndexOf(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">, existing));</span>
      <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== existing &amp;&amp; (stack = stack.slice(</span><span class="s5">0</span><span class="s2">, existing));</span>
      <span class="s2">stack = stack.split(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">);</span>
      <span class="s4">for </span><span class="s2">(existing = []; skipFrames &lt; stack.length; skipFrames++) {</span>
        <span class="s4">var </span><span class="s2">parsed = frameRegExp.exec(stack[skipFrames]);</span>
        <span class="s4">if </span><span class="s2">(parsed) {</span>
          <span class="s4">var </span><span class="s2">name = parsed[</span><span class="s5">1</span><span class="s2">] || </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
            <span class="s2">isAsync = </span><span class="s3">&quot;async &quot; </span><span class="s2">=== parsed[</span><span class="s5">8</span><span class="s2">];</span>
          <span class="s3">&quot;&lt;anonymous&gt;&quot; </span><span class="s2">=== name</span>
            <span class="s2">? (name = </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
            <span class="s2">: name.startsWith(</span><span class="s3">&quot;async &quot;</span><span class="s2">) &amp;&amp;</span>
              <span class="s2">((name = name.slice(</span><span class="s5">5</span><span class="s2">)), (isAsync = !</span><span class="s5">0</span><span class="s2">));</span>
          <span class="s4">var </span><span class="s2">filename = parsed[</span><span class="s5">2</span><span class="s2">] || parsed[</span><span class="s5">5</span><span class="s2">] || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
          <span class="s3">&quot;&lt;anonymous&gt;&quot; </span><span class="s2">=== filename &amp;&amp; (filename = </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
          <span class="s2">existing.push([</span>
            <span class="s2">name,</span>
            <span class="s2">filename,</span>
            <span class="s2">+(parsed[</span><span class="s5">3</span><span class="s2">] || parsed[</span><span class="s5">6</span><span class="s2">]),</span>
            <span class="s2">+(parsed[</span><span class="s5">4</span><span class="s2">] || parsed[</span><span class="s5">7</span><span class="s2">]),</span>
            <span class="s5">0</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">,</span>
            <span class="s2">isAsync</span>
          <span class="s2">]);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">stackTraceCache.set(error, existing);</span>
      <span class="s4">return </span><span class="s2">existing;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createTemporaryReference(temporaryReferences, id) {</span>
      <span class="s4">var </span><span class="s2">reference = Object.defineProperties(</span>
        <span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.&quot;</span>
          <span class="s2">);</span>
        <span class="s2">},</span>
        <span class="s2">{ $$typeof: { value: TEMPORARY_REFERENCE_TAG } }</span>
      <span class="s2">);</span>
      <span class="s2">reference = </span><span class="s4">new </span><span class="s2">Proxy(reference, proxyHandlers);</span>
      <span class="s2">temporaryReferences.set(reference, id);</span>
      <span class="s4">return </span><span class="s2">reference;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">noop() {}</span>
    <span class="s4">function </span><span class="s2">trackUsedThenable(thenableState, thenable, index) {</span>
      <span class="s2">index = thenableState[index];</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== index</span>
        <span class="s2">? (thenableState.push(thenable),</span>
          <span class="s2">(thenableState._stacks || (thenableState._stacks = [])).push(Error()))</span>
        <span class="s2">: index !== thenable &amp;&amp; (thenable.then(noop, noop), (thenable = index));</span>
      <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">thenable.value;</span>
        <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
          <span class="s4">throw </span><span class="s2">thenable.reason;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">thenable.status</span>
            <span class="s2">? thenable.then(noop, noop)</span>
            <span class="s2">: ((thenableState = thenable),</span>
              <span class="s2">(thenableState.status = </span><span class="s3">&quot;pending&quot;</span><span class="s2">),</span>
              <span class="s2">thenableState.then(</span>
                <span class="s4">function </span><span class="s2">(fulfilledValue) {</span>
                  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status) {</span>
                    <span class="s4">var </span><span class="s2">fulfilledThenable = thenable;</span>
                    <span class="s2">fulfilledThenable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
                    <span class="s2">fulfilledThenable.value = fulfilledValue;</span>
                  <span class="s2">}</span>
                <span class="s2">},</span>
                <span class="s4">function </span><span class="s2">(error) {</span>
                  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status) {</span>
                    <span class="s4">var </span><span class="s2">rejectedThenable = thenable;</span>
                    <span class="s2">rejectedThenable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
                    <span class="s2">rejectedThenable.reason = error;</span>
                  <span class="s2">}</span>
                <span class="s2">}</span>
              <span class="s2">));</span>
          <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
            <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">thenable.value;</span>
            <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
              <span class="s4">throw </span><span class="s2">thenable.reason;</span>
          <span class="s2">}</span>
          <span class="s2">suspendedThenable = thenable;</span>
          <span class="s4">throw </span><span class="s2">SuspenseException;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">getSuspendedThenable() {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== suspendedThenable)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;Expected a suspended thenable. This is a bug in React. Please file an issue.&quot;</span>
        <span class="s2">);</span>
      <span class="s4">var </span><span class="s2">thenable = suspendedThenable;</span>
      <span class="s2">suspendedThenable = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">thenable;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">getThenableStateAfterSuspending() {</span>
      <span class="s4">var </span><span class="s2">state = thenableState || [];</span>
      <span class="s2">state._componentDebugInfo = currentComponentDebugInfo;</span>
      <span class="s2">thenableState = currentComponentDebugInfo = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">state;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">unsupportedHook() {</span>
      <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;This Hook is not supported in Server Components.&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">unsupportedRefresh() {</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Refreshing the cache is not supported in Server Components.&quot;</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">unsupportedContext() {</span>
      <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot read a Client Context from a Server Component.&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">resolveOwner() {</span>
      <span class="s4">if </span><span class="s2">(currentOwner) </span><span class="s4">return </span><span class="s2">currentOwner;</span>
      <span class="s4">if </span><span class="s2">(supportsComponentStorage) {</span>
        <span class="s4">var </span><span class="s2">owner = componentStorage.getStore();</span>
        <span class="s4">if </span><span class="s2">(owner) </span><span class="s4">return </span><span class="s2">owner;</span>
      <span class="s2">}</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">prepareStackTrace(error, structuredStackTrace) {</span>
      <span class="s2">error = (error.name || </span><span class="s3">&quot;Error&quot;</span><span class="s2">) + </span><span class="s3">&quot;: &quot; </span><span class="s2">+ (error.message || </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; structuredStackTrace.length; i++)</span>
        <span class="s2">error += </span><span class="s3">&quot;</span><span class="s6">\n    </span><span class="s3">at &quot; </span><span class="s2">+ structuredStackTrace[i].toString();</span>
      <span class="s4">return </span><span class="s2">error;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">resetOwnerStackLimit() {</span>
      <span class="s4">var </span><span class="s2">now = getCurrentTime();</span>
      <span class="s5">1e3 </span><span class="s2">&lt; now - lastResetTime &amp;&amp;</span>
        <span class="s2">((ReactSharedInternalsServer.recentlyCreatedOwnerStacks = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">(lastResetTime = now));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">isObjectPrototype(object) {</span>
      <span class="s4">if </span><span class="s2">(!object) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">ObjectPrototype = Object.prototype;</span>
      <span class="s4">if </span><span class="s2">(object === ObjectPrototype) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(getPrototypeOf(object)) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">object = Object.getOwnPropertyNames(object);</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; object.length; i++)</span>
        <span class="s4">if </span><span class="s2">(!(object[i] </span><span class="s4">in </span><span class="s2">ObjectPrototype)) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">isGetter(object, name) {</span>
      <span class="s4">if </span><span class="s2">(object === Object.prototype || </span><span class="s4">null </span><span class="s2">=== object) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">descriptor = Object.getOwnPropertyDescriptor(object, name);</span>
      <span class="s4">return void </span><span class="s5">0 </span><span class="s2">=== descriptor</span>
        <span class="s2">? isGetter(getPrototypeOf(object), name)</span>
        <span class="s2">: </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">descriptor.get;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">isSimpleObject(object) {</span>
      <span class="s4">if </span><span class="s2">(!isObjectPrototype(getPrototypeOf(object))) </span><span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s4">var </span><span class="s2">names = Object.getOwnPropertyNames(object), i = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">i &lt; names.length;</span>
        <span class="s2">i++</span>
      <span class="s2">) {</span>
        <span class="s4">var </span><span class="s2">descriptor = Object.getOwnPropertyDescriptor(object, names[i]);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">!descriptor ||</span>
          <span class="s2">(!descriptor.enumerable &amp;&amp;</span>
            <span class="s2">((</span><span class="s3">&quot;key&quot; </span><span class="s2">!== names[i] &amp;&amp; </span><span class="s3">&quot;ref&quot; </span><span class="s2">!== names[i]) ||</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">descriptor.get))</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s2">!</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">objectName(object) {</span>
      <span class="s2">object = Object.prototype.toString.call(object);</span>
      <span class="s4">return </span><span class="s2">object.slice(</span><span class="s5">8</span><span class="s2">, object.length - </span><span class="s5">1</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">describeKeyForErrorMessage(key) {</span>
      <span class="s4">var </span><span class="s2">encodedKey = JSON.stringify(key);</span>
      <span class="s4">return </span><span class="s3">'&quot;' </span><span class="s2">+ key + </span><span class="s3">'&quot;' </span><span class="s2">=== encodedKey ? key : encodedKey;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">describeValueForErrorMessage(value) {</span>
      <span class="s4">switch </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s4">case </span><span class="s3">&quot;string&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">JSON.stringify(</span>
            <span class="s5">10 </span><span class="s2">&gt;= value.length ? value : value.slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">) + </span><span class="s3">&quot;...&quot;</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s3">&quot;object&quot;</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(isArrayImpl(value)) </span><span class="s4">return </span><span class="s3">&quot;[...]&quot;</span><span class="s2">;</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== value &amp;&amp; value.$$typeof === CLIENT_REFERENCE_TAG)</span>
            <span class="s4">return </span><span class="s3">&quot;client&quot;</span><span class="s2">;</span>
          <span class="s2">value = objectName(value);</span>
          <span class="s4">return </span><span class="s3">&quot;Object&quot; </span><span class="s2">=== value ? </span><span class="s3">&quot;{...}&quot; </span><span class="s2">: value;</span>
        <span class="s4">case </span><span class="s3">&quot;function&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">value.$$typeof === CLIENT_REFERENCE_TAG</span>
            <span class="s2">? </span><span class="s3">&quot;client&quot;</span>
            <span class="s2">: (value = value.displayName || value.name)</span>
              <span class="s2">? </span><span class="s3">&quot;function &quot; </span><span class="s2">+ value</span>
              <span class="s2">: </span><span class="s3">&quot;function&quot;</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">String(value);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">describeElementType(type) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type) </span><span class="s4">return </span><span class="s2">type;</span>
      <span class="s4">switch </span><span class="s2">(type) {</span>
        <span class="s4">case </span><span class="s2">REACT_SUSPENSE_TYPE:</span>
          <span class="s4">return </span><span class="s3">&quot;Suspense&quot;</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">REACT_SUSPENSE_LIST_TYPE:</span>
          <span class="s4">return </span><span class="s3">&quot;SuspenseList&quot;</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">REACT_VIEW_TRANSITION_TYPE:</span>
          <span class="s4">return </span><span class="s3">&quot;ViewTransition&quot;</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type)</span>
        <span class="s4">switch </span><span class="s2">(type.$$typeof) {</span>
          <span class="s4">case </span><span class="s2">REACT_FORWARD_REF_TYPE:</span>
            <span class="s4">return </span><span class="s2">describeElementType(type.render);</span>
          <span class="s4">case </span><span class="s2">REACT_MEMO_TYPE:</span>
            <span class="s4">return </span><span class="s2">describeElementType(type.type);</span>
          <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
            <span class="s4">var </span><span class="s2">payload = type._payload;</span>
            <span class="s2">type = type._init;</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s4">return </span><span class="s2">describeElementType(type(payload));</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {}</span>
        <span class="s2">}</span>
      <span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">describeObjectForErrorMessage(objectOrArray, expandedName) {</span>
      <span class="s4">var </span><span class="s2">objKind = objectName(objectOrArray);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;Object&quot; </span><span class="s2">!== objKind &amp;&amp; </span><span class="s3">&quot;Array&quot; </span><span class="s2">!== objKind) </span><span class="s4">return </span><span class="s2">objKind;</span>
      <span class="s4">var </span><span class="s2">start = -</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">length = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(objectOrArray))</span>
        <span class="s4">if </span><span class="s2">(jsxChildrenParents.has(objectOrArray)) {</span>
          <span class="s4">var </span><span class="s2">type = jsxChildrenParents.get(objectOrArray);</span>
          <span class="s2">objKind = </span><span class="s3">&quot;&lt;&quot; </span><span class="s2">+ describeElementType(type) + </span><span class="s3">&quot;&gt;&quot;</span><span class="s2">;</span>
          <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; objectOrArray.length; i++) {</span>
            <span class="s4">var </span><span class="s2">value = objectOrArray[i];</span>
            <span class="s2">value =</span>
              <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value</span>
                <span class="s2">? value</span>
                <span class="s2">: </span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== value</span>
                  <span class="s2">? </span><span class="s3">&quot;{&quot; </span><span class="s2">+ describeObjectForErrorMessage(value) + </span><span class="s3">&quot;}&quot;</span>
                  <span class="s2">: </span><span class="s3">&quot;{&quot; </span><span class="s2">+ describeValueForErrorMessage(value) + </span><span class="s3">&quot;}&quot;</span><span class="s2">;</span>
            <span class="s3">&quot;&quot; </span><span class="s2">+ i === expandedName</span>
              <span class="s2">? ((start = objKind.length),</span>
                <span class="s2">(length = value.length),</span>
                <span class="s2">(objKind += value))</span>
              <span class="s2">: (objKind =</span>
                  <span class="s5">15 </span><span class="s2">&gt; value.length &amp;&amp; </span><span class="s5">40 </span><span class="s2">&gt; objKind.length + value.length</span>
                    <span class="s2">? objKind + value</span>
                    <span class="s2">: objKind + </span><span class="s3">&quot;{...}&quot;</span><span class="s2">);</span>
          <span class="s2">}</span>
          <span class="s2">objKind += </span><span class="s3">&quot;&lt;/&quot; </span><span class="s2">+ describeElementType(type) + </span><span class="s3">&quot;&gt;&quot;</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
          <span class="s2">objKind = </span><span class="s3">&quot;[&quot;</span><span class="s2">;</span>
          <span class="s4">for </span><span class="s2">(type = </span><span class="s5">0</span><span class="s2">; type &lt; objectOrArray.length; type++)</span>
            <span class="s5">0 </span><span class="s2">&lt; type &amp;&amp; (objKind += </span><span class="s3">&quot;, &quot;</span><span class="s2">),</span>
              <span class="s2">(i = objectOrArray[type]),</span>
              <span class="s2">(i =</span>
                <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">i &amp;&amp; </span><span class="s4">null </span><span class="s2">!== i</span>
                  <span class="s2">? describeObjectForErrorMessage(i)</span>
                  <span class="s2">: describeValueForErrorMessage(i)),</span>
              <span class="s3">&quot;&quot; </span><span class="s2">+ type === expandedName</span>
                <span class="s2">? ((start = objKind.length),</span>
                  <span class="s2">(length = i.length),</span>
                  <span class="s2">(objKind += i))</span>
                <span class="s2">: (objKind =</span>
                    <span class="s5">10 </span><span class="s2">&gt; i.length &amp;&amp; </span><span class="s5">40 </span><span class="s2">&gt; objKind.length + i.length</span>
                      <span class="s2">? objKind + i</span>
                      <span class="s2">: objKind + </span><span class="s3">&quot;...&quot;</span><span class="s2">);</span>
          <span class="s2">objKind += </span><span class="s3">&quot;]&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s4">else if </span><span class="s2">(objectOrArray.$$typeof === REACT_ELEMENT_TYPE)</span>
        <span class="s2">objKind = </span><span class="s3">&quot;&lt;&quot; </span><span class="s2">+ describeElementType(objectOrArray.type) + </span><span class="s3">&quot;/&gt;&quot;</span><span class="s2">;</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">(objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) </span><span class="s4">return </span><span class="s3">&quot;client&quot;</span><span class="s2">;</span>
        <span class="s4">if </span><span class="s2">(jsxPropsParents.has(objectOrArray)) {</span>
          <span class="s2">objKind = jsxPropsParents.get(objectOrArray);</span>
          <span class="s2">objKind = </span><span class="s3">&quot;&lt;&quot; </span><span class="s2">+ (describeElementType(objKind) || </span><span class="s3">&quot;...&quot;</span><span class="s2">);</span>
          <span class="s2">type = Object.keys(objectOrArray);</span>
          <span class="s4">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s2">; i &lt; type.length; i++) {</span>
            <span class="s2">objKind += </span><span class="s3">&quot; &quot;</span><span class="s2">;</span>
            <span class="s2">value = type[i];</span>
            <span class="s2">objKind += describeKeyForErrorMessage(value) + </span><span class="s3">&quot;=&quot;</span><span class="s2">;</span>
            <span class="s4">var </span><span class="s2">_value2 = objectOrArray[value];</span>
            <span class="s4">var </span><span class="s2">_substr2 =</span>
              <span class="s2">value === expandedName &amp;&amp;</span>
              <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">_value2 &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== _value2</span>
                <span class="s2">? describeObjectForErrorMessage(_value2)</span>
                <span class="s2">: describeValueForErrorMessage(_value2);</span>
            <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">_value2 &amp;&amp; (_substr2 = </span><span class="s3">&quot;{&quot; </span><span class="s2">+ _substr2 + </span><span class="s3">&quot;}&quot;</span><span class="s2">);</span>
            <span class="s2">value === expandedName</span>
              <span class="s2">? ((start = objKind.length),</span>
                <span class="s2">(length = _substr2.length),</span>
                <span class="s2">(objKind += _substr2))</span>
              <span class="s2">: (objKind =</span>
                  <span class="s5">10 </span><span class="s2">&gt; _substr2.length &amp;&amp; </span><span class="s5">40 </span><span class="s2">&gt; objKind.length + _substr2.length</span>
                    <span class="s2">? objKind + _substr2</span>
                    <span class="s2">: objKind + </span><span class="s3">&quot;...&quot;</span><span class="s2">);</span>
          <span class="s2">}</span>
          <span class="s2">objKind += </span><span class="s3">&quot;&gt;&quot;</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
          <span class="s2">objKind = </span><span class="s3">&quot;{&quot;</span><span class="s2">;</span>
          <span class="s2">type = Object.keys(objectOrArray);</span>
          <span class="s4">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s2">; i &lt; type.length; i++)</span>
            <span class="s5">0 </span><span class="s2">&lt; i &amp;&amp; (objKind += </span><span class="s3">&quot;, &quot;</span><span class="s2">),</span>
              <span class="s2">(value = type[i]),</span>
              <span class="s2">(objKind += describeKeyForErrorMessage(value) + </span><span class="s3">&quot;: &quot;</span><span class="s2">),</span>
              <span class="s2">(_value2 = objectOrArray[value]),</span>
              <span class="s2">(_value2 =</span>
                <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">_value2 &amp;&amp; </span><span class="s4">null </span><span class="s2">!== _value2</span>
                  <span class="s2">? describeObjectForErrorMessage(_value2)</span>
                  <span class="s2">: describeValueForErrorMessage(_value2)),</span>
              <span class="s2">value === expandedName</span>
                <span class="s2">? ((start = objKind.length),</span>
                  <span class="s2">(length = _value2.length),</span>
                  <span class="s2">(objKind += _value2))</span>
                <span class="s2">: (objKind =</span>
                    <span class="s5">10 </span><span class="s2">&gt; _value2.length &amp;&amp; </span><span class="s5">40 </span><span class="s2">&gt; objKind.length + _value2.length</span>
                      <span class="s2">? objKind + _value2</span>
                      <span class="s2">: objKind + </span><span class="s3">&quot;...&quot;</span><span class="s2">);</span>
          <span class="s2">objKind += </span><span class="s3">&quot;}&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">return void </span><span class="s5">0 </span><span class="s2">=== expandedName</span>
        <span class="s2">? objKind</span>
        <span class="s2">: -</span><span class="s5">1 </span><span class="s2">&lt; start &amp;&amp; </span><span class="s5">0 </span><span class="s2">&lt; length</span>
          <span class="s2">? ((objectOrArray = </span><span class="s3">&quot; &quot;</span><span class="s2">.repeat(start) + </span><span class="s3">&quot;^&quot;</span><span class="s2">.repeat(length)),</span>
            <span class="s3">&quot;</span><span class="s6">\n  </span><span class="s3">&quot; </span><span class="s2">+ objKind + </span><span class="s3">&quot;</span><span class="s6">\n  </span><span class="s3">&quot; </span><span class="s2">+ objectOrArray)</span>
          <span class="s2">: </span><span class="s3">&quot;</span><span class="s6">\n  </span><span class="s3">&quot; </span><span class="s2">+ objKind;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">defaultFilterStackFrame(filename) {</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s3">&quot;&quot; </span><span class="s2">!== filename &amp;&amp;</span>
        <span class="s2">!filename.startsWith(</span><span class="s3">&quot;node:&quot;</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">!filename.includes(</span><span class="s3">&quot;node_modules&quot;</span><span class="s2">)</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">filterStackTrace(request, stack) {</span>
      <span class="s2">request = request.filterStackFrame;</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">filteredStack = [], i = </span><span class="s5">0</span><span class="s2">; i &lt; stack.length; i++) {</span>
        <span class="s4">var </span><span class="s2">callsite = stack[i],</span>
          <span class="s2">functionName = callsite[</span><span class="s5">0</span><span class="s2">];</span>
        <span class="s4">var </span><span class="s2">url = callsite[</span><span class="s5">1</span><span class="s2">];</span>
        <span class="s4">if </span><span class="s2">(url.startsWith(</span><span class="s3">&quot;about://React/&quot;</span><span class="s2">)) {</span>
          <span class="s4">var </span><span class="s2">envIdx = url.indexOf(</span><span class="s3">&quot;/&quot;</span><span class="s2">, </span><span class="s5">14</span><span class="s2">),</span>
            <span class="s2">suffixIdx = url.lastIndexOf(</span><span class="s3">&quot;?&quot;</span><span class="s2">);</span>
          <span class="s2">-</span><span class="s5">1 </span><span class="s2">&lt; envIdx &amp;&amp;</span>
            <span class="s2">-</span><span class="s5">1 </span><span class="s2">&lt; suffixIdx &amp;&amp;</span>
            <span class="s2">(url = decodeURI(url.slice(envIdx + </span><span class="s5">1</span><span class="s2">, suffixIdx)));</span>
        <span class="s2">}</span>
        <span class="s2">request(url, functionName, callsite[</span><span class="s5">2</span><span class="s2">], callsite[</span><span class="s5">3</span><span class="s2">]) &amp;&amp;</span>
          <span class="s2">((callsite = callsite.slice(</span><span class="s5">0</span><span class="s2">)),</span>
          <span class="s2">(callsite[</span><span class="s5">1</span><span class="s2">] = url),</span>
          <span class="s2">filteredStack.push(callsite));</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">filteredStack;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">patchConsole(consoleInst, methodName) {</span>
      <span class="s4">var </span><span class="s2">descriptor = Object.getOwnPropertyDescriptor(consoleInst, methodName);</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s2">descriptor &amp;&amp;</span>
        <span class="s2">(descriptor.configurable || descriptor.writable) &amp;&amp;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">descriptor.value</span>
      <span class="s2">) {</span>
        <span class="s4">var </span><span class="s2">originalMethod = descriptor.value;</span>
        <span class="s2">descriptor = Object.getOwnPropertyDescriptor(originalMethod, </span><span class="s3">&quot;name&quot;</span><span class="s2">);</span>
        <span class="s4">var </span><span class="s2">wrapperMethod = </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">if </span><span class="s2">((</span><span class="s3">&quot;assert&quot; </span><span class="s2">!== methodName || !arguments[</span><span class="s5">0</span><span class="s2">]) &amp;&amp; </span><span class="s4">null </span><span class="s2">!== request) {</span>
            <span class="s2">a: {</span>
              <span class="s4">var </span><span class="s2">error = Error(</span><span class="s3">&quot;react-stack-top-frame&quot;</span><span class="s2">);</span>
              <span class="s2">collectedStackTrace = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s2">framesToSkip = </span><span class="s5">1</span><span class="s2">;</span>
              <span class="s4">var </span><span class="s2">previousPrepare = Error.prepareStackTrace;</span>
              <span class="s2">Error.prepareStackTrace = collectStackTracePrivate;</span>
              <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;&quot; </span><span class="s2">!== error.stack) {</span>
                  <span class="s4">var </span><span class="s2">JSCompiler_inline_result = </span><span class="s4">null</span><span class="s2">;</span>
                  <span class="s4">break </span><span class="s2">a;</span>
                <span class="s2">}</span>
              <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
                <span class="s2">Error.prepareStackTrace = previousPrepare;</span>
              <span class="s2">}</span>
              <span class="s2">JSCompiler_inline_result = collectedStackTrace;</span>
            <span class="s2">}</span>
            <span class="s2">JSCompiler_inline_result = filterStackTrace(</span>
              <span class="s2">request,</span>
              <span class="s2">JSCompiler_inline_result || []</span>
            <span class="s2">);</span>
            <span class="s2">request.pendingDebugChunks++;</span>
            <span class="s2">error = resolveOwner();</span>
            <span class="s2">previousPrepare = Array.from(arguments);</span>
            <span class="s2">a: {</span>
              <span class="s4">var </span><span class="s2">env = </span><span class="s5">0</span><span class="s2">;</span>
              <span class="s4">switch </span><span class="s2">(methodName) {</span>
                <span class="s4">case </span><span class="s3">&quot;dir&quot;</span><span class="s2">:</span>
                <span class="s4">case </span><span class="s3">&quot;dirxml&quot;</span><span class="s2">:</span>
                <span class="s4">case </span><span class="s3">&quot;groupEnd&quot;</span><span class="s2">:</span>
                <span class="s4">case </span><span class="s3">&quot;table&quot;</span><span class="s2">:</span>
                  <span class="s2">env = </span><span class="s4">null</span><span class="s2">;</span>
                  <span class="s4">break </span><span class="s2">a;</span>
                <span class="s4">case </span><span class="s3">&quot;assert&quot;</span><span class="s2">:</span>
                  <span class="s2">env = </span><span class="s5">1</span><span class="s2">;</span>
              <span class="s2">}</span>
              <span class="s4">var </span><span class="s2">format = previousPrepare[env],</span>
                <span class="s2">style = previousPrepare[env + </span><span class="s5">1</span><span class="s2">],</span>
                <span class="s2">badge = previousPrepare[env + </span><span class="s5">2</span><span class="s2">];</span>
              <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">format &amp;&amp;</span>
              <span class="s2">format.startsWith(</span><span class="s3">&quot;</span><span class="s6">\u001b</span><span class="s3">[0m</span><span class="s6">\u001b</span><span class="s3">[7m%c%s</span><span class="s6">\u001b</span><span class="s3">[0m%c&quot;</span><span class="s2">) &amp;&amp;</span>
              <span class="s3">&quot;background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px&quot; </span><span class="s2">===</span>
                <span class="s2">style &amp;&amp;</span>
              <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">badge</span>
                <span class="s2">? ((format = format.slice(</span><span class="s5">18</span><span class="s2">)),</span>
                  <span class="s3">&quot; &quot; </span><span class="s2">=== format[</span><span class="s5">0</span><span class="s2">] &amp;&amp; (format = format.slice(</span><span class="s5">1</span><span class="s2">)),</span>
                  <span class="s2">previousPrepare.splice(env, </span><span class="s5">4</span><span class="s2">, format),</span>
                  <span class="s2">(env = badge.slice(</span><span class="s5">1</span><span class="s2">, badge.length - </span><span class="s5">1</span><span class="s2">)))</span>
                <span class="s2">: (env = </span><span class="s4">null</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s4">null </span><span class="s2">=== env &amp;&amp; (env = (</span><span class="s5">0</span><span class="s2">, request.environmentName)());</span>
            <span class="s4">null </span><span class="s2">!= error &amp;&amp; outlineComponentInfo(request, error);</span>
            <span class="s2">badge = [methodName, JSCompiler_inline_result, error, env];</span>
            <span class="s2">badge.push.apply(badge, previousPrepare);</span>
            <span class="s2">previousPrepare = serializeDebugModel(</span>
              <span class="s2">request,</span>
              <span class="s2">(</span><span class="s4">null </span><span class="s2">=== request.deferredDebugObjects ? </span><span class="s5">500 </span><span class="s2">: </span><span class="s5">10</span><span class="s2">) +</span>
                <span class="s2">JSCompiler_inline_result.length,</span>
              <span class="s2">badge</span>
            <span class="s2">);</span>
            <span class="s3">&quot;[&quot; </span><span class="s2">!== previousPrepare[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
              <span class="s2">(previousPrepare = serializeDebugModel(</span>
                <span class="s2">request,</span>
                <span class="s5">10 </span><span class="s2">+ JSCompiler_inline_result.length,</span>
                <span class="s2">[</span>
                  <span class="s2">methodName,</span>
                  <span class="s2">JSCompiler_inline_result,</span>
                  <span class="s2">error,</span>
                  <span class="s2">env,</span>
                  <span class="s3">&quot;Unknown Value: React could not send it from the server.&quot;</span>
                <span class="s2">]</span>
              <span class="s2">));</span>
            <span class="s2">JSCompiler_inline_result = stringToChunk(</span>
              <span class="s3">&quot;:W&quot; </span><span class="s2">+ previousPrepare + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span>
            <span class="s2">);</span>
            <span class="s2">request.completedDebugChunks.push(JSCompiler_inline_result);</span>
          <span class="s2">}</span>
          <span class="s4">return </span><span class="s2">originalMethod.apply(</span><span class="s4">this</span><span class="s2">, arguments);</span>
        <span class="s2">};</span>
        <span class="s2">descriptor &amp;&amp; Object.defineProperty(wrapperMethod, </span><span class="s3">&quot;name&quot;</span><span class="s2">, descriptor);</span>
        <span class="s2">Object.defineProperty(consoleInst, methodName, {</span>
          <span class="s2">value: wrapperMethod</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">getCurrentStackInDEV() {</span>
      <span class="s4">var </span><span class="s2">owner = resolveOwner();</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== owner) </span><span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">info = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
        <span class="s4">if </span><span class="s2">(owner.owner || </span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">owner.name) {</span>
          <span class="s4">for </span><span class="s2">(; owner; ) {</span>
            <span class="s4">var </span><span class="s2">ownerStack = owner.debugStack;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= ownerStack) {</span>
              <span class="s4">if </span><span class="s2">((owner = owner.owner)) {</span>
                <span class="s4">var </span><span class="s2">JSCompiler_temp_const = info;</span>
                <span class="s4">var </span><span class="s2">error = ownerStack,</span>
                  <span class="s2">prevPrepareStackTrace = Error.prepareStackTrace;</span>
                <span class="s2">Error.prepareStackTrace = prepareStackTrace;</span>
                <span class="s4">var </span><span class="s2">stack = error.stack;</span>
                <span class="s2">Error.prepareStackTrace = prevPrepareStackTrace;</span>
                <span class="s2">stack.startsWith(</span><span class="s3">&quot;Error: react-stack-top-frame</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">) &amp;&amp;</span>
                  <span class="s2">(stack = stack.slice(</span><span class="s5">29</span><span class="s2">));</span>
                <span class="s4">var </span><span class="s2">idx = stack.indexOf(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">);</span>
                <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== idx &amp;&amp; (stack = stack.slice(idx + </span><span class="s5">1</span><span class="s2">));</span>
                <span class="s2">idx = stack.indexOf(</span><span class="s3">&quot;react_stack_bottom_frame&quot;</span><span class="s2">);</span>
                <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== idx &amp;&amp; (idx = stack.lastIndexOf(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">, idx));</span>
                <span class="s4">var </span><span class="s2">JSCompiler_inline_result =</span>
                  <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== idx ? (stack = stack.slice(</span><span class="s5">0</span><span class="s2">, idx)) : </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
                <span class="s2">info =</span>
                  <span class="s2">JSCompiler_temp_const + (</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+ JSCompiler_inline_result);</span>
              <span class="s2">}</span>
            <span class="s2">} </span><span class="s4">else break</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s4">var </span><span class="s2">JSCompiler_inline_result$jscomp$0 = info;</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
          <span class="s2">JSCompiler_temp_const = owner.name;</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== prefix)</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s4">throw </span><span class="s2">Error();</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
              <span class="s2">(prefix =</span>
                <span class="s2">((error = x.stack.trim().match(</span><span class="s7">/\n( *(at )?)/</span><span class="s2">)) &amp;&amp; error[</span><span class="s5">1</span><span class="s2">]) ||</span>
                <span class="s3">&quot;&quot;</span><span class="s2">),</span>
                <span class="s2">(suffix =</span>
                  <span class="s2">-</span><span class="s5">1 </span><span class="s2">&lt; x.stack.indexOf(</span><span class="s3">&quot;</span><span class="s6">\n    </span><span class="s3">at&quot;</span><span class="s2">)</span>
                    <span class="s2">? </span><span class="s3">&quot; (&lt;anonymous&gt;)&quot;</span>
                    <span class="s2">: -</span><span class="s5">1 </span><span class="s2">&lt; x.stack.indexOf(</span><span class="s3">&quot;@&quot;</span><span class="s2">)</span>
                      <span class="s2">? </span><span class="s3">&quot;@unknown:0:0&quot;</span>
                      <span class="s2">: </span><span class="s3">&quot;&quot;</span><span class="s2">);</span>
            <span class="s2">}</span>
          <span class="s2">JSCompiler_inline_result$jscomp$0 =</span>
            <span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+ prefix + JSCompiler_temp_const + suffix;</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
        <span class="s2">JSCompiler_inline_result$jscomp$0 =</span>
          <span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">Error generating stack: &quot; </span><span class="s2">+ x.message + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+ x.stack;</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">JSCompiler_inline_result$jscomp$0;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">throwTaintViolation(message) {</span>
      <span class="s4">throw </span><span class="s2">Error(message);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">cleanupTaintQueue(request) {</span>
      <span class="s2">request = request.taintCleanupQueue;</span>
      <span class="s2">TaintRegistryPendingRequests.delete(request);</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; request.length; i++) {</span>
        <span class="s4">var </span><span class="s2">entryValue = request[i],</span>
          <span class="s2">entry = TaintRegistryValues.get(entryValue);</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== entry &amp;&amp;</span>
          <span class="s2">(</span><span class="s5">1 </span><span class="s2">=== entry.count</span>
            <span class="s2">? TaintRegistryValues.delete(entryValue)</span>
            <span class="s2">: entry.count--);</span>
      <span class="s2">}</span>
      <span class="s2">request.length = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">defaultErrorHandler(error) {</span>
      <span class="s2">console.error(error);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">RequestInstance(</span>
      <span class="s2">type,</span>
      <span class="s2">model,</span>
      <span class="s2">bundlerConfig,</span>
      <span class="s2">onError,</span>
      <span class="s2">onPostpone,</span>
      <span class="s2">onAllReady,</span>
      <span class="s2">onFatalError,</span>
      <span class="s2">identifierPrefix,</span>
      <span class="s2">temporaryReferences,</span>
      <span class="s2">environmentName,</span>
      <span class="s2">filterStackFrame,</span>
      <span class="s2">keepDebugAlive</span>
    <span class="s2">) {</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">!== ReactSharedInternalsServer.A &amp;&amp;</span>
        <span class="s2">ReactSharedInternalsServer.A !== DefaultAsyncDispatcher</span>
      <span class="s2">)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;Currently React only supports one RSC renderer at a time.&quot;</span>
        <span class="s2">);</span>
      <span class="s2">ReactSharedInternalsServer.A = DefaultAsyncDispatcher;</span>
      <span class="s2">ReactSharedInternalsServer.getCurrentStack = getCurrentStackInDEV;</span>
      <span class="s4">var </span><span class="s2">abortSet = </span><span class="s4">new </span><span class="s2">Set(),</span>
        <span class="s2">pingedTasks = [],</span>
        <span class="s2">cleanupQueue = [];</span>
      <span class="s2">TaintRegistryPendingRequests.add(cleanupQueue);</span>
      <span class="s4">var </span><span class="s2">hints = </span><span class="s4">new </span><span class="s2">Set();</span>
      <span class="s4">this</span><span class="s2">.type = type;</span>
      <span class="s4">this</span><span class="s2">.status = </span><span class="s5">10</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.flushScheduled = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.destination = </span><span class="s4">this</span><span class="s2">.fatalError = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.bundlerConfig = bundlerConfig;</span>
      <span class="s4">this</span><span class="s2">.cache = </span><span class="s4">new </span><span class="s2">Map();</span>
      <span class="s4">this</span><span class="s2">.cacheController = </span><span class="s4">new </span><span class="s2">AbortController();</span>
      <span class="s4">this</span><span class="s2">.pendingChunks = </span><span class="s4">this</span><span class="s2">.nextChunkId = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.hints = hints;</span>
      <span class="s4">this</span><span class="s2">.abortableTasks = abortSet;</span>
      <span class="s4">this</span><span class="s2">.pingedTasks = pingedTasks;</span>
      <span class="s4">this</span><span class="s2">.completedImportChunks = [];</span>
      <span class="s4">this</span><span class="s2">.completedHintChunks = [];</span>
      <span class="s4">this</span><span class="s2">.completedRegularChunks = [];</span>
      <span class="s4">this</span><span class="s2">.completedErrorChunks = [];</span>
      <span class="s4">this</span><span class="s2">.writtenSymbols = </span><span class="s4">new </span><span class="s2">Map();</span>
      <span class="s4">this</span><span class="s2">.writtenClientReferences = </span><span class="s4">new </span><span class="s2">Map();</span>
      <span class="s4">this</span><span class="s2">.writtenServerReferences = </span><span class="s4">new </span><span class="s2">Map();</span>
      <span class="s4">this</span><span class="s2">.writtenObjects = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
      <span class="s4">this</span><span class="s2">.temporaryReferences = temporaryReferences;</span>
      <span class="s4">this</span><span class="s2">.identifierPrefix = identifierPrefix || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.identifierCount = </span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.taintCleanupQueue = cleanupQueue;</span>
      <span class="s4">this</span><span class="s2">.onError = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== onError ? defaultErrorHandler : onError;</span>
      <span class="s4">this</span><span class="s2">.onPostpone =</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== onPostpone ? defaultPostponeHandler : onPostpone;</span>
      <span class="s4">this</span><span class="s2">.onAllReady = onAllReady;</span>
      <span class="s4">this</span><span class="s2">.onFatalError = onFatalError;</span>
      <span class="s4">this</span><span class="s2">.pendingDebugChunks = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.completedDebugChunks = [];</span>
      <span class="s4">this</span><span class="s2">.debugDestination = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.environmentName =</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== environmentName</span>
          <span class="s2">? </span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">return </span><span class="s3">&quot;Server&quot;</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">: </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">environmentName</span>
            <span class="s2">? </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">environmentName;</span>
              <span class="s2">}</span>
            <span class="s2">: environmentName;</span>
      <span class="s4">this</span><span class="s2">.filterStackFrame =</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== filterStackFrame</span>
          <span class="s2">? defaultFilterStackFrame</span>
          <span class="s2">: filterStackFrame;</span>
      <span class="s4">this</span><span class="s2">.didWarnForKey = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">this</span><span class="s2">.writtenDebugObjects = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
      <span class="s4">this</span><span class="s2">.deferredDebugObjects = keepDebugAlive</span>
        <span class="s2">? { retained: </span><span class="s4">new </span><span class="s2">Map(), existing: </span><span class="s4">new </span><span class="s2">Map() }</span>
        <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">type = </span><span class="s4">this</span><span class="s2">.timeOrigin = performance.now();</span>
      <span class="s2">emitTimeOriginChunk(</span><span class="s4">this</span><span class="s2">, type + performance.timeOrigin);</span>
      <span class="s4">this</span><span class="s2">.abortTime = -</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">model = createTask(</span>
        <span class="s4">this</span><span class="s2">,</span>
        <span class="s2">model,</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">abortSet,</span>
        <span class="s2">type,</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
      <span class="s2">pingedTasks.push(model);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createRequest(</span>
      <span class="s2">model,</span>
      <span class="s2">bundlerConfig,</span>
      <span class="s2">onError,</span>
      <span class="s2">identifierPrefix,</span>
      <span class="s2">onPostpone,</span>
      <span class="s2">temporaryReferences,</span>
      <span class="s2">environmentName,</span>
      <span class="s2">filterStackFrame,</span>
      <span class="s2">keepDebugAlive</span>
    <span class="s2">) {</span>
      <span class="s2">resetOwnerStackLimit();</span>
      <span class="s4">return new </span><span class="s2">RequestInstance(</span>
        <span class="s5">20</span><span class="s2">,</span>
        <span class="s2">model,</span>
        <span class="s2">bundlerConfig,</span>
        <span class="s2">onError,</span>
        <span class="s2">onPostpone,</span>
        <span class="s2">noop,</span>
        <span class="s2">noop,</span>
        <span class="s2">identifierPrefix,</span>
        <span class="s2">temporaryReferences,</span>
        <span class="s2">environmentName,</span>
        <span class="s2">filterStackFrame,</span>
        <span class="s2">keepDebugAlive</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createPrerenderRequest(</span>
      <span class="s2">model,</span>
      <span class="s2">bundlerConfig,</span>
      <span class="s2">onAllReady,</span>
      <span class="s2">onFatalError,</span>
      <span class="s2">onError,</span>
      <span class="s2">identifierPrefix,</span>
      <span class="s2">onPostpone,</span>
      <span class="s2">temporaryReferences,</span>
      <span class="s2">environmentName,</span>
      <span class="s2">filterStackFrame,</span>
      <span class="s2">keepDebugAlive</span>
    <span class="s2">) {</span>
      <span class="s2">resetOwnerStackLimit();</span>
      <span class="s4">return new </span><span class="s2">RequestInstance(</span>
        <span class="s5">21</span><span class="s2">,</span>
        <span class="s2">model,</span>
        <span class="s2">bundlerConfig,</span>
        <span class="s2">onError,</span>
        <span class="s2">onPostpone,</span>
        <span class="s2">onAllReady,</span>
        <span class="s2">onFatalError,</span>
        <span class="s2">identifierPrefix,</span>
        <span class="s2">temporaryReferences,</span>
        <span class="s2">environmentName,</span>
        <span class="s2">filterStackFrame,</span>
        <span class="s2">keepDebugAlive</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">resolveRequest() {</span>
      <span class="s4">if </span><span class="s2">(currentRequest) </span><span class="s4">return </span><span class="s2">currentRequest;</span>
      <span class="s4">if </span><span class="s2">(supportsRequestStorage) {</span>
        <span class="s4">var </span><span class="s2">store = requestStorage.getStore();</span>
        <span class="s4">if </span><span class="s2">(store) </span><span class="s4">return </span><span class="s2">store;</span>
      <span class="s2">}</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeDebugThenable(request, counter, thenable) {</span>
      <span class="s2">request.pendingDebugChunks++;</span>
      <span class="s4">var </span><span class="s2">id = request.nextChunkId++,</span>
        <span class="s2">ref = </span><span class="s3">&quot;$@&quot; </span><span class="s2">+ id.toString(</span><span class="s5">16</span><span class="s2">);</span>
      <span class="s2">request.writtenDebugObjects.set(thenable, ref);</span>
      <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">emitOutlinedDebugModelChunk(request, id, counter, thenable.value),</span>
            <span class="s2">ref</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">emitErrorChunk(request, id, </span><span class="s3">&quot;&quot;</span><span class="s2">, thenable.reason, !</span><span class="s5">0</span><span class="s2">), ref;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(request.status === ABORTING)</span>
        <span class="s4">return </span><span class="s2">emitDebugHaltChunk(request, id), ref;</span>
      <span class="s4">var </span><span class="s2">deferredDebugObjects = request.deferredDebugObjects;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== deferredDebugObjects)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">deferredDebugObjects.retained.set(id, thenable),</span>
          <span class="s2">(ref = </span><span class="s3">&quot;$Y@&quot; </span><span class="s2">+ id.toString(</span><span class="s5">16</span><span class="s2">)),</span>
          <span class="s2">request.writtenDebugObjects.set(thenable, ref),</span>
          <span class="s2">ref</span>
        <span class="s2">);</span>
      <span class="s4">var </span><span class="s2">cancelled = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">thenable.then(</span>
        <span class="s4">function </span><span class="s2">(value) {</span>
          <span class="s2">cancelled ||</span>
            <span class="s2">((cancelled = !</span><span class="s5">0</span><span class="s2">),</span>
            <span class="s2">request.status === ABORTING</span>
              <span class="s2">? emitDebugHaltChunk(request, id)</span>
              <span class="s2">: emitOutlinedDebugModelChunk(request, id, counter, value),</span>
            <span class="s2">enqueueFlush(request));</span>
        <span class="s2">},</span>
        <span class="s4">function </span><span class="s2">(reason) {</span>
          <span class="s2">cancelled ||</span>
            <span class="s2">((cancelled = !</span><span class="s5">0</span><span class="s2">),</span>
            <span class="s2">request.status === ABORTING</span>
              <span class="s2">? emitDebugHaltChunk(request, id)</span>
              <span class="s2">: emitErrorChunk(request, id, </span><span class="s3">&quot;&quot;</span><span class="s2">, reason, !</span><span class="s5">0</span><span class="s2">),</span>
            <span class="s2">enqueueFlush(request));</span>
        <span class="s2">}</span>
      <span class="s2">);</span>
      <span class="s2">Promise.resolve().then(</span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s2">cancelled ||</span>
          <span class="s2">((cancelled = !</span><span class="s5">0</span><span class="s2">),</span>
          <span class="s2">emitDebugHaltChunk(request, id),</span>
          <span class="s2">enqueueFlush(request),</span>
          <span class="s2">(counter = request = </span><span class="s4">null</span><span class="s2">));</span>
      <span class="s2">});</span>
      <span class="s4">return </span><span class="s2">ref;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitRequestedDebugThenable(request, id, counter, thenable) {</span>
      <span class="s2">thenable.then(</span>
        <span class="s4">function </span><span class="s2">(value) {</span>
          <span class="s2">request.status === ABORTING</span>
            <span class="s2">? emitDebugHaltChunk(request, id)</span>
            <span class="s2">: emitOutlinedDebugModelChunk(request, id, counter, value);</span>
          <span class="s2">enqueueFlush(request);</span>
        <span class="s2">},</span>
        <span class="s4">function </span><span class="s2">(reason) {</span>
          <span class="s2">request.status === ABORTING</span>
            <span class="s2">? emitDebugHaltChunk(request, id)</span>
            <span class="s2">: emitErrorChunk(request, id, </span><span class="s3">&quot;&quot;</span><span class="s2">, reason, !</span><span class="s5">0</span><span class="s2">);</span>
          <span class="s2">enqueueFlush(request);</span>
        <span class="s2">}</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeThenable(request, task, thenable) {</span>
      <span class="s4">var </span><span class="s2">newTask = createTask(</span>
        <span class="s2">request,</span>
        <span class="s2">thenable,</span>
        <span class="s2">task.keyPath,</span>
        <span class="s2">task.implicitSlot,</span>
        <span class="s2">request.abortableTasks,</span>
        <span class="s2">task.time,</span>
        <span class="s2">task.debugOwner,</span>
        <span class="s2">task.debugStack,</span>
        <span class="s2">task.debugTask</span>
      <span class="s2">);</span>
      <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">forwardDebugInfoFromThenable(</span>
              <span class="s2">request,</span>
              <span class="s2">newTask,</span>
              <span class="s2">thenable,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s4">null</span>
            <span class="s2">),</span>
            <span class="s2">(newTask.model = thenable.value),</span>
            <span class="s2">pingTask(request, newTask),</span>
            <span class="s2">newTask.id</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">forwardDebugInfoFromThenable(</span>
              <span class="s2">request,</span>
              <span class="s2">newTask,</span>
              <span class="s2">thenable,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s4">null</span>
            <span class="s2">),</span>
            <span class="s2">erroredTask(request, newTask, thenable.reason),</span>
            <span class="s2">newTask.id</span>
          <span class="s2">);</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(request.status === ABORTING)</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">request.abortableTasks.delete(newTask),</span>
              <span class="s5">21 </span><span class="s2">=== request.type</span>
                <span class="s2">? (haltTask(newTask), finishHaltedTask(newTask, request))</span>
                <span class="s2">: ((task = request.fatalError),</span>
                  <span class="s2">abortTask(newTask),</span>
                  <span class="s2">finishAbortedTask(newTask, request, task)),</span>
              <span class="s2">newTask.id</span>
            <span class="s2">);</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">thenable.status &amp;&amp;</span>
            <span class="s2">((thenable.status = </span><span class="s3">&quot;pending&quot;</span><span class="s2">),</span>
            <span class="s2">thenable.then(</span>
              <span class="s4">function </span><span class="s2">(fulfilledValue) {</span>
                <span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status &amp;&amp;</span>
                  <span class="s2">((thenable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
                  <span class="s2">(thenable.value = fulfilledValue));</span>
              <span class="s2">},</span>
              <span class="s4">function </span><span class="s2">(error) {</span>
                <span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status &amp;&amp;</span>
                  <span class="s2">((thenable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">), (thenable.reason = error));</span>
              <span class="s2">}</span>
            <span class="s2">));</span>
      <span class="s2">}</span>
      <span class="s2">thenable.then(</span>
        <span class="s4">function </span><span class="s2">(value) {</span>
          <span class="s2">forwardDebugInfoFromCurrentContext(request, newTask, thenable);</span>
          <span class="s2">newTask.model = value;</span>
          <span class="s2">pingTask(request, newTask);</span>
        <span class="s2">},</span>
        <span class="s4">function </span><span class="s2">(reason) {</span>
          <span class="s5">0 </span><span class="s2">=== newTask.status &amp;&amp;</span>
            <span class="s2">((newTask.timed = !</span><span class="s5">0</span><span class="s2">),</span>
            <span class="s2">erroredTask(request, newTask, reason),</span>
            <span class="s2">enqueueFlush(request));</span>
        <span class="s2">}</span>
      <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">newTask.id;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeReadableStream(request, task, stream) {</span>
      <span class="s4">function </span><span class="s2">progress(entry) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== streamTask.status)</span>
          <span class="s4">if </span><span class="s2">(entry.done)</span>
            <span class="s2">(streamTask.status = </span><span class="s5">1</span><span class="s2">),</span>
              <span class="s2">(entry = streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:C</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
              <span class="s2">request.completedRegularChunks.push(stringToChunk(entry)),</span>
              <span class="s2">request.abortableTasks.delete(streamTask),</span>
              <span class="s2">request.cacheController.signal.removeEventListener(</span>
                <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
                <span class="s2">abortStream</span>
              <span class="s2">),</span>
              <span class="s2">enqueueFlush(request),</span>
              <span class="s2">callOnAllReadyIfReady(request);</span>
          <span class="s4">else</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s2">(streamTask.model = entry.value),</span>
                <span class="s2">request.pendingChunks++,</span>
                <span class="s2">tryStreamTask(request, streamTask),</span>
                <span class="s2">enqueueFlush(request),</span>
                <span class="s2">reader.read().then(progress, error);</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x$0) {</span>
              <span class="s2">error(x$0);</span>
            <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">error(reason) {</span>
        <span class="s5">0 </span><span class="s2">=== streamTask.status &amp;&amp;</span>
          <span class="s2">(request.cacheController.signal.removeEventListener(</span>
            <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
            <span class="s2">abortStream</span>
          <span class="s2">),</span>
          <span class="s2">erroredTask(request, streamTask, reason),</span>
          <span class="s2">enqueueFlush(request),</span>
          <span class="s2">reader.cancel(reason).then(error, error));</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">abortStream() {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== streamTask.status) {</span>
          <span class="s4">var </span><span class="s2">signal = request.cacheController.signal;</span>
          <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortStream);</span>
          <span class="s2">signal = signal.reason;</span>
          <span class="s5">21 </span><span class="s2">=== request.type</span>
            <span class="s2">? (request.abortableTasks.delete(streamTask),</span>
              <span class="s2">haltTask(streamTask),</span>
              <span class="s2">finishHaltedTask(streamTask, request))</span>
            <span class="s2">: (erroredTask(request, streamTask, signal), enqueueFlush(request));</span>
          <span class="s2">reader.cancel(signal).then(error, error);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">supportsBYOB = stream.supportsBYOB;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== supportsBYOB)</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">stream.getReader({ mode: </span><span class="s3">&quot;byob&quot; </span><span class="s2">}).releaseLock(), (supportsBYOB = !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
          <span class="s2">supportsBYOB = !</span><span class="s5">1</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">reader = stream.getReader(),</span>
        <span class="s2">streamTask = createTask(</span>
          <span class="s2">request,</span>
          <span class="s2">task.model,</span>
          <span class="s2">task.keyPath,</span>
          <span class="s2">task.implicitSlot,</span>
          <span class="s2">request.abortableTasks,</span>
          <span class="s2">task.time,</span>
          <span class="s2">task.debugOwner,</span>
          <span class="s2">task.debugStack,</span>
          <span class="s2">task.debugTask</span>
        <span class="s2">);</span>
      <span class="s2">request.pendingChunks++;</span>
      <span class="s2">task =</span>
        <span class="s2">streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ (supportsBYOB ? </span><span class="s3">&quot;r&quot; </span><span class="s2">: </span><span class="s3">&quot;R&quot;</span><span class="s2">) + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">request.completedRegularChunks.push(stringToChunk(task));</span>
      <span class="s2">request.cacheController.signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortStream);</span>
      <span class="s2">reader.read().then(progress, error);</span>
      <span class="s4">return </span><span class="s2">serializeByValueID(streamTask.id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeAsyncIterable(request, task, iterable, iterator) {</span>
      <span class="s4">function </span><span class="s2">progress(entry) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== streamTask.status)</span>
          <span class="s4">if </span><span class="s2">(entry.done) {</span>
            <span class="s2">streamTask.status = </span><span class="s5">1</span><span class="s2">;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== entry.value)</span>
              <span class="s4">var </span><span class="s2">endStreamRow = streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:C</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
            <span class="s4">else</span>
              <span class="s4">try </span><span class="s2">{</span>
                <span class="s4">var </span><span class="s2">chunkId = outlineModel(request, entry.value);</span>
                <span class="s2">endStreamRow =</span>
                  <span class="s2">streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) +</span>
                  <span class="s3">&quot;:C&quot; </span><span class="s2">+</span>
                  <span class="s2">stringify(serializeByValueID(chunkId)) +</span>
                  <span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
              <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
                <span class="s2">error(x);</span>
                <span class="s4">return</span><span class="s2">;</span>
              <span class="s2">}</span>
            <span class="s2">request.completedRegularChunks.push(stringToChunk(endStreamRow));</span>
            <span class="s2">request.abortableTasks.delete(streamTask);</span>
            <span class="s2">request.cacheController.signal.removeEventListener(</span>
              <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
              <span class="s2">abortIterable</span>
            <span class="s2">);</span>
            <span class="s2">enqueueFlush(request);</span>
            <span class="s2">callOnAllReadyIfReady(request);</span>
          <span class="s2">} </span><span class="s4">else</span>
            <span class="s4">try </span><span class="s2">{</span>
              <span class="s2">(streamTask.model = entry.value),</span>
                <span class="s2">request.pendingChunks++,</span>
                <span class="s2">tryStreamTask(request, streamTask),</span>
                <span class="s2">enqueueFlush(request),</span>
                <span class="s2">callIteratorInDEV(iterator, progress, error);</span>
            <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x$1) {</span>
              <span class="s2">error(x$1);</span>
            <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">error(reason) {</span>
        <span class="s5">0 </span><span class="s2">=== streamTask.status &amp;&amp;</span>
          <span class="s2">(request.cacheController.signal.removeEventListener(</span>
            <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
            <span class="s2">abortIterable</span>
          <span class="s2">),</span>
          <span class="s2">erroredTask(request, streamTask, reason),</span>
          <span class="s2">enqueueFlush(request),</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">iterator.throw &amp;&amp;</span>
            <span class="s2">iterator.throw(reason).then(error, error));</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">abortIterable() {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== streamTask.status) {</span>
          <span class="s4">var </span><span class="s2">signal = request.cacheController.signal;</span>
          <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortIterable);</span>
          <span class="s4">var </span><span class="s2">reason = signal.reason;</span>
          <span class="s5">21 </span><span class="s2">=== request.type</span>
            <span class="s2">? (request.abortableTasks.delete(streamTask),</span>
              <span class="s2">haltTask(streamTask),</span>
              <span class="s2">finishHaltedTask(streamTask, request))</span>
            <span class="s2">: (erroredTask(request, streamTask, signal.reason),</span>
              <span class="s2">enqueueFlush(request));</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">iterator.throw &amp;&amp;</span>
            <span class="s2">iterator.throw(reason).then(error, error);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">isIterator = iterable === iterator,</span>
        <span class="s2">streamTask = createTask(</span>
          <span class="s2">request,</span>
          <span class="s2">task.model,</span>
          <span class="s2">task.keyPath,</span>
          <span class="s2">task.implicitSlot,</span>
          <span class="s2">request.abortableTasks,</span>
          <span class="s2">task.time,</span>
          <span class="s2">task.debugOwner,</span>
          <span class="s2">task.debugStack,</span>
          <span class="s2">task.debugTask</span>
        <span class="s2">);</span>
      <span class="s2">(task = iterable._debugInfo) &amp;&amp;</span>
        <span class="s2">forwardDebugInfo(request, streamTask, task);</span>
      <span class="s2">request.pendingChunks++;</span>
      <span class="s2">isIterator =</span>
        <span class="s2">streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ (isIterator ? </span><span class="s3">&quot;x&quot; </span><span class="s2">: </span><span class="s3">&quot;X&quot;</span><span class="s2">) + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">request.completedRegularChunks.push(stringToChunk(isIterator));</span>
      <span class="s2">request.cacheController.signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortIterable);</span>
      <span class="s2">callIteratorInDEV(iterator, progress, error);</span>
      <span class="s4">return </span><span class="s2">serializeByValueID(streamTask.id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitHint(request, code, model) {</span>
      <span class="s2">model = stringify(model);</span>
      <span class="s2">code = stringToChunk(</span><span class="s3">&quot;:H&quot; </span><span class="s2">+ code + model + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">);</span>
      <span class="s2">request.completedHintChunks.push(code);</span>
      <span class="s2">enqueueFlush(request);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">readThenable(thenable) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== thenable.status) </span><span class="s4">return </span><span class="s2">thenable.value;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;rejected&quot; </span><span class="s2">=== thenable.status) </span><span class="s4">throw </span><span class="s2">thenable.reason;</span>
      <span class="s4">throw </span><span class="s2">thenable;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createLazyWrapperAroundWakeable(request, task, wakeable) {</span>
      <span class="s4">switch </span><span class="s2">(wakeable.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">forwardDebugInfoFromThenable(request, task, wakeable, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">wakeable.value</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
          <span class="s2">forwardDebugInfoFromThenable(request, task, wakeable, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">wakeable.status &amp;&amp;</span>
            <span class="s2">((wakeable.status = </span><span class="s3">&quot;pending&quot;</span><span class="s2">),</span>
            <span class="s2">wakeable.then(</span>
              <span class="s4">function </span><span class="s2">(fulfilledValue) {</span>
                <span class="s2">forwardDebugInfoFromCurrentContext(request, task, wakeable);</span>
                <span class="s3">&quot;pending&quot; </span><span class="s2">=== wakeable.status &amp;&amp;</span>
                  <span class="s2">((wakeable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
                  <span class="s2">(wakeable.value = fulfilledValue));</span>
              <span class="s2">},</span>
              <span class="s4">function </span><span class="s2">(error) {</span>
                <span class="s2">forwardDebugInfoFromCurrentContext(request, task, wakeable);</span>
                <span class="s3">&quot;pending&quot; </span><span class="s2">=== wakeable.status &amp;&amp;</span>
                  <span class="s2">((wakeable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">), (wakeable.reason = error));</span>
              <span class="s2">}</span>
            <span class="s2">));</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">{</span>
        <span class="s2">$$typeof: REACT_LAZY_TYPE,</span>
        <span class="s2">_payload: wakeable,</span>
        <span class="s2">_init: readThenable</span>
      <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">callWithDebugContextInDEV(request, task, callback, arg) {</span>
      <span class="s4">var </span><span class="s2">componentDebugInfo = {</span>
        <span class="s2">name: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s2">env: task.environmentName,</span>
        <span class="s2">key: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">owner: task.debugOwner</span>
      <span class="s2">};</span>
      <span class="s2">componentDebugInfo.stack =</span>
        <span class="s4">null </span><span class="s2">=== task.debugStack</span>
          <span class="s2">? </span><span class="s4">null</span>
          <span class="s2">: filterStackTrace(request, parseStackTrace(task.debugStack, </span><span class="s5">1</span><span class="s2">));</span>
      <span class="s2">componentDebugInfo.debugStack = task.debugStack;</span>
      <span class="s2">request = componentDebugInfo.debugTask = task.debugTask;</span>
      <span class="s2">currentOwner = componentDebugInfo;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">return </span><span class="s2">request ? request.run(callback.bind(</span><span class="s4">null</span><span class="s2">, arg)) : callback(arg);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">currentOwner = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">processServerComponentReturnValue(</span>
      <span class="s2">request,</span>
      <span class="s2">task,</span>
      <span class="s2">Component,</span>
      <span class="s2">result</span>
    <span class="s2">) {</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">result ||</span>
        <span class="s4">null </span><span class="s2">=== result ||</span>
        <span class="s2">isClientReference(result)</span>
      <span class="s2">)</span>
        <span class="s4">return </span><span class="s2">result;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">result.then)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">result.then(</span><span class="s4">function </span><span class="s2">(resolvedValue) {</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">resolvedValue &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== resolvedValue &amp;&amp;</span>
              <span class="s2">resolvedValue.$$typeof === REACT_ELEMENT_TYPE &amp;&amp;</span>
              <span class="s2">(resolvedValue._store.validated = </span><span class="s5">1</span><span class="s2">);</span>
          <span class="s2">}, voidHandler),</span>
          <span class="s2">createLazyWrapperAroundWakeable(request, task, result)</span>
        <span class="s2">);</span>
      <span class="s2">result.$$typeof === REACT_ELEMENT_TYPE &amp;&amp; (result._store.validated = </span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">var </span><span class="s2">iteratorFn = getIteratorFn(result);</span>
      <span class="s4">if </span><span class="s2">(iteratorFn) {</span>
        <span class="s4">var </span><span class="s2">multiShot = _defineProperty({}, Symbol.iterator, </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">var </span><span class="s2">iterator = iteratorFn.call(result);</span>
          <span class="s2">iterator !== result ||</span>
            <span class="s2">(</span><span class="s3">&quot;[object GeneratorFunction]&quot; </span><span class="s2">===</span>
              <span class="s2">Object.prototype.toString.call(Component) &amp;&amp;</span>
              <span class="s3">&quot;[object Generator]&quot; </span><span class="s2">===</span>
                <span class="s2">Object.prototype.toString.call(result)) ||</span>
            <span class="s2">callWithDebugContextInDEV(request, task, </span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s2">console.error(</span>
                <span class="s3">&quot;Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. &quot;</span>
              <span class="s2">);</span>
            <span class="s2">});</span>
          <span class="s4">return </span><span class="s2">iterator;</span>
        <span class="s2">});</span>
        <span class="s2">multiShot._debugInfo = result._debugInfo;</span>
        <span class="s4">return </span><span class="s2">multiShot;</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">result[ASYNC_ITERATOR] ||</span>
        <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">ReadableStream &amp;&amp;</span>
          <span class="s2">result </span><span class="s4">instanceof </span><span class="s2">ReadableStream)</span>
        <span class="s2">? result</span>
        <span class="s2">: ((multiShot = _defineProperty({}, ASYNC_ITERATOR, </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">var </span><span class="s2">iterator = result[ASYNC_ITERATOR]();</span>
            <span class="s2">iterator !== result ||</span>
              <span class="s2">(</span><span class="s3">&quot;[object AsyncGeneratorFunction]&quot; </span><span class="s2">===</span>
                <span class="s2">Object.prototype.toString.call(Component) &amp;&amp;</span>
                <span class="s3">&quot;[object AsyncGenerator]&quot; </span><span class="s2">===</span>
                  <span class="s2">Object.prototype.toString.call(result)) ||</span>
              <span class="s2">callWithDebugContextInDEV(request, task, </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s2">console.error(</span>
                  <span class="s3">&quot;Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. &quot;</span>
                <span class="s2">);</span>
              <span class="s2">});</span>
            <span class="s4">return </span><span class="s2">iterator;</span>
          <span class="s2">})),</span>
          <span class="s2">(multiShot._debugInfo = result._debugInfo),</span>
          <span class="s2">multiShot);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">renderFunctionComponent(</span>
      <span class="s2">request,</span>
      <span class="s2">task,</span>
      <span class="s2">key,</span>
      <span class="s2">Component,</span>
      <span class="s2">props,</span>
      <span class="s2">validated</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">prevThenableState = task.thenableState;</span>
      <span class="s2">task.thenableState = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(canEmitDebugInfo)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== prevThenableState)</span>
          <span class="s4">var </span><span class="s2">componentDebugInfo = prevThenableState._componentDebugInfo;</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">componentDebugID = task.id;</span>
          <span class="s2">componentDebugInfo = Component.displayName || Component.name || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">componentEnv = (</span><span class="s5">0</span><span class="s2">, request.environmentName)();</span>
          <span class="s2">request.pendingChunks++;</span>
          <span class="s2">componentDebugInfo = {</span>
            <span class="s2">name: componentDebugInfo,</span>
            <span class="s2">env: componentEnv,</span>
            <span class="s2">key: key,</span>
            <span class="s2">owner: task.debugOwner</span>
          <span class="s2">};</span>
          <span class="s2">componentDebugInfo.stack =</span>
            <span class="s4">null </span><span class="s2">=== task.debugStack</span>
              <span class="s2">? </span><span class="s4">null</span>
              <span class="s2">: filterStackTrace(request, parseStackTrace(task.debugStack, </span><span class="s5">1</span><span class="s2">));</span>
          <span class="s2">componentDebugInfo.props = props;</span>
          <span class="s2">componentDebugInfo.debugStack = task.debugStack;</span>
          <span class="s2">componentDebugInfo.debugTask = task.debugTask;</span>
          <span class="s2">outlineComponentInfo(request, componentDebugInfo);</span>
          <span class="s4">var </span><span class="s2">timestamp = performance.now();</span>
          <span class="s2">timestamp &gt; task.time</span>
            <span class="s2">? (emitTimingChunk(request, task.id, timestamp),</span>
              <span class="s2">(task.time = timestamp))</span>
            <span class="s2">: task.timed || emitTimingChunk(request, task.id, task.time);</span>
          <span class="s2">task.timed = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">emitDebugChunk(request, componentDebugID, componentDebugInfo);</span>
          <span class="s2">task.environmentName = componentEnv;</span>
          <span class="s5">2 </span><span class="s2">=== validated &amp;&amp;</span>
            <span class="s2">warnForMissingKey(request, key, componentDebugInfo, task.debugTask);</span>
        <span class="s2">}</span>
      <span class="s4">else return </span><span class="s2">outlineTask(request, task);</span>
      <span class="s2">thenableIndexCounter = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">thenableState = prevThenableState;</span>
      <span class="s2">currentComponentDebugInfo = componentDebugInfo;</span>
      <span class="s2">props = supportsComponentStorage</span>
        <span class="s2">? task.debugTask</span>
          <span class="s2">? task.debugTask.run(</span>
              <span class="s2">componentStorage.run.bind(</span>
                <span class="s2">componentStorage,</span>
                <span class="s2">componentDebugInfo,</span>
                <span class="s2">callComponentInDEV,</span>
                <span class="s2">Component,</span>
                <span class="s2">props,</span>
                <span class="s2">componentDebugInfo</span>
              <span class="s2">)</span>
            <span class="s2">)</span>
          <span class="s2">: componentStorage.run(</span>
              <span class="s2">componentDebugInfo,</span>
              <span class="s2">callComponentInDEV,</span>
              <span class="s2">Component,</span>
              <span class="s2">props,</span>
              <span class="s2">componentDebugInfo</span>
            <span class="s2">)</span>
        <span class="s2">: task.debugTask</span>
          <span class="s2">? task.debugTask.run(</span>
              <span class="s2">callComponentInDEV.bind(</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">Component,</span>
                <span class="s2">props,</span>
                <span class="s2">componentDebugInfo</span>
              <span class="s2">)</span>
            <span class="s2">)</span>
          <span class="s2">: callComponentInDEV(Component, props, componentDebugInfo);</span>
      <span class="s4">if </span><span class="s2">(request.status === ABORTING)</span>
        <span class="s4">throw </span><span class="s2">(</span>
          <span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props ||</span>
            <span class="s4">null </span><span class="s2">=== props ||</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">props.then ||</span>
            <span class="s2">isClientReference(props) ||</span>
            <span class="s2">props.then(voidHandler, voidHandler),</span>
          <span class="s4">null</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s2">validated = thenableState;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== validated)</span>
        <span class="s4">for </span><span class="s2">(</span>
          <span class="s2">prevThenableState = validated._stacks || (validated._stacks = []),</span>
            <span class="s2">componentDebugID = </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">componentDebugID &lt; validated.length;</span>
          <span class="s2">componentDebugID++</span>
        <span class="s2">)</span>
          <span class="s2">forwardDebugInfoFromThenable(</span>
            <span class="s2">request,</span>
            <span class="s2">task,</span>
            <span class="s2">validated[componentDebugID],</span>
            <span class="s2">componentDebugInfo,</span>
            <span class="s2">prevThenableState[componentDebugID]</span>
          <span class="s2">);</span>
      <span class="s2">props = processServerComponentReturnValue(</span>
        <span class="s2">request,</span>
        <span class="s2">task,</span>
        <span class="s2">Component,</span>
        <span class="s2">props</span>
      <span class="s2">);</span>
      <span class="s2">task.debugOwner = componentDebugInfo;</span>
      <span class="s2">task.debugStack = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">task.debugTask = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">Component = task.keyPath;</span>
      <span class="s2">componentDebugInfo = task.implicitSlot;</span>
      <span class="s4">null </span><span class="s2">!== key</span>
        <span class="s2">? (task.keyPath = </span><span class="s4">null </span><span class="s2">=== Component ? key : Component + </span><span class="s3">&quot;,&quot; </span><span class="s2">+ key)</span>
        <span class="s2">: </span><span class="s4">null </span><span class="s2">=== Component &amp;&amp; (task.implicitSlot = !</span><span class="s5">0</span><span class="s2">);</span>
      <span class="s2">request = renderModelDestructive(request, task, emptyRoot, </span><span class="s3">&quot;&quot;</span><span class="s2">, props);</span>
      <span class="s2">task.keyPath = Component;</span>
      <span class="s2">task.implicitSlot = componentDebugInfo;</span>
      <span class="s4">return </span><span class="s2">request;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">warnForMissingKey(request, key, componentDebugInfo, debugTask) {</span>
      <span class="s4">function </span><span class="s2">logKeyError() {</span>
        <span class="s2">console.error(</span>
          <span class="s3">'Each child in a list should have a unique &quot;key&quot; prop.%s%s See https://react.dev/link/warning-keys for more information.'</span><span class="s2">,</span>
          <span class="s3">&quot;&quot;</span><span class="s2">,</span>
          <span class="s3">&quot;&quot;</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s2">key = request.didWarnForKey;</span>
      <span class="s4">null </span><span class="s2">== key &amp;&amp; (key = request.didWarnForKey = </span><span class="s4">new </span><span class="s2">WeakSet());</span>
      <span class="s2">request = componentDebugInfo.owner;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= request) {</span>
        <span class="s4">if </span><span class="s2">(key.has(request)) </span><span class="s4">return</span><span class="s2">;</span>
        <span class="s2">key.add(request);</span>
      <span class="s2">}</span>
      <span class="s2">supportsComponentStorage</span>
        <span class="s2">? debugTask</span>
          <span class="s2">? debugTask.run(</span>
              <span class="s2">componentStorage.run.bind(</span>
                <span class="s2">componentStorage,</span>
                <span class="s2">componentDebugInfo,</span>
                <span class="s2">callComponentInDEV,</span>
                <span class="s2">logKeyError,</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">componentDebugInfo</span>
              <span class="s2">)</span>
            <span class="s2">)</span>
          <span class="s2">: componentStorage.run(</span>
              <span class="s2">componentDebugInfo,</span>
              <span class="s2">callComponentInDEV,</span>
              <span class="s2">logKeyError,</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">componentDebugInfo</span>
            <span class="s2">)</span>
        <span class="s2">: debugTask</span>
          <span class="s2">? debugTask.run(</span>
              <span class="s2">callComponentInDEV.bind(</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">logKeyError,</span>
                <span class="s4">null</span><span class="s2">,</span>
                <span class="s2">componentDebugInfo</span>
              <span class="s2">)</span>
            <span class="s2">)</span>
          <span class="s2">: callComponentInDEV(logKeyError, </span><span class="s4">null</span><span class="s2">, componentDebugInfo);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">renderFragment(request, task, children) {</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; children.length; i++) {</span>
        <span class="s4">var </span><span class="s2">child = children[i];</span>
        <span class="s4">null </span><span class="s2">=== child ||</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">child ||</span>
          <span class="s2">child.$$typeof !== REACT_ELEMENT_TYPE ||</span>
          <span class="s4">null </span><span class="s2">!== child.key ||</span>
          <span class="s2">child._store.validated ||</span>
          <span class="s2">(child._store.validated = </span><span class="s5">2</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== task.keyPath)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(request = [</span>
            <span class="s2">REACT_ELEMENT_TYPE,</span>
            <span class="s2">REACT_FRAGMENT_TYPE,</span>
            <span class="s2">task.keyPath,</span>
            <span class="s2">{ children: children },</span>
            <span class="s4">null</span><span class="s2">,</span>
            <span class="s4">null</span><span class="s2">,</span>
            <span class="s5">0</span>
          <span class="s2">]),</span>
          <span class="s2">task.implicitSlot ? [request] : request</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">((i = children._debugInfo)) {</span>
        <span class="s4">if </span><span class="s2">(canEmitDebugInfo) forwardDebugInfo(request, task, i);</span>
        <span class="s4">else return </span><span class="s2">outlineTask(request, task);</span>
        <span class="s2">children = Array.from(children);</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">children;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">renderAsyncFragment(request, task, children, getAsyncIterator) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== task.keyPath)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(request = [</span>
            <span class="s2">REACT_ELEMENT_TYPE,</span>
            <span class="s2">REACT_FRAGMENT_TYPE,</span>
            <span class="s2">task.keyPath,</span>
            <span class="s2">{ children: children },</span>
            <span class="s4">null</span><span class="s2">,</span>
            <span class="s4">null</span><span class="s2">,</span>
            <span class="s5">0</span>
          <span class="s2">]),</span>
          <span class="s2">task.implicitSlot ? [request] : request</span>
        <span class="s2">);</span>
      <span class="s2">getAsyncIterator = getAsyncIterator.call(children);</span>
      <span class="s4">return </span><span class="s2">serializeAsyncIterable(request, task, children, getAsyncIterator);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">deferTask(request, task) {</span>
      <span class="s2">task = createTask(</span>
        <span class="s2">request,</span>
        <span class="s2">task.model,</span>
        <span class="s2">task.keyPath,</span>
        <span class="s2">task.implicitSlot,</span>
        <span class="s2">request.abortableTasks,</span>
        <span class="s2">task.time,</span>
        <span class="s2">task.debugOwner,</span>
        <span class="s2">task.debugStack,</span>
        <span class="s2">task.debugTask</span>
      <span class="s2">);</span>
      <span class="s2">pingTask(request, task);</span>
      <span class="s4">return </span><span class="s2">serializeLazyID(task.id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">outlineTask(request, task) {</span>
      <span class="s2">task = createTask(</span>
        <span class="s2">request,</span>
        <span class="s2">task.model,</span>
        <span class="s2">task.keyPath,</span>
        <span class="s2">task.implicitSlot,</span>
        <span class="s2">request.abortableTasks,</span>
        <span class="s2">task.time,</span>
        <span class="s2">task.debugOwner,</span>
        <span class="s2">task.debugStack,</span>
        <span class="s2">task.debugTask</span>
      <span class="s2">);</span>
      <span class="s2">retryTask(request, task);</span>
      <span class="s4">return </span><span class="s5">1 </span><span class="s2">=== task.status</span>
        <span class="s2">? serializeByValueID(task.id)</span>
        <span class="s2">: serializeLazyID(task.id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">renderElement(request, task, type, key, ref, props, validated) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== ref &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== ref)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;Refs cannot be used in Server Components, nor passed to Client Components.&quot;</span>
        <span class="s2">);</span>
      <span class="s2">jsxPropsParents.set(props, type);</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props.children &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== props.children &amp;&amp;</span>
        <span class="s2">jsxChildrenParents.set(props.children, type);</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">type ||</span>
        <span class="s2">isClientReference(type) ||</span>
        <span class="s2">type.$$typeof === TEMPORARY_REFERENCE_TAG</span>
      <span class="s2">) {</span>
        <span class="s4">if </span><span class="s2">(type === REACT_FRAGMENT_TYPE &amp;&amp; </span><span class="s4">null </span><span class="s2">=== key)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s5">2 </span><span class="s2">=== validated &amp;&amp;</span>
              <span class="s2">((validated = {</span>
                <span class="s2">name: </span><span class="s3">&quot;Fragment&quot;</span><span class="s2">,</span>
                <span class="s2">env: (</span><span class="s5">0</span><span class="s2">, request.environmentName)(),</span>
                <span class="s2">key: key,</span>
                <span class="s2">owner: task.debugOwner,</span>
                <span class="s2">stack:</span>
                  <span class="s4">null </span><span class="s2">=== task.debugStack</span>
                    <span class="s2">? </span><span class="s4">null</span>
                    <span class="s2">: filterStackTrace(</span>
                        <span class="s2">request,</span>
                        <span class="s2">parseStackTrace(task.debugStack, </span><span class="s5">1</span><span class="s2">)</span>
                      <span class="s2">),</span>
                <span class="s2">props: props,</span>
                <span class="s2">debugStack: task.debugStack,</span>
                <span class="s2">debugTask: task.debugTask</span>
              <span class="s2">}),</span>
              <span class="s2">warnForMissingKey(request, key, validated, task.debugTask)),</span>
            <span class="s2">(validated = task.implicitSlot),</span>
            <span class="s4">null </span><span class="s2">=== task.keyPath &amp;&amp; (task.implicitSlot = !</span><span class="s5">0</span><span class="s2">),</span>
            <span class="s2">(request = renderModelDestructive(</span>
              <span class="s2">request,</span>
              <span class="s2">task,</span>
              <span class="s2">emptyRoot,</span>
              <span class="s3">&quot;&quot;</span><span class="s2">,</span>
              <span class="s2">props.children</span>
            <span class="s2">)),</span>
            <span class="s2">(task.implicitSlot = validated),</span>
            <span class="s2">request</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s4">null </span><span class="s2">!= type &amp;&amp;</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
          <span class="s2">!isClientReference(type)</span>
        <span class="s2">)</span>
          <span class="s4">switch </span><span class="s2">(type.$$typeof) {</span>
            <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
              <span class="s2">type = callLazyInitInDEV(type);</span>
              <span class="s4">if </span><span class="s2">(request.status === ABORTING) </span><span class="s4">throw null</span><span class="s2">;</span>
              <span class="s4">return </span><span class="s2">renderElement(</span>
                <span class="s2">request,</span>
                <span class="s2">task,</span>
                <span class="s2">type,</span>
                <span class="s2">key,</span>
                <span class="s2">ref,</span>
                <span class="s2">props,</span>
                <span class="s2">validated</span>
              <span class="s2">);</span>
            <span class="s4">case </span><span class="s2">REACT_FORWARD_REF_TYPE:</span>
              <span class="s4">return </span><span class="s2">renderFunctionComponent(</span>
                <span class="s2">request,</span>
                <span class="s2">task,</span>
                <span class="s2">key,</span>
                <span class="s2">type.render,</span>
                <span class="s2">props,</span>
                <span class="s2">validated</span>
              <span class="s2">);</span>
            <span class="s4">case </span><span class="s2">REACT_MEMO_TYPE:</span>
              <span class="s4">return </span><span class="s2">renderElement(</span>
                <span class="s2">request,</span>
                <span class="s2">task,</span>
                <span class="s2">type.type,</span>
                <span class="s2">key,</span>
                <span class="s2">ref,</span>
                <span class="s2">props,</span>
                <span class="s2">validated</span>
              <span class="s2">);</span>
            <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
              <span class="s2">type._store.validated = </span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s4">return </span><span class="s2">renderFunctionComponent(</span>
          <span class="s2">request,</span>
          <span class="s2">task,</span>
          <span class="s2">key,</span>
          <span class="s2">type,</span>
          <span class="s2">props,</span>
          <span class="s2">validated</span>
        <span class="s2">);</span>
      <span class="s2">ref = task.keyPath;</span>
      <span class="s4">null </span><span class="s2">=== key ? (key = ref) : </span><span class="s4">null </span><span class="s2">!== ref &amp;&amp; (key = ref + </span><span class="s3">&quot;,&quot; </span><span class="s2">+ key);</span>
      <span class="s4">var </span><span class="s2">debugStack = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">ref = task.debugOwner;</span>
      <span class="s4">null </span><span class="s2">!== ref &amp;&amp; outlineComponentInfo(request, ref);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== task.debugStack) {</span>
        <span class="s2">debugStack = filterStackTrace(</span>
          <span class="s2">request,</span>
          <span class="s2">parseStackTrace(task.debugStack, </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">);</span>
        <span class="s4">var </span><span class="s2">id = outlineDebugModel(</span>
          <span class="s2">request,</span>
          <span class="s2">{ objectLimit: </span><span class="s5">2 </span><span class="s2">* debugStack.length + </span><span class="s5">1 </span><span class="s2">},</span>
          <span class="s2">debugStack</span>
        <span class="s2">);</span>
        <span class="s2">request.writtenObjects.set(debugStack, serializeByValueID(id));</span>
      <span class="s2">}</span>
      <span class="s2">request = [</span>
        <span class="s2">REACT_ELEMENT_TYPE,</span>
        <span class="s2">type,</span>
        <span class="s2">key,</span>
        <span class="s2">props,</span>
        <span class="s2">ref,</span>
        <span class="s2">debugStack,</span>
        <span class="s2">validated</span>
      <span class="s2">];</span>
      <span class="s2">task = task.implicitSlot &amp;&amp; </span><span class="s4">null </span><span class="s2">!== key ? [request] : request;</span>
      <span class="s4">return </span><span class="s2">task;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">pingTask(request, task) {</span>
      <span class="s2">task.timed = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">pingedTasks = request.pingedTasks;</span>
      <span class="s2">pingedTasks.push(task);</span>
      <span class="s5">1 </span><span class="s2">=== pingedTasks.length &amp;&amp;</span>
        <span class="s2">((request.flushScheduled = </span><span class="s4">null </span><span class="s2">!== request.destination),</span>
        <span class="s5">21 </span><span class="s2">=== request.type || </span><span class="s5">10 </span><span class="s2">=== request.status</span>
          <span class="s2">? scheduleMicrotask(</span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">return </span><span class="s2">performWork(request);</span>
            <span class="s2">})</span>
          <span class="s2">: setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">return </span><span class="s2">performWork(request);</span>
            <span class="s2">}, </span><span class="s5">0</span><span class="s2">));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createTask(</span>
      <span class="s2">request,</span>
      <span class="s2">model,</span>
      <span class="s2">keyPath,</span>
      <span class="s2">implicitSlot,</span>
      <span class="s2">abortSet,</span>
      <span class="s2">lastTimestamp,</span>
      <span class="s2">debugOwner,</span>
      <span class="s2">debugStack,</span>
      <span class="s2">debugTask</span>
    <span class="s2">) {</span>
      <span class="s2">request.pendingChunks++;</span>
      <span class="s4">var </span><span class="s2">id = request.nextChunkId++;</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">model ||</span>
        <span class="s4">null </span><span class="s2">=== model ||</span>
        <span class="s4">null </span><span class="s2">!== keyPath ||</span>
        <span class="s2">implicitSlot ||</span>
        <span class="s2">request.writtenObjects.set(model, serializeByValueID(id));</span>
      <span class="s4">var </span><span class="s2">task = {</span>
        <span class="s2">id: id,</span>
        <span class="s2">status: </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">model: model,</span>
        <span class="s2">keyPath: keyPath,</span>
        <span class="s2">implicitSlot: implicitSlot,</span>
        <span class="s2">ping: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">pingTask(request, task);</span>
        <span class="s2">},</span>
        <span class="s2">toJSON: </span><span class="s4">function </span><span class="s2">(parentPropertyName, value) {</span>
          <span class="s4">var </span><span class="s2">parent = </span><span class="s4">this</span><span class="s2">,</span>
            <span class="s2">originalValue = parent[parentPropertyName];</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">originalValue ||</span>
            <span class="s2">originalValue === value ||</span>
            <span class="s2">originalValue </span><span class="s4">instanceof </span><span class="s2">Date ||</span>
            <span class="s2">callWithDebugContextInDEV(request, task, </span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s3">&quot;Object&quot; </span><span class="s2">!== objectName(originalValue)</span>
                <span class="s2">? </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">jsxChildrenParents.get(parent)</span>
                  <span class="s2">? console.error(</span>
                      <span class="s3">&quot;%s objects cannot be rendered as text children. Try formatting it using toString().%s&quot;</span><span class="s2">,</span>
                      <span class="s2">objectName(originalValue),</span>
                      <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
                    <span class="s2">)</span>
                  <span class="s2">: console.error(</span>
                      <span class="s3">&quot;Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s&quot;</span><span class="s2">,</span>
                      <span class="s2">objectName(originalValue),</span>
                      <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
                    <span class="s2">)</span>
                <span class="s2">: console.error(</span>
                    <span class="s3">&quot;Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s&quot;</span><span class="s2">,</span>
                    <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
                  <span class="s2">);</span>
            <span class="s2">});</span>
          <span class="s4">return </span><span class="s2">renderModel(request, task, parent, parentPropertyName, value);</span>
        <span class="s2">},</span>
        <span class="s2">thenableState: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">timed: !</span><span class="s5">1</span>
      <span class="s2">};</span>
      <span class="s2">task.time = lastTimestamp;</span>
      <span class="s2">task.environmentName = request.environmentName();</span>
      <span class="s2">task.debugOwner = debugOwner;</span>
      <span class="s2">task.debugStack = debugStack;</span>
      <span class="s2">task.debugTask = debugTask;</span>
      <span class="s2">abortSet.add(task);</span>
      <span class="s4">return </span><span class="s2">task;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeByValueID(id) {</span>
      <span class="s4">return </span><span class="s3">&quot;$&quot; </span><span class="s2">+ id.toString(</span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeLazyID(id) {</span>
      <span class="s4">return </span><span class="s3">&quot;$L&quot; </span><span class="s2">+ id.toString(</span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeDeferredObject(request, value) {</span>
      <span class="s4">var </span><span class="s2">deferredDebugObjects = request.deferredDebugObjects;</span>
      <span class="s4">return null </span><span class="s2">!== deferredDebugObjects</span>
        <span class="s2">? (request.pendingDebugChunks++,</span>
          <span class="s2">(request = request.nextChunkId++),</span>
          <span class="s2">deferredDebugObjects.existing.set(value, request),</span>
          <span class="s2">deferredDebugObjects.retained.set(request, value),</span>
          <span class="s3">&quot;$Y&quot; </span><span class="s2">+ request.toString(</span><span class="s5">16</span><span class="s2">))</span>
        <span class="s2">: </span><span class="s3">&quot;$Y&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeNumber(number) {</span>
      <span class="s4">return </span><span class="s2">Number.isFinite(number)</span>
        <span class="s2">? </span><span class="s5">0 </span><span class="s2">=== number &amp;&amp; -Infinity === </span><span class="s5">1 </span><span class="s2">/ number</span>
          <span class="s2">? </span><span class="s3">&quot;$-0&quot;</span>
          <span class="s2">: number</span>
        <span class="s2">: Infinity === number</span>
          <span class="s2">? </span><span class="s3">&quot;$Infinity&quot;</span>
          <span class="s2">: -Infinity === number</span>
            <span class="s2">? </span><span class="s3">&quot;$-Infinity&quot;</span>
            <span class="s2">: </span><span class="s3">&quot;$NaN&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">encodeReferenceChunk(request, id, reference) {</span>
      <span class="s2">request = stringify(reference);</span>
      <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ request + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">stringToChunk(id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeClientReference(</span>
      <span class="s2">request,</span>
      <span class="s2">parent,</span>
      <span class="s2">parentPropertyName,</span>
      <span class="s2">clientReference</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">clientReferenceKey = clientReference.$$async</span>
          <span class="s2">? clientReference.$$id + </span><span class="s3">&quot;#async&quot;</span>
          <span class="s2">: clientReference.$$id,</span>
        <span class="s2">writtenClientReferences = request.writtenClientReferences,</span>
        <span class="s2">existingId = writtenClientReferences.get(clientReferenceKey);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existingId)</span>
        <span class="s4">return </span><span class="s2">parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE &amp;&amp; </span><span class="s3">&quot;1&quot; </span><span class="s2">=== parentPropertyName</span>
          <span class="s2">? serializeLazyID(existingId)</span>
          <span class="s2">: serializeByValueID(existingId);</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">clientReferenceMetadata = resolveClientReferenceMetadata(</span>
          <span class="s2">request.bundlerConfig,</span>
          <span class="s2">clientReference</span>
        <span class="s2">);</span>
        <span class="s2">request.pendingChunks++;</span>
        <span class="s4">var </span><span class="s2">importId = request.nextChunkId++;</span>
        <span class="s2">emitImportChunk(request, importId, clientReferenceMetadata, !</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">writtenClientReferences.set(clientReferenceKey, importId);</span>
        <span class="s4">return </span><span class="s2">parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE &amp;&amp; </span><span class="s3">&quot;1&quot; </span><span class="s2">=== parentPropertyName</span>
          <span class="s2">? serializeLazyID(importId)</span>
          <span class="s2">: serializeByValueID(importId);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">request.pendingChunks++,</span>
          <span class="s2">(parent = request.nextChunkId++),</span>
          <span class="s2">(parentPropertyName = logRecoverableError(request, x, </span><span class="s4">null</span><span class="s2">)),</span>
          <span class="s2">emitErrorChunk(request, parent, parentPropertyName, x, !</span><span class="s5">1</span><span class="s2">),</span>
          <span class="s2">serializeByValueID(parent)</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeDebugClientReference(</span>
      <span class="s2">request,</span>
      <span class="s2">parent,</span>
      <span class="s2">parentPropertyName,</span>
      <span class="s2">clientReference</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">existingId = request.writtenClientReferences.get(</span>
        <span class="s2">clientReference.$$async</span>
          <span class="s2">? clientReference.$$id + </span><span class="s3">&quot;#async&quot;</span>
          <span class="s2">: clientReference.$$id</span>
      <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existingId)</span>
        <span class="s4">return </span><span class="s2">parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE &amp;&amp; </span><span class="s3">&quot;1&quot; </span><span class="s2">=== parentPropertyName</span>
          <span class="s2">? serializeLazyID(existingId)</span>
          <span class="s2">: serializeByValueID(existingId);</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">clientReferenceMetadata = resolveClientReferenceMetadata(</span>
          <span class="s2">request.bundlerConfig,</span>
          <span class="s2">clientReference</span>
        <span class="s2">);</span>
        <span class="s2">request.pendingDebugChunks++;</span>
        <span class="s4">var </span><span class="s2">importId = request.nextChunkId++;</span>
        <span class="s2">emitImportChunk(request, importId, clientReferenceMetadata, !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s4">return </span><span class="s2">parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE &amp;&amp; </span><span class="s3">&quot;1&quot; </span><span class="s2">=== parentPropertyName</span>
          <span class="s2">? serializeLazyID(importId)</span>
          <span class="s2">: serializeByValueID(importId);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">request.pendingDebugChunks++,</span>
          <span class="s2">(parent = request.nextChunkId++),</span>
          <span class="s2">(parentPropertyName = logRecoverableError(request, x, </span><span class="s4">null</span><span class="s2">)),</span>
          <span class="s2">emitErrorChunk(request, parent, parentPropertyName, x, !</span><span class="s5">0</span><span class="s2">),</span>
          <span class="s2">serializeByValueID(parent)</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">outlineModel(request, value) {</span>
      <span class="s2">value = createTask(</span>
        <span class="s2">request,</span>
        <span class="s2">value,</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">request.abortableTasks,</span>
        <span class="s2">performance.now(),</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s4">null</span><span class="s2">,</span>
        <span class="s4">null</span>
      <span class="s2">);</span>
      <span class="s2">retryTask(request, value);</span>
      <span class="s4">return </span><span class="s2">value.id;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeServerReference(request, serverReference) {</span>
      <span class="s4">var </span><span class="s2">writtenServerReferences = request.writtenServerReferences,</span>
        <span class="s2">existingId = writtenServerReferences.get(serverReference);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existingId) </span><span class="s4">return </span><span class="s3">&quot;$F&quot; </span><span class="s2">+ existingId.toString(</span><span class="s5">16</span><span class="s2">);</span>
      <span class="s2">existingId = serverReference.$$bound;</span>
      <span class="s2">existingId = </span><span class="s4">null </span><span class="s2">=== existingId ? </span><span class="s4">null </span><span class="s2">: Promise.resolve(existingId);</span>
      <span class="s4">var </span><span class="s2">id = serverReference.$$id,</span>
        <span class="s2">location = </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">error = serverReference.$$location;</span>
      <span class="s2">error &amp;&amp;</span>
        <span class="s2">((error = parseStackTrace(error, </span><span class="s5">1</span><span class="s2">)),</span>
        <span class="s5">0 </span><span class="s2">&lt; error.length &amp;&amp;</span>
          <span class="s2">((location = error[</span><span class="s5">0</span><span class="s2">]),</span>
          <span class="s2">(location = [location[</span><span class="s5">0</span><span class="s2">], location[</span><span class="s5">1</span><span class="s2">], location[</span><span class="s5">2</span><span class="s2">], location[</span><span class="s5">3</span><span class="s2">]])));</span>
      <span class="s2">existingId =</span>
        <span class="s4">null </span><span class="s2">!== location</span>
          <span class="s2">? {</span>
              <span class="s2">id: id,</span>
              <span class="s2">bound: existingId,</span>
              <span class="s2">name:</span>
                <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">serverReference</span>
                  <span class="s2">? serverReference.name</span>
                  <span class="s2">: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
              <span class="s2">env: (</span><span class="s5">0</span><span class="s2">, request.environmentName)(),</span>
              <span class="s2">location: location</span>
            <span class="s2">}</span>
          <span class="s2">: { id: id, bound: existingId };</span>
      <span class="s2">request = outlineModel(request, existingId);</span>
      <span class="s2">writtenServerReferences.set(serverReference, request);</span>
      <span class="s4">return </span><span class="s3">&quot;$F&quot; </span><span class="s2">+ request.toString(</span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeLargeTextString(request, text) {</span>
      <span class="s2">request.pendingChunks++;</span>
      <span class="s4">var </span><span class="s2">textId = request.nextChunkId++;</span>
      <span class="s2">emitTextChunk(request, textId, text, !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">return </span><span class="s2">serializeByValueID(textId);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeMap(request, map) {</span>
      <span class="s2">map = Array.from(map);</span>
      <span class="s4">return </span><span class="s3">&quot;$Q&quot; </span><span class="s2">+ outlineModel(request, map).toString(</span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeFormData(request, formData) {</span>
      <span class="s2">formData = Array.from(formData.entries());</span>
      <span class="s4">return </span><span class="s3">&quot;$K&quot; </span><span class="s2">+ outlineModel(request, formData).toString(</span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeSet(request, set) {</span>
      <span class="s2">set = Array.from(set);</span>
      <span class="s4">return </span><span class="s3">&quot;$W&quot; </span><span class="s2">+ outlineModel(request, set).toString(</span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeTypedArray(request, tag, typedArray) {</span>
      <span class="s2">request.pendingChunks++;</span>
      <span class="s4">var </span><span class="s2">bufferId = request.nextChunkId++;</span>
      <span class="s2">emitTypedArrayChunk(request, bufferId, tag, typedArray, !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">return </span><span class="s2">serializeByValueID(bufferId);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeDebugTypedArray(request, tag, typedArray) {</span>
      <span class="s2">request.pendingDebugChunks++;</span>
      <span class="s4">var </span><span class="s2">bufferId = request.nextChunkId++;</span>
      <span class="s2">emitTypedArrayChunk(request, bufferId, tag, typedArray, !</span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">return </span><span class="s2">serializeByValueID(bufferId);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeDebugBlob(request, blob) {</span>
      <span class="s4">function </span><span class="s2">progress(entry) {</span>
        <span class="s4">if </span><span class="s2">(entry.done)</span>
          <span class="s2">emitOutlinedDebugModelChunk(</span>
            <span class="s2">request,</span>
            <span class="s2">id,</span>
            <span class="s2">{ objectLimit: model.length + </span><span class="s5">2 </span><span class="s2">},</span>
            <span class="s2">model</span>
          <span class="s2">),</span>
            <span class="s2">enqueueFlush(request);</span>
        <span class="s4">else</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">model.push(entry.value), reader.read().then(progress).catch(error)</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">error(reason) {</span>
        <span class="s2">emitErrorChunk(request, id, </span><span class="s3">&quot;&quot;</span><span class="s2">, reason, !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s2">enqueueFlush(request);</span>
        <span class="s2">reader.cancel(reason).then(noop, noop);</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">model = [blob.type],</span>
        <span class="s2">reader = blob.stream().getReader();</span>
      <span class="s2">request.pendingDebugChunks++;</span>
      <span class="s4">var </span><span class="s2">id = request.nextChunkId++;</span>
      <span class="s2">reader.read().then(progress).catch(error);</span>
      <span class="s4">return </span><span class="s3">&quot;$B&quot; </span><span class="s2">+ id.toString(</span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeBlob(request, blob) {</span>
      <span class="s4">function </span><span class="s2">progress(entry) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== newTask.status)</span>
          <span class="s4">if </span><span class="s2">(entry.done)</span>
            <span class="s2">request.cacheController.signal.removeEventListener(</span>
              <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
              <span class="s2">abortBlob</span>
            <span class="s2">),</span>
              <span class="s2">pingTask(request, newTask);</span>
          <span class="s4">else</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">model.push(entry.value), reader.read().then(progress).catch(error)</span>
            <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">error(reason) {</span>
        <span class="s5">0 </span><span class="s2">=== newTask.status &amp;&amp;</span>
          <span class="s2">(request.cacheController.signal.removeEventListener(</span>
            <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
            <span class="s2">abortBlob</span>
          <span class="s2">),</span>
          <span class="s2">erroredTask(request, newTask, reason),</span>
          <span class="s2">enqueueFlush(request),</span>
          <span class="s2">reader.cancel(reason).then(error, error));</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">abortBlob() {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== newTask.status) {</span>
          <span class="s4">var </span><span class="s2">signal = request.cacheController.signal;</span>
          <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortBlob);</span>
          <span class="s2">signal = signal.reason;</span>
          <span class="s5">21 </span><span class="s2">=== request.type</span>
            <span class="s2">? (request.abortableTasks.delete(newTask),</span>
              <span class="s2">haltTask(newTask),</span>
              <span class="s2">finishHaltedTask(newTask, request))</span>
            <span class="s2">: (erroredTask(request, newTask, signal), enqueueFlush(request));</span>
          <span class="s2">reader.cancel(signal).then(error, error);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">model = [blob.type],</span>
        <span class="s2">newTask = createTask(</span>
          <span class="s2">request,</span>
          <span class="s2">model,</span>
          <span class="s4">null</span><span class="s2">,</span>
          <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">request.abortableTasks,</span>
          <span class="s2">performance.now(),</span>
          <span class="s4">null</span><span class="s2">,</span>
          <span class="s4">null</span><span class="s2">,</span>
          <span class="s4">null</span>
        <span class="s2">),</span>
        <span class="s2">reader = blob.stream().getReader();</span>
      <span class="s2">request.cacheController.signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortBlob);</span>
      <span class="s2">reader.read().then(progress).catch(error);</span>
      <span class="s4">return </span><span class="s3">&quot;$B&quot; </span><span class="s2">+ newTask.id.toString(</span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">renderModel(request, task, parent, key, value) {</span>
      <span class="s2">serializedSize += key.length;</span>
      <span class="s4">var </span><span class="s2">prevKeyPath = task.keyPath,</span>
        <span class="s2">prevImplicitSlot = task.implicitSlot;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">return </span><span class="s2">renderModelDestructive(request, task, parent, key, value);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(thrownValue) {</span>
        <span class="s2">parent = task.model;</span>
        <span class="s2">parent =</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">parent &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== parent &amp;&amp;</span>
          <span class="s2">(parent.$$typeof === REACT_ELEMENT_TYPE ||</span>
            <span class="s2">parent.$$typeof === REACT_LAZY_TYPE);</span>
        <span class="s4">if </span><span class="s2">(request.status === ABORTING) {</span>
          <span class="s2">task.status = </span><span class="s5">3</span><span class="s2">;</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">21 </span><span class="s2">=== request.type)</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">(task = request.nextChunkId++),</span>
              <span class="s2">(task = parent</span>
                <span class="s2">? serializeLazyID(task)</span>
                <span class="s2">: serializeByValueID(task)),</span>
              <span class="s2">task</span>
            <span class="s2">);</span>
          <span class="s2">task = request.fatalError;</span>
          <span class="s4">return </span><span class="s2">parent ? serializeLazyID(task) : serializeByValueID(task);</span>
        <span class="s2">}</span>
        <span class="s2">key =</span>
          <span class="s2">thrownValue === SuspenseException</span>
            <span class="s2">? getSuspendedThenable()</span>
            <span class="s2">: thrownValue;</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">key &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== key &amp;&amp;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">key.then</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(request = createTask(</span>
              <span class="s2">request,</span>
              <span class="s2">task.model,</span>
              <span class="s2">task.keyPath,</span>
              <span class="s2">task.implicitSlot,</span>
              <span class="s2">request.abortableTasks,</span>
              <span class="s2">task.time,</span>
              <span class="s2">task.debugOwner,</span>
              <span class="s2">task.debugStack,</span>
              <span class="s2">task.debugTask</span>
            <span class="s2">)),</span>
            <span class="s2">(value = request.ping),</span>
            <span class="s2">key.then(value, value),</span>
            <span class="s2">(request.thenableState = getThenableStateAfterSuspending()),</span>
            <span class="s2">(task.keyPath = prevKeyPath),</span>
            <span class="s2">(task.implicitSlot = prevImplicitSlot),</span>
            <span class="s2">parent</span>
              <span class="s2">? serializeLazyID(request.id)</span>
              <span class="s2">: serializeByValueID(request.id)</span>
          <span class="s2">);</span>
        <span class="s2">task.keyPath = prevKeyPath;</span>
        <span class="s2">task.implicitSlot = prevImplicitSlot;</span>
        <span class="s2">request.pendingChunks++;</span>
        <span class="s2">prevKeyPath = request.nextChunkId++;</span>
        <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">key &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== key &amp;&amp;</span>
        <span class="s2">key.$$typeof === REACT_POSTPONE_TYPE</span>
          <span class="s2">? (logPostpone(request, key.message, task),</span>
            <span class="s2">emitPostponeChunk(request, prevKeyPath, key))</span>
          <span class="s2">: ((task = logRecoverableError(request, key, task)),</span>
            <span class="s2">emitErrorChunk(request, prevKeyPath, task, key, !</span><span class="s5">1</span><span class="s2">));</span>
        <span class="s4">return </span><span class="s2">parent</span>
          <span class="s2">? serializeLazyID(prevKeyPath)</span>
          <span class="s2">: serializeByValueID(prevKeyPath);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">renderModelDestructive(</span>
      <span class="s2">request,</span>
      <span class="s2">task,</span>
      <span class="s2">parent,</span>
      <span class="s2">parentPropertyName,</span>
      <span class="s2">value</span>
    <span class="s2">) {</span>
      <span class="s2">task.model = value;</span>
      <span class="s4">if </span><span class="s2">(value === REACT_ELEMENT_TYPE) </span><span class="s4">return </span><span class="s3">&quot;$&quot;</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== value) </span><span class="s4">return null</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s4">switch </span><span class="s2">(value.$$typeof) {</span>
          <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
            <span class="s4">var </span><span class="s2">elementReference = </span><span class="s4">null</span><span class="s2">,</span>
              <span class="s2">_writtenObjects = request.writtenObjects;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== task.keyPath &amp;&amp; !task.implicitSlot) {</span>
              <span class="s4">var </span><span class="s2">_existingReference = _writtenObjects.get(value);</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== _existingReference)</span>
                <span class="s4">if </span><span class="s2">(modelRoot === value) modelRoot = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s4">else return </span><span class="s2">_existingReference;</span>
              <span class="s4">else</span>
                <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== parentPropertyName.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">) &amp;&amp;</span>
                  <span class="s2">((_existingReference = _writtenObjects.get(parent)),</span>
                  <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== _existingReference &amp;&amp;</span>
                    <span class="s2">((elementReference =</span>
                      <span class="s2">_existingReference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ parentPropertyName),</span>
                    <span class="s2">_writtenObjects.set(value, elementReference)));</span>
            <span class="s2">}</span>
            <span class="s4">if </span><span class="s2">(serializedSize &gt; MAX_ROW_SIZE) </span><span class="s4">return </span><span class="s2">deferTask(request, task);</span>
            <span class="s4">if </span><span class="s2">((_existingReference = value._debugInfo))</span>
              <span class="s4">if </span><span class="s2">(canEmitDebugInfo)</span>
                <span class="s2">forwardDebugInfo(request, task, _existingReference);</span>
              <span class="s4">else return </span><span class="s2">outlineTask(request, task);</span>
            <span class="s2">_existingReference = value.props;</span>
            <span class="s4">var </span><span class="s2">refProp = _existingReference.ref;</span>
            <span class="s2">refProp = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== refProp ? refProp : </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">task.debugOwner = value._owner;</span>
            <span class="s2">task.debugStack = value._debugStack;</span>
            <span class="s2">task.debugTask = value._debugTask;</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== value._owner ||</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== value._debugStack ||</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== value._debugTask</span>
            <span class="s2">) {</span>
              <span class="s4">var </span><span class="s2">key = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
              <span class="s4">null </span><span class="s2">!== value.key &amp;&amp; (key = </span><span class="s3">' key=&quot;' </span><span class="s2">+ value.key + </span><span class="s3">'&quot;'</span><span class="s2">);</span>
              <span class="s2">console.error(</span>
                <span class="s3">&quot;Attempted to render &lt;%s%s&gt; without development properties. This is not supported. It can happen if:</span><span class="s6">\n</span><span class="s3">- The element is created with a production version of React but rendered in development.</span><span class="s6">\n</span><span class="s3">- The element was cloned with a custom function instead of `React.cloneElement`.</span><span class="s6">\n</span><span class="s3">The props of this element may help locate this element: %o&quot;</span><span class="s2">,</span>
                <span class="s2">value.type,</span>
                <span class="s2">key,</span>
                <span class="s2">value.props</span>
              <span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s2">request = renderElement(</span>
              <span class="s2">request,</span>
              <span class="s2">task,</span>
              <span class="s2">value.type,</span>
              <span class="s2">value.key,</span>
              <span class="s2">refProp,</span>
              <span class="s2">_existingReference,</span>
              <span class="s2">value._store.validated</span>
            <span class="s2">);</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">request &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== request &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== elementReference &amp;&amp;</span>
              <span class="s2">(_writtenObjects.has(request) ||</span>
                <span class="s2">_writtenObjects.set(request, elementReference));</span>
            <span class="s4">return </span><span class="s2">request;</span>
          <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
            <span class="s4">if </span><span class="s2">(serializedSize &gt; MAX_ROW_SIZE) </span><span class="s4">return </span><span class="s2">deferTask(request, task);</span>
            <span class="s2">task.thenableState = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">elementReference = callLazyInitInDEV(value);</span>
            <span class="s4">if </span><span class="s2">(request.status === ABORTING) </span><span class="s4">throw null</span><span class="s2">;</span>
            <span class="s4">if </span><span class="s2">((_writtenObjects = value._debugInfo))</span>
              <span class="s4">if </span><span class="s2">(canEmitDebugInfo)</span>
                <span class="s2">forwardDebugInfo(request, task, _writtenObjects);</span>
              <span class="s4">else return </span><span class="s2">outlineTask(request, task);</span>
            <span class="s4">return </span><span class="s2">renderModelDestructive(</span>
              <span class="s2">request,</span>
              <span class="s2">task,</span>
              <span class="s2">emptyRoot,</span>
              <span class="s3">&quot;&quot;</span><span class="s2">,</span>
              <span class="s2">elementReference</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s2">REACT_LEGACY_ELEMENT_TYPE:</span>
            <span class="s4">throw </span><span class="s2">Error(</span>
              <span class="s3">'A React Element from an older version of React was rendered. This is not supported. It can happen if:</span><span class="s6">\n</span><span class="s3">- Multiple copies of the &quot;react&quot; package is used.</span><span class="s6">\n</span><span class="s3">- A library pre-bundled an old copy of &quot;react&quot; or &quot;react/jsx-runtime&quot;.</span><span class="s6">\n</span><span class="s3">- A compiler tries to &quot;inline&quot; JSX instead of using the runtime.'</span>
            <span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(isClientReference(value))</span>
          <span class="s4">return </span><span class="s2">serializeClientReference(</span>
            <span class="s2">request,</span>
            <span class="s2">parent,</span>
            <span class="s2">parentPropertyName,</span>
            <span class="s2">value</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request.temporaryReferences &amp;&amp;</span>
          <span class="s2">((elementReference = request.temporaryReferences.get(value)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== elementReference)</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s3">&quot;$T&quot; </span><span class="s2">+ elementReference;</span>
        <span class="s2">elementReference = TaintRegistryObjects.get(value);</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== elementReference &amp;&amp; throwTaintViolation(elementReference);</span>
        <span class="s2">elementReference = request.writtenObjects;</span>
        <span class="s2">_writtenObjects = elementReference.get(value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.then) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== _writtenObjects) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== task.keyPath || task.implicitSlot)</span>
              <span class="s4">return </span><span class="s2">(</span>
                <span class="s3">&quot;$@&quot; </span><span class="s2">+ serializeThenable(request, task, value).toString(</span><span class="s5">16</span><span class="s2">)</span>
              <span class="s2">);</span>
            <span class="s4">if </span><span class="s2">(modelRoot === value) modelRoot = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s4">else return </span><span class="s2">_writtenObjects;</span>
          <span class="s2">}</span>
          <span class="s2">request = </span><span class="s3">&quot;$@&quot; </span><span class="s2">+ serializeThenable(request, task, value).toString(</span><span class="s5">16</span><span class="s2">);</span>
          <span class="s2">elementReference.set(value, request);</span>
          <span class="s4">return </span><span class="s2">request;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== _writtenObjects)</span>
          <span class="s4">if </span><span class="s2">(modelRoot === value) {</span>
            <span class="s4">if </span><span class="s2">(_writtenObjects !== serializeByValueID(task.id))</span>
              <span class="s4">return </span><span class="s2">_writtenObjects;</span>
            <span class="s2">modelRoot = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s4">else return </span><span class="s2">_writtenObjects;</span>
        <span class="s4">else if </span><span class="s2">(</span>
          <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== parentPropertyName.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">) &amp;&amp;</span>
          <span class="s2">((_writtenObjects = elementReference.get(parent)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== _writtenObjects)</span>
        <span class="s2">) {</span>
          <span class="s2">_existingReference = parentPropertyName;</span>
          <span class="s4">if </span><span class="s2">(isArrayImpl(parent) &amp;&amp; parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE)</span>
            <span class="s4">switch </span><span class="s2">(parentPropertyName) {</span>
              <span class="s4">case </span><span class="s3">&quot;1&quot;</span><span class="s2">:</span>
                <span class="s2">_existingReference = </span><span class="s3">&quot;type&quot;</span><span class="s2">;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;2&quot;</span><span class="s2">:</span>
                <span class="s2">_existingReference = </span><span class="s3">&quot;key&quot;</span><span class="s2">;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;3&quot;</span><span class="s2">:</span>
                <span class="s2">_existingReference = </span><span class="s3">&quot;props&quot;</span><span class="s2">;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s3">&quot;4&quot;</span><span class="s2">:</span>
                <span class="s2">_existingReference = </span><span class="s3">&quot;_owner&quot;</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">elementReference.set(</span>
            <span class="s2">value,</span>
            <span class="s2">_writtenObjects + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ _existingReference</span>
          <span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(isArrayImpl(value)) </span><span class="s4">return </span><span class="s2">renderFragment(request, task, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Map) </span><span class="s4">return </span><span class="s2">serializeMap(request, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Set) </span><span class="s4">return </span><span class="s2">serializeSet(request, value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">FormData &amp;&amp; value </span><span class="s4">instanceof </span><span class="s2">FormData)</span>
          <span class="s4">return </span><span class="s2">serializeFormData(request, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Error) </span><span class="s4">return </span><span class="s2">serializeErrorValue(request, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">ArrayBuffer)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s4">new </span><span class="s2">Uint8Array(value));</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int8Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;O&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint8Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;o&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint8ClampedArray)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;U&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int16Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint16Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;s&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int32Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;L&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint32Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;l&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Float32Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;G&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Float64Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;g&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">BigInt64Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;M&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">BigUint64Array)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;m&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">DataView)</span>
          <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;V&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Blob &amp;&amp; value </span><span class="s4">instanceof </span><span class="s2">Blob)</span>
          <span class="s4">return </span><span class="s2">serializeBlob(request, value);</span>
        <span class="s4">if </span><span class="s2">((elementReference = getIteratorFn(value)))</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(elementReference = elementReference.call(value)),</span>
            <span class="s2">elementReference === value</span>
              <span class="s2">? </span><span class="s3">&quot;$i&quot; </span><span class="s2">+</span>
                <span class="s2">outlineModel(request, Array.from(elementReference)).toString(</span><span class="s5">16</span><span class="s2">)</span>
              <span class="s2">: renderFragment(request, task, Array.from(elementReference))</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">ReadableStream &amp;&amp;</span>
          <span class="s2">value </span><span class="s4">instanceof </span><span class="s2">ReadableStream</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s2">serializeReadableStream(request, task, value);</span>
        <span class="s2">elementReference = value[ASYNC_ITERATOR];</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">elementReference)</span>
          <span class="s4">return </span><span class="s2">renderAsyncFragment(request, task, value, elementReference);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Date) </span><span class="s4">return </span><span class="s3">&quot;$D&quot; </span><span class="s2">+ value.toJSON();</span>
        <span class="s2">elementReference = getPrototypeOf(value);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">elementReference !== ObjectPrototype &amp;&amp;</span>
          <span class="s2">(</span><span class="s4">null </span><span class="s2">=== elementReference ||</span>
            <span class="s4">null </span><span class="s2">!== getPrototypeOf(elementReference))</span>
        <span class="s2">)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.&quot; </span><span class="s2">+</span>
              <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;Object&quot; </span><span class="s2">!== objectName(value))</span>
          <span class="s2">callWithDebugContextInDEV(request, task, </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s2">console.error(</span>
              <span class="s3">&quot;Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s&quot;</span><span class="s2">,</span>
              <span class="s2">objectName(value),</span>
              <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
            <span class="s2">);</span>
          <span class="s2">});</span>
        <span class="s4">else if </span><span class="s2">(!isSimpleObject(value))</span>
          <span class="s2">callWithDebugContextInDEV(request, task, </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s2">console.error(</span>
              <span class="s3">&quot;Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s&quot;</span><span class="s2">,</span>
              <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
            <span class="s2">);</span>
          <span class="s2">});</span>
        <span class="s4">else if </span><span class="s2">(Object.getOwnPropertySymbols) {</span>
          <span class="s4">var </span><span class="s2">symbols = Object.getOwnPropertySymbols(value);</span>
          <span class="s5">0 </span><span class="s2">&lt; symbols.length &amp;&amp;</span>
            <span class="s2">callWithDebugContextInDEV(request, task, </span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s2">console.error(</span>
                <span class="s3">&quot;Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s&quot;</span><span class="s2">,</span>
                <span class="s2">symbols[</span><span class="s5">0</span><span class="s2">].description,</span>
                <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
              <span class="s2">);</span>
            <span class="s2">});</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">value;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(task = TaintRegistryValues.get(value)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== task &amp;&amp; throwTaintViolation(task.message),</span>
          <span class="s2">(serializedSize += value.length),</span>
          <span class="s3">&quot;Z&quot; </span><span class="s2">=== value[value.length - </span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
          <span class="s2">parent[parentPropertyName] </span><span class="s4">instanceof </span><span class="s2">Date</span>
            <span class="s2">? </span><span class="s3">&quot;$D&quot; </span><span class="s2">+ value</span>
            <span class="s2">: </span><span class="s5">1024 </span><span class="s2">&lt;= value.length &amp;&amp; </span><span class="s4">null </span><span class="s2">!== byteLengthOfChunk</span>
              <span class="s2">? serializeLargeTextString(request, value)</span>
              <span class="s2">: </span><span class="s3">&quot;$&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">]</span>
                <span class="s2">? </span><span class="s3">&quot;$&quot; </span><span class="s2">+ value</span>
                <span class="s2">: value</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s2">value;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s2">serializeNumber(value);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s3">&quot;$undefined&quot;</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s4">if </span><span class="s2">(isClientReference(value))</span>
          <span class="s4">return </span><span class="s2">serializeClientReference(</span>
            <span class="s2">request,</span>
            <span class="s2">parent,</span>
            <span class="s2">parentPropertyName,</span>
            <span class="s2">value</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(value.$$typeof === SERVER_REFERENCE_TAG)</span>
          <span class="s4">return </span><span class="s2">serializeServerReference(request, value);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request.temporaryReferences &amp;&amp;</span>
          <span class="s2">((request = request.temporaryReferences.get(value)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request)</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s3">&quot;$T&quot; </span><span class="s2">+ request;</span>
        <span class="s2">request = TaintRegistryObjects.get(value);</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request &amp;&amp; throwTaintViolation(request);</span>
        <span class="s4">if </span><span class="s2">(value.$$typeof === TEMPORARY_REFERENCE_TAG)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s7">/^on[A-Z]/</span><span class="s2">.test(parentPropertyName))</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Event handlers cannot be passed to Client Component props.&quot; </span><span class="s2">+</span>
              <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName) +</span>
              <span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">If you need interactivity, consider converting part of this to a Client Component.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">jsxChildrenParents.has(parent) ||</span>
          <span class="s2">(jsxPropsParents.has(parent) &amp;&amp; </span><span class="s3">&quot;children&quot; </span><span class="s2">=== parentPropertyName)</span>
        <span class="s2">)</span>
          <span class="s4">throw </span><span class="s2">(</span>
            <span class="s2">((request = value.displayName || value.name || </span><span class="s3">&quot;Component&quot;</span><span class="s2">),</span>
            <span class="s2">Error(</span>
              <span class="s3">&quot;Functions are not valid as a child of Client Components. This may happen if you return &quot; </span><span class="s2">+</span>
                <span class="s2">request +</span>
                <span class="s3">&quot; instead of &lt;&quot; </span><span class="s2">+</span>
                <span class="s2">request +</span>
                <span class="s3">&quot; /&gt; from render. Or maybe you meant to call this function rather than return it.&quot; </span><span class="s2">+</span>
                <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
            <span class="s2">))</span>
          <span class="s2">);</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with &quot;use server&quot;. Or maybe you meant to call this function rather than return it.' </span><span class="s2">+</span>
            <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s2">task = request.writtenSymbols;</span>
        <span class="s2">elementReference = task.get(value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== elementReference)</span>
          <span class="s4">return </span><span class="s2">serializeByValueID(elementReference);</span>
        <span class="s2">elementReference = value.description;</span>
        <span class="s4">if </span><span class="s2">(Symbol.for(elementReference) !== value)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(&quot; </span><span class="s2">+</span>
              <span class="s2">(value.description + </span><span class="s3">&quot;) cannot be found among global symbols.&quot;</span><span class="s2">) +</span>
              <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
          <span class="s2">);</span>
        <span class="s2">request.pendingChunks++;</span>
        <span class="s2">_writtenObjects = request.nextChunkId++;</span>
        <span class="s2">emitSymbolChunk(request, _writtenObjects, elementReference);</span>
        <span class="s2">task.set(value, _writtenObjects);</span>
        <span class="s4">return </span><span class="s2">serializeByValueID(_writtenObjects);</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(request = TaintRegistryValues.get(value)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request &amp;&amp; throwTaintViolation(request.message),</span>
          <span class="s3">&quot;$n&quot; </span><span class="s2">+ value.toString(</span><span class="s5">10</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Type &quot; </span><span class="s2">+</span>
          <span class="s4">typeof </span><span class="s2">value +</span>
          <span class="s3">&quot; is not supported in Client Component props.&quot; </span><span class="s2">+</span>
          <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">logPostpone(request, reason, task) {</span>
      <span class="s4">var </span><span class="s2">prevRequest = currentRequest;</span>
      <span class="s2">currentRequest = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">onPostpone = request.onPostpone;</span>
        <span class="s4">null </span><span class="s2">!== task</span>
          <span class="s2">? supportsRequestStorage</span>
            <span class="s2">? requestStorage.run(</span>
                <span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s2">callWithDebugContextInDEV,</span>
                <span class="s2">request,</span>
                <span class="s2">task,</span>
                <span class="s2">onPostpone,</span>
                <span class="s2">reason</span>
              <span class="s2">)</span>
            <span class="s2">: callWithDebugContextInDEV(request, task, onPostpone, reason)</span>
          <span class="s2">: supportsRequestStorage</span>
            <span class="s2">? requestStorage.run(</span><span class="s4">void </span><span class="s5">0</span><span class="s2">, onPostpone, reason)</span>
            <span class="s2">: onPostpone(reason);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">currentRequest = prevRequest;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">logRecoverableError(request, error, task) {</span>
      <span class="s4">var </span><span class="s2">prevRequest = currentRequest;</span>
      <span class="s2">currentRequest = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">onError = request.onError;</span>
        <span class="s4">var </span><span class="s2">errorDigest =</span>
          <span class="s4">null </span><span class="s2">!== task</span>
            <span class="s2">? supportsRequestStorage</span>
              <span class="s2">? requestStorage.run(</span>
                  <span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
                  <span class="s2">callWithDebugContextInDEV,</span>
                  <span class="s2">request,</span>
                  <span class="s2">task,</span>
                  <span class="s2">onError,</span>
                  <span class="s2">error</span>
                <span class="s2">)</span>
              <span class="s2">: callWithDebugContextInDEV(request, task, onError, error)</span>
            <span class="s2">: supportsRequestStorage</span>
              <span class="s2">? requestStorage.run(</span><span class="s4">void </span><span class="s5">0</span><span class="s2">, onError, error)</span>
              <span class="s2">: onError(error);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">currentRequest = prevRequest;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= errorDigest &amp;&amp; </span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">errorDigest)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">'onError returned something with a type other than &quot;string&quot;. onError should return a string and may return null or undefined but must not return anything else. It received something of type &quot;' </span><span class="s2">+</span>
            <span class="s4">typeof </span><span class="s2">errorDigest +</span>
            <span class="s3">'&quot; instead'</span>
        <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">errorDigest || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">fatalError(request, error) {</span>
      <span class="s4">var </span><span class="s2">onFatalError = request.onFatalError;</span>
      <span class="s2">onFatalError(error);</span>
      <span class="s2">cleanupTaintQueue(request);</span>
      <span class="s4">null </span><span class="s2">!== request.destination</span>
        <span class="s2">? ((request.status = CLOSED),</span>
          <span class="s2">closeWithError(request.destination, error))</span>
        <span class="s2">: ((request.status = </span><span class="s5">13</span><span class="s2">), (request.fatalError = error));</span>
      <span class="s2">request.cacheController.abort(</span>
        <span class="s2">Error(</span><span class="s3">&quot;The render was aborted due to a fatal error.&quot;</span><span class="s2">, { cause: error })</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitPostponeChunk(request, id, postponeInstance) {</span>
      <span class="s4">var </span><span class="s2">reason = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s2">env = request.environmentName();</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">reason = String(postponeInstance.message);</span>
        <span class="s4">var </span><span class="s2">stack = filterStackTrace(</span>
          <span class="s2">request,</span>
          <span class="s2">parseStackTrace(postponeInstance, </span><span class="s5">0</span><span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
        <span class="s2">stack = [];</span>
      <span class="s2">}</span>
      <span class="s2">id =</span>
        <span class="s2">id.toString(</span><span class="s5">16</span><span class="s2">) +</span>
        <span class="s3">&quot;:P&quot; </span><span class="s2">+</span>
        <span class="s2">stringify({ reason: reason, stack: stack, env: env }) +</span>
        <span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">id = stringToChunk(id);</span>
      <span class="s2">request.completedErrorChunks.push(id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeErrorValue(request, error) {</span>
      <span class="s4">var </span><span class="s2">name = </span><span class="s3">&quot;Error&quot;</span><span class="s2">,</span>
        <span class="s2">env = (</span><span class="s5">0</span><span class="s2">, request.environmentName)();</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">name = error.name;</span>
        <span class="s4">var </span><span class="s2">message = String(error.message);</span>
        <span class="s4">var </span><span class="s2">stack = filterStackTrace(request, parseStackTrace(error, </span><span class="s5">0</span><span class="s2">));</span>
        <span class="s4">var </span><span class="s2">errorEnv = error.environmentName;</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">errorEnv &amp;&amp; (env = errorEnv);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
        <span class="s2">(message =</span>
          <span class="s3">&quot;An error occurred but serializing the error message failed.&quot;</span><span class="s2">),</span>
          <span class="s2">(stack = []);</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s3">&quot;$Z&quot; </span><span class="s2">+</span>
        <span class="s2">outlineModel(request, {</span>
          <span class="s2">name: name,</span>
          <span class="s2">message: message,</span>
          <span class="s2">stack: stack,</span>
          <span class="s2">env: env</span>
        <span class="s2">}).toString(</span><span class="s5">16</span><span class="s2">)</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitErrorChunk(request, id, digest, error, debug) {</span>
      <span class="s4">var </span><span class="s2">name = </span><span class="s3">&quot;Error&quot;</span><span class="s2">,</span>
        <span class="s2">env = (</span><span class="s5">0</span><span class="s2">, request.environmentName)();</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">if </span><span class="s2">(error </span><span class="s4">instanceof </span><span class="s2">Error) {</span>
          <span class="s2">name = error.name;</span>
          <span class="s4">var </span><span class="s2">message = String(error.message);</span>
          <span class="s4">var </span><span class="s2">stack = filterStackTrace(request, parseStackTrace(error, </span><span class="s5">0</span><span class="s2">));</span>
          <span class="s4">var </span><span class="s2">errorEnv = error.environmentName;</span>
          <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">errorEnv &amp;&amp; (env = errorEnv);</span>
        <span class="s2">} </span><span class="s4">else</span>
          <span class="s2">(message =</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">error &amp;&amp; </span><span class="s4">null </span><span class="s2">!== error</span>
              <span class="s2">? describeObjectForErrorMessage(error)</span>
              <span class="s2">: String(error)),</span>
            <span class="s2">(stack = []);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
        <span class="s2">(message =</span>
          <span class="s3">&quot;An error occurred but serializing the error message failed.&quot;</span><span class="s2">),</span>
          <span class="s2">(stack = []);</span>
      <span class="s2">}</span>
      <span class="s2">digest = {</span>
        <span class="s2">digest: digest,</span>
        <span class="s2">name: name,</span>
        <span class="s2">message: message,</span>
        <span class="s2">stack: stack,</span>
        <span class="s2">env: env</span>
      <span class="s2">};</span>
      <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:E&quot; </span><span class="s2">+ stringify(digest) + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">id = stringToChunk(id);</span>
      <span class="s2">debug</span>
        <span class="s2">? request.completedDebugChunks.push(id)</span>
        <span class="s2">: request.completedErrorChunks.push(id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitImportChunk(request, id, clientReferenceMetadata, debug) {</span>
      <span class="s2">clientReferenceMetadata = stringify(clientReferenceMetadata);</span>
      <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:I&quot; </span><span class="s2">+ clientReferenceMetadata + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">id = stringToChunk(id);</span>
      <span class="s2">debug</span>
        <span class="s2">? request.completedDebugChunks.push(id)</span>
        <span class="s2">: request.completedImportChunks.push(id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitSymbolChunk(request, id, name) {</span>
      <span class="s2">id = encodeReferenceChunk(request, id, </span><span class="s3">&quot;$S&quot; </span><span class="s2">+ name);</span>
      <span class="s2">request.completedImportChunks.push(id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitModelChunk(request, id, json) {</span>
      <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ json + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">id = stringToChunk(id);</span>
      <span class="s2">request.completedRegularChunks.push(id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitDebugHaltChunk(request, id) {</span>
      <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">id = stringToChunk(id);</span>
      <span class="s2">request.completedDebugChunks.push(id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitDebugChunk(request, id, debugInfo) {</span>
      <span class="s4">var </span><span class="s2">json = serializeDebugModel(request, </span><span class="s5">500</span><span class="s2">, debugInfo);</span>
      <span class="s4">null </span><span class="s2">!== request.debugDestination</span>
        <span class="s2">? ((debugInfo = request.nextChunkId++),</span>
          <span class="s2">(json = debugInfo.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ json + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
          <span class="s2">request.pendingDebugChunks++,</span>
          <span class="s2">request.completedDebugChunks.push(stringToChunk(json)),</span>
          <span class="s2">(id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">':D&quot;$' </span><span class="s2">+ debugInfo.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">'&quot;</span><span class="s6">\n</span><span class="s3">'</span><span class="s2">),</span>
          <span class="s2">request.completedRegularChunks.push(stringToChunk(id)))</span>
        <span class="s2">: ((id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:D&quot; </span><span class="s2">+ json + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
          <span class="s2">request.completedRegularChunks.push(stringToChunk(id)));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">outlineComponentInfo(request, componentInfo) {</span>
      <span class="s4">if </span><span class="s2">(!request.writtenDebugObjects.has(componentInfo)) {</span>
        <span class="s4">null </span><span class="s2">!= componentInfo.owner &amp;&amp;</span>
          <span class="s2">outlineComponentInfo(request, componentInfo.owner);</span>
        <span class="s4">var </span><span class="s2">objectLimit = </span><span class="s5">10</span><span class="s2">;</span>
        <span class="s4">null </span><span class="s2">!= componentInfo.stack &amp;&amp;</span>
          <span class="s2">(objectLimit += componentInfo.stack.length);</span>
        <span class="s2">objectLimit = { objectLimit: objectLimit };</span>
        <span class="s4">var </span><span class="s2">componentDebugInfo = {</span>
          <span class="s2">name: componentInfo.name,</span>
          <span class="s2">key: componentInfo.key</span>
        <span class="s2">};</span>
        <span class="s4">null </span><span class="s2">!= componentInfo.env &amp;&amp;</span>
          <span class="s2">(componentDebugInfo.env = componentInfo.env);</span>
        <span class="s4">null </span><span class="s2">!= componentInfo.owner &amp;&amp;</span>
          <span class="s2">(componentDebugInfo.owner = componentInfo.owner);</span>
        <span class="s4">null </span><span class="s2">== componentInfo.stack &amp;&amp; </span><span class="s4">null </span><span class="s2">!= componentInfo.debugStack</span>
          <span class="s2">? (componentDebugInfo.stack = filterStackTrace(</span>
              <span class="s2">request,</span>
              <span class="s2">parseStackTrace(componentInfo.debugStack, </span><span class="s5">1</span><span class="s2">)</span>
            <span class="s2">))</span>
          <span class="s2">: </span><span class="s4">null </span><span class="s2">!= componentInfo.stack &amp;&amp;</span>
            <span class="s2">(componentDebugInfo.stack = componentInfo.stack);</span>
        <span class="s2">componentDebugInfo.props = componentInfo.props;</span>
        <span class="s2">objectLimit = outlineDebugModel(</span>
          <span class="s2">request,</span>
          <span class="s2">objectLimit,</span>
          <span class="s2">componentDebugInfo</span>
        <span class="s2">);</span>
        <span class="s2">objectLimit = serializeByValueID(objectLimit);</span>
        <span class="s2">request.writtenDebugObjects.set(componentInfo, objectLimit);</span>
        <span class="s2">request.writtenObjects.set(componentInfo, objectLimit);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitTypedArrayChunk(request, id, tag, typedArray, debug) {</span>
      <span class="s4">if </span><span class="s2">(TaintRegistryByteLengths.has(typedArray.byteLength)) {</span>
        <span class="s4">var </span><span class="s2">tainted = TaintRegistryValues.get(</span>
          <span class="s2">String.fromCharCode.apply(</span>
            <span class="s2">String,</span>
            <span class="s4">new </span><span class="s2">Uint8Array(</span>
              <span class="s2">typedArray.buffer,</span>
              <span class="s2">typedArray.byteOffset,</span>
              <span class="s2">typedArray.byteLength</span>
            <span class="s2">)</span>
          <span class="s2">)</span>
        <span class="s2">);</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== tainted &amp;&amp; throwTaintViolation(tainted.message);</span>
      <span class="s2">}</span>
      <span class="s2">debug ? request.pendingDebugChunks++ : request.pendingChunks++;</span>
      <span class="s2">tainted = </span><span class="s4">new </span><span class="s2">Uint8Array(</span>
        <span class="s2">typedArray.buffer,</span>
        <span class="s2">typedArray.byteOffset,</span>
        <span class="s2">typedArray.byteLength</span>
      <span class="s2">);</span>
      <span class="s2">typedArray = </span><span class="s5">2048 </span><span class="s2">&lt; typedArray.byteLength ? tainted.slice() : tainted;</span>
      <span class="s2">tainted = typedArray.byteLength;</span>
      <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ tag + tainted.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;,&quot;</span><span class="s2">;</span>
      <span class="s2">id = stringToChunk(id);</span>
      <span class="s2">debug</span>
        <span class="s2">? request.completedDebugChunks.push(id, typedArray)</span>
        <span class="s2">: request.completedRegularChunks.push(id, typedArray);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitTextChunk(request, id, text, debug) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== byteLengthOfChunk)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;Existence of byteLengthOfChunk should have already been checked. This is a bug in React.&quot;</span>
        <span class="s2">);</span>
      <span class="s2">debug ? request.pendingDebugChunks++ : request.pendingChunks++;</span>
      <span class="s2">text = stringToChunk(text);</span>
      <span class="s4">var </span><span class="s2">binaryLength = text.byteLength;</span>
      <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:T&quot; </span><span class="s2">+ binaryLength.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;,&quot;</span><span class="s2">;</span>
      <span class="s2">id = stringToChunk(id);</span>
      <span class="s2">debug</span>
        <span class="s2">? request.completedDebugChunks.push(id, text)</span>
        <span class="s2">: request.completedRegularChunks.push(id, text);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">renderDebugModel(</span>
      <span class="s2">request,</span>
      <span class="s2">counter,</span>
      <span class="s2">parent,</span>
      <span class="s2">parentPropertyName,</span>
      <span class="s2">value</span>
    <span class="s2">) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== value) </span><span class="s4">return null</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(value === REACT_ELEMENT_TYPE) </span><span class="s4">return </span><span class="s3">&quot;$&quot;</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s4">if </span><span class="s2">(isClientReference(value))</span>
          <span class="s4">return </span><span class="s2">serializeDebugClientReference(</span>
            <span class="s2">request,</span>
            <span class="s2">parent,</span>
            <span class="s2">parentPropertyName,</span>
            <span class="s2">value</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(value.$$typeof === CONSTRUCTOR_MARKER) {</span>
          <span class="s2">value = value.constructor;</span>
          <span class="s4">var </span><span class="s2">ref = request.writtenDebugObjects.get(value);</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== ref &amp;&amp;</span>
            <span class="s2">((request = outlineDebugModel(request, counter, value)),</span>
            <span class="s2">(ref = serializeByValueID(request)));</span>
          <span class="s4">return </span><span class="s3">&quot;$P&quot; </span><span class="s2">+ ref.slice(</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request.temporaryReferences) {</span>
          <span class="s4">var </span><span class="s2">tempRef = request.temporaryReferences.get(value);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== tempRef) </span><span class="s4">return </span><span class="s3">&quot;$T&quot; </span><span class="s2">+ tempRef;</span>
        <span class="s2">}</span>
        <span class="s2">tempRef = request.writtenDebugObjects;</span>
        <span class="s4">var </span><span class="s2">existingDebugReference = tempRef.get(value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existingDebugReference)</span>
          <span class="s4">if </span><span class="s2">(debugModelRoot === value) debugModelRoot = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s4">else return </span><span class="s2">existingDebugReference;</span>
        <span class="s4">else if </span><span class="s2">(-</span><span class="s5">1 </span><span class="s2">=== parentPropertyName.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">))</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">((existingDebugReference = tempRef.get(parent)),</span>
            <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existingDebugReference)</span>
          <span class="s2">) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&gt;= counter.objectLimit &amp;&amp; !doNotLimit.has(value))</span>
              <span class="s4">return </span><span class="s2">serializeDeferredObject(request, value);</span>
            <span class="s4">var </span><span class="s2">propertyName = parentPropertyName;</span>
            <span class="s4">if </span><span class="s2">(isArrayImpl(parent) &amp;&amp; parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE)</span>
              <span class="s4">switch </span><span class="s2">(parentPropertyName) {</span>
                <span class="s4">case </span><span class="s3">&quot;1&quot;</span><span class="s2">:</span>
                  <span class="s2">propertyName = </span><span class="s3">&quot;type&quot;</span><span class="s2">;</span>
                  <span class="s4">break</span><span class="s2">;</span>
                <span class="s4">case </span><span class="s3">&quot;2&quot;</span><span class="s2">:</span>
                  <span class="s2">propertyName = </span><span class="s3">&quot;key&quot;</span><span class="s2">;</span>
                  <span class="s4">break</span><span class="s2">;</span>
                <span class="s4">case </span><span class="s3">&quot;3&quot;</span><span class="s2">:</span>
                  <span class="s2">propertyName = </span><span class="s3">&quot;props&quot;</span><span class="s2">;</span>
                  <span class="s4">break</span><span class="s2">;</span>
                <span class="s4">case </span><span class="s3">&quot;4&quot;</span><span class="s2">:</span>
                  <span class="s2">propertyName = </span><span class="s3">&quot;_owner&quot;</span><span class="s2">;</span>
              <span class="s2">}</span>
            <span class="s2">tempRef.set(value, existingDebugReference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ propertyName);</span>
          <span class="s2">} </span><span class="s4">else if </span><span class="s2">(debugNoOutline !== value) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.then)</span>
              <span class="s4">return </span><span class="s2">serializeDebugThenable(request, counter, value);</span>
            <span class="s2">request = outlineDebugModel(request, counter, value);</span>
            <span class="s4">return </span><span class="s2">serializeByValueID(request);</span>
          <span class="s2">}</span>
        <span class="s2">parent = request.writtenObjects.get(value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parent) </span><span class="s4">return </span><span class="s2">parent;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&gt;= counter.objectLimit &amp;&amp; !doNotLimit.has(value))</span>
          <span class="s4">return </span><span class="s2">serializeDeferredObject(request, value);</span>
        <span class="s2">counter.objectLimit--;</span>
        <span class="s2">parent = request.deferredDebugObjects;</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s4">null </span><span class="s2">!== parent &amp;&amp;</span>
          <span class="s2">((parentPropertyName = parent.existing.get(value)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentPropertyName)</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">parent.existing.delete(value),</span>
            <span class="s2">parent.retained.delete(parentPropertyName),</span>
            <span class="s2">emitOutlinedDebugModelChunk(</span>
              <span class="s2">request,</span>
              <span class="s2">parentPropertyName,</span>
              <span class="s2">counter,</span>
              <span class="s2">value</span>
            <span class="s2">),</span>
            <span class="s2">serializeByValueID(parentPropertyName)</span>
          <span class="s2">);</span>
        <span class="s4">switch </span><span class="s2">(value.$$typeof) {</span>
          <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
            <span class="s4">null </span><span class="s2">!= value._owner &amp;&amp; outlineComponentInfo(request, value._owner);</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.type &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== value.type &amp;&amp;</span>
              <span class="s2">doNotLimit.add(value.type);</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.key &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== value.key &amp;&amp;</span>
              <span class="s2">doNotLimit.add(value.key);</span>
            <span class="s2">doNotLimit.add(value.props);</span>
            <span class="s4">null </span><span class="s2">!== value._owner &amp;&amp; doNotLimit.add(value._owner);</span>
            <span class="s2">counter = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= value._debugStack)</span>
              <span class="s4">for </span><span class="s2">(</span>
                <span class="s2">counter = filterStackTrace(</span>
                  <span class="s2">request,</span>
                  <span class="s2">parseStackTrace(value._debugStack, </span><span class="s5">1</span><span class="s2">)</span>
                <span class="s2">),</span>
                  <span class="s2">doNotLimit.add(counter),</span>
                  <span class="s2">request = </span><span class="s5">0</span><span class="s2">;</span>
                <span class="s2">request &lt; counter.length;</span>
                <span class="s2">request++</span>
              <span class="s2">)</span>
                <span class="s2">doNotLimit.add(counter[request]);</span>
            <span class="s4">return </span><span class="s2">[</span>
              <span class="s2">REACT_ELEMENT_TYPE,</span>
              <span class="s2">value.type,</span>
              <span class="s2">value.key,</span>
              <span class="s2">value.props,</span>
              <span class="s2">value._owner,</span>
              <span class="s2">counter,</span>
              <span class="s2">value._store.validated</span>
            <span class="s2">];</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.then)</span>
          <span class="s4">return </span><span class="s2">serializeDebugThenable(request, counter, value);</span>
        <span class="s4">if </span><span class="s2">(isArrayImpl(value)) </span><span class="s4">return </span><span class="s2">value;</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Map) {</span>
          <span class="s2">value = Array.from(value);</span>
          <span class="s2">counter.objectLimit++;</span>
          <span class="s4">for </span><span class="s2">(ref = </span><span class="s5">0</span><span class="s2">; ref &lt; value.length; ref++) {</span>
            <span class="s4">var </span><span class="s2">entry = value[ref];</span>
            <span class="s2">doNotLimit.add(entry);</span>
            <span class="s4">var </span><span class="s2">key = entry[</span><span class="s5">0</span><span class="s2">];</span>
            <span class="s2">entry = entry[</span><span class="s5">1</span><span class="s2">];</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">key &amp;&amp; </span><span class="s4">null </span><span class="s2">!== key &amp;&amp; doNotLimit.add(key);</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">entry &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== entry &amp;&amp;</span>
              <span class="s2">doNotLimit.add(entry);</span>
          <span class="s2">}</span>
          <span class="s4">return </span><span class="s3">&quot;$Q&quot; </span><span class="s2">+ outlineDebugModel(request, counter, value).toString(</span><span class="s5">16</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Set) {</span>
          <span class="s2">value = Array.from(value);</span>
          <span class="s2">counter.objectLimit++;</span>
          <span class="s4">for </span><span class="s2">(ref = </span><span class="s5">0</span><span class="s2">; ref &lt; value.length; ref++)</span>
            <span class="s2">(key = value[ref]),</span>
              <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">key &amp;&amp; </span><span class="s4">null </span><span class="s2">!== key &amp;&amp; doNotLimit.add(key);</span>
          <span class="s4">return </span><span class="s3">&quot;$W&quot; </span><span class="s2">+ outlineDebugModel(request, counter, value).toString(</span><span class="s5">16</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">FormData &amp;&amp; value </span><span class="s4">instanceof </span><span class="s2">FormData)</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s2">(value = Array.from(value.entries())),</span>
            <span class="s3">&quot;$K&quot; </span><span class="s2">+</span>
              <span class="s2">outlineDebugModel(</span>
                <span class="s2">request,</span>
                <span class="s2">{ objectLimit: </span><span class="s5">2 </span><span class="s2">* value.length + </span><span class="s5">1 </span><span class="s2">},</span>
                <span class="s2">value</span>
              <span class="s2">).toString(</span><span class="s5">16</span><span class="s2">)</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Error) {</span>
          <span class="s2">counter = </span><span class="s3">&quot;Error&quot;</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">env = (</span><span class="s5">0</span><span class="s2">, request.environmentName)();</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s2">(counter = value.name),</span>
              <span class="s2">(ref = String(value.message)),</span>
              <span class="s2">(key = filterStackTrace(request, parseStackTrace(value, </span><span class="s5">0</span><span class="s2">))),</span>
              <span class="s2">(entry = value.environmentName),</span>
              <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">entry &amp;&amp; (env = entry);</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
            <span class="s2">(ref =</span>
              <span class="s3">&quot;An error occurred but serializing the error message failed.&quot;</span><span class="s2">),</span>
              <span class="s2">(key = []);</span>
          <span class="s2">}</span>
          <span class="s2">request =</span>
            <span class="s3">&quot;$Z&quot; </span><span class="s2">+</span>
            <span class="s2">outlineDebugModel(</span>
              <span class="s2">request,</span>
              <span class="s2">{ objectLimit: </span><span class="s5">2 </span><span class="s2">* key.length + </span><span class="s5">1 </span><span class="s2">},</span>
              <span class="s2">{ name: counter, message: ref, stack: key, env: env }</span>
            <span class="s2">).toString(</span><span class="s5">16</span><span class="s2">);</span>
          <span class="s4">return </span><span class="s2">request;</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">ArrayBuffer)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s4">new </span><span class="s2">Uint8Array(value));</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int8Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;O&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint8Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;o&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint8ClampedArray)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;U&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int16Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint16Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;s&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int32Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;L&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint32Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;l&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Float32Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;G&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Float64Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;g&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">BigInt64Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;M&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">BigUint64Array)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;m&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">DataView)</span>
          <span class="s4">return </span><span class="s2">serializeDebugTypedArray(request, </span><span class="s3">&quot;V&quot;</span><span class="s2">, value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Blob &amp;&amp; value </span><span class="s4">instanceof </span><span class="s2">Blob)</span>
          <span class="s4">return </span><span class="s2">serializeDebugBlob(request, value);</span>
        <span class="s4">if </span><span class="s2">(getIteratorFn(value)) </span><span class="s4">return </span><span class="s2">Array.from(value);</span>
        <span class="s2">request = getPrototypeOf(value);</span>
        <span class="s4">if </span><span class="s2">(request !== ObjectPrototype &amp;&amp; </span><span class="s4">null </span><span class="s2">!== request) {</span>
          <span class="s2">counter = Object.create(</span><span class="s4">null</span><span class="s2">);</span>
          <span class="s4">for </span><span class="s2">(env </span><span class="s4">in </span><span class="s2">value)</span>
            <span class="s4">if </span><span class="s2">(hasOwnProperty.call(value, env) || isGetter(request, env))</span>
              <span class="s2">counter[env] = value[env];</span>
          <span class="s2">ref = request.constructor;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">ref ||</span>
            <span class="s2">ref.prototype !== request ||</span>
            <span class="s2">hasOwnProperty.call(value, </span><span class="s3">&quot;&quot;</span><span class="s2">) ||</span>
            <span class="s2">isGetter(request, </span><span class="s3">&quot;&quot;</span><span class="s2">) ||</span>
            <span class="s2">(counter[</span><span class="s3">&quot;&quot;</span><span class="s2">] = { $$typeof: CONSTRUCTOR_MARKER, constructor: ref });</span>
          <span class="s4">return </span><span class="s2">counter;</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">value;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;Z&quot; </span><span class="s2">=== value[value.length - </span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
          <span class="s2">parent[parentPropertyName] </span><span class="s4">instanceof </span><span class="s2">Date</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s3">&quot;$D&quot; </span><span class="s2">+ value;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">1024 </span><span class="s2">&lt;= value.length) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&gt;= counter.objectLimit)</span>
            <span class="s4">return </span><span class="s2">serializeDeferredObject(request, value);</span>
          <span class="s2">counter.objectLimit--;</span>
          <span class="s2">request.pendingDebugChunks++;</span>
          <span class="s2">counter = request.nextChunkId++;</span>
          <span class="s2">emitTextChunk(request, counter, value, !</span><span class="s5">0</span><span class="s2">);</span>
          <span class="s4">return </span><span class="s2">serializeByValueID(counter);</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s3">&quot;$&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">] ? </span><span class="s3">&quot;$&quot; </span><span class="s2">+ value : value;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s2">value;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s2">serializeNumber(value);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s3">&quot;$undefined&quot;</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s4">if </span><span class="s2">(isClientReference(value))</span>
          <span class="s4">return </span><span class="s2">serializeDebugClientReference(</span>
            <span class="s2">request,</span>
            <span class="s2">parent,</span>
            <span class="s2">parentPropertyName,</span>
            <span class="s2">value</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request.temporaryReferences &amp;&amp;</span>
          <span class="s2">((counter = request.temporaryReferences.get(value)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== counter)</span>
        <span class="s2">)</span>
          <span class="s4">return </span><span class="s3">&quot;$T&quot; </span><span class="s2">+ counter;</span>
        <span class="s2">counter = request.writtenDebugObjects;</span>
        <span class="s2">ref = counter.get(value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== ref) </span><span class="s4">return </span><span class="s2">ref;</span>
        <span class="s2">ref = Function.prototype.toString.call(value);</span>
        <span class="s2">key = value.name;</span>
        <span class="s2">key =</span>
          <span class="s3">&quot;$E&quot; </span><span class="s2">+</span>
          <span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">key</span>
            <span class="s2">? </span><span class="s3">&quot;Object.defineProperty(&quot; </span><span class="s2">+</span>
              <span class="s2">ref +</span>
              <span class="s3">',&quot;name&quot;,{value:' </span><span class="s2">+</span>
              <span class="s2">JSON.stringify(key) +</span>
              <span class="s3">&quot;})&quot;</span>
            <span class="s2">: </span><span class="s3">&quot;(&quot; </span><span class="s2">+ ref + </span><span class="s3">&quot;)&quot;</span><span class="s2">);</span>
        <span class="s2">request.pendingDebugChunks++;</span>
        <span class="s2">ref = request.nextChunkId++;</span>
        <span class="s2">key = encodeReferenceChunk(request, ref, key);</span>
        <span class="s2">request.completedDebugChunks.push(key);</span>
        <span class="s2">request = serializeByValueID(ref);</span>
        <span class="s2">counter.set(value, request);</span>
        <span class="s4">return </span><span class="s2">request;</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
        <span class="s2">counter = request.writtenSymbols.get(value);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== counter) </span><span class="s4">return </span><span class="s2">serializeByValueID(counter);</span>
        <span class="s2">value = value.description;</span>
        <span class="s2">request.pendingChunks++;</span>
        <span class="s2">counter = request.nextChunkId++;</span>
        <span class="s2">emitSymbolChunk(request, counter, value);</span>
        <span class="s4">return </span><span class="s2">serializeByValueID(counter);</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value</span>
        <span class="s2">? </span><span class="s3">&quot;$n&quot; </span><span class="s2">+ value.toString(</span><span class="s5">10</span><span class="s2">)</span>
        <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Date</span>
          <span class="s2">? </span><span class="s3">&quot;$D&quot; </span><span class="s2">+ value.toJSON()</span>
          <span class="s2">: </span><span class="s3">&quot;unknown type &quot; </span><span class="s2">+ </span><span class="s4">typeof </span><span class="s2">value;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">serializeDebugModel(request, objectLimit, model) {</span>
      <span class="s4">function </span><span class="s2">replacer(parentPropertyName, value) {</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">return </span><span class="s2">renderDebugModel(</span>
            <span class="s2">request,</span>
            <span class="s2">counter,</span>
            <span class="s4">this</span><span class="s2">,</span>
            <span class="s2">parentPropertyName,</span>
            <span class="s2">value</span>
          <span class="s2">);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s3">&quot;Unknown Value: React could not send it from the server.</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+</span>
            <span class="s2">x.message</span>
          <span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">counter = { objectLimit: objectLimit };</span>
      <span class="s2">objectLimit = debugNoOutline;</span>
      <span class="s2">debugNoOutline = model;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">return </span><span class="s2">stringify(model, replacer);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
        <span class="s4">return </span><span class="s2">stringify(</span>
          <span class="s3">&quot;Unknown Value: React could not send it from the server.</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+</span>
            <span class="s2">x.message</span>
        <span class="s2">);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">debugNoOutline = objectLimit;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitOutlinedDebugModelChunk(request, id, counter, model) {</span>
      <span class="s4">function </span><span class="s2">replacer(parentPropertyName, value) {</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">return </span><span class="s2">renderDebugModel(</span>
            <span class="s2">request,</span>
            <span class="s2">counter,</span>
            <span class="s4">this</span><span class="s2">,</span>
            <span class="s2">parentPropertyName,</span>
            <span class="s2">value</span>
          <span class="s2">);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s3">&quot;Unknown Value: React could not send it from the server.</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+</span>
            <span class="s2">x.message</span>
          <span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">model &amp;&amp; </span><span class="s4">null </span><span class="s2">!== model &amp;&amp; doNotLimit.add(model);</span>
      <span class="s4">var </span><span class="s2">prevModelRoot = debugModelRoot;</span>
      <span class="s2">debugModelRoot = model;</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">model &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== model &amp;&amp;</span>
        <span class="s2">request.writtenDebugObjects.set(model, serializeByValueID(id));</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">json = stringify(model, replacer);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
        <span class="s2">json = stringify(</span>
          <span class="s3">&quot;Unknown Value: React could not send it from the server.</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+</span>
            <span class="s2">x.message</span>
        <span class="s2">);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">debugModelRoot = prevModelRoot;</span>
      <span class="s2">}</span>
      <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ json + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
      <span class="s2">id = stringToChunk(id);</span>
      <span class="s2">request.completedDebugChunks.push(id);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">outlineDebugModel(request, counter, model) {</span>
      <span class="s4">var </span><span class="s2">id = request.nextChunkId++;</span>
      <span class="s2">request.pendingDebugChunks++;</span>
      <span class="s2">emitOutlinedDebugModelChunk(request, id, counter, model);</span>
      <span class="s4">return </span><span class="s2">id;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitTimeOriginChunk(request, timeOrigin) {</span>
      <span class="s2">request.pendingDebugChunks++;</span>
      <span class="s2">timeOrigin = stringToChunk(</span><span class="s3">&quot;:N&quot; </span><span class="s2">+ timeOrigin + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">);</span>
      <span class="s2">request.completedDebugChunks.push(timeOrigin);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">forwardDebugInfo(request$jscomp$1, task, debugInfo) {</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">id = task.id, i = </span><span class="s5">0</span><span class="s2">; i &lt; debugInfo.length; i++) {</span>
        <span class="s4">var </span><span class="s2">info = debugInfo[i];</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">info.time)</span>
          <span class="s2">markOperationEndTime(request$jscomp$1, task, info.time);</span>
        <span class="s4">else if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">info.name)</span>
          <span class="s2">outlineComponentInfo(request$jscomp$1, info),</span>
            <span class="s2">request$jscomp$1.pendingChunks++,</span>
            <span class="s2">emitDebugChunk(request$jscomp$1, id, info);</span>
        <span class="s4">else if </span><span class="s2">(info.awaited) {</span>
          <span class="s4">var </span><span class="s2">ioInfo = info.awaited;</span>
          <span class="s4">if </span><span class="s2">(!(ioInfo.end &lt;= request$jscomp$1.timeOrigin)) {</span>
            <span class="s4">var </span><span class="s2">request = request$jscomp$1,</span>
              <span class="s2">ioInfo$jscomp$0 = ioInfo;</span>
            <span class="s4">if </span><span class="s2">(!request.writtenObjects.has(ioInfo$jscomp$0)) {</span>
              <span class="s2">request.pendingDebugChunks++;</span>
              <span class="s4">var </span><span class="s2">id$jscomp$0 = request.nextChunkId++,</span>
                <span class="s2">owner = ioInfo$jscomp$0.owner;</span>
              <span class="s4">null </span><span class="s2">!= owner &amp;&amp; outlineComponentInfo(request, owner);</span>
              <span class="s4">var </span><span class="s2">debugStack =</span>
                <span class="s4">null </span><span class="s2">== ioInfo$jscomp$0.stack &amp;&amp;</span>
                <span class="s4">null </span><span class="s2">!= ioInfo$jscomp$0.debugStack</span>
                  <span class="s2">? filterStackTrace(</span>
                      <span class="s2">request,</span>
                      <span class="s2">parseStackTrace(ioInfo$jscomp$0.debugStack, </span><span class="s5">1</span><span class="s2">)</span>
                    <span class="s2">)</span>
                  <span class="s2">: ioInfo$jscomp$0.stack;</span>
              <span class="s4">var </span><span class="s2">request$jscomp$0 = request,</span>
                <span class="s2">id$jscomp$1 = id$jscomp$0,</span>
                <span class="s2">value = ioInfo$jscomp$0.value,</span>
                <span class="s2">env = ioInfo$jscomp$0.env,</span>
                <span class="s2">objectLimit = </span><span class="s5">10</span><span class="s2">;</span>
              <span class="s2">debugStack &amp;&amp; (objectLimit += debugStack.length);</span>
              <span class="s4">var </span><span class="s2">debugIOInfo = {</span>
                <span class="s2">name: ioInfo$jscomp$0.name,</span>
                <span class="s2">start: ioInfo$jscomp$0.start - request$jscomp$0.timeOrigin,</span>
                <span class="s2">end: ioInfo$jscomp$0.end - request$jscomp$0.timeOrigin</span>
              <span class="s2">};</span>
              <span class="s4">null </span><span class="s2">!= env &amp;&amp; (debugIOInfo.env = env);</span>
              <span class="s4">null </span><span class="s2">!= debugStack &amp;&amp; (debugIOInfo.stack = debugStack);</span>
              <span class="s4">null </span><span class="s2">!= owner &amp;&amp; (debugIOInfo.owner = owner);</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== value &amp;&amp; (debugIOInfo.value = value);</span>
              <span class="s2">value = serializeDebugModel(</span>
                <span class="s2">request$jscomp$0,</span>
                <span class="s2">objectLimit,</span>
                <span class="s2">debugIOInfo</span>
              <span class="s2">);</span>
              <span class="s2">id$jscomp$1 = id$jscomp$1.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:J&quot; </span><span class="s2">+ value + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
              <span class="s2">id$jscomp$1 = stringToChunk(id$jscomp$1);</span>
              <span class="s2">request$jscomp$0.completedDebugChunks.push(id$jscomp$1);</span>
              <span class="s2">request.writtenDebugObjects.set(</span>
                <span class="s2">ioInfo$jscomp$0,</span>
                <span class="s2">serializeByValueID(id$jscomp$0)</span>
              <span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s2">request =</span>
              <span class="s4">null </span><span class="s2">== info.stack &amp;&amp; </span><span class="s4">null </span><span class="s2">!= info.debugStack</span>
                <span class="s2">? filterStackTrace(</span>
                    <span class="s2">request$jscomp$1,</span>
                    <span class="s2">parseStackTrace(info.debugStack, </span><span class="s5">1</span><span class="s2">)</span>
                  <span class="s2">)</span>
                <span class="s2">: info.stack;</span>
            <span class="s2">ioInfo = { awaited: ioInfo };</span>
            <span class="s4">null </span><span class="s2">!= info.env &amp;&amp; (ioInfo.env = info.env);</span>
            <span class="s4">null </span><span class="s2">!= info.owner &amp;&amp; (ioInfo.owner = info.owner);</span>
            <span class="s4">null </span><span class="s2">!= request &amp;&amp; (ioInfo.stack = request);</span>
            <span class="s2">request$jscomp$1.pendingChunks++;</span>
            <span class="s2">emitDebugChunk(request$jscomp$1, id, ioInfo);</span>
          <span class="s2">}</span>
        <span class="s2">} </span><span class="s4">else</span>
          <span class="s2">request$jscomp$1.pendingChunks++,</span>
            <span class="s2">emitDebugChunk(request$jscomp$1, id, info);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">forwardDebugInfoFromThenable(request, task, thenable) {</span>
      <span class="s2">(thenable = thenable._debugInfo) &amp;&amp;</span>
        <span class="s2">forwardDebugInfo(request, task, thenable);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">forwardDebugInfoFromCurrentContext(request, task, thenable) {</span>
      <span class="s2">(thenable = thenable._debugInfo) &amp;&amp;</span>
        <span class="s2">forwardDebugInfo(request, task, thenable);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">forwardDebugInfoFromAbortedTask(request, task) {</span>
      <span class="s4">var </span><span class="s2">model = task.model;</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">model &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== model &amp;&amp;</span>
        <span class="s2">(model = model._debugInfo) &amp;&amp;</span>
        <span class="s2">forwardDebugInfo(request, task, model);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitTimingChunk(request, id, timestamp) {</span>
      <span class="s2">request.pendingChunks++;</span>
      <span class="s4">var </span><span class="s2">json = </span><span class="s3">'{&quot;time&quot;:' </span><span class="s2">+ (timestamp - request.timeOrigin) + </span><span class="s3">&quot;}&quot;</span><span class="s2">;</span>
      <span class="s4">null </span><span class="s2">!== request.debugDestination</span>
        <span class="s2">? ((timestamp = request.nextChunkId++),</span>
          <span class="s2">(json = timestamp.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ json + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
          <span class="s2">request.pendingDebugChunks++,</span>
          <span class="s2">request.completedDebugChunks.push(stringToChunk(json)),</span>
          <span class="s2">(id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">':D&quot;$' </span><span class="s2">+ timestamp.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">'&quot;</span><span class="s6">\n</span><span class="s3">'</span><span class="s2">),</span>
          <span class="s2">request.completedRegularChunks.push(stringToChunk(id)))</span>
        <span class="s2">: ((id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:D&quot; </span><span class="s2">+ json + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
          <span class="s2">request.completedRegularChunks.push(stringToChunk(id)));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">markOperationEndTime(request, task, timestamp) {</span>
      <span class="s2">(request.status === ABORTING &amp;&amp; timestamp &gt; request.abortTime) ||</span>
        <span class="s2">(timestamp &gt; task.time</span>
          <span class="s2">? (emitTimingChunk(request, task.id, timestamp),</span>
            <span class="s2">(task.time = timestamp))</span>
          <span class="s2">: emitTimingChunk(request, task.id, task.time));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">emitChunk(request, task, value) {</span>
      <span class="s4">var </span><span class="s2">id = task.id;</span>
      <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== byteLengthOfChunk</span>
        <span class="s2">? ((task = TaintRegistryValues.get(value)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== task &amp;&amp; throwTaintViolation(task.message),</span>
          <span class="s2">emitTextChunk(request, id, value, !</span><span class="s5">1</span><span class="s2">))</span>
        <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">ArrayBuffer</span>
          <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s4">new </span><span class="s2">Uint8Array(value), !</span><span class="s5">1</span><span class="s2">)</span>
          <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Int8Array</span>
            <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;O&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
            <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Uint8Array</span>
              <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;o&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
              <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Uint8ClampedArray</span>
                <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;U&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Int16Array</span>
                  <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;S&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                  <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Uint16Array</span>
                    <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;s&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                    <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Int32Array</span>
                      <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;L&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                      <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Uint32Array</span>
                        <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;l&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                        <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Float32Array</span>
                          <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;G&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                          <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Float64Array</span>
                            <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;g&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                            <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">BigInt64Array</span>
                              <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;M&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                              <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">BigUint64Array</span>
                                <span class="s2">? emitTypedArrayChunk(</span>
                                    <span class="s2">request,</span>
                                    <span class="s2">id,</span>
                                    <span class="s3">&quot;m&quot;</span><span class="s2">,</span>
                                    <span class="s2">value,</span>
                                    <span class="s2">!</span><span class="s5">1</span>
                                  <span class="s2">)</span>
                                <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">DataView</span>
                                  <span class="s2">? emitTypedArrayChunk(</span>
                                      <span class="s2">request,</span>
                                      <span class="s2">id,</span>
                                      <span class="s3">&quot;V&quot;</span><span class="s2">,</span>
                                      <span class="s2">value,</span>
                                      <span class="s2">!</span><span class="s5">1</span>
                                    <span class="s2">)</span>
                                  <span class="s2">: ((value = stringify(value, task.toJSON)),</span>
                                    <span class="s2">emitModelChunk(request, task.id, value));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">erroredTask(request, task, error) {</span>
      <span class="s2">task.timed &amp;&amp; markOperationEndTime(request, task, performance.now());</span>
      <span class="s2">task.status = </span><span class="s5">4</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span>
        <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">error &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== error &amp;&amp;</span>
        <span class="s2">error.$$typeof === REACT_POSTPONE_TYPE</span>
      <span class="s2">)</span>
        <span class="s2">logPostpone(request, error.message, task),</span>
          <span class="s2">emitPostponeChunk(request, task.id, error);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">digest = logRecoverableError(request, error, task);</span>
        <span class="s2">emitErrorChunk(request, task.id, digest, error, !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s2">request.abortableTasks.delete(task);</span>
      <span class="s2">callOnAllReadyIfReady(request);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">retryTask(request, task) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== task.status) {</span>
        <span class="s4">var </span><span class="s2">prevCanEmitDebugInfo = canEmitDebugInfo;</span>
        <span class="s2">task.status = </span><span class="s5">5</span><span class="s2">;</span>
        <span class="s4">var </span><span class="s2">parentSerializedSize = serializedSize;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">modelRoot = task.model;</span>
          <span class="s2">canEmitDebugInfo = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">resolvedModel = renderModelDestructive(</span>
            <span class="s2">request,</span>
            <span class="s2">task,</span>
            <span class="s2">emptyRoot,</span>
            <span class="s3">&quot;&quot;</span><span class="s2">,</span>
            <span class="s2">task.model</span>
          <span class="s2">);</span>
          <span class="s2">canEmitDebugInfo = !</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">modelRoot = resolvedModel;</span>
          <span class="s2">task.keyPath = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">task.implicitSlot = !</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s4">var </span><span class="s2">currentEnv = (</span><span class="s5">0</span><span class="s2">, request.environmentName)();</span>
          <span class="s2">currentEnv !== task.environmentName &amp;&amp;</span>
            <span class="s2">(request.pendingChunks++,</span>
            <span class="s2">emitDebugChunk(request, task.id, { env: currentEnv }));</span>
          <span class="s2">task.timed &amp;&amp; markOperationEndTime(request, task, performance.now());</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">resolvedModel &amp;&amp; </span><span class="s4">null </span><span class="s2">!== resolvedModel)</span>
            <span class="s2">request.writtenObjects.set(</span>
              <span class="s2">resolvedModel,</span>
              <span class="s2">serializeByValueID(task.id)</span>
            <span class="s2">),</span>
              <span class="s2">emitChunk(request, task, resolvedModel);</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">json = stringify(resolvedModel);</span>
            <span class="s2">emitModelChunk(request, task.id, json);</span>
          <span class="s2">}</span>
          <span class="s2">task.status = </span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">request.abortableTasks.delete(task);</span>
          <span class="s2">callOnAllReadyIfReady(request);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(thrownValue) {</span>
          <span class="s4">if </span><span class="s2">(request.status === ABORTING)</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">(request.abortableTasks.delete(task),</span>
              <span class="s2">(task.status = </span><span class="s5">0</span><span class="s2">),</span>
              <span class="s5">21 </span><span class="s2">=== request.type)</span>
            <span class="s2">)</span>
              <span class="s2">haltTask(task), finishHaltedTask(task, request);</span>
            <span class="s4">else </span><span class="s2">{</span>
              <span class="s4">var </span><span class="s2">errorId = request.fatalError;</span>
              <span class="s2">abortTask(task);</span>
              <span class="s2">finishAbortedTask(task, request, errorId);</span>
            <span class="s2">}</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">x =</span>
              <span class="s2">thrownValue === SuspenseException</span>
                <span class="s2">? getSuspendedThenable()</span>
                <span class="s2">: thrownValue;</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">x &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== x &amp;&amp;</span>
              <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">x.then</span>
            <span class="s2">) {</span>
              <span class="s2">task.status = </span><span class="s5">0</span><span class="s2">;</span>
              <span class="s2">task.thenableState = getThenableStateAfterSuspending();</span>
              <span class="s4">var </span><span class="s2">ping = task.ping;</span>
              <span class="s2">x.then(ping, ping);</span>
            <span class="s2">} </span><span class="s4">else </span><span class="s2">erroredTask(request, task, x);</span>
          <span class="s2">}</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">(canEmitDebugInfo = prevCanEmitDebugInfo),</span>
            <span class="s2">(serializedSize = parentSerializedSize);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">tryStreamTask(request, task) {</span>
      <span class="s4">var </span><span class="s2">prevCanEmitDebugInfo = canEmitDebugInfo;</span>
      <span class="s2">canEmitDebugInfo = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">parentSerializedSize = serializedSize;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">emitChunk(request, task, task.model);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(serializedSize = parentSerializedSize),</span>
          <span class="s2">(canEmitDebugInfo = prevCanEmitDebugInfo);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">performWork(request) {</span>
      <span class="s4">var </span><span class="s2">prevDispatcher = ReactSharedInternalsServer.H;</span>
      <span class="s2">ReactSharedInternalsServer.H = HooksDispatcher;</span>
      <span class="s4">var </span><span class="s2">prevRequest = currentRequest;</span>
      <span class="s2">currentRequest$1 = currentRequest = request;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">pingedTasks = request.pingedTasks;</span>
        <span class="s2">request.pingedTasks = [];</span>
        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; pingedTasks.length; i++)</span>
          <span class="s2">retryTask(request, pingedTasks[i]);</span>
        <span class="s2">flushCompletedChunks(request);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
        <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">), fatalError(request, error);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(ReactSharedInternalsServer.H = prevDispatcher),</span>
          <span class="s2">(currentRequest$1 = </span><span class="s4">null</span><span class="s2">),</span>
          <span class="s2">(currentRequest = prevRequest);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">abortTask(task) {</span>
      <span class="s5">0 </span><span class="s2">=== task.status &amp;&amp; (task.status = </span><span class="s5">3</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">finishAbortedTask(task, request, errorId) {</span>
      <span class="s5">3 </span><span class="s2">=== task.status &amp;&amp;</span>
        <span class="s2">(forwardDebugInfoFromAbortedTask(request, task),</span>
        <span class="s2">task.timed &amp;&amp; markOperationEndTime(request, task, request.abortTime),</span>
        <span class="s2">(errorId = serializeByValueID(errorId)),</span>
        <span class="s2">(task = encodeReferenceChunk(request, task.id, errorId)),</span>
        <span class="s2">request.completedErrorChunks.push(task));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">haltTask(task) {</span>
      <span class="s5">0 </span><span class="s2">=== task.status &amp;&amp; (task.status = </span><span class="s5">3</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">finishHaltedTask(task, request) {</span>
      <span class="s5">3 </span><span class="s2">=== task.status &amp;&amp;</span>
        <span class="s2">(forwardDebugInfoFromAbortedTask(request, task),</span>
        <span class="s2">request.pendingChunks--);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">flushCompletedChunks(request) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== request.debugDestination) {</span>
        <span class="s4">var </span><span class="s2">debugDestination = request.debugDestination;</span>
        <span class="s2">currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">);</span>
        <span class="s2">writtenBytes = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s4">var </span><span class="s2">debugChunks = request.completedDebugChunks, i = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">i &lt; debugChunks.length;</span>
            <span class="s2">i++</span>
          <span class="s2">)</span>
            <span class="s2">request.pendingDebugChunks--,</span>
              <span class="s2">writeChunkAndReturn(debugDestination, debugChunks[i]);</span>
          <span class="s2">debugChunks.splice(</span><span class="s5">0</span><span class="s2">, i);</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">completeWriting(debugDestination);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s2">debugDestination = request.destination;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== debugDestination) {</span>
        <span class="s2">currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">);</span>
        <span class="s2">writtenBytes = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">importsChunks = request.completedImportChunks;</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">debugChunks = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">debugChunks &lt; importsChunks.length;</span>
            <span class="s2">debugChunks++</span>
          <span class="s2">)</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">(request.pendingChunks--,</span>
              <span class="s2">!writeChunkAndReturn(</span>
                <span class="s2">debugDestination,</span>
                <span class="s2">importsChunks[debugChunks]</span>
              <span class="s2">))</span>
            <span class="s2">) {</span>
              <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s2">debugChunks++;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">importsChunks.splice(</span><span class="s5">0</span><span class="s2">, debugChunks);</span>
          <span class="s4">var </span><span class="s2">hintChunks = request.completedHintChunks;</span>
          <span class="s4">for </span><span class="s2">(debugChunks = </span><span class="s5">0</span><span class="s2">; debugChunks &lt; hintChunks.length; debugChunks++)</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">!writeChunkAndReturn(debugDestination, hintChunks[debugChunks])</span>
            <span class="s2">) {</span>
              <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s2">debugChunks++;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">hintChunks.splice(</span><span class="s5">0</span><span class="s2">, debugChunks);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== request.debugDestination) {</span>
            <span class="s4">var </span><span class="s2">_debugChunks = request.completedDebugChunks;</span>
            <span class="s4">for </span><span class="s2">(</span>
              <span class="s2">debugChunks = </span><span class="s5">0</span><span class="s2">;</span>
              <span class="s2">debugChunks &lt; _debugChunks.length;</span>
              <span class="s2">debugChunks++</span>
            <span class="s2">)</span>
              <span class="s4">if </span><span class="s2">(</span>
                <span class="s2">(request.pendingDebugChunks--,</span>
                <span class="s2">!writeChunkAndReturn(</span>
                  <span class="s2">debugDestination,</span>
                  <span class="s2">_debugChunks[debugChunks]</span>
                <span class="s2">))</span>
              <span class="s2">) {</span>
                <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s2">debugChunks++;</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s2">}</span>
            <span class="s2">_debugChunks.splice(</span><span class="s5">0</span><span class="s2">, debugChunks);</span>
          <span class="s2">}</span>
          <span class="s4">var </span><span class="s2">regularChunks = request.completedRegularChunks;</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">debugChunks = </span><span class="s5">0</span><span class="s2">;</span>
            <span class="s2">debugChunks &lt; regularChunks.length;</span>
            <span class="s2">debugChunks++</span>
          <span class="s2">)</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">(request.pendingChunks--,</span>
              <span class="s2">!writeChunkAndReturn(</span>
                <span class="s2">debugDestination,</span>
                <span class="s2">regularChunks[debugChunks]</span>
              <span class="s2">))</span>
            <span class="s2">) {</span>
              <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s2">debugChunks++;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">regularChunks.splice(</span><span class="s5">0</span><span class="s2">, debugChunks);</span>
          <span class="s4">var </span><span class="s2">errorChunks = request.completedErrorChunks;</span>
          <span class="s4">for </span><span class="s2">(debugChunks = </span><span class="s5">0</span><span class="s2">; debugChunks &lt; errorChunks.length; debugChunks++)</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s2">(request.pendingChunks--,</span>
              <span class="s2">!writeChunkAndReturn(debugDestination, errorChunks[debugChunks]))</span>
            <span class="s2">) {</span>
              <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
              <span class="s2">debugChunks++;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s2">}</span>
          <span class="s2">errorChunks.splice(</span><span class="s5">0</span><span class="s2">, debugChunks);</span>
        <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
          <span class="s2">(request.flushScheduled = !</span><span class="s5">1</span><span class="s2">), completeWriting(debugDestination);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s5">0 </span><span class="s2">=== request.pendingChunks &amp;&amp;</span>
        <span class="s2">((importsChunks = request.debugDestination),</span>
        <span class="s5">0 </span><span class="s2">=== request.pendingDebugChunks</span>
          <span class="s2">? (</span><span class="s4">null </span><span class="s2">!== importsChunks &amp;&amp;</span>
              <span class="s2">(importsChunks.close(), (request.debugDestination = </span><span class="s4">null</span><span class="s2">)),</span>
            <span class="s2">cleanupTaintQueue(request),</span>
            <span class="s2">request.status &lt; ABORTING &amp;&amp;</span>
              <span class="s2">request.cacheController.abort(</span>
                <span class="s2">Error(</span>
                  <span class="s3">&quot;This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.&quot;</span>
                <span class="s2">)</span>
              <span class="s2">),</span>
            <span class="s4">null </span><span class="s2">!== request.destination &amp;&amp;</span>
              <span class="s2">((request.status = CLOSED),</span>
              <span class="s2">request.destination.close(),</span>
              <span class="s2">(request.destination = </span><span class="s4">null</span><span class="s2">)),</span>
            <span class="s4">null </span><span class="s2">!== request.debugDestination &amp;&amp;</span>
              <span class="s2">(request.debugDestination.close(),</span>
              <span class="s2">(request.debugDestination = </span><span class="s4">null</span><span class="s2">)))</span>
          <span class="s2">: </span><span class="s4">null </span><span class="s2">!== importsChunks &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!== request.destination &amp;&amp;</span>
            <span class="s2">((request.status = CLOSED),</span>
            <span class="s2">request.destination.close(),</span>
            <span class="s2">(request.destination = </span><span class="s4">null</span><span class="s2">)));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">startWork(request) {</span>
      <span class="s2">request.flushScheduled = </span><span class="s4">null </span><span class="s2">!== request.destination;</span>
      <span class="s2">supportsRequestStorage</span>
        <span class="s2">? scheduleMicrotask(</span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s2">requestStorage.run(request, performWork, request);</span>
          <span class="s2">})</span>
        <span class="s2">: scheduleMicrotask(</span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">return </span><span class="s2">performWork(request);</span>
          <span class="s2">});</span>
      <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s5">10 </span><span class="s2">=== request.status &amp;&amp; (request.status = </span><span class="s5">11</span><span class="s2">);</span>
      <span class="s2">}, </span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">enqueueFlush(request) {</span>
      <span class="s2">!</span><span class="s5">1 </span><span class="s2">!== request.flushScheduled ||</span>
        <span class="s5">0 </span><span class="s2">!== request.pingedTasks.length ||</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== request.destination &amp;&amp; </span><span class="s4">null </span><span class="s2">=== request.debugDestination) ||</span>
        <span class="s2">((request.flushScheduled = !</span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">request.flushScheduled = !</span><span class="s5">1</span><span class="s2">;</span>
          <span class="s2">flushCompletedChunks(request);</span>
        <span class="s2">}, </span><span class="s5">0</span><span class="s2">));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">callOnAllReadyIfReady(request) {</span>
      <span class="s5">0 </span><span class="s2">=== request.abortableTasks.size &amp;&amp;</span>
        <span class="s2">((request = request.onAllReady), request());</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">startFlowing(request, destination) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== request.status)</span>
        <span class="s2">(request.status = CLOSED),</span>
          <span class="s2">closeWithError(destination, request.fatalError);</span>
      <span class="s4">else if </span><span class="s2">(request.status !== CLOSED &amp;&amp; </span><span class="s4">null </span><span class="s2">=== request.destination) {</span>
        <span class="s2">request.destination = destination;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">flushCompletedChunks(request);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
          <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">), fatalError(request, error);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">finishHalt(request, abortedTasks) {</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">abortedTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
          <span class="s4">return </span><span class="s2">finishHaltedTask(task, request);</span>
        <span class="s2">});</span>
        <span class="s4">var </span><span class="s2">onAllReady = request.onAllReady;</span>
        <span class="s2">onAllReady();</span>
        <span class="s2">flushCompletedChunks(request);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
        <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">), fatalError(request, error);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">finishAbort(request, abortedTasks, errorId) {</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s2">abortedTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
          <span class="s4">return </span><span class="s2">finishAbortedTask(task, request, errorId);</span>
        <span class="s2">});</span>
        <span class="s4">var </span><span class="s2">onAllReady = request.onAllReady;</span>
        <span class="s2">onAllReady();</span>
        <span class="s2">flushCompletedChunks(request);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
        <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">), fatalError(request, error);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">abort(request, reason) {</span>
      <span class="s4">if </span><span class="s2">(!(</span><span class="s5">11 </span><span class="s2">&lt; request.status))</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">request.status = ABORTING;</span>
          <span class="s2">request.abortTime = performance.now();</span>
          <span class="s2">request.cacheController.abort(reason);</span>
          <span class="s4">var </span><span class="s2">abortableTasks = request.abortableTasks;</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt; abortableTasks.size)</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s5">21 </span><span class="s2">=== request.type)</span>
              <span class="s2">abortableTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
                <span class="s4">return </span><span class="s2">haltTask(task, request);</span>
              <span class="s2">}),</span>
                <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
                  <span class="s4">return </span><span class="s2">finishHalt(request, abortableTasks);</span>
                <span class="s2">}, </span><span class="s5">0</span><span class="s2">);</span>
            <span class="s4">else if </span><span class="s2">(</span>
              <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reason &amp;&amp;</span>
              <span class="s4">null </span><span class="s2">!== reason &amp;&amp;</span>
              <span class="s2">reason.$$typeof === REACT_POSTPONE_TYPE</span>
            <span class="s2">) {</span>
              <span class="s2">logPostpone(request, reason.message, </span><span class="s4">null</span><span class="s2">);</span>
              <span class="s4">var </span><span class="s2">errorId = request.nextChunkId++;</span>
              <span class="s2">request.fatalError = errorId;</span>
              <span class="s2">request.pendingChunks++;</span>
              <span class="s2">emitPostponeChunk(request, errorId, reason);</span>
              <span class="s2">abortableTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
                <span class="s4">return </span><span class="s2">abortTask(task, request, errorId);</span>
              <span class="s2">});</span>
              <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">finishAbort(request, abortableTasks, errorId);</span>
              <span class="s2">}, </span><span class="s5">0</span><span class="s2">);</span>
            <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
              <span class="s4">var </span><span class="s2">error =</span>
                  <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== reason</span>
                    <span class="s2">? Error(</span>
                        <span class="s3">&quot;The render was aborted by the server without a reason.&quot;</span>
                      <span class="s2">)</span>
                    <span class="s2">: </span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reason &amp;&amp;</span>
                        <span class="s4">null </span><span class="s2">!== reason &amp;&amp;</span>
                        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reason.then</span>
                      <span class="s2">? Error(</span>
                          <span class="s3">&quot;The render was aborted by the server with a promise.&quot;</span>
                        <span class="s2">)</span>
                      <span class="s2">: reason,</span>
                <span class="s2">digest = logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">),</span>
                <span class="s2">_errorId2 = request.nextChunkId++;</span>
              <span class="s2">request.fatalError = _errorId2;</span>
              <span class="s2">request.pendingChunks++;</span>
              <span class="s2">emitErrorChunk(request, _errorId2, digest, error, !</span><span class="s5">1</span><span class="s2">);</span>
              <span class="s2">abortableTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
                <span class="s4">return </span><span class="s2">abortTask(task, request, _errorId2);</span>
              <span class="s2">});</span>
              <span class="s2">setTimeout(</span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s4">return </span><span class="s2">finishAbort(request, abortableTasks, _errorId2);</span>
              <span class="s2">}, </span><span class="s5">0</span><span class="s2">);</span>
            <span class="s2">}</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">onAllReady = request.onAllReady;</span>
            <span class="s2">onAllReady();</span>
            <span class="s2">flushCompletedChunks(request);</span>
          <span class="s2">}</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error$2) {</span>
          <span class="s2">logRecoverableError(request, error$2, </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">fatalError(request, error$2);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">fromHex(str) {</span>
      <span class="s4">return </span><span class="s2">parseInt(str, </span><span class="s5">16</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">closeDebugChannel(request) {</span>
      <span class="s4">var </span><span class="s2">deferredDebugObjects = request.deferredDebugObjects;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== deferredDebugObjects)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.&quot;</span>
        <span class="s2">);</span>
      <span class="s2">deferredDebugObjects.retained.forEach(</span><span class="s4">function </span><span class="s2">(value, id) {</span>
        <span class="s2">request.pendingDebugChunks--;</span>
        <span class="s2">deferredDebugObjects.retained.delete(id);</span>
        <span class="s2">deferredDebugObjects.existing.delete(value);</span>
      <span class="s2">});</span>
      <span class="s2">enqueueFlush(request);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">resolveServerReference(bundlerConfig, id) {</span>
      <span class="s4">var </span><span class="s2">name = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s2">resolvedModuleData = bundlerConfig[id];</span>
      <span class="s4">if </span><span class="s2">(resolvedModuleData) name = resolvedModuleData.name;</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">idx = id.lastIndexOf(</span><span class="s3">&quot;#&quot;</span><span class="s2">);</span>
        <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== idx &amp;&amp;</span>
          <span class="s2">((name = id.slice(idx + </span><span class="s5">1</span><span class="s2">)),</span>
          <span class="s2">(resolvedModuleData = bundlerConfig[id.slice(</span><span class="s5">0</span><span class="s2">, idx)]));</span>
        <span class="s4">if </span><span class="s2">(!resolvedModuleData)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">'Could not find the module &quot;' </span><span class="s2">+</span>
              <span class="s2">id +</span>
              <span class="s3">'&quot; in the React Server Manifest. This is probably a bug in the React Server Components bundler.'</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">resolvedModuleData.async</span>
        <span class="s2">? [resolvedModuleData.id, resolvedModuleData.chunks, name, </span><span class="s5">1</span><span class="s2">]</span>
        <span class="s2">: [resolvedModuleData.id, resolvedModuleData.chunks, name];</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">requireAsyncModule(id) {</span>
      <span class="s4">var </span><span class="s2">promise = globalThis.__next_require__(id);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">promise.then || </span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== promise.status)</span>
        <span class="s4">return null</span><span class="s2">;</span>
      <span class="s2">promise.then(</span>
        <span class="s4">function </span><span class="s2">(value) {</span>
          <span class="s2">promise.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
          <span class="s2">promise.value = value;</span>
        <span class="s2">},</span>
        <span class="s4">function </span><span class="s2">(reason) {</span>
          <span class="s2">promise.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
          <span class="s2">promise.reason = reason;</span>
        <span class="s2">}</span>
      <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">promise;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">ignoreReject() {}</span>
    <span class="s4">function </span><span class="s2">preloadModule(metadata) {</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s4">var </span><span class="s2">chunks = metadata[</span><span class="s5">1</span><span class="s2">], promises = [], i = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">i &lt; chunks.length;</span>

      <span class="s2">) {</span>
        <span class="s4">var </span><span class="s2">chunkId = chunks[i++];</span>
        <span class="s2">chunks[i++];</span>
        <span class="s4">var </span><span class="s2">entry = chunkCache.get(chunkId);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== entry) {</span>
          <span class="s2">entry = __webpack_chunk_load__(chunkId);</span>
          <span class="s2">promises.push(entry);</span>
          <span class="s4">var </span><span class="s2">resolve = chunkCache.set.bind(chunkCache, chunkId, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">entry.then(resolve, ignoreReject);</span>
          <span class="s2">chunkCache.set(chunkId, entry);</span>
        <span class="s2">} </span><span class="s4">else null </span><span class="s2">!== entry &amp;&amp; promises.push(entry);</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s5">4 </span><span class="s2">=== metadata.length</span>
        <span class="s2">? </span><span class="s5">0 </span><span class="s2">=== promises.length</span>
          <span class="s2">? requireAsyncModule(metadata[</span><span class="s5">0</span><span class="s2">])</span>
          <span class="s2">: Promise.all(promises).then(</span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">return </span><span class="s2">requireAsyncModule(metadata[</span><span class="s5">0</span><span class="s2">]);</span>
            <span class="s2">})</span>
        <span class="s2">: </span><span class="s5">0 </span><span class="s2">&lt; promises.length</span>
          <span class="s2">? Promise.all(promises)</span>
          <span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">requireModule(metadata) {</span>
      <span class="s4">var </span><span class="s2">moduleExports = globalThis.__next_require__(metadata[</span><span class="s5">0</span><span class="s2">]);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">4 </span><span class="s2">=== metadata.length &amp;&amp; </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">moduleExports.then)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== moduleExports.status)</span>
          <span class="s2">moduleExports = moduleExports.value;</span>
        <span class="s4">else throw </span><span class="s2">moduleExports.reason;</span>
      <span class="s4">return </span><span class="s3">&quot;*&quot; </span><span class="s2">=== metadata[</span><span class="s5">2</span><span class="s2">]</span>
        <span class="s2">? moduleExports</span>
        <span class="s2">: </span><span class="s3">&quot;&quot; </span><span class="s2">=== metadata[</span><span class="s5">2</span><span class="s2">]</span>
          <span class="s2">? moduleExports.__esModule</span>
            <span class="s2">? moduleExports.default</span>
            <span class="s2">: moduleExports</span>
          <span class="s2">: moduleExports[metadata[</span><span class="s5">2</span><span class="s2">]];</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">Chunk(status, value, reason, response) {</span>
      <span class="s4">this</span><span class="s2">.status = status;</span>
      <span class="s4">this</span><span class="s2">.value = value;</span>
      <span class="s4">this</span><span class="s2">.reason = reason;</span>
      <span class="s4">this</span><span class="s2">._response = response;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createPendingChunk(response) {</span>
      <span class="s4">return new </span><span class="s2">Chunk(</span><span class="s3">&quot;pending&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, response);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">wakeChunk(listeners, value) {</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; listeners.length; i++) (</span><span class="s5">0</span><span class="s2">, listeners[i])(value);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">triggerErrorOnChunk(chunk, error) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">!== chunk.status &amp;&amp; </span><span class="s3">&quot;blocked&quot; </span><span class="s2">!== chunk.status)</span>
        <span class="s2">chunk.reason.error(error);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">listeners = chunk.reason;</span>
        <span class="s2">chunk.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
        <span class="s2">chunk.reason = error;</span>
        <span class="s4">null </span><span class="s2">!== listeners &amp;&amp; wakeChunk(listeners, error);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">resolveModelChunk(chunk, value, id) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">!== chunk.status)</span>
        <span class="s2">(chunk = chunk.reason),</span>
          <span class="s3">&quot;C&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s2">? chunk.close(</span><span class="s3">&quot;C&quot; </span><span class="s2">=== value ? </span><span class="s3">'&quot;$undefined&quot;' </span><span class="s2">: value.slice(</span><span class="s5">1</span><span class="s2">))</span>
            <span class="s2">: chunk.enqueueModel(value);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">resolveListeners = chunk.value,</span>
          <span class="s2">rejectListeners = chunk.reason;</span>
        <span class="s2">chunk.status = </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">;</span>
        <span class="s2">chunk.value = value;</span>
        <span class="s2">chunk.reason = id;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== resolveListeners)</span>
          <span class="s4">switch </span><span class="s2">((initializeModelChunk(chunk), chunk.status)) {</span>
            <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
              <span class="s2">wakeChunk(resolveListeners, chunk.value);</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
            <span class="s4">case </span><span class="s3">&quot;cyclic&quot;</span><span class="s2">:</span>
              <span class="s4">if </span><span class="s2">(chunk.value)</span>
                <span class="s4">for </span><span class="s2">(value = </span><span class="s5">0</span><span class="s2">; value &lt; resolveListeners.length; value++)</span>
                  <span class="s2">chunk.value.push(resolveListeners[value]);</span>
              <span class="s4">else </span><span class="s2">chunk.value = resolveListeners;</span>
              <span class="s4">if </span><span class="s2">(chunk.reason) {</span>
                <span class="s4">if </span><span class="s2">(rejectListeners)</span>
                  <span class="s4">for </span><span class="s2">(value = </span><span class="s5">0</span><span class="s2">; value &lt; rejectListeners.length; value++)</span>
                    <span class="s2">chunk.reason.push(rejectListeners[value]);</span>
              <span class="s2">} </span><span class="s4">else </span><span class="s2">chunk.reason = rejectListeners;</span>
              <span class="s4">break</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
              <span class="s2">rejectListeners &amp;&amp; wakeChunk(rejectListeners, chunk.reason);</span>
          <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createResolvedIteratorResultChunk(response, value, done) {</span>
      <span class="s4">return new </span><span class="s2">Chunk(</span>
        <span class="s3">&quot;resolved_model&quot;</span><span class="s2">,</span>
        <span class="s2">(done ? </span><span class="s3">'{&quot;done&quot;:true,&quot;value&quot;:' </span><span class="s2">: </span><span class="s3">'{&quot;done&quot;:false,&quot;value&quot;:'</span><span class="s2">) +</span>
          <span class="s2">value +</span>
          <span class="s3">&quot;}&quot;</span><span class="s2">,</span>
        <span class="s2">-</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">response</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">resolveIteratorResultChunk(chunk, value, done) {</span>
      <span class="s2">resolveModelChunk(</span>
        <span class="s2">chunk,</span>
        <span class="s2">(done ? </span><span class="s3">'{&quot;done&quot;:true,&quot;value&quot;:' </span><span class="s2">: </span><span class="s3">'{&quot;done&quot;:false,&quot;value&quot;:'</span><span class="s2">) +</span>
          <span class="s2">value +</span>
          <span class="s3">&quot;}&quot;</span><span class="s2">,</span>
        <span class="s2">-</span><span class="s5">1</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">loadServerReference$1(</span>
      <span class="s2">response,</span>
      <span class="s2">id,</span>
      <span class="s2">bound,</span>
      <span class="s2">parentChunk,</span>
      <span class="s2">parentObject,</span>
      <span class="s2">key</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">serverReference = resolveServerReference(response._bundlerConfig, id);</span>
      <span class="s2">id = preloadModule(serverReference);</span>
      <span class="s4">if </span><span class="s2">(bound)</span>
        <span class="s2">bound = Promise.all([bound, id]).then(</span><span class="s4">function </span><span class="s2">(_ref) {</span>
          <span class="s2">_ref = _ref[</span><span class="s5">0</span><span class="s2">];</span>
          <span class="s4">var </span><span class="s2">fn = requireModule(serverReference);</span>
          <span class="s4">return </span><span class="s2">fn.bind.apply(fn, [</span><span class="s4">null</span><span class="s2">].concat(_ref));</span>
        <span class="s2">});</span>
      <span class="s4">else if </span><span class="s2">(id)</span>
        <span class="s2">bound = Promise.resolve(id).then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">requireModule(serverReference);</span>
        <span class="s2">});</span>
      <span class="s4">else return </span><span class="s2">requireModule(serverReference);</span>
      <span class="s2">bound.then(</span>
        <span class="s2">createModelResolver(</span>
          <span class="s2">parentChunk,</span>
          <span class="s2">parentObject,</span>
          <span class="s2">key,</span>
          <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">response,</span>
          <span class="s2">createModel,</span>
          <span class="s2">[]</span>
        <span class="s2">),</span>
        <span class="s2">createModelReject(parentChunk)</span>
      <span class="s2">);</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">reviveModel(response, parentObj, parentKey, value, reference) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value)</span>
        <span class="s4">return </span><span class="s2">parseModelString(</span>
          <span class="s2">response,</span>
          <span class="s2">parentObj,</span>
          <span class="s2">parentKey,</span>
          <span class="s2">value,</span>
          <span class="s2">reference</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== value)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== reference &amp;&amp;</span>
            <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== response._temporaryReferences &amp;&amp;</span>
            <span class="s2">response._temporaryReferences.set(value, reference),</span>
          <span class="s2">Array.isArray(value))</span>
        <span class="s2">)</span>
          <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; value.length; i++)</span>
            <span class="s2">value[i] = reviveModel(</span>
              <span class="s2">response,</span>
              <span class="s2">value,</span>
              <span class="s3">&quot;&quot; </span><span class="s2">+ i,</span>
              <span class="s2">value[i],</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== reference ? reference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ i : </span><span class="s4">void </span><span class="s5">0</span>
            <span class="s2">);</span>
        <span class="s4">else</span>
          <span class="s4">for </span><span class="s2">(i </span><span class="s4">in </span><span class="s2">value)</span>
            <span class="s2">hasOwnProperty.call(value, i) &amp;&amp;</span>
              <span class="s2">((parentObj =</span>
                <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== reference &amp;&amp; -</span><span class="s5">1 </span><span class="s2">=== i.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">)</span>
                  <span class="s2">? reference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ i</span>
                  <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">),</span>
              <span class="s2">(parentObj = reviveModel(</span>
                <span class="s2">response,</span>
                <span class="s2">value,</span>
                <span class="s2">i,</span>
                <span class="s2">value[i],</span>
                <span class="s2">parentObj</span>
              <span class="s2">)),</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentObj ? (value[i] = parentObj) : </span><span class="s4">delete </span><span class="s2">value[i]);</span>
      <span class="s4">return </span><span class="s2">value;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">initializeModelChunk(chunk) {</span>
      <span class="s4">var </span><span class="s2">prevChunk = initializingChunk,</span>
        <span class="s2">prevBlocked = initializingChunkBlockedModel;</span>
      <span class="s2">initializingChunk = chunk;</span>
      <span class="s2">initializingChunkBlockedModel = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">rootReference =</span>
          <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== chunk.reason ? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: chunk.reason.toString(</span><span class="s5">16</span><span class="s2">),</span>
        <span class="s2">resolvedModel = chunk.value;</span>
      <span class="s2">chunk.status = </span><span class="s3">&quot;cyclic&quot;</span><span class="s2">;</span>
      <span class="s2">chunk.value = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">chunk.reason = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">rawModel = JSON.parse(resolvedModel),</span>
          <span class="s2">value = reviveModel(</span>
            <span class="s2">chunk._response,</span>
            <span class="s2">{ </span><span class="s3">&quot;&quot;</span><span class="s2">: rawModel },</span>
            <span class="s3">&quot;&quot;</span><span class="s2">,</span>
            <span class="s2">rawModel,</span>
            <span class="s2">rootReference</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s4">null </span><span class="s2">!== initializingChunkBlockedModel &amp;&amp;</span>
          <span class="s5">0 </span><span class="s2">&lt; initializingChunkBlockedModel.deps</span>
        <span class="s2">)</span>
          <span class="s2">(initializingChunkBlockedModel.value = value),</span>
            <span class="s2">(chunk.status = </span><span class="s3">&quot;blocked&quot;</span><span class="s2">);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">resolveListeners = chunk.value;</span>
          <span class="s2">chunk.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
          <span class="s2">chunk.value = value;</span>
          <span class="s4">null </span><span class="s2">!== resolveListeners &amp;&amp; wakeChunk(resolveListeners, value);</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
        <span class="s2">(chunk.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">), (chunk.reason = error);</span>
      <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
        <span class="s2">(initializingChunk = prevChunk),</span>
          <span class="s2">(initializingChunkBlockedModel = prevBlocked);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">reportGlobalError(response, error) {</span>
      <span class="s2">response._closed = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">response._closedReason = error;</span>
      <span class="s2">response._chunks.forEach(</span><span class="s4">function </span><span class="s2">(chunk) {</span>
        <span class="s3">&quot;pending&quot; </span><span class="s2">=== chunk.status &amp;&amp; triggerErrorOnChunk(chunk, error);</span>
      <span class="s2">});</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">getChunk(response, id) {</span>
      <span class="s4">var </span><span class="s2">chunks = response._chunks,</span>
        <span class="s2">chunk = chunks.get(id);</span>
      <span class="s2">chunk ||</span>
        <span class="s2">((chunk = response._formData.get(response._prefix + id)),</span>
        <span class="s2">(chunk =</span>
          <span class="s4">null </span><span class="s2">!= chunk</span>
            <span class="s2">? </span><span class="s4">new </span><span class="s2">Chunk(</span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">, chunk, id, response)</span>
            <span class="s2">: response._closed</span>
              <span class="s2">? </span><span class="s4">new </span><span class="s2">Chunk(</span><span class="s3">&quot;rejected&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, response._closedReason, response)</span>
              <span class="s2">: createPendingChunk(response)),</span>
        <span class="s2">chunks.set(id, chunk));</span>
      <span class="s4">return </span><span class="s2">chunk;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createModelResolver(</span>
      <span class="s2">chunk,</span>
      <span class="s2">parentObject,</span>
      <span class="s2">key,</span>
      <span class="s2">cyclic,</span>
      <span class="s2">response,</span>
      <span class="s2">map,</span>
      <span class="s2">path</span>
    <span class="s2">) {</span>
      <span class="s4">if </span><span class="s2">(initializingChunkBlockedModel) {</span>
        <span class="s4">var </span><span class="s2">blocked = initializingChunkBlockedModel;</span>
        <span class="s2">cyclic || blocked.deps++;</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s2">blocked = initializingChunkBlockedModel = {</span>
          <span class="s2">deps: cyclic ? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">value: </span><span class="s4">null</span>
        <span class="s2">};</span>
      <span class="s4">return function </span><span class="s2">(value) {</span>
        <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">1</span><span class="s2">; i &lt; path.length; i++) value = value[path[i]];</span>
        <span class="s2">parentObject[key] = map(response, value);</span>
        <span class="s3">&quot;&quot; </span><span class="s2">=== key &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">=== blocked.value &amp;&amp;</span>
          <span class="s2">(blocked.value = parentObject[key]);</span>
        <span class="s2">blocked.deps--;</span>
        <span class="s5">0 </span><span class="s2">=== blocked.deps &amp;&amp;</span>
          <span class="s3">&quot;blocked&quot; </span><span class="s2">=== chunk.status &amp;&amp;</span>
          <span class="s2">((value = chunk.value),</span>
          <span class="s2">(chunk.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
          <span class="s2">(chunk.value = blocked.value),</span>
          <span class="s4">null </span><span class="s2">!== value &amp;&amp; wakeChunk(value, blocked.value));</span>
      <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createModelReject(chunk) {</span>
      <span class="s4">return function </span><span class="s2">(error) {</span>
        <span class="s4">return </span><span class="s2">triggerErrorOnChunk(chunk, error);</span>
      <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">getOutlinedModel(response, reference, parentObject, key, map) {</span>
      <span class="s2">reference = reference.split(</span><span class="s3">&quot;:&quot;</span><span class="s2">);</span>
      <span class="s4">var </span><span class="s2">id = parseInt(reference[</span><span class="s5">0</span><span class="s2">], </span><span class="s5">16</span><span class="s2">);</span>
      <span class="s2">id = getChunk(response, id);</span>
      <span class="s4">switch </span><span class="s2">(id.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
          <span class="s2">initializeModelChunk(id);</span>
      <span class="s2">}</span>
      <span class="s4">switch </span><span class="s2">(id.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s2">parentObject = id.value;</span>
          <span class="s4">for </span><span class="s2">(key = </span><span class="s5">1</span><span class="s2">; key &lt; reference.length; key++)</span>
            <span class="s2">parentObject = parentObject[reference[key]];</span>
          <span class="s4">return </span><span class="s2">map(response, parentObject);</span>
        <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;cyclic&quot;</span><span class="s2">:</span>
          <span class="s4">var </span><span class="s2">parentChunk = initializingChunk;</span>
          <span class="s2">id.then(</span>
            <span class="s2">createModelResolver(</span>
              <span class="s2">parentChunk,</span>
              <span class="s2">parentObject,</span>
              <span class="s2">key,</span>
              <span class="s3">&quot;cyclic&quot; </span><span class="s2">=== id.status,</span>
              <span class="s2">response,</span>
              <span class="s2">map,</span>
              <span class="s2">reference</span>
            <span class="s2">),</span>
            <span class="s2">createModelReject(parentChunk)</span>
          <span class="s2">);</span>
          <span class="s4">return null</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s4">throw </span><span class="s2">id.reason;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createMap(response, model) {</span>
      <span class="s4">return new </span><span class="s2">Map(model);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createSet(response, model) {</span>
      <span class="s4">return new </span><span class="s2">Set(model);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">extractIterator(response, model) {</span>
      <span class="s4">return </span><span class="s2">model[Symbol.iterator]();</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createModel(response, model) {</span>
      <span class="s4">return </span><span class="s2">model;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">parseTypedArray(</span>
      <span class="s2">response,</span>
      <span class="s2">reference,</span>
      <span class="s2">constructor,</span>
      <span class="s2">bytesPerElement,</span>
      <span class="s2">parentObject,</span>
      <span class="s2">parentKey</span>
    <span class="s2">) {</span>
      <span class="s2">reference = parseInt(reference.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
      <span class="s2">reference = response._formData.get(response._prefix + reference);</span>
      <span class="s2">reference =</span>
        <span class="s2">constructor === ArrayBuffer</span>
          <span class="s2">? reference.arrayBuffer()</span>
          <span class="s2">: reference.arrayBuffer().then(</span><span class="s4">function </span><span class="s2">(buffer) {</span>
              <span class="s4">return new </span><span class="s2">constructor(buffer);</span>
            <span class="s2">});</span>
      <span class="s2">bytesPerElement = initializingChunk;</span>
      <span class="s2">reference.then(</span>
        <span class="s2">createModelResolver(</span>
          <span class="s2">bytesPerElement,</span>
          <span class="s2">parentObject,</span>
          <span class="s2">parentKey,</span>
          <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">response,</span>
          <span class="s2">createModel,</span>
          <span class="s2">[]</span>
        <span class="s2">),</span>
        <span class="s2">createModelReject(bytesPerElement)</span>
      <span class="s2">);</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">resolveStream(response, id, stream, controller) {</span>
      <span class="s4">var </span><span class="s2">chunks = response._chunks;</span>
      <span class="s2">stream = </span><span class="s4">new </span><span class="s2">Chunk(</span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">, stream, controller, response);</span>
      <span class="s2">chunks.set(id, stream);</span>
      <span class="s2">response = response._formData.getAll(response._prefix + id);</span>
      <span class="s4">for </span><span class="s2">(id = </span><span class="s5">0</span><span class="s2">; id &lt; response.length; id++)</span>
        <span class="s2">(chunks = response[id]),</span>
          <span class="s3">&quot;C&quot; </span><span class="s2">=== chunks[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s2">? controller.close(</span>
                <span class="s3">&quot;C&quot; </span><span class="s2">=== chunks ? </span><span class="s3">'&quot;$undefined&quot;' </span><span class="s2">: chunks.slice(</span><span class="s5">1</span><span class="s2">)</span>
              <span class="s2">)</span>
            <span class="s2">: controller.enqueueModel(chunks);</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">parseReadableStream(response, reference, type) {</span>
      <span class="s2">reference = parseInt(reference.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
      <span class="s4">var </span><span class="s2">controller = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">type = </span><span class="s4">new </span><span class="s2">ReadableStream({</span>
        <span class="s2">type: type,</span>
        <span class="s2">start: </span><span class="s4">function </span><span class="s2">(c) {</span>
          <span class="s2">controller = c;</span>
        <span class="s2">}</span>
      <span class="s2">});</span>
      <span class="s4">var </span><span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">resolveStream(response, reference, type, {</span>
        <span class="s2">enqueueModel: </span><span class="s4">function </span><span class="s2">(json) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) {</span>
            <span class="s4">var </span><span class="s2">chunk = </span><span class="s4">new </span><span class="s2">Chunk(</span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">, json, -</span><span class="s5">1</span><span class="s2">, response);</span>
            <span class="s2">initializeModelChunk(chunk);</span>
            <span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== chunk.status</span>
              <span class="s2">? controller.enqueue(chunk.value)</span>
              <span class="s2">: (chunk.then(</span>
                  <span class="s4">function </span><span class="s2">(v) {</span>
                    <span class="s4">return </span><span class="s2">controller.enqueue(v);</span>
                  <span class="s2">},</span>
                  <span class="s4">function </span><span class="s2">(e) {</span>
                    <span class="s4">return </span><span class="s2">controller.error(e);</span>
                  <span class="s2">}</span>
                <span class="s2">),</span>
                <span class="s2">(previousBlockedChunk = chunk));</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
            <span class="s2">chunk = previousBlockedChunk;</span>
            <span class="s4">var </span><span class="s2">_chunk = createPendingChunk(response);</span>
            <span class="s2">_chunk.then(</span>
              <span class="s4">function </span><span class="s2">(v) {</span>
                <span class="s4">return </span><span class="s2">controller.enqueue(v);</span>
              <span class="s2">},</span>
              <span class="s4">function </span><span class="s2">(e) {</span>
                <span class="s4">return </span><span class="s2">controller.error(e);</span>
              <span class="s2">}</span>
            <span class="s2">);</span>
            <span class="s2">previousBlockedChunk = _chunk;</span>
            <span class="s2">chunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s2">previousBlockedChunk === _chunk &amp;&amp; (previousBlockedChunk = </span><span class="s4">null</span><span class="s2">);</span>
              <span class="s2">resolveModelChunk(_chunk, json, -</span><span class="s5">1</span><span class="s2">);</span>
            <span class="s2">});</span>
          <span class="s2">}</span>
        <span class="s2">},</span>
        <span class="s2">close: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) controller.close();</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">blockedChunk = previousBlockedChunk;</span>
            <span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">blockedChunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">return </span><span class="s2">controller.close();</span>
            <span class="s2">});</span>
          <span class="s2">}</span>
        <span class="s2">},</span>
        <span class="s2">error: </span><span class="s4">function </span><span class="s2">(error) {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) controller.error(error);</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">blockedChunk = previousBlockedChunk;</span>
            <span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">blockedChunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">return </span><span class="s2">controller.error(error);</span>
            <span class="s2">});</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">});</span>
      <span class="s4">return </span><span class="s2">type;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">asyncIterator() {</span>
      <span class="s4">return this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createIterator(next) {</span>
      <span class="s2">next = { next: next };</span>
      <span class="s2">next[ASYNC_ITERATOR] = asyncIterator;</span>
      <span class="s4">return </span><span class="s2">next;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">parseAsyncIterable(response, reference, iterator) {</span>
      <span class="s2">reference = parseInt(reference.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
      <span class="s4">var </span><span class="s2">buffer = [],</span>
        <span class="s2">closed = !</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">nextWriteIndex = </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">iterable = _defineProperty({}, ASYNC_ITERATOR, </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">var </span><span class="s2">nextReadIndex = </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">return </span><span class="s2">createIterator(</span><span class="s4">function </span><span class="s2">(arg) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== arg)</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;Values cannot be passed to next() of AsyncIterables passed to Client Components.&quot;</span>
              <span class="s2">);</span>
            <span class="s4">if </span><span class="s2">(nextReadIndex === buffer.length) {</span>
              <span class="s4">if </span><span class="s2">(closed)</span>
                <span class="s4">return new </span><span class="s2">Chunk(</span>
                  <span class="s3">&quot;fulfilled&quot;</span><span class="s2">,</span>
                  <span class="s2">{ done: !</span><span class="s5">0</span><span class="s2">, value: </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">},</span>
                  <span class="s4">null</span><span class="s2">,</span>
                  <span class="s2">response</span>
                <span class="s2">);</span>
              <span class="s2">buffer[nextReadIndex] = createPendingChunk(response);</span>
            <span class="s2">}</span>
            <span class="s4">return </span><span class="s2">buffer[nextReadIndex++];</span>
          <span class="s2">});</span>
        <span class="s2">});</span>
      <span class="s2">iterator = iterator ? iterable[ASYNC_ITERATOR]() : iterable;</span>
      <span class="s2">resolveStream(response, reference, iterator, {</span>
        <span class="s2">enqueueModel: </span><span class="s4">function </span><span class="s2">(value) {</span>
          <span class="s2">nextWriteIndex === buffer.length</span>
            <span class="s2">? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(</span>
                <span class="s2">response,</span>
                <span class="s2">value,</span>
                <span class="s2">!</span><span class="s5">1</span>
              <span class="s2">))</span>
            <span class="s2">: resolveIteratorResultChunk(buffer[nextWriteIndex], value, !</span><span class="s5">1</span><span class="s2">);</span>
          <span class="s2">nextWriteIndex++;</span>
        <span class="s2">},</span>
        <span class="s2">close: </span><span class="s4">function </span><span class="s2">(value) {</span>
          <span class="s2">closed = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">nextWriteIndex === buffer.length</span>
            <span class="s2">? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(</span>
                <span class="s2">response,</span>
                <span class="s2">value,</span>
                <span class="s2">!</span><span class="s5">0</span>
              <span class="s2">))</span>
            <span class="s2">: resolveIteratorResultChunk(buffer[nextWriteIndex], value, !</span><span class="s5">0</span><span class="s2">);</span>
          <span class="s4">for </span><span class="s2">(nextWriteIndex++; nextWriteIndex &lt; buffer.length; )</span>
            <span class="s2">resolveIteratorResultChunk(</span>
              <span class="s2">buffer[nextWriteIndex++],</span>
              <span class="s3">'&quot;$undefined&quot;'</span><span class="s2">,</span>
              <span class="s2">!</span><span class="s5">0</span>
            <span class="s2">);</span>
        <span class="s2">},</span>
        <span class="s2">error: </span><span class="s4">function </span><span class="s2">(error) {</span>
          <span class="s2">closed = !</span><span class="s5">0</span><span class="s2">;</span>
          <span class="s4">for </span><span class="s2">(</span>
            <span class="s2">nextWriteIndex === buffer.length &amp;&amp;</span>
            <span class="s2">(buffer[nextWriteIndex] = createPendingChunk(response));</span>
            <span class="s2">nextWriteIndex &lt; buffer.length;</span>

          <span class="s2">)</span>
            <span class="s2">triggerErrorOnChunk(buffer[nextWriteIndex++], error);</span>
        <span class="s2">}</span>
      <span class="s2">});</span>
      <span class="s4">return </span><span class="s2">iterator;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">parseModelString(response, obj, key, value, reference) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;$&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">]) {</span>
        <span class="s4">switch </span><span class="s2">(value[</span><span class="s5">1</span><span class="s2">]) {</span>
          <span class="s4">case </span><span class="s3">&quot;$&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">value.slice(</span><span class="s5">1</span><span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;@&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">(obj = parseInt(value.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">)), getChunk(response, obj)</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;F&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
              <span class="s2">(value = getOutlinedModel(</span>
                <span class="s2">response,</span>
                <span class="s2">value,</span>
                <span class="s2">obj,</span>
                <span class="s2">key,</span>
                <span class="s2">createModel</span>
              <span class="s2">)),</span>
              <span class="s2">loadServerReference$1(</span>
                <span class="s2">response,</span>
                <span class="s2">value.id,</span>
                <span class="s2">value.bound,</span>
                <span class="s2">initializingChunk,</span>
                <span class="s2">obj,</span>
                <span class="s2">key</span>
              <span class="s2">)</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;T&quot;</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== reference ||</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== response._temporaryReferences</span>
            <span class="s2">)</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.&quot;</span>
              <span class="s2">);</span>
            <span class="s4">return </span><span class="s2">createTemporaryReference(</span>
              <span class="s2">response._temporaryReferences,</span>
              <span class="s2">reference</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;Q&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
              <span class="s2">getOutlinedModel(response, value, obj, key, createMap)</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;W&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
              <span class="s2">getOutlinedModel(response, value, obj, key, createSet)</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;K&quot;</span><span class="s2">:</span>
            <span class="s2">obj = value.slice(</span><span class="s5">2</span><span class="s2">);</span>
            <span class="s4">var </span><span class="s2">formPrefix = response._prefix + obj + </span><span class="s3">&quot;_&quot;</span><span class="s2">,</span>
              <span class="s2">data = </span><span class="s4">new </span><span class="s2">FormData();</span>
            <span class="s2">response._formData.forEach(</span><span class="s4">function </span><span class="s2">(entry, entryKey) {</span>
              <span class="s2">entryKey.startsWith(formPrefix) &amp;&amp;</span>
                <span class="s2">data.append(entryKey.slice(formPrefix.length), entry);</span>
            <span class="s2">});</span>
            <span class="s4">return </span><span class="s2">data;</span>
          <span class="s4">case </span><span class="s3">&quot;i&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
              <span class="s2">getOutlinedModel(response, value, obj, key, extractIterator)</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;I&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">Infinity;</span>
          <span class="s4">case </span><span class="s3">&quot;-&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s3">&quot;$-0&quot; </span><span class="s2">=== value ? -</span><span class="s5">0 </span><span class="s2">: -Infinity;</span>
          <span class="s4">case </span><span class="s3">&quot;N&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">NaN;</span>
          <span class="s4">case </span><span class="s3">&quot;u&quot;</span><span class="s2">:</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;D&quot;</span><span class="s2">:</span>
            <span class="s4">return new </span><span class="s2">Date(Date.parse(value.slice(</span><span class="s5">2</span><span class="s2">)));</span>
          <span class="s4">case </span><span class="s3">&quot;n&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">BigInt(value.slice(</span><span class="s5">2</span><span class="s2">));</span>
        <span class="s2">}</span>
        <span class="s4">switch </span><span class="s2">(value[</span><span class="s5">1</span><span class="s2">]) {</span>
          <span class="s4">case </span><span class="s3">&quot;A&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, ArrayBuffer, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;O&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Int8Array, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;o&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Uint8Array, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;U&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(</span>
              <span class="s2">response,</span>
              <span class="s2">value,</span>
              <span class="s2">Uint8ClampedArray,</span>
              <span class="s5">1</span><span class="s2">,</span>
              <span class="s2">obj,</span>
              <span class="s2">key</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;S&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Int16Array, </span><span class="s5">2</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;s&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Uint16Array, </span><span class="s5">2</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;L&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Int32Array, </span><span class="s5">4</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;l&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Uint32Array, </span><span class="s5">4</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;G&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Float32Array, </span><span class="s5">4</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;g&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Float64Array, </span><span class="s5">8</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;M&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, BigInt64Array, </span><span class="s5">8</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;m&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(</span>
              <span class="s2">response,</span>
              <span class="s2">value,</span>
              <span class="s2">BigUint64Array,</span>
              <span class="s5">8</span><span class="s2">,</span>
              <span class="s2">obj,</span>
              <span class="s2">key</span>
            <span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;V&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseTypedArray(response, value, DataView, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
          <span class="s4">case </span><span class="s3">&quot;B&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">(</span>
              <span class="s2">(obj = parseInt(value.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">)),</span>
              <span class="s2">response._formData.get(response._prefix + obj)</span>
            <span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s4">switch </span><span class="s2">(value[</span><span class="s5">1</span><span class="s2">]) {</span>
          <span class="s4">case </span><span class="s3">&quot;R&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseReadableStream(response, value, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;r&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseReadableStream(response, value, </span><span class="s3">&quot;bytes&quot;</span><span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;X&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseAsyncIterable(response, value, !</span><span class="s5">1</span><span class="s2">);</span>
          <span class="s4">case </span><span class="s3">&quot;x&quot;</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">parseAsyncIterable(response, value, !</span><span class="s5">0</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s2">value = value.slice(</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s4">return </span><span class="s2">getOutlinedModel(response, value, obj, key, createModel);</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">value;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">createResponse(</span>
      <span class="s2">bundlerConfig,</span>
      <span class="s2">formFieldPrefix,</span>
      <span class="s2">temporaryReferences</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">backingFormData =</span>
          <span class="s5">3 </span><span class="s2">&lt; arguments.length &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== arguments[</span><span class="s5">3</span><span class="s2">]</span>
            <span class="s2">? arguments[</span><span class="s5">3</span><span class="s2">]</span>
            <span class="s2">: </span><span class="s4">new </span><span class="s2">FormData(),</span>
        <span class="s2">chunks = </span><span class="s4">new </span><span class="s2">Map();</span>
      <span class="s4">return </span><span class="s2">{</span>
        <span class="s2">_bundlerConfig: bundlerConfig,</span>
        <span class="s2">_prefix: formFieldPrefix,</span>
        <span class="s2">_formData: backingFormData,</span>
        <span class="s2">_chunks: chunks,</span>
        <span class="s2">_closed: !</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">_closedReason: </span><span class="s4">null</span><span class="s2">,</span>
        <span class="s2">_temporaryReferences: temporaryReferences</span>
      <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">close(response) {</span>
      <span class="s2">reportGlobalError(response, Error(</span><span class="s3">&quot;Connection closed.&quot;</span><span class="s2">));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">loadServerReference(bundlerConfig, id, bound) {</span>
      <span class="s4">var </span><span class="s2">serverReference = resolveServerReference(bundlerConfig, id);</span>
      <span class="s2">bundlerConfig = preloadModule(serverReference);</span>
      <span class="s4">return </span><span class="s2">bound</span>
        <span class="s2">? Promise.all([bound, bundlerConfig]).then(</span><span class="s4">function </span><span class="s2">(_ref) {</span>
            <span class="s2">_ref = _ref[</span><span class="s5">0</span><span class="s2">];</span>
            <span class="s4">var </span><span class="s2">fn = requireModule(serverReference);</span>
            <span class="s4">return </span><span class="s2">fn.bind.apply(fn, [</span><span class="s4">null</span><span class="s2">].concat(_ref));</span>
          <span class="s2">})</span>
        <span class="s2">: bundlerConfig</span>
          <span class="s2">? Promise.resolve(bundlerConfig).then(</span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">return </span><span class="s2">requireModule(serverReference);</span>
            <span class="s2">})</span>
          <span class="s2">: Promise.resolve(requireModule(serverReference));</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">decodeBoundActionMetaData(body, serverManifest, formFieldPrefix) {</span>
      <span class="s2">body = createResponse(serverManifest, formFieldPrefix, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">, body);</span>
      <span class="s2">close(body);</span>
      <span class="s2">body = getChunk(body, </span><span class="s5">0</span><span class="s2">);</span>
      <span class="s2">body.then(</span><span class="s4">function </span><span class="s2">() {});</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">!== body.status) </span><span class="s4">throw </span><span class="s2">body.reason;</span>
      <span class="s4">return </span><span class="s2">body.value;</span>
    <span class="s2">}</span>
    <span class="s4">function </span><span class="s2">startReadingFromDebugChannelReadableStream(</span>
      <span class="s2">request$jscomp$0,</span>
      <span class="s2">stream</span>
    <span class="s2">) {</span>
      <span class="s4">function </span><span class="s2">progress(_ref) {</span>
        <span class="s4">var </span><span class="s2">done = _ref.done,</span>
          <span class="s2">buffer = _ref.value;</span>
        <span class="s2">_ref = stringBuffer;</span>
        <span class="s2">done</span>
          <span class="s2">? ((buffer = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">0</span><span class="s2">)),</span>
            <span class="s2">(buffer = stringDecoder.decode(buffer)))</span>
          <span class="s2">: (buffer = stringDecoder.decode(buffer, decoderOptions));</span>
        <span class="s2">stringBuffer = _ref + buffer;</span>
        <span class="s2">_ref = stringBuffer.split(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">);</span>
        <span class="s4">for </span><span class="s2">(buffer = </span><span class="s5">0</span><span class="s2">; buffer &lt; _ref.length - </span><span class="s5">1</span><span class="s2">; buffer++) {</span>
          <span class="s4">var </span><span class="s2">request = request$jscomp$0,</span>
            <span class="s2">message = _ref[buffer],</span>
            <span class="s2">deferredDebugObjects = request.deferredDebugObjects;</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== deferredDebugObjects)</span>
            <span class="s4">throw </span><span class="s2">Error(</span>
              <span class="s3">&quot;resolveDebugMessage/closeDebugChannel should not be called for a Request that wasn't kept alive. This is a bug in React.&quot;</span>
            <span class="s2">);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;&quot; </span><span class="s2">=== message) closeDebugChannel(request);</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">command = message.charCodeAt(</span><span class="s5">0</span><span class="s2">);</span>
            <span class="s2">message = message.slice(</span><span class="s5">2</span><span class="s2">).split(</span><span class="s3">&quot;,&quot;</span><span class="s2">).map(fromHex);</span>
            <span class="s4">switch </span><span class="s2">(command) {</span>
              <span class="s4">case </span><span class="s5">82</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s2">(command = </span><span class="s5">0</span><span class="s2">; command &lt; message.length; command++) {</span>
                  <span class="s4">var </span><span class="s2">id = message[command],</span>
                    <span class="s2">retainedValue = deferredDebugObjects.retained.get(id);</span>
                  <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== retainedValue &amp;&amp;</span>
                    <span class="s2">(request.pendingDebugChunks--,</span>
                    <span class="s2">deferredDebugObjects.retained.delete(id),</span>
                    <span class="s2">deferredDebugObjects.existing.delete(retainedValue),</span>
                    <span class="s2">enqueueFlush(request));</span>
                <span class="s2">}</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s5">81</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s2">(command = </span><span class="s5">0</span><span class="s2">; command &lt; message.length; command++)</span>
                  <span class="s2">(id = message[command]),</span>
                    <span class="s2">(retainedValue = deferredDebugObjects.retained.get(id)),</span>
                    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== retainedValue &amp;&amp;</span>
                      <span class="s2">(deferredDebugObjects.retained.delete(id),</span>
                      <span class="s2">deferredDebugObjects.existing.delete(retainedValue),</span>
                      <span class="s2">emitOutlinedDebugModelChunk(</span>
                        <span class="s2">request,</span>
                        <span class="s2">id,</span>
                        <span class="s2">{ objectLimit: </span><span class="s5">10 </span><span class="s2">},</span>
                        <span class="s2">retainedValue</span>
                      <span class="s2">),</span>
                      <span class="s2">enqueueFlush(request));</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">case </span><span class="s5">80</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s2">(command = </span><span class="s5">0</span><span class="s2">; command &lt; message.length; command++)</span>
                  <span class="s2">(id = message[command]),</span>
                    <span class="s2">(retainedValue = deferredDebugObjects.retained.get(id)),</span>
                    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== retainedValue &amp;&amp;</span>
                      <span class="s2">(deferredDebugObjects.retained.delete(id),</span>
                      <span class="s2">emitRequestedDebugThenable(</span>
                        <span class="s2">request,</span>
                        <span class="s2">id,</span>
                        <span class="s2">{ objectLimit: </span><span class="s5">10 </span><span class="s2">},</span>
                        <span class="s2">retainedValue</span>
                      <span class="s2">));</span>
                <span class="s4">break</span><span class="s2">;</span>
              <span class="s4">default</span><span class="s2">:</span>
                <span class="s4">throw </span><span class="s2">Error(</span>
                  <span class="s3">&quot;Unknown command. The debugChannel was not wired up properly.&quot;</span>
                <span class="s2">);</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">stringBuffer = _ref[_ref.length - </span><span class="s5">1</span><span class="s2">];</span>
        <span class="s4">if </span><span class="s2">(done) closeDebugChannel(request$jscomp$0);</span>
        <span class="s4">else return </span><span class="s2">reader.read().then(progress).catch(error);</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">error(e) {</span>
        <span class="s2">abort(</span>
          <span class="s2">request$jscomp$0,</span>
          <span class="s2">Error(</span><span class="s3">&quot;Lost connection to the Debug Channel.&quot;</span><span class="s2">, { cause: e })</span>
        <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">reader = stream.getReader(),</span>
        <span class="s2">stringDecoder = </span><span class="s4">new </span><span class="s2">TextDecoder(),</span>
        <span class="s2">stringBuffer = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
      <span class="s2">reader.read().then(progress).catch(error);</span>
    <span class="s2">}</span>
    <span class="s4">var </span><span class="s2">ReactDOM = require(</span><span class="s3">&quot;react-dom&quot;</span><span class="s2">),</span>
      <span class="s2">React = require(</span><span class="s3">&quot;react&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_LEGACY_ELEMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.element&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_ELEMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.transitional.element&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_FRAGMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.fragment&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_CONTEXT_TYPE = Symbol.for(</span><span class="s3">&quot;react.context&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_FORWARD_REF_TYPE = Symbol.for(</span><span class="s3">&quot;react.forward_ref&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_SUSPENSE_TYPE = Symbol.for(</span><span class="s3">&quot;react.suspense&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_SUSPENSE_LIST_TYPE = Symbol.for(</span><span class="s3">&quot;react.suspense_list&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_MEMO_TYPE = Symbol.for(</span><span class="s3">&quot;react.memo&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_LAZY_TYPE = Symbol.for(</span><span class="s3">&quot;react.lazy&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_MEMO_CACHE_SENTINEL = Symbol.for(</span><span class="s3">&quot;react.memo_cache_sentinel&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_POSTPONE_TYPE = Symbol.for(</span><span class="s3">&quot;react.postpone&quot;</span><span class="s2">),</span>
      <span class="s2">REACT_VIEW_TRANSITION_TYPE = Symbol.for(</span><span class="s3">&quot;react.view_transition&quot;</span><span class="s2">),</span>
      <span class="s2">MAYBE_ITERATOR_SYMBOL = Symbol.iterator,</span>
      <span class="s2">ASYNC_ITERATOR = Symbol.asyncIterator,</span>
      <span class="s2">LocalPromise = Promise,</span>
      <span class="s2">scheduleMicrotask =</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">queueMicrotask</span>
          <span class="s2">? queueMicrotask</span>
          <span class="s2">: </span><span class="s4">function </span><span class="s2">(callback) {</span>
              <span class="s2">LocalPromise.resolve(</span><span class="s4">null</span><span class="s2">)</span>
                <span class="s2">.then(callback)</span>
                <span class="s2">.catch(handleErrorInNextTick);</span>
            <span class="s2">},</span>
      <span class="s2">currentView = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">writtenBytes = </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">textEncoder = </span><span class="s4">new </span><span class="s2">TextEncoder(),</span>
      <span class="s2">CLIENT_REFERENCE_TAG$1 = Symbol.for(</span><span class="s3">&quot;react.client.reference&quot;</span><span class="s2">),</span>
      <span class="s2">SERVER_REFERENCE_TAG = Symbol.for(</span><span class="s3">&quot;react.server.reference&quot;</span><span class="s2">),</span>
      <span class="s2">FunctionBind = Function.prototype.bind,</span>
      <span class="s2">ArraySlice = Array.prototype.slice,</span>
      <span class="s2">PROMISE_PROTOTYPE = Promise.prototype,</span>
      <span class="s2">deepProxyHandlers = {</span>
        <span class="s2">get: </span><span class="s4">function </span><span class="s2">(target, name) {</span>
          <span class="s4">switch </span><span class="s2">(name) {</span>
            <span class="s4">case </span><span class="s3">&quot;$$typeof&quot;</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">target.$$typeof;</span>
            <span class="s4">case </span><span class="s3">&quot;$$id&quot;</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">target.$$id;</span>
            <span class="s4">case </span><span class="s3">&quot;$$async&quot;</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">target.$$async;</span>
            <span class="s4">case </span><span class="s3">&quot;name&quot;</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">target.name;</span>
            <span class="s4">case </span><span class="s3">&quot;displayName&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultProps&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;_debugInfo&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s2">Symbol.toPrimitive:</span>
              <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toPrimitive];</span>
            <span class="s4">case </span><span class="s2">Symbol.toStringTag:</span>
              <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toStringTag];</span>
            <span class="s4">case </span><span class="s3">&quot;Provider&quot;</span><span class="s2">:</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.&quot;</span>
              <span class="s2">);</span>
            <span class="s4">case </span><span class="s3">&quot;then&quot;</span><span class="s2">:</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;Cannot await or return from a thenable. You cannot await a client module from a server component.&quot;</span>
              <span class="s2">);</span>
          <span class="s2">}</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Cannot access &quot; </span><span class="s2">+</span>
              <span class="s2">(String(target.name) + </span><span class="s3">&quot;.&quot; </span><span class="s2">+ String(name)) +</span>
              <span class="s3">&quot; on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.&quot;</span>
          <span class="s2">);</span>
        <span class="s2">},</span>
        <span class="s2">set: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot assign to a client module from a server module.&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">proxyHandlers$1 = {</span>
        <span class="s2">get: </span><span class="s4">function </span><span class="s2">(target, name) {</span>
          <span class="s4">return </span><span class="s2">getReference(target, name);</span>
        <span class="s2">},</span>
        <span class="s2">getOwnPropertyDescriptor: </span><span class="s4">function </span><span class="s2">(target, name) {</span>
          <span class="s4">var </span><span class="s2">descriptor = Object.getOwnPropertyDescriptor(target, name);</span>
          <span class="s2">descriptor ||</span>
            <span class="s2">((descriptor = {</span>
              <span class="s2">value: getReference(target, name),</span>
              <span class="s2">writable: !</span><span class="s5">1</span><span class="s2">,</span>
              <span class="s2">configurable: !</span><span class="s5">1</span><span class="s2">,</span>
              <span class="s2">enumerable: !</span><span class="s5">1</span>
            <span class="s2">}),</span>
            <span class="s2">Object.defineProperty(target, name, descriptor));</span>
          <span class="s4">return </span><span class="s2">descriptor;</span>
        <span class="s2">},</span>
        <span class="s2">getPrototypeOf: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">PROMISE_PROTOTYPE;</span>
        <span class="s2">},</span>
        <span class="s2">set: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot assign to a client module from a server module.&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">ReactDOMSharedInternals =</span>
        <span class="s2">ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,</span>
      <span class="s2">previousDispatcher = ReactDOMSharedInternals.d;</span>
    <span class="s2">ReactDOMSharedInternals.d = {</span>
      <span class="s2">f: previousDispatcher.f,</span>
      <span class="s2">r: previousDispatcher.r,</span>
      <span class="s2">D: </span><span class="s4">function </span><span class="s2">(href) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href &amp;&amp; href) {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">if </span><span class="s2">(request) {</span>
            <span class="s4">var </span><span class="s2">hints = request.hints,</span>
              <span class="s2">key = </span><span class="s3">&quot;D|&quot; </span><span class="s2">+ href;</span>
            <span class="s2">hints.has(key) || (hints.add(key), emitHint(request, </span><span class="s3">&quot;D&quot;</span><span class="s2">, href));</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">previousDispatcher.D(href);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">C: </span><span class="s4">function </span><span class="s2">(href, crossOrigin) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href) {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">if </span><span class="s2">(request) {</span>
            <span class="s4">var </span><span class="s2">hints = request.hints,</span>
              <span class="s2">key =</span>
                <span class="s3">&quot;C|&quot; </span><span class="s2">+</span>
                <span class="s2">(</span><span class="s4">null </span><span class="s2">== crossOrigin ? </span><span class="s3">&quot;null&quot; </span><span class="s2">: crossOrigin) +</span>
                <span class="s3">&quot;|&quot; </span><span class="s2">+</span>
                <span class="s2">href;</span>
            <span class="s2">hints.has(key) ||</span>
              <span class="s2">(hints.add(key),</span>
              <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">crossOrigin</span>
                <span class="s2">? emitHint(request, </span><span class="s3">&quot;C&quot;</span><span class="s2">, [href, crossOrigin])</span>
                <span class="s2">: emitHint(request, </span><span class="s3">&quot;C&quot;</span><span class="s2">, href));</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">previousDispatcher.C(href, crossOrigin);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">L: </span><span class="s4">function </span><span class="s2">(href, as, options) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href) {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">if </span><span class="s2">(request) {</span>
            <span class="s4">var </span><span class="s2">hints = request.hints,</span>
              <span class="s2">key = </span><span class="s3">&quot;L&quot;</span><span class="s2">;</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;image&quot; </span><span class="s2">=== as &amp;&amp; options) {</span>
              <span class="s4">var </span><span class="s2">imageSrcSet = options.imageSrcSet,</span>
                <span class="s2">imageSizes = options.imageSizes,</span>
                <span class="s2">uniquePart = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
              <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">imageSrcSet &amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s2">!== imageSrcSet</span>
                <span class="s2">? ((uniquePart += </span><span class="s3">&quot;[&quot; </span><span class="s2">+ imageSrcSet + </span><span class="s3">&quot;]&quot;</span><span class="s2">),</span>
                  <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">imageSizes &amp;&amp;</span>
                    <span class="s2">(uniquePart += </span><span class="s3">&quot;[&quot; </span><span class="s2">+ imageSizes + </span><span class="s3">&quot;]&quot;</span><span class="s2">))</span>
                <span class="s2">: (uniquePart += </span><span class="s3">&quot;[][]&quot; </span><span class="s2">+ href);</span>
              <span class="s2">key += </span><span class="s3">&quot;[image]&quot; </span><span class="s2">+ uniquePart;</span>
            <span class="s2">} </span><span class="s4">else </span><span class="s2">key += </span><span class="s3">&quot;[&quot; </span><span class="s2">+ as + </span><span class="s3">&quot;]&quot; </span><span class="s2">+ href;</span>
            <span class="s2">hints.has(key) ||</span>
              <span class="s2">(hints.add(key),</span>
              <span class="s2">(options = trimOptions(options))</span>
                <span class="s2">? emitHint(request, </span><span class="s3">&quot;L&quot;</span><span class="s2">, [href, as, options])</span>
                <span class="s2">: emitHint(request, </span><span class="s3">&quot;L&quot;</span><span class="s2">, [href, as]));</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">previousDispatcher.L(href, as, options);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">m: </span><span class="s4">function </span><span class="s2">(href, options) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href) {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">if </span><span class="s2">(request) {</span>
            <span class="s4">var </span><span class="s2">hints = request.hints,</span>
              <span class="s2">key = </span><span class="s3">&quot;m|&quot; </span><span class="s2">+ href;</span>
            <span class="s4">if </span><span class="s2">(hints.has(key)) </span><span class="s4">return</span><span class="s2">;</span>
            <span class="s2">hints.add(key);</span>
            <span class="s4">return </span><span class="s2">(options = trimOptions(options))</span>
              <span class="s2">? emitHint(request, </span><span class="s3">&quot;m&quot;</span><span class="s2">, [href, options])</span>
              <span class="s2">: emitHint(request, </span><span class="s3">&quot;m&quot;</span><span class="s2">, href);</span>
          <span class="s2">}</span>
          <span class="s2">previousDispatcher.m(href, options);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">X: </span><span class="s4">function </span><span class="s2">(src, options) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">src) {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">if </span><span class="s2">(request) {</span>
            <span class="s4">var </span><span class="s2">hints = request.hints,</span>
              <span class="s2">key = </span><span class="s3">&quot;X|&quot; </span><span class="s2">+ src;</span>
            <span class="s4">if </span><span class="s2">(hints.has(key)) </span><span class="s4">return</span><span class="s2">;</span>
            <span class="s2">hints.add(key);</span>
            <span class="s4">return </span><span class="s2">(options = trimOptions(options))</span>
              <span class="s2">? emitHint(request, </span><span class="s3">&quot;X&quot;</span><span class="s2">, [src, options])</span>
              <span class="s2">: emitHint(request, </span><span class="s3">&quot;X&quot;</span><span class="s2">, src);</span>
          <span class="s2">}</span>
          <span class="s2">previousDispatcher.X(src, options);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">S: </span><span class="s4">function </span><span class="s2">(href, precedence, options) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href) {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">if </span><span class="s2">(request) {</span>
            <span class="s4">var </span><span class="s2">hints = request.hints,</span>
              <span class="s2">key = </span><span class="s3">&quot;S|&quot; </span><span class="s2">+ href;</span>
            <span class="s4">if </span><span class="s2">(hints.has(key)) </span><span class="s4">return</span><span class="s2">;</span>
            <span class="s2">hints.add(key);</span>
            <span class="s4">return </span><span class="s2">(options = trimOptions(options))</span>
              <span class="s2">? emitHint(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, [</span>
                  <span class="s2">href,</span>
                  <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">precedence ? precedence : </span><span class="s5">0</span><span class="s2">,</span>
                  <span class="s2">options</span>
                <span class="s2">])</span>
              <span class="s2">: </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">precedence</span>
                <span class="s2">? emitHint(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, [href, precedence])</span>
                <span class="s2">: emitHint(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, href);</span>
          <span class="s2">}</span>
          <span class="s2">previousDispatcher.S(href, precedence, options);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">M: </span><span class="s4">function </span><span class="s2">(src, options) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">src) {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">if </span><span class="s2">(request) {</span>
            <span class="s4">var </span><span class="s2">hints = request.hints,</span>
              <span class="s2">key = </span><span class="s3">&quot;M|&quot; </span><span class="s2">+ src;</span>
            <span class="s4">if </span><span class="s2">(hints.has(key)) </span><span class="s4">return</span><span class="s2">;</span>
            <span class="s2">hints.add(key);</span>
            <span class="s4">return </span><span class="s2">(options = trimOptions(options))</span>
              <span class="s2">? emitHint(request, </span><span class="s3">&quot;M&quot;</span><span class="s2">, [src, options])</span>
              <span class="s2">: emitHint(request, </span><span class="s3">&quot;M&quot;</span><span class="s2">, src);</span>
          <span class="s2">}</span>
          <span class="s2">previousDispatcher.M(src, options);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s4">var </span><span class="s2">framesToSkip = </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">collectedStackTrace = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">identifierRegExp = </span><span class="s7">/^[a-zA-Z_$][0-9a-zA-Z_$]*$/</span><span class="s2">,</span>
      <span class="s2">frameRegExp =</span>
        <span class="s7">/^ {3} at (?:(.+) \((?:(.+):(\d+):(\d+)|&lt;anonymous&gt;)\)|(?:async )?(.+):(\d+):(\d+)|&lt;anonymous&gt;)$/</span><span class="s2">,</span>
      <span class="s2">stackTraceCache = </span><span class="s4">new </span><span class="s2">WeakMap(),</span>
      <span class="s2">supportsRequestStorage = </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">AsyncLocalStorage,</span>
      <span class="s2">requestStorage = supportsRequestStorage ? </span><span class="s4">new </span><span class="s2">AsyncLocalStorage() : </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">supportsComponentStorage = supportsRequestStorage,</span>
      <span class="s2">componentStorage = supportsComponentStorage</span>
        <span class="s2">? </span><span class="s4">new </span><span class="s2">AsyncLocalStorage()</span>
        <span class="s2">: </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">TEMPORARY_REFERENCE_TAG = Symbol.for(</span><span class="s3">&quot;react.temporary.reference&quot;</span><span class="s2">),</span>
      <span class="s2">proxyHandlers = {</span>
        <span class="s2">get: </span><span class="s4">function </span><span class="s2">(target, name) {</span>
          <span class="s4">switch </span><span class="s2">(name) {</span>
            <span class="s4">case </span><span class="s3">&quot;$$typeof&quot;</span><span class="s2">:</span>
              <span class="s4">return </span><span class="s2">target.$$typeof;</span>
            <span class="s4">case </span><span class="s3">&quot;name&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;displayName&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;defaultProps&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;_debugInfo&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
            <span class="s4">case </span><span class="s2">Symbol.toPrimitive:</span>
              <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toPrimitive];</span>
            <span class="s4">case </span><span class="s2">Symbol.toStringTag:</span>
              <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toStringTag];</span>
            <span class="s4">case </span><span class="s3">&quot;Provider&quot;</span><span class="s2">:</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.&quot;</span>
              <span class="s2">);</span>
            <span class="s4">case </span><span class="s3">&quot;then&quot;</span><span class="s2">:</span>
              <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Cannot access &quot; </span><span class="s2">+</span>
              <span class="s2">String(name) +</span>
              <span class="s3">&quot; on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.&quot;</span>
          <span class="s2">);</span>
        <span class="s2">},</span>
        <span class="s2">set: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Cannot assign to a temporary client reference from a server module.&quot;</span>
          <span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">SuspenseException = Error(</span>
        <span class="s3">&quot;Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.</span><span class="s6">\n\n</span><span class="s3">To handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.&quot;</span>
      <span class="s2">),</span>
      <span class="s2">suspendedThenable = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">currentRequest$1 = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">thenableIndexCounter = </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">thenableState = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">currentComponentDebugInfo = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">HooksDispatcher = {</span>
        <span class="s2">readContext: unsupportedContext,</span>
        <span class="s2">use: </span><span class="s4">function </span><span class="s2">(usable) {</span>
          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">!== usable &amp;&amp; </span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">usable) ||</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">usable</span>
          <span class="s2">) {</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">usable.then) {</span>
              <span class="s4">var </span><span class="s2">index = thenableIndexCounter;</span>
              <span class="s2">thenableIndexCounter += </span><span class="s5">1</span><span class="s2">;</span>
              <span class="s4">null </span><span class="s2">=== thenableState &amp;&amp; (thenableState = []);</span>
              <span class="s4">return </span><span class="s2">trackUsedThenable(thenableState, usable, index);</span>
            <span class="s2">}</span>
            <span class="s2">usable.$$typeof === REACT_CONTEXT_TYPE &amp;&amp; unsupportedContext();</span>
          <span class="s2">}</span>
          <span class="s4">if </span><span class="s2">(isClientReference(usable)) {</span>
            <span class="s4">if </span><span class="s2">(</span>
              <span class="s4">null </span><span class="s2">!= usable.value &amp;&amp;</span>
              <span class="s2">usable.value.$$typeof === REACT_CONTEXT_TYPE</span>
            <span class="s2">)</span>
              <span class="s4">throw </span><span class="s2">Error(</span>
                <span class="s3">&quot;Cannot read a Client Context from a Server Component.&quot;</span>
              <span class="s2">);</span>
            <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot use() an already resolved Client Reference.&quot;</span><span class="s2">);</span>
          <span class="s2">}</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;An unsupported type was passed to use(): &quot; </span><span class="s2">+ String(usable)</span>
          <span class="s2">);</span>
        <span class="s2">},</span>
        <span class="s2">useCallback: </span><span class="s4">function </span><span class="s2">(callback) {</span>
          <span class="s4">return </span><span class="s2">callback;</span>
        <span class="s2">},</span>
        <span class="s2">useContext: unsupportedContext,</span>
        <span class="s2">useEffect: unsupportedHook,</span>
        <span class="s2">useImperativeHandle: unsupportedHook,</span>
        <span class="s2">useLayoutEffect: unsupportedHook,</span>
        <span class="s2">useInsertionEffect: unsupportedHook,</span>
        <span class="s2">useMemo: </span><span class="s4">function </span><span class="s2">(nextCreate) {</span>
          <span class="s4">return </span><span class="s2">nextCreate();</span>
        <span class="s2">},</span>
        <span class="s2">useReducer: unsupportedHook,</span>
        <span class="s2">useRef: unsupportedHook,</span>
        <span class="s2">useState: unsupportedHook,</span>
        <span class="s2">useDebugValue: </span><span class="s4">function </span><span class="s2">() {},</span>
        <span class="s2">useDeferredValue: unsupportedHook,</span>
        <span class="s2">useTransition: unsupportedHook,</span>
        <span class="s2">useSyncExternalStore: unsupportedHook,</span>
        <span class="s2">useId: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== currentRequest$1)</span>
            <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;useId can only be used while React is rendering&quot;</span><span class="s2">);</span>
          <span class="s4">var </span><span class="s2">id = currentRequest$1.identifierCount++;</span>
          <span class="s4">return </span><span class="s2">(</span>
            <span class="s3">&quot;_&quot; </span><span class="s2">+</span>
            <span class="s2">currentRequest$1.identifierPrefix +</span>
            <span class="s3">&quot;S_&quot; </span><span class="s2">+</span>
            <span class="s2">id.toString(</span><span class="s5">32</span><span class="s2">) +</span>
            <span class="s3">&quot;_&quot;</span>
          <span class="s2">);</span>
        <span class="s2">},</span>
        <span class="s2">useHostTransitionStatus: unsupportedHook,</span>
        <span class="s2">useFormState: unsupportedHook,</span>
        <span class="s2">useActionState: unsupportedHook,</span>
        <span class="s2">useOptimistic: unsupportedHook,</span>
        <span class="s2">useMemoCache: </span><span class="s4">function </span><span class="s2">(size) {</span>
          <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">data = Array(size), i = </span><span class="s5">0</span><span class="s2">; i &lt; size; i++)</span>
            <span class="s2">data[i] = REACT_MEMO_CACHE_SENTINEL;</span>
          <span class="s4">return </span><span class="s2">data;</span>
        <span class="s2">},</span>
        <span class="s2">useCacheRefresh: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">unsupportedRefresh;</span>
        <span class="s2">}</span>
      <span class="s2">};</span>
    <span class="s2">HooksDispatcher.useEffectEvent = unsupportedHook;</span>
    <span class="s4">var </span><span class="s2">currentOwner = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">DefaultAsyncDispatcher = {</span>
        <span class="s2">getCacheForType: </span><span class="s4">function </span><span class="s2">(resourceType) {</span>
          <span class="s4">var </span><span class="s2">cache = (cache = resolveRequest()) ? cache.cache : </span><span class="s4">new </span><span class="s2">Map();</span>
          <span class="s4">var </span><span class="s2">entry = cache.get(resourceType);</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== entry &amp;&amp;</span>
            <span class="s2">((entry = resourceType()), cache.set(resourceType, entry));</span>
          <span class="s4">return </span><span class="s2">entry;</span>
        <span class="s2">},</span>
        <span class="s2">cacheSignal: </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
          <span class="s4">return </span><span class="s2">request ? request.cacheController.signal : </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">};</span>
    <span class="s2">DefaultAsyncDispatcher.getOwner = resolveOwner;</span>
    <span class="s4">var </span><span class="s2">ReactSharedInternalsServer =</span>
      <span class="s2">React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;</span>
    <span class="s4">if </span><span class="s2">(!ReactSharedInternalsServer)</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">'The &quot;react&quot; package in this environment is not configured correctly. The &quot;react-server&quot; condition must be enabled in any environment that runs React Server Components.'</span>
      <span class="s2">);</span>
    <span class="s4">var </span><span class="s2">prefix, suffix;</span>
    <span class="s4">new </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">WeakMap ? WeakMap : Map)();</span>
    <span class="s4">var </span><span class="s2">lastResetTime = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">performance &amp;&amp;</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">performance.now</span>
    <span class="s2">) {</span>
      <span class="s4">var </span><span class="s2">localPerformance = performance;</span>
      <span class="s4">var </span><span class="s2">getCurrentTime = </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">return </span><span class="s2">localPerformance.now();</span>
      <span class="s2">};</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">localDate = Date;</span>
      <span class="s2">getCurrentTime = </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">return </span><span class="s2">localDate.now();</span>
      <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s4">var </span><span class="s2">callComponent = {</span>
        <span class="s2">react_stack_bottom_frame: </span><span class="s4">function </span><span class="s2">(</span>
          <span class="s2">Component,</span>
          <span class="s2">props,</span>
          <span class="s2">componentDebugInfo</span>
        <span class="s2">) {</span>
          <span class="s2">currentOwner = componentDebugInfo;</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">return </span><span class="s2">Component(props, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">);</span>
          <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
            <span class="s2">currentOwner = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">callComponentInDEV =</span>
        <span class="s2">callComponent.react_stack_bottom_frame.bind(callComponent),</span>
      <span class="s2">callLazyInit = {</span>
        <span class="s2">react_stack_bottom_frame: </span><span class="s4">function </span><span class="s2">(lazy) {</span>
          <span class="s4">var </span><span class="s2">init = lazy._init;</span>
          <span class="s4">return </span><span class="s2">init(lazy._payload);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">callLazyInitInDEV =</span>
        <span class="s2">callLazyInit.react_stack_bottom_frame.bind(callLazyInit),</span>
      <span class="s2">callIterator = {</span>
        <span class="s2">react_stack_bottom_frame: </span><span class="s4">function </span><span class="s2">(iterator, progress, error) {</span>
          <span class="s2">iterator.next().then(progress, error);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
      <span class="s2">callIteratorInDEV =</span>
        <span class="s2">callIterator.react_stack_bottom_frame.bind(callIterator),</span>
      <span class="s2">isArrayImpl = Array.isArray,</span>
      <span class="s2">getPrototypeOf = Object.getPrototypeOf,</span>
      <span class="s2">jsxPropsParents = </span><span class="s4">new </span><span class="s2">WeakMap(),</span>
      <span class="s2">jsxChildrenParents = </span><span class="s4">new </span><span class="s2">WeakMap(),</span>
      <span class="s2">CLIENT_REFERENCE_TAG = Symbol.for(</span><span class="s3">&quot;react.client.reference&quot;</span><span class="s2">),</span>
      <span class="s2">hasOwnProperty = Object.prototype.hasOwnProperty,</span>
      <span class="s2">doNotLimit = </span><span class="s4">new </span><span class="s2">WeakSet();</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">console &amp;&amp;</span>
      <span class="s4">null </span><span class="s2">!== console &amp;&amp;</span>
      <span class="s2">(patchConsole(console, </span><span class="s3">&quot;assert&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;debug&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;dir&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;dirxml&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;error&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;group&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;groupCollapsed&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;groupEnd&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;info&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;log&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;table&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;trace&quot;</span><span class="s2">),</span>
      <span class="s2">patchConsole(console, </span><span class="s3">&quot;warn&quot;</span><span class="s2">));</span>
    <span class="s4">var </span><span class="s2">ObjectPrototype = Object.prototype,</span>
      <span class="s2">stringify = JSON.stringify,</span>
      <span class="s2">ABORTING = </span><span class="s5">12</span><span class="s2">,</span>
      <span class="s2">CLOSED = </span><span class="s5">14</span><span class="s2">,</span>
      <span class="s2">TaintRegistryObjects = ReactSharedInternalsServer.TaintRegistryObjects,</span>
      <span class="s2">TaintRegistryValues = ReactSharedInternalsServer.TaintRegistryValues,</span>
      <span class="s2">TaintRegistryByteLengths =</span>
        <span class="s2">ReactSharedInternalsServer.TaintRegistryByteLengths,</span>
      <span class="s2">TaintRegistryPendingRequests =</span>
        <span class="s2">ReactSharedInternalsServer.TaintRegistryPendingRequests,</span>
      <span class="s2">defaultPostponeHandler = noop,</span>
      <span class="s2">currentRequest = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">canEmitDebugInfo = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">serializedSize = </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">MAX_ROW_SIZE = </span><span class="s5">3200</span><span class="s2">,</span>
      <span class="s2">modelRoot = !</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">CONSTRUCTOR_MARKER = Symbol(),</span>
      <span class="s2">debugModelRoot = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">debugNoOutline = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">emptyRoot = {},</span>
      <span class="s2">decoderOptions = { stream: !</span><span class="s5">0 </span><span class="s2">},</span>
      <span class="s2">chunkCache = </span><span class="s4">new </span><span class="s2">Map();</span>
    <span class="s2">Chunk.prototype = Object.create(Promise.prototype);</span>
    <span class="s2">Chunk.prototype.then = </span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
      <span class="s4">switch </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
          <span class="s2">initializeModelChunk(</span><span class="s4">this</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">switch </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s2">resolve(</span><span class="s4">this</span><span class="s2">.value);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;cyclic&quot;</span><span class="s2">:</span>
          <span class="s2">resolve &amp;&amp;</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">=== </span><span class="s4">this</span><span class="s2">.value &amp;&amp; (</span><span class="s4">this</span><span class="s2">.value = []),</span>
            <span class="s4">this</span><span class="s2">.value.push(resolve));</span>
          <span class="s2">reject &amp;&amp;</span>
            <span class="s2">(</span><span class="s4">null </span><span class="s2">=== </span><span class="s4">this</span><span class="s2">.reason &amp;&amp; (</span><span class="s4">this</span><span class="s2">.reason = []),</span>
            <span class="s4">this</span><span class="s2">.reason.push(reject));</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">default</span><span class="s2">:</span>
          <span class="s2">reject(</span><span class="s4">this</span><span class="s2">.reason);</span>
      <span class="s2">}</span>
    <span class="s2">};</span>
    <span class="s4">var </span><span class="s2">initializingChunk = </span><span class="s4">null</span><span class="s2">,</span>
      <span class="s2">initializingChunkBlockedModel = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">exports.createClientModuleProxy = </span><span class="s4">function </span><span class="s2">(moduleId) {</span>
      <span class="s2">moduleId = registerClientReferenceImpl({}, moduleId, !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">return new </span><span class="s2">Proxy(moduleId, proxyHandlers$1);</span>
    <span class="s2">};</span>
    <span class="s2">exports.createTemporaryReferenceSet = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return new </span><span class="s2">WeakMap();</span>
    <span class="s2">};</span>
    <span class="s2">exports.decodeAction = </span><span class="s4">function </span><span class="s2">(body, serverManifest) {</span>
      <span class="s4">var </span><span class="s2">formData = </span><span class="s4">new </span><span class="s2">FormData(),</span>
        <span class="s2">action = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">body.forEach(</span><span class="s4">function </span><span class="s2">(value, key) {</span>
        <span class="s2">key.startsWith(</span><span class="s3">&quot;$ACTION_&quot;</span><span class="s2">)</span>
          <span class="s2">? key.startsWith(</span><span class="s3">&quot;$ACTION_REF_&quot;</span><span class="s2">)</span>
            <span class="s2">? ((value = </span><span class="s3">&quot;$ACTION_&quot; </span><span class="s2">+ key.slice(</span><span class="s5">12</span><span class="s2">) + </span><span class="s3">&quot;:&quot;</span><span class="s2">),</span>
              <span class="s2">(value = decodeBoundActionMetaData(body, serverManifest, value)),</span>
              <span class="s2">(action = loadServerReference(</span>
                <span class="s2">serverManifest,</span>
                <span class="s2">value.id,</span>
                <span class="s2">value.bound</span>
              <span class="s2">)))</span>
            <span class="s2">: key.startsWith(</span><span class="s3">&quot;$ACTION_ID_&quot;</span><span class="s2">) &amp;&amp;</span>
              <span class="s2">((value = key.slice(</span><span class="s5">11</span><span class="s2">)),</span>
              <span class="s2">(action = loadServerReference(serverManifest, value, </span><span class="s4">null</span><span class="s2">)))</span>
          <span class="s2">: formData.append(key, value);</span>
      <span class="s2">});</span>
      <span class="s4">return null </span><span class="s2">=== action</span>
        <span class="s2">? </span><span class="s4">null</span>
        <span class="s2">: action.then(</span><span class="s4">function </span><span class="s2">(fn) {</span>
            <span class="s4">return </span><span class="s2">fn.bind(</span><span class="s4">null</span><span class="s2">, formData);</span>
          <span class="s2">});</span>
    <span class="s2">};</span>
    <span class="s2">exports.decodeFormState = </span><span class="s4">function </span><span class="s2">(actionResult, body, serverManifest) {</span>
      <span class="s4">var </span><span class="s2">keyPath = body.get(</span><span class="s3">&quot;$ACTION_KEY&quot;</span><span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">keyPath) </span><span class="s4">return </span><span class="s2">Promise.resolve(</span><span class="s4">null</span><span class="s2">);</span>
      <span class="s4">var </span><span class="s2">metaData = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">body.forEach(</span><span class="s4">function </span><span class="s2">(value, key) {</span>
        <span class="s2">key.startsWith(</span><span class="s3">&quot;$ACTION_REF_&quot;</span><span class="s2">) &amp;&amp;</span>
          <span class="s2">((value = </span><span class="s3">&quot;$ACTION_&quot; </span><span class="s2">+ key.slice(</span><span class="s5">12</span><span class="s2">) + </span><span class="s3">&quot;:&quot;</span><span class="s2">),</span>
          <span class="s2">(metaData = decodeBoundActionMetaData(body, serverManifest, value)));</span>
      <span class="s2">});</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== metaData) </span><span class="s4">return </span><span class="s2">Promise.resolve(</span><span class="s4">null</span><span class="s2">);</span>
      <span class="s4">var </span><span class="s2">referenceId = metaData.id;</span>
      <span class="s4">return </span><span class="s2">Promise.resolve(metaData.bound).then(</span><span class="s4">function </span><span class="s2">(bound) {</span>
        <span class="s4">return null </span><span class="s2">=== bound</span>
          <span class="s2">? </span><span class="s4">null</span>
          <span class="s2">: [actionResult, keyPath, referenceId, bound.length - </span><span class="s5">1</span><span class="s2">];</span>
      <span class="s2">});</span>
    <span class="s2">};</span>
    <span class="s2">exports.decodeReply = </span><span class="s4">function </span><span class="s2">(body, webpackMap, options) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">body) {</span>
        <span class="s4">var </span><span class="s2">form = </span><span class="s4">new </span><span class="s2">FormData();</span>
        <span class="s2">form.append(</span><span class="s3">&quot;0&quot;</span><span class="s2">, body);</span>
        <span class="s2">body = form;</span>
      <span class="s2">}</span>
      <span class="s2">body = createResponse(</span>
        <span class="s2">webpackMap,</span>
        <span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">body</span>
      <span class="s2">);</span>
      <span class="s2">webpackMap = getChunk(body, </span><span class="s5">0</span><span class="s2">);</span>
      <span class="s2">close(body);</span>
      <span class="s4">return </span><span class="s2">webpackMap;</span>
    <span class="s2">};</span>
    <span class="s2">exports.decodeReplyFromAsyncIterable = </span><span class="s4">function </span><span class="s2">(</span>
      <span class="s2">iterable,</span>
      <span class="s2">webpackMap,</span>
      <span class="s2">options</span>
    <span class="s2">) {</span>
      <span class="s4">function </span><span class="s2">progress(entry) {</span>
        <span class="s4">if </span><span class="s2">(entry.done) close(response$jscomp$0);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s2">entry = entry.value;</span>
          <span class="s4">var </span><span class="s2">name = entry[</span><span class="s5">0</span><span class="s2">];</span>
          <span class="s2">entry = entry[</span><span class="s5">1</span><span class="s2">];</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">entry) {</span>
            <span class="s4">var </span><span class="s2">response = response$jscomp$0;</span>
            <span class="s2">response._formData.append(name, entry);</span>
            <span class="s4">var </span><span class="s2">prefix = response._prefix;</span>
            <span class="s2">name.startsWith(prefix) &amp;&amp;</span>
              <span class="s2">((response = response._chunks),</span>
              <span class="s2">(name = +name.slice(prefix.length)),</span>
              <span class="s2">(prefix = response.get(name)) &amp;&amp;</span>
                <span class="s2">resolveModelChunk(prefix, entry, name));</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">response$jscomp$0._formData.append(name, entry);</span>
          <span class="s2">iterator.next().then(progress, error);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">function </span><span class="s2">error(reason) {</span>
        <span class="s2">reportGlobalError(response$jscomp$0, reason);</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">iterator.throw &amp;&amp;</span>
          <span class="s2">iterator.throw(reason).then(error, error);</span>
      <span class="s2">}</span>
      <span class="s4">var </span><span class="s2">iterator = iterable[ASYNC_ITERATOR](),</span>
        <span class="s2">response$jscomp$0 = createResponse(</span>
          <span class="s2">webpackMap,</span>
          <span class="s3">&quot;&quot;</span><span class="s2">,</span>
          <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span>
        <span class="s2">);</span>
      <span class="s2">iterator.next().then(progress, error);</span>
      <span class="s4">return </span><span class="s2">getChunk(response$jscomp$0, </span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">};</span>
    <span class="s2">exports.registerClientReference = </span><span class="s4">function </span><span class="s2">(</span>
      <span class="s2">proxyImplementation,</span>
      <span class="s2">id,</span>
      <span class="s2">exportName</span>
    <span class="s2">) {</span>
      <span class="s4">return </span><span class="s2">registerClientReferenceImpl(</span>
        <span class="s2">proxyImplementation,</span>
        <span class="s2">id + </span><span class="s3">&quot;#&quot; </span><span class="s2">+ exportName,</span>
        <span class="s2">!</span><span class="s5">1</span>
      <span class="s2">);</span>
    <span class="s2">};</span>
    <span class="s2">exports.registerServerReference = </span><span class="s4">function </span><span class="s2">(reference, id, exportName) {</span>
      <span class="s4">return </span><span class="s2">Object.defineProperties(reference, {</span>
        <span class="s2">$$typeof: { value: SERVER_REFERENCE_TAG },</span>
        <span class="s2">$$id: {</span>
          <span class="s2">value: </span><span class="s4">null </span><span class="s2">=== exportName ? id : id + </span><span class="s3">&quot;#&quot; </span><span class="s2">+ exportName,</span>
          <span class="s2">configurable: !</span><span class="s5">0</span>
        <span class="s2">},</span>
        <span class="s2">$$bound: { value: </span><span class="s4">null</span><span class="s2">, configurable: !</span><span class="s5">0 </span><span class="s2">},</span>
        <span class="s2">$$location: { value: Error(</span><span class="s3">&quot;react-stack-top-frame&quot;</span><span class="s2">), configurable: !</span><span class="s5">0 </span><span class="s2">},</span>
        <span class="s2">bind: { value: bind, configurable: !</span><span class="s5">0 </span><span class="s2">}</span>
      <span class="s2">});</span>
    <span class="s2">};</span>
    <span class="s2">exports.renderToReadableStream = </span><span class="s4">function </span><span class="s2">(model, webpackMap, options) {</span>
      <span class="s4">var </span><span class="s2">debugChannelReadable =</span>
          <span class="s2">options &amp;&amp; options.debugChannel</span>
            <span class="s2">? options.debugChannel.readable</span>
            <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">debugChannelWritable =</span>
          <span class="s2">options &amp;&amp; options.debugChannel</span>
            <span class="s2">? options.debugChannel.writable</span>
            <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s2">request = createRequest(</span>
          <span class="s2">model,</span>
          <span class="s2">webpackMap,</span>
          <span class="s2">options ? options.onError : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.identifierPrefix : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.onPostpone : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.environmentName : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.filterStackFrame : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== debugChannelReadable</span>
        <span class="s2">);</span>
      <span class="s4">if </span><span class="s2">(options &amp;&amp; options.signal) {</span>
        <span class="s4">var </span><span class="s2">signal = options.signal;</span>
        <span class="s4">if </span><span class="s2">(signal.aborted) abort(request, signal.reason);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">listener = </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s2">abort(request, signal.reason);</span>
            <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
          <span class="s2">};</span>
          <span class="s2">signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== debugChannelWritable &amp;&amp;</span>
        <span class="s4">new </span><span class="s2">ReadableStream(</span>
          <span class="s2">{</span>
            <span class="s2">type: </span><span class="s3">&quot;bytes&quot;</span><span class="s2">,</span>
            <span class="s2">pull: </span><span class="s4">function </span><span class="s2">(controller) {</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== request.status)</span>
                <span class="s2">(request.status = CLOSED),</span>
                  <span class="s2">closeWithError(controller, request.fatalError);</span>
              <span class="s4">else if </span><span class="s2">(</span>
                <span class="s2">request.status !== CLOSED &amp;&amp;</span>
                <span class="s4">null </span><span class="s2">=== request.debugDestination</span>
              <span class="s2">) {</span>
                <span class="s2">request.debugDestination = controller;</span>
                <span class="s4">try </span><span class="s2">{</span>
                  <span class="s2">flushCompletedChunks(request);</span>
                <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
                  <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">),</span>
                    <span class="s2">fatalError(request, error);</span>
                <span class="s2">}</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
          <span class="s2">},</span>
          <span class="s2">{ highWaterMark: </span><span class="s5">0 </span><span class="s2">}</span>
        <span class="s2">).pipeTo(debugChannelWritable);</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== debugChannelReadable &amp;&amp;</span>
        <span class="s2">startReadingFromDebugChannelReadableStream(</span>
          <span class="s2">request,</span>
          <span class="s2">debugChannelReadable</span>
        <span class="s2">);</span>
      <span class="s4">return new </span><span class="s2">ReadableStream(</span>
        <span class="s2">{</span>
          <span class="s2">type: </span><span class="s3">&quot;bytes&quot;</span><span class="s2">,</span>
          <span class="s2">start: </span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s2">startWork(request);</span>
          <span class="s2">},</span>
          <span class="s2">pull: </span><span class="s4">function </span><span class="s2">(controller) {</span>
            <span class="s2">startFlowing(request, controller);</span>
          <span class="s2">},</span>
          <span class="s2">cancel: </span><span class="s4">function </span><span class="s2">(reason) {</span>
            <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s2">abort(request, reason);</span>
          <span class="s2">}</span>
        <span class="s2">},</span>
        <span class="s2">{ highWaterMark: </span><span class="s5">0 </span><span class="s2">}</span>
      <span class="s2">);</span>
    <span class="s2">};</span>
    <span class="s2">exports.unstable_prerender = </span><span class="s4">function </span><span class="s2">(model, webpackMap, options) {</span>
      <span class="s4">return new </span><span class="s2">Promise(</span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
        <span class="s4">var </span><span class="s2">request = createPrerenderRequest(</span>
          <span class="s2">model,</span>
          <span class="s2">webpackMap,</span>
          <span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">var </span><span class="s2">stream = </span><span class="s4">new </span><span class="s2">ReadableStream(</span>
              <span class="s2">{</span>
                <span class="s2">type: </span><span class="s3">&quot;bytes&quot;</span><span class="s2">,</span>
                <span class="s2">pull: </span><span class="s4">function </span><span class="s2">(controller) {</span>
                  <span class="s2">startFlowing(request, controller);</span>
                <span class="s2">},</span>
                <span class="s2">cancel: </span><span class="s4">function </span><span class="s2">(reason) {</span>
                  <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
                  <span class="s2">abort(request, reason);</span>
                <span class="s2">}</span>
              <span class="s2">},</span>
              <span class="s2">{ highWaterMark: </span><span class="s5">0 </span><span class="s2">}</span>
            <span class="s2">);</span>
            <span class="s2">resolve({ prelude: stream });</span>
          <span class="s2">},</span>
          <span class="s2">reject,</span>
          <span class="s2">options ? options.onError : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.identifierPrefix : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.onPostpone : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.environmentName : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">options ? options.filterStackFrame : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
          <span class="s2">!</span><span class="s5">1</span>
        <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(options &amp;&amp; options.signal) {</span>
          <span class="s4">var </span><span class="s2">signal = options.signal;</span>
          <span class="s4">if </span><span class="s2">(signal.aborted) abort(request, signal.reason);</span>
          <span class="s4">else </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">listener = </span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s2">abort(request, signal.reason);</span>
              <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
            <span class="s2">};</span>
            <span class="s2">signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">startWork(request);</span>
      <span class="s2">});</span>
    <span class="s2">};</span>
  <span class="s2">})();</span>
</pre>
</body>
</html>