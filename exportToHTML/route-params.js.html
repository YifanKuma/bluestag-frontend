<html>
<head>
<title>route-params.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
route-params.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">doesStaticSegmentAppearInURL: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getCacheKeyForDynamicParam: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getParamValueFromCacheKey: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getRenderedPathname: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getRenderedSearch: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">parseDynamicParamFromURLPart: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">urlToUrlWithoutFlightMarker: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">doesStaticSegmentAppearInURL: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">doesStaticSegmentAppearInURL;</span>
    <span class="s1">},</span>
    <span class="s1">getCacheKeyForDynamicParam: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getCacheKeyForDynamicParam;</span>
    <span class="s1">},</span>
    <span class="s1">getParamValueFromCacheKey: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getParamValueFromCacheKey;</span>
    <span class="s1">},</span>
    <span class="s1">getRenderedPathname: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getRenderedPathname;</span>
    <span class="s1">},</span>
    <span class="s1">getRenderedSearch: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getRenderedSearch;</span>
    <span class="s1">},</span>
    <span class="s1">parseDynamicParamFromURLPart: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">parseDynamicParamFromURLPart;</span>
    <span class="s1">},</span>
    <span class="s1">urlToUrlWithoutFlightMarker: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">urlToUrlWithoutFlightMarker;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_segment = require(</span><span class="s0">&quot;../shared/lib/segment&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segmentvalueencoding = require(</span><span class="s0">&quot;../shared/lib/segment-cache/segment-value-encoding&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterheaders = require(</span><span class="s0">&quot;./components/app-router-headers&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">getRenderedSearch(response) {</span>
    <span class="s4">// If the server performed a rewrite, the search params used to render the</span>
    <span class="s4">// page will be different from the params in the request URL. In this case,</span>
    <span class="s4">// the response will include a header that gives the rewritten search query.</span>
    <span class="s2">const </span><span class="s1">rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);</span>
    <span class="s2">if </span><span class="s1">(rewrittenQuery !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">rewrittenQuery === </span><span class="s0">'' </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'?' </span><span class="s1">+ rewrittenQuery;</span>
    <span class="s1">}</span>
    <span class="s4">// If the header is not present, there was no rewrite, so we use the search</span>
    <span class="s4">// query of the response URL.</span>
    <span class="s2">return </span><span class="s1">urlToUrlWithoutFlightMarker(</span><span class="s2">new </span><span class="s1">URL(response.url)).search;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getRenderedPathname(response) {</span>
    <span class="s4">// If the server performed a rewrite, the pathname used to render the</span>
    <span class="s4">// page will be different from the pathname in the request URL. In this case,</span>
    <span class="s4">// the response will include a header that gives the rewritten pathname.</span>
    <span class="s2">const </span><span class="s1">rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);</span>
    <span class="s2">return </span><span class="s1">rewrittenPath != </span><span class="s2">null </span><span class="s1">? rewrittenPath : urlToUrlWithoutFlightMarker(</span><span class="s2">new </span><span class="s1">URL(response.url)).pathname;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {</span>
    <span class="s4">// This needs to match the behavior in get-dynamic-param.ts.</span>
    <span class="s2">switch</span><span class="s1">(paramType){</span>
        <span class="s4">// Catchalls</span>
        <span class="s2">case </span><span class="s0">'c'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'ci'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s4">// Catchalls receive all the remaining URL parts. If there are no</span>
                <span class="s4">// remaining pathname parts, return an empty array.</span>
                <span class="s2">return </span><span class="s1">partIndex &lt; pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=&gt;encodeURIComponent(s)) : [];</span>
            <span class="s1">}</span>
        <span class="s4">// Optional catchalls</span>
        <span class="s2">case </span><span class="s0">'oc'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s4">// Optional catchalls receive all the remaining URL parts, unless this is</span>
                <span class="s4">// the end of the pathname, in which case they return null.</span>
                <span class="s2">return </span><span class="s1">partIndex &lt; pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=&gt;encodeURIComponent(s)) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s4">// Dynamic</span>
        <span class="s2">case </span><span class="s0">'d'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'di'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(partIndex &gt;= pathnameParts.length) {</span>
                    <span class="s4">// The route tree expected there to be more parts in the URL than there</span>
                    <span class="s4">// actually are. This could happen if the x-nextjs-rewritten-path header</span>
                    <span class="s4">// is incorrectly set, or potentially due to bug in Next.js. TODO:</span>
                    <span class="s4">// Should this be a hard error? During a prefetch, we can just abort.</span>
                    <span class="s4">// During a client navigation, we could trigger a hard refresh. But if</span>
                    <span class="s4">// it happens during initial render, we don't really have any</span>
                    <span class="s4">// recovery options.</span>
                    <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">encodeURIComponent(pathnameParts[partIndex]);</span>
            <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">paramType;</span>
            <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">doesStaticSegmentAppearInURL(segment) {</span>
    <span class="s4">// This is not a parameterized segment; however, we need to determine</span>
    <span class="s4">// whether or not this segment appears in the URL. For example, this route</span>
    <span class="s4">// groups do not appear in the URL, so they should be skipped. Any other</span>
    <span class="s4">// special cases must be handled here.</span>
    <span class="s4">// TODO: Consider encoding this directly into the router tree instead of</span>
    <span class="s4">// inferring it on the client based on the segment type. Something like</span>
    <span class="s4">// a `doesAppearInURL` flag in FlightRouterState.</span>
    <span class="s2">if </span><span class="s1">(segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || </span><span class="s4">// For some reason, the loader tree sometimes includes extra __PAGE__</span>
    <span class="s4">// &quot;layouts&quot; when part of a parallel route. But it's not a leaf node.</span>
    <span class="s4">// Otherwise, we wouldn't need this special case because pages are</span>
    <span class="s4">// always leaf nodes.</span>
    <span class="s4">// TODO: Investigate why the loader produces these fake page segments.</span>
    <span class="s1">segment.startsWith(_segment.PAGE_SEGMENT_KEY) || </span><span class="s4">// Route groups.</span>
    <span class="s1">segment[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'(' </span><span class="s1">&amp;&amp; segment.endsWith(</span><span class="s0">')'</span><span class="s1">) || segment === _segment.DEFAULT_SEGMENT_KEY || segment === </span><span class="s0">'/_not-found'</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s4">// All other segment types appear in the URL</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCacheKeyForDynamicParam(paramValue, renderedSearch) {</span>
    <span class="s4">// This needs to match the logic in get-dynamic-param.ts, until we're able to</span>
    <span class="s4">// unify the various implementations so that these are always computed on</span>
    <span class="s4">// the client.</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">paramValue === </span><span class="s0">'string'</span><span class="s1">) {</span>
        <span class="s4">// TODO: Refactor or remove this helper function to accept a string rather</span>
        <span class="s4">// than the whole segment type. Also we can probably just append the</span>
        <span class="s4">// search string instead of turning it into JSON.</span>
        <span class="s2">const </span><span class="s1">pageSegmentWithSearchParams = (</span><span class="s3">0</span><span class="s1">, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(</span><span class="s2">new </span><span class="s1">URLSearchParams(renderedSearch)));</span>
        <span class="s2">return </span><span class="s1">pageSegmentWithSearchParams;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(paramValue === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">paramValue.join(</span><span class="s0">'/'</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">urlToUrlWithoutFlightMarker(url) {</span>
    <span class="s2">const </span><span class="s1">urlWithoutFlightParameters = </span><span class="s2">new </span><span class="s1">URL(url);</span>
    <span class="s1">urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'production'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(process.env.__NEXT_CONFIG_OUTPUT === </span><span class="s0">'export' </span><span class="s1">&amp;&amp; urlWithoutFlightParameters.pathname.endsWith(</span><span class="s0">'.txt'</span><span class="s1">)) {</span>
            <span class="s2">const </span><span class="s1">{ pathname } = urlWithoutFlightParameters;</span>
            <span class="s2">const </span><span class="s1">length = pathname.endsWith(</span><span class="s0">'/index.txt'</span><span class="s1">) ? </span><span class="s3">10 </span><span class="s1">: </span><span class="s3">4</span><span class="s1">;</span>
            <span class="s4">// Slice off `/index.txt` or `.txt` from the end of the pathname</span>
            <span class="s1">urlWithoutFlightParameters.pathname = pathname.slice(</span><span class="s3">0</span><span class="s1">, -length);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">urlWithoutFlightParameters;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getParamValueFromCacheKey(paramCacheKey, paramType) {</span>
    <span class="s4">// Turn the cache key string sent by the server (as part of FlightRouterState)</span>
    <span class="s4">// into a value that can be passed to `useParams` and client components.</span>
    <span class="s2">const </span><span class="s1">isCatchAll = paramType === </span><span class="s0">'c' </span><span class="s1">|| paramType === </span><span class="s0">'oc'</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(isCatchAll) {</span>
        <span class="s4">// Catch-all param keys are a concatenation of the path segments.</span>
        <span class="s4">// See equivalent logic in `getSelectedParams`.</span>
        <span class="s4">// TODO: We should just pass the array directly, rather than concatenate</span>
        <span class="s4">// it to a string and then split it back to an array. It needs to be an</span>
        <span class="s4">// array in some places, like when passing a key React, but we can convert</span>
        <span class="s4">// it at runtime in those places.</span>
        <span class="s2">return </span><span class="s1">paramCacheKey.split(</span><span class="s0">'/'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">paramCacheKey;</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=route-params.js.map</span></pre>
</body>
</html>