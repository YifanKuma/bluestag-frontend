<html>
<head>
<title>encryption-utils-server.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
encryption-utils-server.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/encryption-utils-server.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file should never be bundled into application's runtime code and should</span><span class="s3">\n</span><span class="s1">// stay in the Next.js server.</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n</span><span class="s1">import { getStorageDirectory } from '../cache-dir'</span><span class="s3">\n</span><span class="s1">import { arrayBufferToString } from './encryption-utils'</span><span class="s3">\n\n</span><span class="s1">// Keep the key in memory as it should never change during the lifetime of the server in</span><span class="s3">\n</span><span class="s1">// both development and production.</span><span class="s3">\n</span><span class="s1">let __next_encryption_key_generation_promise: Promise&lt;string&gt; | null = null</span><span class="s3">\n</span><span class="s1">const CONFIG_FILE = '.rscinfo'</span><span class="s3">\n</span><span class="s1">const ENCRYPTION_KEY = 'encryption.key'</span><span class="s3">\n</span><span class="s1">const ENCRYPTION_EXPIRE_AT = 'encryption.expire_at'</span><span class="s3">\n</span><span class="s1">const EXPIRATION = 1000 * 60 * 60 * 24 * 14 // 14 days</span><span class="s3">\n\n</span><span class="s1">async function writeCache(distDir: string, configValue: string) {</span><span class="s3">\n  </span><span class="s1">const cacheBaseDir = getStorageDirectory(distDir)</span><span class="s3">\n  </span><span class="s1">if (!cacheBaseDir) return</span><span class="s3">\n\n  </span><span class="s1">const configPath = path.join(cacheBaseDir, CONFIG_FILE)</span><span class="s3">\n  </span><span class="s1">if (!fs.existsSync(cacheBaseDir)) {</span><span class="s3">\n    </span><span class="s1">await fs.promises.mkdir(cacheBaseDir, { recursive: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">await fs.promises.writeFile(</span><span class="s3">\n    </span><span class="s1">configPath,</span><span class="s3">\n    </span><span class="s1">JSON.stringify({</span><span class="s3">\n      </span><span class="s1">[ENCRYPTION_KEY]: configValue,</span><span class="s3">\n      </span><span class="s1">[ENCRYPTION_EXPIRE_AT]: Date.now() + EXPIRATION,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// This utility is used to get a key for the cache directory. If the</span><span class="s3">\n</span><span class="s1">// key is not present, it will generate a new one and store it in the</span><span class="s3">\n</span><span class="s1">// cache directory inside dist.</span><span class="s3">\n</span><span class="s1">// The key will also expire after a certain amount of time. Once it</span><span class="s3">\n</span><span class="s1">// expires, a new one will be generated.</span><span class="s3">\n</span><span class="s1">// During the lifetime of the server, it will be reused and never refreshed.</span><span class="s3">\n</span><span class="s1">async function loadOrGenerateKey(</span><span class="s3">\n  </span><span class="s1">distDir: string,</span><span class="s3">\n  </span><span class="s1">isBuild: boolean,</span><span class="s3">\n  </span><span class="s1">generateKey: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n  </span><span class="s1">const cacheBaseDir = getStorageDirectory(distDir)</span><span class="s3">\n\n  </span><span class="s1">if (!cacheBaseDir) {</span><span class="s3">\n    </span><span class="s1">// There's no persistent storage available. We generate a new key.</span><span class="s3">\n    </span><span class="s1">// This also covers development time.</span><span class="s3">\n    </span><span class="s1">return await generateKey()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const configPath = path.join(cacheBaseDir, CONFIG_FILE)</span><span class="s3">\n  </span><span class="s1">async function hasCachedKey(): Promise&lt;false | string&gt; {</span><span class="s3">\n    </span><span class="s1">if (!fs.existsSync(configPath)) return false</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const config = JSON.parse(await fs.promises.readFile(configPath, 'utf8'))</span><span class="s3">\n      </span><span class="s1">if (!config) return false</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">typeof config[ENCRYPTION_KEY] !== 'string' ||</span><span class="s3">\n        </span><span class="s1">typeof config[ENCRYPTION_EXPIRE_AT] !== 'number'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// For build time, we need to rotate the key if it's expired. Otherwise</span><span class="s3">\n      </span><span class="s1">// (next start) we have to keep the key as it is so the runtime key matches</span><span class="s3">\n      </span><span class="s1">// the build time key.</span><span class="s3">\n      </span><span class="s1">if (isBuild &amp;&amp; config[ENCRYPTION_EXPIRE_AT] &lt; Date.now()) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const cachedKey = config[ENCRYPTION_KEY]</span><span class="s3">\n\n      </span><span class="s1">// If encryption key is provided via env, and it's not same as valid cache,</span><span class="s3">\n      </span><span class="s1">//  we should not use the cached key and respect the env key.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">cachedKey &amp;&amp;</span><span class="s3">\n        </span><span class="s1">process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY &amp;&amp;</span><span class="s3">\n        </span><span class="s1">cachedKey !== process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return cachedKey</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n      </span><span class="s1">// Broken config file. We should generate a new key and overwrite it.</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const maybeValidKey = await hasCachedKey()</span><span class="s3">\n  </span><span class="s1">if (typeof maybeValidKey === 'string') {</span><span class="s3">\n    </span><span class="s1">return maybeValidKey</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const key = await generateKey()</span><span class="s3">\n  </span><span class="s1">await writeCache(distDir, key)</span><span class="s3">\n\n  </span><span class="s1">return key</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function generateEncryptionKeyBase64({</span><span class="s3">\n  </span><span class="s1">isBuild,</span><span class="s3">\n  </span><span class="s1">distDir,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">isBuild: boolean</span><span class="s3">\n  </span><span class="s1">distDir: string</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">// This avoids it being generated multiple times in parallel.</span><span class="s3">\n  </span><span class="s1">if (!__next_encryption_key_generation_promise) {</span><span class="s3">\n    </span><span class="s1">__next_encryption_key_generation_promise = loadOrGenerateKey(</span><span class="s3">\n      </span><span class="s1">distDir,</span><span class="s3">\n      </span><span class="s1">isBuild,</span><span class="s3">\n      </span><span class="s1">async () =&gt; {</span><span class="s3">\n        </span><span class="s1">const providedKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY</span><span class="s3">\n\n        </span><span class="s1">if (providedKey) {</span><span class="s3">\n          </span><span class="s1">return providedKey</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const key = await crypto.subtle.generateKey(</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">name: 'AES-GCM',</span><span class="s3">\n            </span><span class="s1">length: 256,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">true,</span><span class="s3">\n          </span><span class="s1">['encrypt', 'decrypt']</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">const exported = await crypto.subtle.exportKey('raw', key)</span><span class="s3">\n        </span><span class="s1">return btoa(arrayBufferToString(exported))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return __next_encryption_key_generation_promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;generateEncryptionKeyBase64&quot;</span><span class="s0">,</span><span class="s1">&quot;__next_encryption_key_generation_promise&quot;</span><span class="s0">,</span><span class="s1">&quot;CONFIG_FILE&quot;</span><span class="s0">,</span><span class="s1">&quot;ENCRYPTION_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;ENCRYPTION_EXPIRE_AT&quot;</span><span class="s0">,</span><span class="s1">&quot;EXPIRATION&quot;</span><span class="s0">,</span><span class="s1">&quot;writeCache&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;configValue&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheBaseDir&quot;</span><span class="s0">,</span><span class="s1">&quot;getStorageDirectory&quot;</span><span class="s0">,</span><span class="s1">&quot;configPath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;existsSync&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;writeFile&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;loadOrGenerateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuild&quot;</span><span class="s0">,</span><span class="s1">&quot;generateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCachedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_SERVER_ACTIONS_ENCRYPTION_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeValidKey&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;providedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;crypto&quot;</span><span class="s0">,</span><span class="s1">&quot;subtle&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;exportKey&quot;</span><span class="s0">,</span><span class="s1">&quot;btoa&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayBufferToString&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>