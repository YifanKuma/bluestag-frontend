<html>
<head>
<title>next-metadata-image-loader.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-metadata-image-loader.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/build/webpack/loaders/next-metadata-image-loader.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/*</span><span class="s3">\n </span><span class="s1">* This loader is responsible for extracting the metadata image info for rendering in html</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type webpack from 'webpack'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">MetadataImageModule,</span><span class="s3">\n  </span><span class="s1">PossibleImageFileNameConvention,</span><span class="s3">\n</span><span class="s1">} from './metadata/types'</span><span class="s3">\n</span><span class="s1">import { existsSync, promises as fs } from 'fs'</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import loaderUtils from 'next/dist/compiled/loader-utils3'</span><span class="s3">\n</span><span class="s1">import { getImageSize } from '../../../server/image-optimizer'</span><span class="s3">\n</span><span class="s1">import { imageExtMimeTypeMap } from '../../../lib/mime-type'</span><span class="s3">\n</span><span class="s1">import { WEBPACK_RESOURCE_QUERIES } from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep'</span><span class="s3">\n</span><span class="s1">import type { PageExtensions } from '../../page-extensions-type'</span><span class="s3">\n</span><span class="s1">import { getLoaderModuleNamedExports } from './utils'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">segment: string</span><span class="s3">\n  </span><span class="s1">type: PossibleImageFileNameConvention</span><span class="s3">\n  </span><span class="s1">pageExtensions: PageExtensions</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// [NOTE] For turbopack, refer to app_page_loader_tree's write_metadata_item for</span><span class="s3">\n</span><span class="s1">// corresponding features.</span><span class="s3">\n</span><span class="s1">async function nextMetadataImageLoader(</span><span class="s3">\n  </span><span class="s1">this: webpack.LoaderContext&lt;Options&gt;,</span><span class="s3">\n  </span><span class="s1">content: Buffer</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const options: Options = this.getOptions()</span><span class="s3">\n  </span><span class="s1">const { type, segment, pageExtensions, basePath } = options</span><span class="s3">\n  </span><span class="s1">const { resourcePath, rootContext: context } = this</span><span class="s3">\n  </span><span class="s1">const { name: fileNameBase, ext } = path.parse(resourcePath)</span><span class="s3">\n  </span><span class="s1">const useNumericSizes = type === 'twitter' || type === 'openGraph'</span><span class="s3">\n\n  </span><span class="s1">let extension = ext.slice(1)</span><span class="s3">\n  </span><span class="s1">if (extension === 'jpg') {</span><span class="s3">\n    </span><span class="s1">extension = 'jpeg'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const opts = { context, content }</span><span class="s3">\n\n  </span><span class="s1">// No hash query for favicon.ico</span><span class="s3">\n  </span><span class="s1">const contentHash =</span><span class="s3">\n    </span><span class="s1">type === 'favicon'</span><span class="s3">\n      </span><span class="s1">? ''</span><span class="s3">\n      </span><span class="s1">: loaderUtils.interpolateName(this, '[contenthash]', opts)</span><span class="s3">\n\n  </span><span class="s1">const interpolatedName = loaderUtils.interpolateName(</span><span class="s3">\n    </span><span class="s1">this,</span><span class="s3">\n    </span><span class="s1">'[name].[ext]',</span><span class="s3">\n    </span><span class="s1">opts</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const isDynamicResource = pageExtensions.includes(extension)</span><span class="s3">\n  </span><span class="s1">const pageSegment = isDynamicResource ? fileNameBase : interpolatedName</span><span class="s3">\n  </span><span class="s1">const hashQuery = contentHash ? '?' + contentHash : ''</span><span class="s3">\n  </span><span class="s1">const pathnamePrefix = normalizePathSep(path.join(basePath, segment))</span><span class="s3">\n\n  </span><span class="s1">if (isDynamicResource) {</span><span class="s3">\n    </span><span class="s1">const exportedFieldsExcludingDefault = (</span><span class="s3">\n      </span><span class="s1">await getLoaderModuleNamedExports(resourcePath, this)</span><span class="s3">\n    </span><span class="s1">).filter((name) =&gt; name !== 'default')</span><span class="s3">\n\n    </span><span class="s1">// re-export and spread as `exportedImageData` to avoid non-exported error</span><span class="s3">\n    </span><span class="s1">return `</span><span class="s3">\\\n    </span><span class="s1">import {</span><span class="s3">\n      </span><span class="s1">${exportedFieldsExcludingDefault</span><span class="s3">\n        </span><span class="s1">.map((field) =&gt; `${field} as _${field}`)</span><span class="s3">\n        </span><span class="s1">.join(',')}</span><span class="s3">\n    </span><span class="s1">} from ${JSON.stringify(</span><span class="s3">\n      </span><span class="s1">// This is an arbitrary resource query to ensure it's a new request, instead</span><span class="s3">\n      </span><span class="s1">// of sharing the same module with next-metadata-route-loader.</span><span class="s3">\n      </span><span class="s1">// Since here we only need export fields such as `size`, `alt` and</span><span class="s3">\n      </span><span class="s1">// `generateImageMetadata`, avoid sharing the same module can make this entry</span><span class="s3">\n      </span><span class="s1">// smaller.</span><span class="s3">\n      </span><span class="s1">resourcePath + '?' + WEBPACK_RESOURCE_QUERIES.metadataImageMeta</span><span class="s3">\n    </span><span class="s1">)}</span><span class="s3">\n    </span><span class="s1">import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'</span><span class="s3">\n\n    </span><span class="s1">const imageModule = {</span><span class="s3">\n      </span><span class="s1">${exportedFieldsExcludingDefault</span><span class="s3">\n        </span><span class="s1">.map((field) =&gt; `${field}: _${field}`)</span><span class="s3">\n        </span><span class="s1">.join(',')}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">export default async function (props) {</span><span class="s3">\n      </span><span class="s1">const { __metadata_id__: _, ...params } = await props.params</span><span class="s3">\n      </span><span class="s1">const imageUrl = fillMetadataSegment(${JSON.stringify(</span><span class="s3">\n        </span><span class="s1">pathnamePrefix</span><span class="s3">\n      </span><span class="s1">)}, params, ${JSON.stringify(pageSegment)})</span><span class="s3">\n\n      </span><span class="s1">const { generateImageMetadata } = imageModule</span><span class="s3">\n\n      </span><span class="s1">function getImageMetadata(imageMetadata, idParam) {</span><span class="s3">\n        </span><span class="s1">const data = {</span><span class="s3">\n          </span><span class="s1">alt: imageMetadata.alt,</span><span class="s3">\n          </span><span class="s1">type: imageMetadata.contentType || 'image/png',</span><span class="s3">\n          </span><span class="s1">url: imageUrl + (idParam ? ('/' + idParam) : '') + ${JSON.stringify(</span><span class="s3">\n            </span><span class="s1">hashQuery</span><span class="s3">\n          </span><span class="s1">)},</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const { size } = imageMetadata</span><span class="s3">\n        </span><span class="s1">if (size) {</span><span class="s3">\n          </span><span class="s1">${</span><span class="s3">\n            </span><span class="s1">type === 'twitter' || type === 'openGraph'</span><span class="s3">\n              </span><span class="s1">? 'data.width = size.width; data.height = size.height;'</span><span class="s3">\n              </span><span class="s1">: 'data.sizes = size.width + </span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot; </span><span class="s1">+ size.height;'</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return data</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (generateImageMetadata) {</span><span class="s3">\n        </span><span class="s1">const imageMetadataArray = await generateImageMetadata({ params })</span><span class="s3">\n        </span><span class="s1">return imageMetadataArray.map((imageMetadata, index) =&gt; {</span><span class="s3">\n          </span><span class="s1">const idParam = (imageMetadata.id || index) + ''</span><span class="s3">\n          </span><span class="s1">return getImageMetadata(imageMetadata, idParam)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return [getImageMetadata(imageModule, '')]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const imageSize: { width?: number; height?: number } = await getImageSize(</span><span class="s3">\n    </span><span class="s1">content</span><span class="s3">\n  </span><span class="s1">).catch((err) =&gt; err)</span><span class="s3">\n\n  </span><span class="s1">if (imageSize instanceof Error) {</span><span class="s3">\n    </span><span class="s1">const err = imageSize</span><span class="s3">\n    </span><span class="s1">err.name = 'InvalidImageFormatError'</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const imageData: Omit&lt;MetadataImageModule, 'url'&gt; = {</span><span class="s3">\n    </span><span class="s1">...(extension in imageExtMimeTypeMap &amp;&amp; {</span><span class="s3">\n      </span><span class="s1">type: imageExtMimeTypeMap[extension as keyof typeof imageExtMimeTypeMap],</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">...(useNumericSizes &amp;&amp; imageSize.width != null &amp;&amp; imageSize.height != null</span><span class="s3">\n      </span><span class="s1">? imageSize</span><span class="s3">\n      </span><span class="s1">: {</span><span class="s3">\n          </span><span class="s1">sizes:</span><span class="s3">\n            </span><span class="s1">// For SVGs, skip sizes and use </span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot; </span><span class="s1">to let it scale automatically based on viewport,</span><span class="s3">\n            </span><span class="s1">// For the images doesn't provide the size properly, use </span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot; </span><span class="s1">as well.</span><span class="s3">\n            </span><span class="s1">// If the size is presented, use the actual size for the image.</span><span class="s3">\n            </span><span class="s1">extension !== 'svg' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">imageSize.width != null &amp;&amp;</span><span class="s3">\n            </span><span class="s1">imageSize.height != null</span><span class="s3">\n              </span><span class="s1">? `${imageSize.width}x${imageSize.height}`</span><span class="s3">\n              </span><span class="s1">: 'any',</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (type === 'openGraph' || type === 'twitter') {</span><span class="s3">\n    </span><span class="s1">const altPath = path.join(</span><span class="s3">\n      </span><span class="s1">path.dirname(resourcePath),</span><span class="s3">\n      </span><span class="s1">fileNameBase + '.alt.txt'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (existsSync(altPath)) {</span><span class="s3">\n      </span><span class="s1">imageData.alt = await fs.readFile(altPath, 'utf8')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return `</span><span class="s3">\\\n  </span><span class="s1">import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'</span><span class="s3">\n\n  </span><span class="s1">export default async (props) =&gt; {</span><span class="s3">\n    </span><span class="s1">const imageData = ${JSON.stringify(imageData)}</span><span class="s3">\n    </span><span class="s1">const imageUrl = fillMetadataSegment(${JSON.stringify(</span><span class="s3">\n      </span><span class="s1">pathnamePrefix</span><span class="s3">\n    </span><span class="s1">)}, await props.params, ${JSON.stringify(pageSegment)})</span><span class="s3">\n\n    </span><span class="s1">return [{</span><span class="s3">\n      </span><span class="s1">...imageData,</span><span class="s3">\n      </span><span class="s1">url: imageUrl + ${JSON.stringify(type === 'favicon' ? '' : hashQuery)},</span><span class="s3">\n    </span><span class="s1">}]</span><span class="s3">\n  </span><span class="s1">}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const raw = true</span><span class="s3">\n</span><span class="s1">export default nextMetadataImageLoader</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;nextMetadataImageLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;getOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;pageExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;resourcePath&quot;</span><span class="s0">,</span><span class="s1">&quot;rootContext&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;fileNameBase&quot;</span><span class="s0">,</span><span class="s1">&quot;ext&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;useNumericSizes&quot;</span><span class="s0">,</span><span class="s1">&quot;extension&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;contentHash&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolateName&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolatedName&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicResource&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;pageSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;hashQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnamePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePathSep&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;exportedFieldsExcludingDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;getLoaderModuleNamedExports&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;field&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;WEBPACK_RESOURCE_QUERIES&quot;</span><span class="s0">,</span><span class="s1">&quot;metadataImageMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;imageSize&quot;</span><span class="s0">,</span><span class="s1">&quot;getImageSize&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;imageData&quot;</span><span class="s0">,</span><span class="s1">&quot;imageExtMimeTypeMap&quot;</span><span class="s0">,</span><span class="s1">&quot;width&quot;</span><span class="s0">,</span><span class="s1">&quot;height&quot;</span><span class="s0">,</span><span class="s1">&quot;sizes&quot;</span><span class="s0">,</span><span class="s1">&quot;altPath&quot;</span><span class="s0">,</span><span class="s1">&quot;dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;existsSync&quot;</span><span class="s0">,</span><span class="s1">&quot;alt&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>