<html>
<head>
<title>posix.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #264eff;}
.s7 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
posix.cjs</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s3">function </span><span class="s1">assertPath(path) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">path !== </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`Path must be a string, received &quot;</span><span class="s1">${JSON.stringify(path)}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">stripSuffix(name, suffix) {</span>
  <span class="s3">if </span><span class="s1">(suffix.length &gt;= name.length) {</span>
    <span class="s3">return </span><span class="s1">name;</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">lenDiff = name.length - suffix.length;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = suffix.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; --i){</span>
    <span class="s3">if </span><span class="s1">(name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {</span>
      <span class="s3">return </span><span class="s1">name;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">name.slice(</span><span class="s4">0</span><span class="s1">, -suffix.length);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">lastPathSegment(path, isSep, start = </span><span class="s4">0</span><span class="s1">) {</span>
  <span class="s3">let </span><span class="s1">matchedNonSeparator = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">end = path.length;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = path.length - </span><span class="s4">1</span><span class="s1">; i &gt;= start; --i){</span>
    <span class="s3">if </span><span class="s1">(isSep(path.charCodeAt(i))) {</span>
      <span class="s3">if </span><span class="s1">(matchedNonSeparator) {</span>
        <span class="s1">start = i + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!matchedNonSeparator) {</span>
      <span class="s1">matchedNonSeparator = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">end = i + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">path.slice(start, end);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">assertArgs$1(path, suffix) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">path;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">suffix !== </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`Suffix must be a string, received &quot;</span><span class="s1">${JSON.stringify(suffix)}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">assertArg$3(url) {</span>
  <span class="s1">url = url </span><span class="s3">instanceof </span><span class="s1">URL ? url : </span><span class="s3">new </span><span class="s1">URL(url);</span>
  <span class="s3">if </span><span class="s1">(url.protocol !== </span><span class="s0">&quot;file:&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`URL must be a file URL: received &quot;</span><span class="s1">${url.protocol}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">url;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Converts a file URL to a path string.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { fromFileUrl } from &quot;@std/path/posix/from-file-url&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(fromFileUrl(new URL(&quot;file:///home/foo&quot;)), &quot;/home/foo&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">url The file URL to convert.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The path string.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">fromFileUrl(url) {</span>
  <span class="s1">url = assertArg$3(url);</span>
  <span class="s3">return </span><span class="s1">decodeURIComponent(url.pathname.replace(</span><span class="s6">/%(?![0-9A-Fa-f]{2})/g</span><span class="s1">, </span><span class="s0">&quot;%25&quot;</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s2">// Ported from https://github.com/browserify/path-browserify/</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">stripTrailingSeparators(segment, isSep) {</span>
  <span class="s3">if </span><span class="s1">(segment.length &lt;= </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">segment;</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">end = segment.length;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = segment.length - </span><span class="s4">1</span><span class="s1">; i &gt; </span><span class="s4">0</span><span class="s1">; i--){</span>
    <span class="s3">if </span><span class="s1">(isSep(segment.charCodeAt(i))) {</span>
      <span class="s1">end = i;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">segment.slice(</span><span class="s4">0</span><span class="s1">, end);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s2">// Ported from https://github.com/browserify/path-browserify/</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">// Alphabet chars.</span>
<span class="s2">// Non-alphabetic chars.</span>
<span class="s3">const </span><span class="s1">CHAR_DOT = </span><span class="s4">46</span><span class="s1">; </span><span class="s2">/* . */ </span>
<span class="s3">const </span><span class="s1">CHAR_FORWARD_SLASH = </span><span class="s4">47</span><span class="s1">; </span><span class="s2">/* / */</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s2">// Ported from https://github.com/browserify/path-browserify/</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">isPosixPathSeparator(code) {</span>
  <span class="s3">return </span><span class="s1">code === CHAR_FORWARD_SLASH;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return the last portion of a `path`.</span>
 <span class="s2">* Trailing directory separators are ignored, and optional suffix is removed.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { basename } from &quot;@std/path/posix/basename&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(basename(&quot;/home/user/Documents/&quot;), &quot;Documents&quot;);</span>
 <span class="s2">* assertEquals(basename(&quot;/home/user/Documents/image.png&quot;), &quot;image.png&quot;);</span>
 <span class="s2">* assertEquals(basename(&quot;/home/user/Documents/image.png&quot;, &quot;.png&quot;), &quot;image&quot;);</span>
 <span class="s2">* assertEquals(basename(new URL(&quot;file:///home/user/Documents/image.png&quot;)), &quot;image.png&quot;);</span>
 <span class="s2">* assertEquals(basename(new URL(&quot;file:///home/user/Documents/image.png&quot;), &quot;.png&quot;), &quot;image&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Working with URLs</span>
 <span class="s2">*</span>
 <span class="s2">* Note: This function doesn't automatically strip hash and query parts from</span>
 <span class="s2">* URLs. If your URL contains a hash or query, remove them before passing the</span>
 <span class="s2">* URL to the function. This can be done by passing the URL to `new URL(url)`,</span>
 <span class="s2">* and setting the `hash` and `search` properties to empty strings.</span>
 <span class="s2">*</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { basename } from &quot;@std/path/posix/basename&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(basename(&quot;https://deno.land/std/path/mod.ts&quot;), &quot;mod.ts&quot;);</span>
 <span class="s2">* assertEquals(basename(&quot;https://deno.land/std/path/mod.ts&quot;, &quot;.ts&quot;), &quot;mod&quot;);</span>
 <span class="s2">* assertEquals(basename(&quot;https://deno.land/std/path/mod.ts?a=b&quot;), &quot;mod.ts?a=b&quot;);</span>
 <span class="s2">* assertEquals(basename(&quot;https://deno.land/std/path/mod.ts#header&quot;), &quot;mod.ts#header&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to extract the name from.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">suffix The suffix to remove from extracted name.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The extracted name.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">basename(path, suffix = </span><span class="s0">&quot;&quot;</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">assertArgs$1(path, suffix);</span>
  <span class="s3">const </span><span class="s1">lastSegment = lastPathSegment(path, isPosixPathSeparator);</span>
  <span class="s3">const </span><span class="s1">strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);</span>
  <span class="s3">return </span><span class="s1">suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* The character used to separate entries in the PATH environment variable.</span>
 <span class="s2">*/ </span><span class="s3">const </span><span class="s1">DELIMITER = </span><span class="s0">&quot;:&quot;</span><span class="s1">;</span>
<span class="s2">/**</span>
 <span class="s2">* The character used to separate components of a file path.</span>
 <span class="s2">*/ </span><span class="s3">const </span><span class="s1">SEPARATOR = </span><span class="s0">&quot;/&quot;</span><span class="s1">;</span>
<span class="s2">/**</span>
 <span class="s2">* A regular expression that matches one or more path separators.</span>
 <span class="s2">*/ </span><span class="s3">const </span><span class="s1">SEPARATOR_PATTERN = </span><span class="s6">/\/+/</span><span class="s1">;</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">assertArg$2(path) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return the directory path of a `path`.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { dirname } from &quot;@std/path/posix/dirname&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(dirname(&quot;/home/user/Documents/&quot;), &quot;/home/user&quot;);</span>
 <span class="s2">* assertEquals(dirname(&quot;/home/user/Documents/image.png&quot;), &quot;/home/user/Documents&quot;);</span>
 <span class="s2">* assertEquals(dirname(&quot;https://deno.land/std/path/mod.ts&quot;), &quot;https://deno.land/std/path&quot;);</span>
 <span class="s2">* assertEquals(dirname(new URL(&quot;file:///home/user/Documents/image.png&quot;)), &quot;/home/user/Documents&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Working with URLs</span>
 <span class="s2">*</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { dirname } from &quot;@std/path/posix/dirname&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(dirname(&quot;https://deno.land/std/path/mod.ts&quot;), &quot;https://deno.land/std/path&quot;);</span>
 <span class="s2">* assertEquals(dirname(&quot;https://deno.land/std/path/mod.ts?a=b&quot;), &quot;https://deno.land/std/path&quot;);</span>
 <span class="s2">* assertEquals(dirname(&quot;https://deno.land/std/path/mod.ts#header&quot;), &quot;https://deno.land/std/path&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to get the directory from.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The directory path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">dirname(path) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">assertArg$2(path);</span>
  <span class="s3">let </span><span class="s1">end = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">matchedNonSeparator = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = path.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">1</span><span class="s1">; --i){</span>
    <span class="s3">if </span><span class="s1">(isPosixPathSeparator(path.charCodeAt(i))) {</span>
      <span class="s3">if </span><span class="s1">(matchedNonSeparator) {</span>
        <span class="s1">end = i;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">matchedNonSeparator = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">// No matches. Fallback based on provided path:</span>
  <span class="s2">//</span>
  <span class="s2">// - leading slashes paths</span>
  <span class="s2">//     &quot;/foo&quot; =&gt; &quot;/&quot;</span>
  <span class="s2">//     &quot;///foo&quot; =&gt; &quot;/&quot;</span>
  <span class="s2">// - no slash path</span>
  <span class="s2">//     &quot;foo&quot; =&gt; &quot;.&quot;</span>
  <span class="s3">if </span><span class="s1">(end === -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">isPosixPathSeparator(path.charCodeAt(</span><span class="s4">0</span><span class="s1">)) ? </span><span class="s0">&quot;/&quot; </span><span class="s1">: </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">stripTrailingSeparators(path.slice(</span><span class="s4">0</span><span class="s1">, end), isPosixPathSeparator);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return the extension of the `path` with leading period.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { extname } from &quot;@std/path/posix/extname&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(extname(&quot;/home/user/Documents/file.ts&quot;), &quot;.ts&quot;);</span>
 <span class="s2">* assertEquals(extname(&quot;/home/user/Documents/&quot;), &quot;&quot;);</span>
 <span class="s2">* assertEquals(extname(&quot;/home/user/Documents/image.png&quot;), &quot;.png&quot;);</span>
 <span class="s2">* assertEquals(extname(new URL(&quot;file:///home/user/Documents/file.ts&quot;)), &quot;.ts&quot;);</span>
 <span class="s2">* assertEquals(extname(new URL(&quot;file:///home/user/Documents/file.ts?a=b&quot;)), &quot;.ts&quot;);</span>
 <span class="s2">* assertEquals(extname(new URL(&quot;file:///home/user/Documents/file.ts#header&quot;)), &quot;.ts&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Working with URLs</span>
 <span class="s2">*</span>
 <span class="s2">* Note: This function doesn't automatically strip hash and query parts from</span>
 <span class="s2">* URLs. If your URL contains a hash or query, remove them before passing the</span>
 <span class="s2">* URL to the function. This can be done by passing the URL to `new URL(url)`,</span>
 <span class="s2">* and setting the `hash` and `search` properties to empty strings.</span>
 <span class="s2">*</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { extname } from &quot;@std/path/posix/extname&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(extname(&quot;https://deno.land/std/path/mod.ts&quot;), &quot;.ts&quot;);</span>
 <span class="s2">* assertEquals(extname(&quot;https://deno.land/std/path/mod.ts?a=b&quot;), &quot;.ts?a=b&quot;);</span>
 <span class="s2">* assertEquals(extname(&quot;https://deno.land/std/path/mod.ts#header&quot;), &quot;.ts#header&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to get the extension from.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The extension (ex. for `file.ts` returns `.ts`).</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">extname(path) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">let </span><span class="s1">startDot = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">startPart = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">end = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">matchedSlash = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s2">// Track the state of characters (if any) we see before our first dot and</span>
  <span class="s2">// after any path separator we find</span>
  <span class="s3">let </span><span class="s1">preDotState = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = path.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; --i){</span>
    <span class="s3">const </span><span class="s1">code = path.charCodeAt(i);</span>
    <span class="s3">if </span><span class="s1">(isPosixPathSeparator(code)) {</span>
      <span class="s2">// If we reached a path separator that was not part of a set of path</span>
      <span class="s2">// separators at the end of the string, stop now</span>
      <span class="s3">if </span><span class="s1">(!matchedSlash) {</span>
        <span class="s1">startPart = i + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(end === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">// We saw the first non-path separator, mark this as the end of our</span>
      <span class="s2">// extension</span>
      <span class="s1">matchedSlash = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">end = i + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(code === CHAR_DOT) {</span>
      <span class="s2">// If this is our first dot, mark it as the start of our extension</span>
      <span class="s3">if </span><span class="s1">(startDot === -</span><span class="s4">1</span><span class="s1">) startDot = i;</span>
      <span class="s3">else if </span><span class="s1">(preDotState !== </span><span class="s4">1</span><span class="s1">) preDotState = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(startDot !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">// We saw a non-dot and non-path separator before our dot, so we should</span>
      <span class="s2">// have a good chance at having a non-empty extension</span>
      <span class="s1">preDotState = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(startDot === -</span><span class="s4">1 </span><span class="s1">|| end === -</span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">// We saw a non-dot character immediately before the dot</span>
  <span class="s1">preDotState === </span><span class="s4">0 </span><span class="s1">|| </span><span class="s2">// The (right-most) trimmed path component is exactly '..'</span>
  <span class="s1">preDotState === </span><span class="s4">1 </span><span class="s1">&amp;&amp; startDot === end - </span><span class="s4">1 </span><span class="s1">&amp;&amp; startDot === startPart + </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">path.slice(startDot, end);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">_format(sep, pathObject) {</span>
  <span class="s3">const </span><span class="s1">dir = pathObject.dir || pathObject.root;</span>
  <span class="s3">const </span><span class="s1">base = pathObject.base || (pathObject.name ?? </span><span class="s0">&quot;&quot;</span><span class="s1">) + (pathObject.ext ?? </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(!dir) </span><span class="s3">return </span><span class="s1">base;</span>
  <span class="s3">if </span><span class="s1">(base === sep) </span><span class="s3">return </span><span class="s1">dir;</span>
  <span class="s3">if </span><span class="s1">(dir === pathObject.root) </span><span class="s3">return </span><span class="s1">dir + base;</span>
  <span class="s3">return </span><span class="s1">dir + sep + base;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">assertArg$1(pathObject) {</span>
  <span class="s3">if </span><span class="s1">(pathObject === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">pathObject !== </span><span class="s0">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`The &quot;pathObject&quot; argument must be of type Object, received type &quot;</span><span class="s1">${</span><span class="s3">typeof </span><span class="s1">pathObject}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Generate a path from `ParsedPath` object.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { format } from &quot;@std/path/posix/format&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = format({</span>
 <span class="s2">*   root: &quot;/&quot;,</span>
 <span class="s2">*   dir: &quot;/path/dir&quot;,</span>
 <span class="s2">*   base: &quot;file.txt&quot;,</span>
 <span class="s2">*   ext: &quot;.txt&quot;,</span>
 <span class="s2">*   name: &quot;file&quot;</span>
 <span class="s2">* });</span>
 <span class="s2">* assertEquals(path, &quot;/path/dir/file.txt&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">pathObject The path object to format.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The formatted path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">format(pathObject) {</span>
  <span class="s1">assertArg$1(pathObject);</span>
  <span class="s3">return </span><span class="s1">_format(</span><span class="s0">&quot;/&quot;</span><span class="s1">, pathObject);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Verifies whether provided path is absolute.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { isAbsolute } from &quot;@std/path/posix/is-absolute&quot;;</span>
 <span class="s2">* import { assert, assertFalse } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assert(isAbsolute(&quot;/home/user/Documents/&quot;));</span>
 <span class="s2">* assertFalse(isAbsolute(&quot;home/user/Documents/&quot;));</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to verify.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">Whether the path is absolute.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">isAbsolute(path) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">return </span><span class="s1">path.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; isPosixPathSeparator(path.charCodeAt(</span><span class="s4">0</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">assertArg(path) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// Copyright the Browserify authors. MIT License.</span>
<span class="s2">// Ported from https://github.com/browserify/path-browserify/</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">// Resolves . and .. elements in a path with directory names</span>
<span class="s3">function </span><span class="s1">normalizeString(path, allowAboveRoot, separator, isPathSeparator) {</span>
  <span class="s3">let </span><span class="s1">res = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">lastSlash = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">code;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt;= path.length; ++i){</span>
    <span class="s3">if </span><span class="s1">(i &lt; path.length) code = path.charCodeAt(i);</span>
    <span class="s3">else if </span><span class="s1">(isPathSeparator(code)) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s3">else </span><span class="s1">code = CHAR_FORWARD_SLASH;</span>
    <span class="s3">if </span><span class="s1">(isPathSeparator(code)) {</span>
      <span class="s3">if </span><span class="s1">(lastSlash === i - </span><span class="s4">1 </span><span class="s1">|| dots === </span><span class="s4">1</span><span class="s1">) ; </span><span class="s3">else if </span><span class="s1">(lastSlash !== i - </span><span class="s4">1 </span><span class="s1">&amp;&amp; dots === </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(res.length &lt; </span><span class="s4">2 </span><span class="s1">|| lastSegmentLength !== </span><span class="s4">2 </span><span class="s1">|| res.charCodeAt(res.length - </span><span class="s4">1</span><span class="s1">) !== CHAR_DOT || res.charCodeAt(res.length - </span><span class="s4">2</span><span class="s1">) !== CHAR_DOT) {</span>
          <span class="s3">if </span><span class="s1">(res.length &gt; </span><span class="s4">2</span><span class="s1">) {</span>
            <span class="s3">const </span><span class="s1">lastSlashIndex = res.lastIndexOf(separator);</span>
            <span class="s3">if </span><span class="s1">(lastSlashIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">res = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
              <span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">res = res.slice(</span><span class="s4">0</span><span class="s1">, lastSlashIndex);</span>
              <span class="s1">lastSegmentLength = res.length - </span><span class="s4">1 </span><span class="s1">- res.lastIndexOf(separator);</span>
            <span class="s1">}</span>
            <span class="s1">lastSlash = i;</span>
            <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(res.length === </span><span class="s4">2 </span><span class="s1">|| res.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">res = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
            <span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">lastSlash = i;</span>
            <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(allowAboveRoot) {</span>
          <span class="s3">if </span><span class="s1">(res.length &gt; </span><span class="s4">0</span><span class="s1">) res += </span><span class="s0">`</span><span class="s1">${separator}</span><span class="s0">..`</span><span class="s1">;</span>
          <span class="s3">else </span><span class="s1">res = </span><span class="s0">&quot;..&quot;</span><span class="s1">;</span>
          <span class="s1">lastSegmentLength = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(res.length &gt; </span><span class="s4">0</span><span class="s1">) res += separator + path.slice(lastSlash + </span><span class="s4">1</span><span class="s1">, i);</span>
        <span class="s3">else </span><span class="s1">res = path.slice(lastSlash + </span><span class="s4">1</span><span class="s1">, i);</span>
        <span class="s1">lastSegmentLength = i - lastSlash - </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">lastSlash = i;</span>
      <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(code === CHAR_DOT &amp;&amp; dots !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">++dots;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">dots = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">res;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Normalize the `path`, resolving `'..'` and `'.'` segments.</span>
 <span class="s2">* Note that resolving these segments does not necessarily mean that all will be eliminated.</span>
 <span class="s2">* A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { normalize } from &quot;@std/path/posix/normalize&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(normalize(&quot;/foo/bar//baz/asdf/quux/..&quot;), &quot;/foo/bar/baz/asdf&quot;);</span>
 <span class="s2">* assertEquals(normalize(new URL(&quot;file:///foo/bar//baz/asdf/quux/..&quot;)), &quot;/foo/bar/baz/asdf/&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Working with URLs</span>
 <span class="s2">*</span>
 <span class="s2">* Note: This function will remove the double slashes from a URL's scheme.</span>
 <span class="s2">* Hence, do not pass a full URL to this function. Instead, pass the pathname of</span>
 <span class="s2">* the URL.</span>
 <span class="s2">*</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { normalize } from &quot;@std/path/posix/normalize&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const url = new URL(&quot;https://deno.land&quot;);</span>
 <span class="s2">* url.pathname = normalize(&quot;//std//assert//.//mod.ts&quot;);</span>
 <span class="s2">* assertEquals(url.href, &quot;https://deno.land/std/assert/mod.ts&quot;);</span>
 <span class="s2">*</span>
 <span class="s2">* url.pathname = normalize(&quot;std/assert/../async/retry.ts&quot;);</span>
 <span class="s2">* assertEquals(url.href, &quot;https://deno.land/std/async/retry.ts&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to normalize.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The normalized path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">normalize(path) {</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">assertArg(path);</span>
  <span class="s3">const </span><span class="s1">isAbsolute = isPosixPathSeparator(path.charCodeAt(</span><span class="s4">0</span><span class="s1">));</span>
  <span class="s3">const </span><span class="s1">trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - </span><span class="s4">1</span><span class="s1">));</span>
  <span class="s2">// Normalize the path</span>
  <span class="s1">path = normalizeString(path, !isAbsolute, </span><span class="s0">&quot;/&quot;</span><span class="s1">, isPosixPathSeparator);</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; !isAbsolute) path = </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(path.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; trailingSeparator) path += </span><span class="s0">&quot;/&quot;</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(isAbsolute) </span><span class="s3">return </span><span class="s0">`/</span><span class="s1">${path}</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">path;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Join all given a sequence of `paths`,then normalizes the resulting path.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { join } from &quot;@std/path/posix/join&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(join(&quot;/foo&quot;, &quot;bar&quot;, &quot;baz/asdf&quot;, &quot;quux&quot;, &quot;..&quot;), &quot;/foo/bar/baz/asdf&quot;);</span>
 <span class="s2">* assertEquals(join(new URL(&quot;file:///foo&quot;), &quot;bar&quot;, &quot;baz/asdf&quot;, &quot;quux&quot;, &quot;..&quot;), &quot;/foo/bar/baz/asdf&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Working with URLs</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { join } from &quot;@std/path/posix/join&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const url = new URL(&quot;https://deno.land&quot;);</span>
 <span class="s2">* url.pathname = join(&quot;std&quot;, &quot;path&quot;, &quot;mod.ts&quot;);</span>
 <span class="s2">* assertEquals(url.href, &quot;https://deno.land/std/path/mod.ts&quot;);</span>
 <span class="s2">*</span>
 <span class="s2">* url.pathname = join(&quot;//std&quot;, &quot;path/&quot;, &quot;/mod.ts&quot;);</span>
 <span class="s2">* assertEquals(url.href, &quot;https://deno.land/std/path/mod.ts&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to join. This can be string or file URL.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">paths The paths to join.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The joined path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">join(path, ...paths) {</span>
  <span class="s3">if </span><span class="s1">(path === undefined) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(path </span><span class="s3">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">path = fromFileUrl(path);</span>
  <span class="s1">}</span>
  <span class="s1">paths = path ? [</span>
    <span class="s1">path,</span>
    <span class="s1">...paths</span>
  <span class="s1">] : paths;</span>
  <span class="s1">paths.forEach((path)=&gt;assertPath(path));</span>
  <span class="s3">const </span><span class="s1">joined = paths.filter((path)=&gt;path.length &gt; </span><span class="s4">0</span><span class="s1">).join(</span><span class="s0">&quot;/&quot;</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">joined === </span><span class="s0">&quot;&quot; </span><span class="s1">? </span><span class="s0">&quot;.&quot; </span><span class="s1">: normalize(joined);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return a `ParsedPath` object of the `path`.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { parse } from &quot;@std/path/posix/parse&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = parse(&quot;/home/user/file.txt&quot;);</span>
 <span class="s2">* assertEquals(path, {</span>
 <span class="s2">*   root: &quot;/&quot;,</span>
 <span class="s2">*   dir: &quot;/home/user&quot;,</span>
 <span class="s2">*   base: &quot;file.txt&quot;,</span>
 <span class="s2">*   ext: &quot;.txt&quot;,</span>
 <span class="s2">*   name: &quot;file&quot;</span>
 <span class="s2">* });</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to parse.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The parsed path object.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">parse(path) {</span>
  <span class="s1">assertPath(path);</span>
  <span class="s3">const </span><span class="s1">ret = {</span>
    <span class="s1">root: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">dir: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">base: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">ext: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">name: </span><span class="s0">&quot;&quot;</span>
  <span class="s1">};</span>
  <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">ret;</span>
  <span class="s3">const </span><span class="s1">isAbsolute = isPosixPathSeparator(path.charCodeAt(</span><span class="s4">0</span><span class="s1">));</span>
  <span class="s3">let </span><span class="s1">start;</span>
  <span class="s3">if </span><span class="s1">(isAbsolute) {</span>
    <span class="s1">ret.root = </span><span class="s0">&quot;/&quot;</span><span class="s1">;</span>
    <span class="s1">start = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">start = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">startDot = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">startPart = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">end = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">matchedSlash = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">i = path.length - </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">// Track the state of characters (if any) we see before our first dot and</span>
  <span class="s2">// after any path separator we find</span>
  <span class="s3">let </span><span class="s1">preDotState = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">// Get non-dir info</span>
  <span class="s3">for</span><span class="s1">(; i &gt;= start; --i){</span>
    <span class="s3">const </span><span class="s1">code = path.charCodeAt(i);</span>
    <span class="s3">if </span><span class="s1">(isPosixPathSeparator(code)) {</span>
      <span class="s2">// If we reached a path separator that was not part of a set of path</span>
      <span class="s2">// separators at the end of the string, stop now</span>
      <span class="s3">if </span><span class="s1">(!matchedSlash) {</span>
        <span class="s1">startPart = i + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(end === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">// We saw the first non-path separator, mark this as the end of our</span>
      <span class="s2">// extension</span>
      <span class="s1">matchedSlash = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">end = i + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(code === CHAR_DOT) {</span>
      <span class="s2">// If this is our first dot, mark it as the start of our extension</span>
      <span class="s3">if </span><span class="s1">(startDot === -</span><span class="s4">1</span><span class="s1">) startDot = i;</span>
      <span class="s3">else if </span><span class="s1">(preDotState !== </span><span class="s4">1</span><span class="s1">) preDotState = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(startDot !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">// We saw a non-dot and non-path separator before our dot, so we should</span>
      <span class="s2">// have a good chance at having a non-empty extension</span>
      <span class="s1">preDotState = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(startDot === -</span><span class="s4">1 </span><span class="s1">|| end === -</span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">// We saw a non-dot character immediately before the dot</span>
  <span class="s1">preDotState === </span><span class="s4">0 </span><span class="s1">|| </span><span class="s2">// The (right-most) trimmed path component is exactly '..'</span>
  <span class="s1">preDotState === </span><span class="s4">1 </span><span class="s1">&amp;&amp; startDot === end - </span><span class="s4">1 </span><span class="s1">&amp;&amp; startDot === startPart + </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(end !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(startPart === </span><span class="s4">0 </span><span class="s1">&amp;&amp; isAbsolute) {</span>
        <span class="s1">ret.base = ret.name = path.slice(</span><span class="s4">1</span><span class="s1">, end);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">ret.base = ret.name = path.slice(startPart, end);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">// Fallback to '/' in case there is no basename</span>
    <span class="s1">ret.base = ret.base || </span><span class="s0">&quot;/&quot;</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(startPart === </span><span class="s4">0 </span><span class="s1">&amp;&amp; isAbsolute) {</span>
      <span class="s1">ret.name = path.slice(</span><span class="s4">1</span><span class="s1">, startDot);</span>
      <span class="s1">ret.base = path.slice(</span><span class="s4">1</span><span class="s1">, end);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">ret.name = path.slice(startPart, startDot);</span>
      <span class="s1">ret.base = path.slice(startPart, end);</span>
    <span class="s1">}</span>
    <span class="s1">ret.ext = path.slice(startDot, end);</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(startPart &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">ret.dir = stripTrailingSeparators(path.slice(</span><span class="s4">0</span><span class="s1">, startPart - </span><span class="s4">1</span><span class="s1">), isPosixPathSeparator);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isAbsolute) ret.dir = </span><span class="s0">&quot;/&quot;</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">ret;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Resolves path segments into a `path`.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { resolve } from &quot;@std/path/posix/resolve&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = resolve(&quot;/foo&quot;, &quot;bar&quot;, &quot;baz/asdf&quot;, &quot;quux&quot;, &quot;..&quot;);</span>
 <span class="s2">* assertEquals(path, &quot;/foo/bar/baz/asdf&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">pathSegments The path segments to resolve.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The resolved path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">resolve(...pathSegments) {</span>
  <span class="s3">let </span><span class="s1">resolvedPath = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">resolvedAbsolute = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = pathSegments.length - </span><span class="s4">1</span><span class="s1">; i &gt;= -</span><span class="s4">1 </span><span class="s1">&amp;&amp; !resolvedAbsolute; i--){</span>
    <span class="s3">let </span><span class="s1">path;</span>
    <span class="s3">if </span><span class="s1">(i &gt;= </span><span class="s4">0</span><span class="s1">) path = pathSegments[i];</span>
    <span class="s3">else </span><span class="s1">{</span>
      <span class="s2">// deno-lint-ignore no-explicit-any</span>
      <span class="s3">const </span><span class="s1">{ Deno } = globalThis;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Deno?.cwd !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Resolved a relative path without a current working directory (CWD)&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">path = Deno.cwd();</span>
    <span class="s1">}</span>
    <span class="s1">assertPath(path);</span>
    <span class="s2">// Skip empty entries</span>
    <span class="s3">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">resolvedPath = </span><span class="s0">`</span><span class="s1">${path}</span><span class="s0">/</span><span class="s1">${resolvedPath}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(</span><span class="s4">0</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s2">// At this point the path should be resolved to a full absolute path, but</span>
  <span class="s2">// handle relative paths to be safe (might happen when Deno.cwd() fails)</span>
  <span class="s2">// Normalize the path</span>
  <span class="s1">resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, </span><span class="s0">&quot;/&quot;</span><span class="s1">, isPosixPathSeparator);</span>
  <span class="s3">if </span><span class="s1">(resolvedAbsolute) {</span>
    <span class="s3">if </span><span class="s1">(resolvedPath.length &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s0">`/</span><span class="s1">${resolvedPath}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s3">else return </span><span class="s0">&quot;/&quot;</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(resolvedPath.length &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">resolvedPath;</span>
  <span class="s3">else return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">assertArgs(from, to) {</span>
  <span class="s1">assertPath(from);</span>
  <span class="s1">assertPath(to);</span>
  <span class="s3">if </span><span class="s1">(from === to) </span><span class="s3">return </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Return the relative path from `from` to `to` based on current working directory.</span>
 <span class="s2">*</span>
 <span class="s2">* If `from` and `to` are the same, return an empty string.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { relative } from &quot;@std/path/posix/relative&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = relative(&quot;/data/orandea/test/aaa&quot;, &quot;/data/orandea/impl/bbb&quot;);</span>
 <span class="s2">* assertEquals(path, &quot;../../impl/bbb&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">from The path to start from.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">to The path to reach.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The relative path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">relative(from, to) {</span>
  <span class="s1">assertArgs(from, to);</span>
  <span class="s1">from = resolve(from);</span>
  <span class="s1">to = resolve(to);</span>
  <span class="s3">if </span><span class="s1">(from === to) </span><span class="s3">return </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s2">// Trim any leading backslashes</span>
  <span class="s3">let </span><span class="s1">fromStart = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s1">fromEnd = from.length;</span>
  <span class="s3">for</span><span class="s1">(; fromStart &lt; fromEnd; ++fromStart){</span>
    <span class="s3">if </span><span class="s1">(!isPosixPathSeparator(from.charCodeAt(fromStart))) </span><span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">fromLen = fromEnd - fromStart;</span>
  <span class="s2">// Trim any leading backslashes</span>
  <span class="s3">let </span><span class="s1">toStart = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s1">toEnd = to.length;</span>
  <span class="s3">for</span><span class="s1">(; toStart &lt; toEnd; ++toStart){</span>
    <span class="s3">if </span><span class="s1">(!isPosixPathSeparator(to.charCodeAt(toStart))) </span><span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">toLen = toEnd - toStart;</span>
  <span class="s2">// Compare paths to find the longest common path from root</span>
  <span class="s3">const </span><span class="s1">length = fromLen &lt; toLen ? fromLen : toLen;</span>
  <span class="s3">let </span><span class="s1">lastCommonSep = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">for</span><span class="s1">(; i &lt;= length; ++i){</span>
    <span class="s3">if </span><span class="s1">(i === length) {</span>
      <span class="s3">if </span><span class="s1">(toLen &gt; length) {</span>
        <span class="s3">if </span><span class="s1">(isPosixPathSeparator(to.charCodeAt(toStart + i))) {</span>
          <span class="s2">// We get here if `from` is the exact base path for `to`.</span>
          <span class="s2">// For example: from='/foo/bar'; to='/foo/bar/baz'</span>
          <span class="s3">return </span><span class="s1">to.slice(toStart + i + </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">// We get here if `from` is the root</span>
          <span class="s2">// For example: from='/'; to='/foo'</span>
          <span class="s3">return </span><span class="s1">to.slice(toStart + i);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(fromLen &gt; length) {</span>
        <span class="s3">if </span><span class="s1">(isPosixPathSeparator(from.charCodeAt(fromStart + i))) {</span>
          <span class="s2">// We get here if `to` is the exact base path for `from`.</span>
          <span class="s2">// For example: from='/foo/bar/baz'; to='/foo/bar'</span>
          <span class="s1">lastCommonSep = i;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">// We get here if `to` is the root.</span>
          <span class="s2">// For example: from='/foo'; to='/'</span>
          <span class="s1">lastCommonSep = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">fromCode = from.charCodeAt(fromStart + i);</span>
    <span class="s3">const </span><span class="s1">toCode = to.charCodeAt(toStart + i);</span>
    <span class="s3">if </span><span class="s1">(fromCode !== toCode) </span><span class="s3">break</span><span class="s1">;</span>
    <span class="s3">else if </span><span class="s1">(isPosixPathSeparator(fromCode)) lastCommonSep = i;</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">out = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s2">// Generate the relative path based on the path difference between `to`</span>
  <span class="s2">// and `from`</span>
  <span class="s3">for</span><span class="s1">(i = fromStart + lastCommonSep + </span><span class="s4">1</span><span class="s1">; i &lt;= fromEnd; ++i){</span>
    <span class="s3">if </span><span class="s1">(i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {</span>
      <span class="s3">if </span><span class="s1">(out.length === </span><span class="s4">0</span><span class="s1">) out += </span><span class="s0">&quot;..&quot;</span><span class="s1">;</span>
      <span class="s3">else </span><span class="s1">out += </span><span class="s0">&quot;/..&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">// Lastly, append the rest of the destination (`to`) path that comes after</span>
  <span class="s2">// the common path parts</span>
  <span class="s3">if </span><span class="s1">(out.length &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">out + to.slice(toStart + lastCommonSep);</span>
  <span class="s3">else </span><span class="s1">{</span>
    <span class="s1">toStart += lastCommonSep;</span>
    <span class="s3">if </span><span class="s1">(isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;</span>
    <span class="s3">return </span><span class="s1">to.slice(toStart);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">const </span><span class="s1">WHITESPACE_ENCODINGS = {</span>
  <span class="s0">&quot;</span><span class="s7">\u0009</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%09&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u000A</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%0A&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u000B</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%0B&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u000C</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%0C&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u000D</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%0D&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\u0020</span><span class="s0">&quot;</span><span class="s1">: </span><span class="s0">&quot;%20&quot;</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">encodeWhitespace(string) {</span>
  <span class="s3">return </span><span class="s1">string.replaceAll(</span><span class="s6">/[\s]/g</span><span class="s1">, (c)=&gt;{</span>
    <span class="s3">return </span><span class="s1">WHITESPACE_ENCODINGS[c] ?? c;</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Converts a path string to a file URL.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { toFileUrl } from &quot;@std/path/posix/to-file-url&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(toFileUrl(&quot;/home/foo&quot;), new URL(&quot;file:///home/foo&quot;));</span>
 <span class="s2">* assertEquals(toFileUrl(&quot;/home/foo bar&quot;), new URL(&quot;file:///home/foo%20bar&quot;));</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path to convert.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The file URL.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">toFileUrl(path) {</span>
  <span class="s3">if </span><span class="s1">(!isAbsolute(path)) {</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">`Path must be absolute: received &quot;</span><span class="s1">${path}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">url = </span><span class="s3">new </span><span class="s1">URL(</span><span class="s0">&quot;file:///&quot;</span><span class="s1">);</span>
  <span class="s1">url.pathname = encodeWhitespace(path.replace(</span><span class="s6">/%/g</span><span class="s1">, </span><span class="s0">&quot;%25&quot;</span><span class="s1">).replace(</span><span class="s6">/\\/g</span><span class="s1">, </span><span class="s0">&quot;%5C&quot;</span><span class="s1">));</span>
  <span class="s3">return </span><span class="s1">url;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Converts a path to a namespaced path. This function returns the path as is on posix.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { toNamespacedPath } from &quot;@std/path/posix/to-namespaced-path&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(toNamespacedPath(&quot;/home/foo&quot;), &quot;/home/foo&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">path The path.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The namespaced path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">toNamespacedPath(path) {</span>
  <span class="s2">// Non-op on posix systems</span>
  <span class="s3">return </span><span class="s1">path;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">function </span><span class="s1">common$1(paths, sep) {</span>
  <span class="s3">const </span><span class="s1">[first = </span><span class="s0">&quot;&quot;</span><span class="s1">, ...remaining] = paths;</span>
  <span class="s3">const </span><span class="s1">parts = first.split(sep);</span>
  <span class="s3">let </span><span class="s1">endOfPrefix = parts.length;</span>
  <span class="s3">let </span><span class="s1">append = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">path of remaining){</span>
    <span class="s3">const </span><span class="s1">compare = path.split(sep);</span>
    <span class="s3">if </span><span class="s1">(compare.length &lt;= endOfPrefix) {</span>
      <span class="s1">endOfPrefix = compare.length;</span>
      <span class="s1">append = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; endOfPrefix; i++){</span>
      <span class="s3">if </span><span class="s1">(compare[i] !== parts[i]) {</span>
        <span class="s1">endOfPrefix = i;</span>
        <span class="s1">append = i === </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">&quot;&quot; </span><span class="s1">: sep;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">parts.slice(</span><span class="s4">0</span><span class="s1">, endOfPrefix).join(sep) + append;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/** Determines the common path from a set of paths for POSIX systems.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { common } from &quot;@std/path/posix/common&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = common([</span>
 <span class="s2">*   &quot;./deno/std/path/mod.ts&quot;,</span>
 <span class="s2">*   &quot;./deno/std/fs/mod.ts&quot;,</span>
 <span class="s2">* ]);</span>
 <span class="s2">* assertEquals(path, &quot;./deno/std/&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">paths The paths to compare.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The common path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">common(paths) {</span>
  <span class="s3">return </span><span class="s1">common$1(paths, SEPARATOR);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Options for {</span><span class="s5">@linkcode </span><span class="s2">globToRegExp}, {</span><span class="s5">@linkcode </span><span class="s2">joinGlobs},</span>
 <span class="s2">* {</span><span class="s5">@linkcode </span><span class="s2">normalizeGlob} and {</span><span class="s5">@linkcode </span><span class="s2">expandGlob}.</span>
 <span class="s2">*/ </span><span class="s3">const </span><span class="s1">REG_EXP_ESCAPE_CHARS = [</span>
  <span class="s0">&quot;!&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;$&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;(&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;)&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;*&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;+&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;.&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;=&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;?&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;[&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;^&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;{&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;|&quot;</span>
<span class="s1">];</span>
<span class="s3">const </span><span class="s1">RANGE_ESCAPE_CHARS = [</span>
  <span class="s0">&quot;-&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">,</span>
  <span class="s0">&quot;]&quot;</span>
<span class="s1">];</span>
<span class="s3">function </span><span class="s1">_globToRegExp(c, glob, { extended = </span><span class="s3">true</span><span class="s1">, globstar: globstarOption = </span><span class="s3">true</span><span class="s1">, </span><span class="s2">// os = osType,</span>
<span class="s1">caseInsensitive = </span><span class="s3">false </span><span class="s1">} = {}) {</span>
  <span class="s3">if </span><span class="s1">(glob === </span><span class="s0">&quot;&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s6">/(?!)/</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">// Remove trailing separators.</span>
  <span class="s3">let </span><span class="s1">newLength = glob.length;</span>
  <span class="s3">for</span><span class="s1">(; newLength &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; c.seps.includes(glob[newLength - </span><span class="s4">1</span><span class="s1">]); newLength--);</span>
  <span class="s1">glob = glob.slice(</span><span class="s4">0</span><span class="s1">, newLength);</span>
  <span class="s3">let </span><span class="s1">regExpString = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s2">// Terminates correctly. Trust that `j` is incremented every iteration.</span>
  <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">; j &lt; glob.length;){</span>
    <span class="s3">let </span><span class="s1">segment = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">groupStack = [];</span>
    <span class="s3">let </span><span class="s1">inRange = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">inEscape = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">endsWithSep = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">i = j;</span>
    <span class="s2">// Terminates with `i` at the non-inclusive end of the current segment.</span>
    <span class="s3">for</span><span class="s1">(; i &lt; glob.length &amp;&amp; !c.seps.includes(glob[i]); i++){</span>
      <span class="s3">if </span><span class="s1">(inEscape) {</span>
        <span class="s1">inEscape = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s1">escapeChars = inRange ? RANGE_ESCAPE_CHARS : REG_EXP_ESCAPE_CHARS;</span>
        <span class="s1">segment += escapeChars.includes(glob[i]) ? </span><span class="s0">`</span><span class="s7">\\</span><span class="s1">${glob[i]}</span><span class="s0">` </span><span class="s1">: glob[i];</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === c.escapePrefix) {</span>
        <span class="s1">inEscape = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;[&quot;</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(!inRange) {</span>
          <span class="s1">inRange = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">segment += </span><span class="s0">&quot;[&quot;</span><span class="s1">;</span>
          <span class="s3">if </span><span class="s1">(glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;!&quot;</span><span class="s1">) {</span>
            <span class="s1">i++;</span>
            <span class="s1">segment += </span><span class="s0">&quot;^&quot;</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;^&quot;</span><span class="s1">) {</span>
            <span class="s1">i++;</span>
            <span class="s1">segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">^&quot;</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;:&quot;</span><span class="s1">) {</span>
          <span class="s3">let </span><span class="s1">k = i + </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s3">let </span><span class="s1">value = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
          <span class="s3">while</span><span class="s1">(glob[k + </span><span class="s4">1</span><span class="s1">] !== undefined &amp;&amp; glob[k + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">&quot;:&quot;</span><span class="s1">){</span>
            <span class="s1">value += glob[k + </span><span class="s4">1</span><span class="s1">];</span>
            <span class="s1">k++;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(glob[k + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;:&quot; </span><span class="s1">&amp;&amp; glob[k + </span><span class="s4">2</span><span class="s1">] === </span><span class="s0">&quot;]&quot;</span><span class="s1">) {</span>
            <span class="s1">i = k + </span><span class="s4">2</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(value === </span><span class="s0">&quot;alnum&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">dA-Za-z&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;alpha&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;A-Za-z&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;ascii&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\x00</span><span class="s0">-</span><span class="s7">\x7F</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;blank&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\t </span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;cntrl&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\x00</span><span class="s0">-</span><span class="s7">\x1F\x7F</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;digit&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">d&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;graph&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\x21</span><span class="s0">-</span><span class="s7">\x7E</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;lower&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;a-z&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;print&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\x20</span><span class="s0">-</span><span class="s7">\x7E</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;punct&quot;</span><span class="s1">) {</span>
              <span class="s1">segment += </span><span class="s0">&quot;!</span><span class="s7">\&quot;</span><span class="s0">#$%&amp;'()*+,</span><span class="s7">\\</span><span class="s0">-./:;&lt;=&gt;?@[</span><span class="s7">\\\\\\</span><span class="s0">]^_{|}~&quot;</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;space&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">s</span><span class="s7">\v</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;upper&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;A-Z&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;word&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">w&quot;</span><span class="s1">;</span>
            <span class="s3">else if </span><span class="s1">(value === </span><span class="s0">&quot;xdigit&quot;</span><span class="s1">) segment += </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">dA-Fa-f&quot;</span><span class="s1">;</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;]&quot; </span><span class="s1">&amp;&amp; inRange) {</span>
        <span class="s1">inRange = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">segment += </span><span class="s0">&quot;]&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(inRange) {</span>
        <span class="s1">segment += glob[i];</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;)&quot; </span><span class="s1">&amp;&amp; groupStack.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; groupStack[groupStack.length - </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">&quot;BRACE&quot;</span><span class="s1">) {</span>
        <span class="s1">segment += </span><span class="s0">&quot;)&quot;</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s1">type = groupStack.pop();</span>
        <span class="s3">if </span><span class="s1">(type === </span><span class="s0">&quot;!&quot;</span><span class="s1">) {</span>
          <span class="s1">segment += c.wildcard;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type !== </span><span class="s0">&quot;@&quot;</span><span class="s1">) {</span>
          <span class="s1">segment += type;</span>
        <span class="s1">}</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;|&quot; </span><span class="s1">&amp;&amp; groupStack.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; groupStack[groupStack.length - </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">&quot;BRACE&quot;</span><span class="s1">) {</span>
        <span class="s1">segment += </span><span class="s0">&quot;|&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;+&quot; </span><span class="s1">&amp;&amp; extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
        <span class="s1">i++;</span>
        <span class="s1">groupStack.push(</span><span class="s0">&quot;+&quot;</span><span class="s1">);</span>
        <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;@&quot; </span><span class="s1">&amp;&amp; extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
        <span class="s1">i++;</span>
        <span class="s1">groupStack.push(</span><span class="s0">&quot;@&quot;</span><span class="s1">);</span>
        <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;?&quot;</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
          <span class="s1">i++;</span>
          <span class="s1">groupStack.push(</span><span class="s0">&quot;?&quot;</span><span class="s1">);</span>
          <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">segment += </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;!&quot; </span><span class="s1">&amp;&amp; extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
        <span class="s1">i++;</span>
        <span class="s1">groupStack.push(</span><span class="s0">&quot;!&quot;</span><span class="s1">);</span>
        <span class="s1">segment += </span><span class="s0">&quot;(?!&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;{&quot;</span><span class="s1">) {</span>
        <span class="s1">groupStack.push(</span><span class="s0">&quot;BRACE&quot;</span><span class="s1">);</span>
        <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;}&quot; </span><span class="s1">&amp;&amp; groupStack[groupStack.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;BRACE&quot;</span><span class="s1">) {</span>
        <span class="s1">groupStack.pop();</span>
        <span class="s1">segment += </span><span class="s0">&quot;)&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;,&quot; </span><span class="s1">&amp;&amp; groupStack[groupStack.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;BRACE&quot;</span><span class="s1">) {</span>
        <span class="s1">segment += </span><span class="s0">&quot;|&quot;</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(glob[i] === </span><span class="s0">&quot;*&quot;</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(extended &amp;&amp; glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;(&quot;</span><span class="s1">) {</span>
          <span class="s1">i++;</span>
          <span class="s1">groupStack.push(</span><span class="s0">&quot;*&quot;</span><span class="s1">);</span>
          <span class="s1">segment += </span><span class="s0">&quot;(?:&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">const </span><span class="s1">prevChar = glob[i - </span><span class="s4">1</span><span class="s1">];</span>
          <span class="s3">let </span><span class="s1">numStars = </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s3">while</span><span class="s1">(glob[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">&quot;*&quot;</span><span class="s1">){</span>
            <span class="s1">i++;</span>
            <span class="s1">numStars++;</span>
          <span class="s1">}</span>
          <span class="s3">const </span><span class="s1">nextChar = glob[i + </span><span class="s4">1</span><span class="s1">];</span>
          <span class="s3">if </span><span class="s1">(globstarOption &amp;&amp; numStars === </span><span class="s4">2 </span><span class="s1">&amp;&amp; [</span>
            <span class="s1">...c.seps,</span>
            <span class="s1">undefined</span>
          <span class="s1">].includes(prevChar) &amp;&amp; [</span>
            <span class="s1">...c.seps,</span>
            <span class="s1">undefined</span>
          <span class="s1">].includes(nextChar)) {</span>
            <span class="s1">segment += c.globstar;</span>
            <span class="s1">endsWithSep = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">segment += c.wildcard;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">segment += REG_EXP_ESCAPE_CHARS.includes(glob[i]) ? </span><span class="s0">`</span><span class="s7">\\</span><span class="s1">${glob[i]}</span><span class="s0">` </span><span class="s1">: glob[i];</span>
    <span class="s1">}</span>
    <span class="s2">// Check for unclosed groups or a dangling backslash.</span>
    <span class="s3">if </span><span class="s1">(groupStack.length &gt; </span><span class="s4">0 </span><span class="s1">|| inRange || inEscape) {</span>
      <span class="s2">// Parse failure. Take all characters from this segment literally.</span>
      <span class="s1">segment = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">c of glob.slice(j, i)){</span>
        <span class="s1">segment += REG_EXP_ESCAPE_CHARS.includes(c) ? </span><span class="s0">`</span><span class="s7">\\</span><span class="s1">${c}</span><span class="s0">` </span><span class="s1">: c;</span>
        <span class="s1">endsWithSep = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">regExpString += segment;</span>
    <span class="s3">if </span><span class="s1">(!endsWithSep) {</span>
      <span class="s1">regExpString += i &lt; glob.length ? c.sep : c.sepMaybe;</span>
      <span class="s1">endsWithSep = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">// Terminates with `i` at the start of the next segment.</span>
    <span class="s3">while</span><span class="s1">(c.seps.includes(glob[i]))i++;</span>
    <span class="s1">j = i;</span>
  <span class="s1">}</span>
  <span class="s1">regExpString = </span><span class="s0">`^</span><span class="s1">${regExpString}</span><span class="s0">$`</span><span class="s1">;</span>
  <span class="s3">return new </span><span class="s1">RegExp(regExpString, caseInsensitive ? </span><span class="s0">&quot;i&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s3">const </span><span class="s1">constants = {</span>
  <span class="s1">sep: </span><span class="s0">&quot;/+&quot;</span><span class="s1">,</span>
  <span class="s1">sepMaybe: </span><span class="s0">&quot;/*&quot;</span><span class="s1">,</span>
  <span class="s1">seps: [</span>
    <span class="s0">&quot;/&quot;</span>
  <span class="s1">],</span>
  <span class="s1">globstar: </span><span class="s0">&quot;(?:[^/]*(?:/|$)+)*&quot;</span><span class="s1">,</span>
  <span class="s1">wildcard: </span><span class="s0">&quot;[^/]*&quot;</span><span class="s1">,</span>
  <span class="s1">escapePrefix: </span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span>
<span class="s1">};</span>
<span class="s2">/** Convert a glob string to a regular expression.</span>
 <span class="s2">*</span>
 <span class="s2">* Tries to match bash glob expansion as closely as possible.</span>
 <span class="s2">*</span>
 <span class="s2">* Basic glob syntax:</span>
 <span class="s2">* - `*` - Matches everything without leaving the path segment.</span>
 <span class="s2">* - `?` - Matches any single character.</span>
 <span class="s2">* - `{foo,bar}` - Matches `foo` or `bar`.</span>
 <span class="s2">* - `[abcd]` - Matches `a`, `b`, `c` or `d`.</span>
 <span class="s2">* - `[a-d]` - Matches `a`, `b`, `c` or `d`.</span>
 <span class="s2">* - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.</span>
 <span class="s2">* - `[[:&lt;class&gt;:]]` - Matches any character belonging to `&lt;class&gt;`.</span>
 <span class="s2">*     - `[[:alnum:]]` - Matches any digit or letter.</span>
 <span class="s2">*     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.</span>
 <span class="s2">*     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes</span>
 <span class="s2">*       for a complete list of supported character classes.</span>
 <span class="s2">* - `\` - Escapes the next character for an `os` other than `&quot;windows&quot;`.</span>
 <span class="s2">* - \` - Escapes the next character for `os` set to `&quot;windows&quot;`.</span>
 <span class="s2">* - `/` - Path separator.</span>
 <span class="s2">* - `\` - Additional path separator only for `os` set to `&quot;windows&quot;`.</span>
 <span class="s2">*</span>
 <span class="s2">* Extended syntax:</span>
 <span class="s2">* - Requires `{ extended: true }`.</span>
 <span class="s2">* - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.</span>
 <span class="s2">* - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.</span>
 <span class="s2">* - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.</span>
 <span class="s2">* - `+(foo|bar)` - Matches _n &gt; 0_ instances of `{foo,bar}`.</span>
 <span class="s2">* - `!(foo|bar)` - Matches anything other than `{foo,bar}`.</span>
 <span class="s2">* - See https://www.linuxjournal.com/content/bash-extended-globbing.</span>
 <span class="s2">*</span>
 <span class="s2">* Globstar syntax:</span>
 <span class="s2">* - Requires `{ globstar: true }`.</span>
 <span class="s2">* - `**` - Matches any number of any path segments.</span>
 <span class="s2">*     - Must comprise its entire path segment in the provided glob.</span>
 <span class="s2">* - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.</span>
 <span class="s2">*</span>
 <span class="s2">* Note the following properties:</span>
 <span class="s2">* - The generated `RegExp` is anchored at both start and end.</span>
 <span class="s2">* - Repeating and trailing separators are tolerated. Trailing separators in the</span>
 <span class="s2">*   provided glob have no meaning and are discarded.</span>
 <span class="s2">* - Absolute globs will only match absolute paths, etc.</span>
 <span class="s2">* - Empty globs will match nothing.</span>
 <span class="s2">* - Any special glob syntax must be contained to one path segment. For example,</span>
 <span class="s2">*   `?(foo|bar/baz)` is invalid. The separator will take precedence and the</span>
 <span class="s2">*   first segment ends with an unclosed group.</span>
 <span class="s2">* - If a path segment ends with unclosed groups or a dangling escape prefix, a</span>
 <span class="s2">*   parse error has occurred. Every character for that segment is taken</span>
 <span class="s2">*   literally in this event.</span>
 <span class="s2">*</span>
 <span class="s2">* Limitations:</span>
 <span class="s2">* - A negative group like `!(foo|bar)` will wrongly be converted to a negative</span>
 <span class="s2">*   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly</span>
 <span class="s2">*   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,</span>
 <span class="s2">*   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if</span>
 <span class="s2">*   the group occurs not nested at the end of the segment.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { globToRegExp } from &quot;@std/path/posix/glob-to-regexp&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assertEquals(globToRegExp(&quot;*.js&quot;), /^[^/]*\.js\/*$/);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">glob Glob string to convert.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">options Conversion options.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The regular expression equivalent to the glob.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">globToRegExp(glob, options = {}) {</span>
  <span class="s3">return </span><span class="s1">_globToRegExp(constants, glob, options);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Test whether the given string is a glob.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { isGlob } from &quot;@std/path/is-glob&quot;;</span>
 <span class="s2">* import { assert } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* assert(!isGlob(&quot;foo/bar/../baz&quot;));</span>
 <span class="s2">* assert(isGlob(&quot;foo/*ar/../baz&quot;));</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">str String to test.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">`true` if the given string is a glob, otherwise `false`</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">isGlob(str) {</span>
  <span class="s3">const </span><span class="s1">chars = {</span>
    <span class="s0">&quot;{&quot;</span><span class="s1">: </span><span class="s0">&quot;}&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;(&quot;</span><span class="s1">: </span><span class="s0">&quot;)&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;[&quot;</span><span class="s1">: </span><span class="s0">&quot;]&quot;</span>
  <span class="s1">};</span>
  <span class="s3">const </span><span class="s1">regex = </span><span class="s6">/\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(str === </span><span class="s0">&quot;&quot;</span><span class="s1">) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">match;</span>
  <span class="s3">while</span><span class="s1">(match = regex.exec(str)){</span>
    <span class="s3">if </span><span class="s1">(match[</span><span class="s4">2</span><span class="s1">]) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">idx = match.index + match[</span><span class="s4">0</span><span class="s1">].length;</span>
    <span class="s2">// if an open bracket/brace/paren is escaped,</span>
    <span class="s2">// set the index to the next closing character</span>
    <span class="s3">const </span><span class="s1">open = match[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s3">const </span><span class="s1">close = open ? chars[open] : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(open &amp;&amp; close) {</span>
      <span class="s3">const </span><span class="s1">n = str.indexOf(close, idx);</span>
      <span class="s3">if </span><span class="s1">(n !== -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">idx = n + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">str = str.slice(idx);</span>
  <span class="s1">}</span>
  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Like normalize(), but doesn't collapse &quot;**\/..&quot; when `globstar` is true.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { normalizeGlob } from &quot;@std/path/posix/normalize-glob&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = normalizeGlob(&quot;foo/bar/../*&quot;, { globstar: true });</span>
 <span class="s2">* assertEquals(path, &quot;foo/*&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">glob The glob to normalize.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">options The options to use.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The normalized path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">normalizeGlob(glob, options = {}) {</span>
  <span class="s3">const </span><span class="s1">{ globstar = </span><span class="s3">false </span><span class="s1">} = options;</span>
  <span class="s3">if </span><span class="s1">(glob.match(</span><span class="s6">/\0/g</span><span class="s1">)) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">`Glob contains invalid characters: &quot;</span><span class="s1">${glob}</span><span class="s0">&quot;`</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(!globstar) {</span>
    <span class="s3">return </span><span class="s1">normalize(glob);</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s1">s = SEPARATOR_PATTERN.source;</span>
  <span class="s3">const </span><span class="s1">badParentPattern = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s0">`(?&lt;=(</span><span class="s1">${s}</span><span class="s0">|^)</span><span class="s7">\\</span><span class="s0">*</span><span class="s7">\\</span><span class="s0">*</span><span class="s1">${s}</span><span class="s0">)</span><span class="s7">\\</span><span class="s0">.</span><span class="s7">\\</span><span class="s0">.(?=</span><span class="s1">${s}</span><span class="s0">|$)`</span><span class="s1">, </span><span class="s0">&quot;g&quot;</span><span class="s1">);</span>
  <span class="s3">return </span><span class="s1">normalize(glob.replace(badParentPattern, </span><span class="s0">&quot;</span><span class="s7">\0</span><span class="s0">&quot;</span><span class="s1">)).replace(</span><span class="s6">/\0/g</span><span class="s1">, </span><span class="s0">&quot;..&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">// Copyright 2018-2025 the Deno authors. MIT license.</span>
<span class="s2">// This module is browser compatible.</span>
<span class="s2">/**</span>
 <span class="s2">* Like join(), but doesn't collapse &quot;**\/..&quot; when `globstar` is true.</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@example </span><span class="s2">Usage</span>
 <span class="s2">* ```ts</span>
 <span class="s2">* import { joinGlobs } from &quot;@std/path/posix/join-globs&quot;;</span>
 <span class="s2">* import { assertEquals } from &quot;@std/assert&quot;;</span>
 <span class="s2">*</span>
 <span class="s2">* const path = joinGlobs([&quot;foo&quot;, &quot;bar&quot;, &quot;**&quot;], { globstar: true });</span>
 <span class="s2">* assertEquals(path, &quot;foo/bar/**&quot;);</span>
 <span class="s2">* ```</span>
 <span class="s2">*</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">globs The globs to join.</span>
 <span class="s2">* </span><span class="s5">@param </span><span class="s2">options The options to use.</span>
 <span class="s2">* </span><span class="s5">@returns </span><span class="s2">The joined path.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s1">joinGlobs(globs, options = {}) {</span>
  <span class="s3">const </span><span class="s1">{ globstar = </span><span class="s3">false </span><span class="s1">} = options;</span>
  <span class="s3">if </span><span class="s1">(!globstar || globs.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">join(...globs);</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s1">joined;</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">glob of globs){</span>
    <span class="s3">const </span><span class="s1">path = glob;</span>
    <span class="s3">if </span><span class="s1">(path.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!joined) joined = path;</span>
      <span class="s3">else </span><span class="s1">joined += </span><span class="s0">`</span><span class="s1">${SEPARATOR}${path}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(!joined) </span><span class="s3">return </span><span class="s0">&quot;.&quot;</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">normalizeGlob(joined, {</span>
    <span class="s1">globstar</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">exports.DELIMITER = DELIMITER;</span>
<span class="s1">exports.SEPARATOR = SEPARATOR;</span>
<span class="s1">exports.SEPARATOR_PATTERN = SEPARATOR_PATTERN;</span>
<span class="s1">exports.basename = basename;</span>
<span class="s1">exports.common = common;</span>
<span class="s1">exports.dirname = dirname;</span>
<span class="s1">exports.extname = extname;</span>
<span class="s1">exports.format = format;</span>
<span class="s1">exports.fromFileUrl = fromFileUrl;</span>
<span class="s1">exports.globToRegExp = globToRegExp;</span>
<span class="s1">exports.isAbsolute = isAbsolute;</span>
<span class="s1">exports.isGlob = isGlob;</span>
<span class="s1">exports.join = join;</span>
<span class="s1">exports.joinGlobs = joinGlobs;</span>
<span class="s1">exports.normalize = normalize;</span>
<span class="s1">exports.normalizeGlob = normalizeGlob;</span>
<span class="s1">exports.parse = parse;</span>
<span class="s1">exports.relative = relative;</span>
<span class="s1">exports.resolve = resolve;</span>
<span class="s1">exports.toFileUrl = toFileUrl;</span>
<span class="s1">exports.toNamespacedPath = toNamespacedPath;</span>
</pre>
</body>
</html>