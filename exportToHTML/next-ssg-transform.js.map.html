<html>
<head>
<title>next-ssg-transform.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-ssg-transform.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/build/babel/plugins/next-ssg-transform.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">NodePath,</span><span class="s3">\n  </span><span class="s1">types as BabelTypes,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/babel/core'</span><span class="s3">\n</span><span class="s1">import type { PluginObj } from 'next/dist/compiled/babel/core'</span><span class="s3">\n</span><span class="s1">import { SERVER_PROPS_SSG_CONFLICT } from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { SERVER_PROPS_ID, STATIC_PROPS_ID } from '../../../shared/lib/constants'</span><span class="s3">\n\n</span><span class="s1">export const EXPORT_NAME_GET_STATIC_PROPS = 'getStaticProps'</span><span class="s3">\n</span><span class="s1">export const EXPORT_NAME_GET_STATIC_PATHS = 'getStaticPaths'</span><span class="s3">\n</span><span class="s1">export const EXPORT_NAME_GET_SERVER_PROPS = 'getServerSideProps'</span><span class="s3">\n\n</span><span class="s1">const ssgExports = new Set([</span><span class="s3">\n  </span><span class="s1">EXPORT_NAME_GET_STATIC_PROPS,</span><span class="s3">\n  </span><span class="s1">EXPORT_NAME_GET_STATIC_PATHS,</span><span class="s3">\n  </span><span class="s1">EXPORT_NAME_GET_SERVER_PROPS,</span><span class="s3">\n\n  </span><span class="s1">// legacy methods added so build doesn't fail from importing</span><span class="s3">\n  </span><span class="s1">// server-side only methods</span><span class="s3">\n  </span><span class="s1">`unstable_getStaticProps`,</span><span class="s3">\n  </span><span class="s1">`unstable_getStaticPaths`,</span><span class="s3">\n  </span><span class="s1">`unstable_getServerProps`,</span><span class="s3">\n  </span><span class="s1">`unstable_getServerSideProps`,</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">type PluginState = {</span><span class="s3">\n  </span><span class="s1">refs: Set&lt;NodePath&lt;BabelTypes.Identifier&gt;&gt;</span><span class="s3">\n  </span><span class="s1">isPrerender: boolean</span><span class="s3">\n  </span><span class="s1">isServerProps: boolean</span><span class="s3">\n  </span><span class="s1">done: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function decorateSsgExport(</span><span class="s3">\n  </span><span class="s1">t: typeof BabelTypes,</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;BabelTypes.Program&gt;,</span><span class="s3">\n  </span><span class="s1">state: PluginState</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const gsspName = state.isPrerender ? STATIC_PROPS_ID : SERVER_PROPS_ID</span><span class="s3">\n  </span><span class="s1">const gsspId = t.identifier(gsspName)</span><span class="s3">\n\n  </span><span class="s1">const addGsspExport = (</span><span class="s3">\n    </span><span class="s1">exportPath:</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.ExportDefaultDeclaration&gt;</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.ExportNamedDeclaration&gt;</span><span class="s3">\n  </span><span class="s1">): void =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.done) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state.done = true</span><span class="s3">\n\n    </span><span class="s1">const [pageCompPath] = exportPath.replaceWithMultiple([</span><span class="s3">\n      </span><span class="s1">t.exportNamedDeclaration(</span><span class="s3">\n        </span><span class="s1">t.variableDeclaration(</span><span class="s3">\n          </span><span class="s1">// We use 'var' instead of 'let' or 'const' for ES5 support. Since</span><span class="s3">\n          </span><span class="s1">// this runs in `Program#exit`, no ES2015 transforms (preset env)</span><span class="s3">\n          </span><span class="s1">// will be ran against this code.</span><span class="s3">\n          </span><span class="s1">'var',</span><span class="s3">\n          </span><span class="s1">[t.variableDeclarator(gsspId, t.booleanLiteral(true))]</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">[t.exportSpecifier(gsspId, gsspId)]</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">exportPath.node,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">exportPath.scope.registerDeclaration(</span><span class="s3">\n      </span><span class="s1">pageCompPath as NodePath&lt;BabelTypes.Node&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">path.traverse({</span><span class="s3">\n    </span><span class="s1">ExportDefaultDeclaration(exportDefaultPath) {</span><span class="s3">\n      </span><span class="s1">addGsspExport(exportDefaultPath)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ExportNamedDeclaration(exportNamedPath) {</span><span class="s3">\n      </span><span class="s1">addGsspExport(exportNamedPath)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const isDataIdentifier = (name: string, state: PluginState): boolean =&gt; {</span><span class="s3">\n  </span><span class="s1">if (ssgExports.has(name)) {</span><span class="s3">\n    </span><span class="s1">if (name === EXPORT_NAME_GET_SERVER_PROPS) {</span><span class="s3">\n      </span><span class="s1">if (state.isPrerender) {</span><span class="s3">\n        </span><span class="s1">throw new Error(SERVER_PROPS_SSG_CONFLICT)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">state.isServerProps = true</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (state.isServerProps) {</span><span class="s3">\n        </span><span class="s1">throw new Error(SERVER_PROPS_SSG_CONFLICT)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">state.isPrerender = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function nextTransformSsg({</span><span class="s3">\n  </span><span class="s1">types: t,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">types: typeof BabelTypes</span><span class="s3">\n</span><span class="s1">}): PluginObj&lt;PluginState&gt; {</span><span class="s3">\n  </span><span class="s1">function getIdentifier(</span><span class="s3">\n    </span><span class="s1">path:</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.FunctionDeclaration&gt;</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.FunctionExpression&gt;</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.ArrowFunctionExpression&gt;</span><span class="s3">\n  </span><span class="s1">): NodePath&lt;BabelTypes.Identifier&gt; | null {</span><span class="s3">\n    </span><span class="s1">const parentPath = path.parentPath</span><span class="s3">\n    </span><span class="s1">if (parentPath.type === 'VariableDeclarator') {</span><span class="s3">\n      </span><span class="s1">const pp = parentPath as NodePath&lt;BabelTypes.VariableDeclarator&gt;</span><span class="s3">\n      </span><span class="s1">const name = pp.get('id')</span><span class="s3">\n      </span><span class="s1">return name.node.type === 'Identifier'</span><span class="s3">\n        </span><span class="s1">? (name as NodePath&lt;BabelTypes.Identifier&gt;)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (parentPath.type === 'AssignmentExpression') {</span><span class="s3">\n      </span><span class="s1">const pp = parentPath as NodePath&lt;BabelTypes.AssignmentExpression&gt;</span><span class="s3">\n      </span><span class="s1">const name = pp.get('left')</span><span class="s3">\n      </span><span class="s1">return name.node.type === 'Identifier'</span><span class="s3">\n        </span><span class="s1">? (name as NodePath&lt;BabelTypes.Identifier&gt;)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (path.node.type === 'ArrowFunctionExpression') {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return path.node.id &amp;&amp; path.node.id.type === 'Identifier'</span><span class="s3">\n      </span><span class="s1">? (path.get('id') as NodePath&lt;BabelTypes.Identifier&gt;)</span><span class="s3">\n      </span><span class="s1">: null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function isIdentifierReferenced(</span><span class="s3">\n    </span><span class="s1">ident: NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">const b = ident.scope.getBinding(ident.node.name)</span><span class="s3">\n    </span><span class="s1">if (b?.referenced) {</span><span class="s3">\n      </span><span class="s1">// Functions can reference themselves, so we need to check if there's a</span><span class="s3">\n      </span><span class="s1">// binding outside the function scope or not.</span><span class="s3">\n      </span><span class="s1">if (b.path.type === 'FunctionDeclaration') {</span><span class="s3">\n        </span><span class="s1">return !b.constantViolations</span><span class="s3">\n          </span><span class="s1">.concat(b.referencePaths)</span><span class="s3">\n          </span><span class="s1">// Check that every reference is contained within the function:</span><span class="s3">\n          </span><span class="s1">.every((ref) =&gt; ref.findParent((p) =&gt; p === b.path))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function markFunction(</span><span class="s3">\n    </span><span class="s1">path:</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.FunctionDeclaration&gt;</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.FunctionExpression&gt;</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.ArrowFunctionExpression&gt;,</span><span class="s3">\n    </span><span class="s1">state: PluginState</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const ident = getIdentifier(path)</span><span class="s3">\n    </span><span class="s1">if (ident?.node &amp;&amp; isIdentifierReferenced(ident)) {</span><span class="s3">\n      </span><span class="s1">state.refs.add(ident)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function markImport(</span><span class="s3">\n    </span><span class="s1">path:</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.ImportSpecifier&gt;</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.ImportDefaultSpecifier&gt;</span><span class="s3">\n      </span><span class="s1">| NodePath&lt;BabelTypes.ImportNamespaceSpecifier&gt;,</span><span class="s3">\n    </span><span class="s1">state: PluginState</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const local = path.get('local') as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n    </span><span class="s1">if (isIdentifierReferenced(local)) {</span><span class="s3">\n      </span><span class="s1">state.refs.add(local)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">visitor: {</span><span class="s3">\n      </span><span class="s1">Program: {</span><span class="s3">\n        </span><span class="s1">enter(path, state) {</span><span class="s3">\n          </span><span class="s1">state.refs = new Set&lt;NodePath&lt;BabelTypes.Identifier&gt;&gt;()</span><span class="s3">\n          </span><span class="s1">state.isPrerender = false</span><span class="s3">\n          </span><span class="s1">state.isServerProps = false</span><span class="s3">\n          </span><span class="s1">state.done = false</span><span class="s3">\n\n          </span><span class="s1">path.traverse(</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">VariableDeclarator(variablePath, variableState) {</span><span class="s3">\n                </span><span class="s1">if (variablePath.node.id.type === 'Identifier') {</span><span class="s3">\n                  </span><span class="s1">const local = variablePath.get(</span><span class="s3">\n                    </span><span class="s1">'id'</span><span class="s3">\n                  </span><span class="s1">) as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                  </span><span class="s1">if (isIdentifierReferenced(local)) {</span><span class="s3">\n                    </span><span class="s1">variableState.refs.add(local)</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">} else if (variablePath.node.id.type === 'ObjectPattern') {</span><span class="s3">\n                  </span><span class="s1">const pattern = variablePath.get(</span><span class="s3">\n                    </span><span class="s1">'id'</span><span class="s3">\n                  </span><span class="s1">) as NodePath&lt;BabelTypes.ObjectPattern&gt;</span><span class="s3">\n\n                  </span><span class="s1">const properties = pattern.get('properties')</span><span class="s3">\n                  </span><span class="s1">properties.forEach((p) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const local = p.get(</span><span class="s3">\n                      </span><span class="s1">p.node.type === 'ObjectProperty'</span><span class="s3">\n                        </span><span class="s1">? 'value'</span><span class="s3">\n                        </span><span class="s1">: p.node.type === 'RestElement'</span><span class="s3">\n                          </span><span class="s1">? 'argument'</span><span class="s3">\n                          </span><span class="s1">: (function () {</span><span class="s3">\n                              </span><span class="s1">throw new Error('invariant')</span><span class="s3">\n                            </span><span class="s1">})()</span><span class="s3">\n                    </span><span class="s1">) as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                    </span><span class="s1">if (isIdentifierReferenced(local)) {</span><span class="s3">\n                      </span><span class="s1">variableState.refs.add(local)</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">})</span><span class="s3">\n                </span><span class="s1">} else if (variablePath.node.id.type === 'ArrayPattern') {</span><span class="s3">\n                  </span><span class="s1">const pattern = variablePath.get(</span><span class="s3">\n                    </span><span class="s1">'id'</span><span class="s3">\n                  </span><span class="s1">) as NodePath&lt;BabelTypes.ArrayPattern&gt;</span><span class="s3">\n\n                  </span><span class="s1">const elements = pattern.get('elements')</span><span class="s3">\n                  </span><span class="s1">elements.forEach((e) =&gt; {</span><span class="s3">\n                    </span><span class="s1">let local: NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                    </span><span class="s1">if (e.node?.type === 'Identifier') {</span><span class="s3">\n                      </span><span class="s1">local = e as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                    </span><span class="s1">} else if (e.node?.type === 'RestElement') {</span><span class="s3">\n                      </span><span class="s1">local = e.get(</span><span class="s3">\n                        </span><span class="s1">'argument'</span><span class="s3">\n                      </span><span class="s1">) as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                      </span><span class="s1">return</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n\n                    </span><span class="s1">if (isIdentifierReferenced(local)) {</span><span class="s3">\n                      </span><span class="s1">variableState.refs.add(local)</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">})</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">FunctionDeclaration: markFunction,</span><span class="s3">\n              </span><span class="s1">FunctionExpression: markFunction,</span><span class="s3">\n              </span><span class="s1">ArrowFunctionExpression: markFunction,</span><span class="s3">\n              </span><span class="s1">ImportSpecifier: markImport,</span><span class="s3">\n              </span><span class="s1">ImportDefaultSpecifier: markImport,</span><span class="s3">\n              </span><span class="s1">ImportNamespaceSpecifier: markImport,</span><span class="s3">\n              </span><span class="s1">ExportNamedDeclaration(exportNamedPath, exportNamedState) {</span><span class="s3">\n                </span><span class="s1">const specifiers = exportNamedPath.get('specifiers')</span><span class="s3">\n                </span><span class="s1">if (specifiers.length) {</span><span class="s3">\n                  </span><span class="s1">specifiers.forEach((s) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (</span><span class="s3">\n                      </span><span class="s1">isDataIdentifier(</span><span class="s3">\n                        </span><span class="s1">t.isIdentifier(s.node.exported)</span><span class="s3">\n                          </span><span class="s1">? s.node.exported.name</span><span class="s3">\n                          </span><span class="s1">: s.node.exported.value,</span><span class="s3">\n                        </span><span class="s1">exportNamedState</span><span class="s3">\n                      </span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">) {</span><span class="s3">\n                      </span><span class="s1">s.remove()</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">})</span><span class="s3">\n\n                  </span><span class="s1">if (exportNamedPath.node.specifiers.length &lt; 1) {</span><span class="s3">\n                    </span><span class="s1">exportNamedPath.remove()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">return</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">const decl = exportNamedPath.get('declaration') as NodePath&lt;</span><span class="s3">\n                  </span><span class="s1">| BabelTypes.FunctionDeclaration</span><span class="s3">\n                  </span><span class="s1">| BabelTypes.VariableDeclaration</span><span class="s3">\n                </span><span class="s1">&gt;</span><span class="s3">\n                </span><span class="s1">if (decl == null || decl.node == null) {</span><span class="s3">\n                  </span><span class="s1">return</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">switch (decl.node.type) {</span><span class="s3">\n                  </span><span class="s1">case 'FunctionDeclaration': {</span><span class="s3">\n                    </span><span class="s1">const name = decl.node.id!.name</span><span class="s3">\n                    </span><span class="s1">if (isDataIdentifier(name, exportNamedState)) {</span><span class="s3">\n                      </span><span class="s1">exportNamedPath.remove()</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">break</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">case 'VariableDeclaration': {</span><span class="s3">\n                    </span><span class="s1">const inner = decl.get(</span><span class="s3">\n                      </span><span class="s1">'declarations'</span><span class="s3">\n                    </span><span class="s1">) as NodePath&lt;BabelTypes.VariableDeclarator&gt;[]</span><span class="s3">\n                    </span><span class="s1">inner.forEach((d) =&gt; {</span><span class="s3">\n                      </span><span class="s1">if (d.node.id.type !== 'Identifier') {</span><span class="s3">\n                        </span><span class="s1">return</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                      </span><span class="s1">const name = d.node.id.name</span><span class="s3">\n                      </span><span class="s1">if (isDataIdentifier(name, exportNamedState)) {</span><span class="s3">\n                        </span><span class="s1">d.remove()</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">})</span><span class="s3">\n                    </span><span class="s1">break</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">default: {</span><span class="s3">\n                    </span><span class="s1">break</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">state</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">if (!state.isPrerender &amp;&amp; !state.isServerProps) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const refs = state.refs</span><span class="s3">\n          </span><span class="s1">let count: number</span><span class="s3">\n\n          </span><span class="s1">function sweepFunction(</span><span class="s3">\n            </span><span class="s1">sweepPath:</span><span class="s3">\n              </span><span class="s1">| NodePath&lt;BabelTypes.FunctionDeclaration&gt;</span><span class="s3">\n              </span><span class="s1">| NodePath&lt;BabelTypes.FunctionExpression&gt;</span><span class="s3">\n              </span><span class="s1">| NodePath&lt;BabelTypes.ArrowFunctionExpression&gt;</span><span class="s3">\n          </span><span class="s1">): void {</span><span class="s3">\n            </span><span class="s1">const ident = getIdentifier(sweepPath)</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">ident?.node &amp;&amp;</span><span class="s3">\n              </span><span class="s1">refs.has(ident) &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!isIdentifierReferenced(ident)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">++count</span><span class="s3">\n\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">t.isAssignmentExpression(sweepPath.parentPath.node) ||</span><span class="s3">\n                </span><span class="s1">t.isVariableDeclarator(sweepPath.parentPath.node)</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">sweepPath.parentPath.remove()</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">sweepPath.remove()</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">function sweepImport(</span><span class="s3">\n            </span><span class="s1">sweepPath:</span><span class="s3">\n              </span><span class="s1">| NodePath&lt;BabelTypes.ImportSpecifier&gt;</span><span class="s3">\n              </span><span class="s1">| NodePath&lt;BabelTypes.ImportDefaultSpecifier&gt;</span><span class="s3">\n              </span><span class="s1">| NodePath&lt;BabelTypes.ImportNamespaceSpecifier&gt;</span><span class="s3">\n          </span><span class="s1">): void {</span><span class="s3">\n            </span><span class="s1">const local = sweepPath.get(</span><span class="s3">\n              </span><span class="s1">'local'</span><span class="s3">\n            </span><span class="s1">) as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n            </span><span class="s1">if (refs.has(local) &amp;&amp; !isIdentifierReferenced(local)) {</span><span class="s3">\n              </span><span class="s1">++count</span><span class="s3">\n              </span><span class="s1">sweepPath.remove()</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">(sweepPath.parent as BabelTypes.ImportDeclaration).specifiers</span><span class="s3">\n                  </span><span class="s1">.length === 0</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">sweepPath.parentPath.remove()</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">do {</span><span class="s3">\n            </span><span class="s1">;(path.scope as any).crawl()</span><span class="s3">\n            </span><span class="s1">count = 0</span><span class="s3">\n\n            </span><span class="s1">path.traverse({</span><span class="s3">\n              </span><span class="s1">// eslint-disable-next-line no-loop-func</span><span class="s3">\n              </span><span class="s1">VariableDeclarator(variablePath) {</span><span class="s3">\n                </span><span class="s1">if (variablePath.node.id.type === 'Identifier') {</span><span class="s3">\n                  </span><span class="s1">const local = variablePath.get(</span><span class="s3">\n                    </span><span class="s1">'id'</span><span class="s3">\n                  </span><span class="s1">) as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                  </span><span class="s1">if (refs.has(local) &amp;&amp; !isIdentifierReferenced(local)) {</span><span class="s3">\n                    </span><span class="s1">++count</span><span class="s3">\n                    </span><span class="s1">variablePath.remove()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">} else if (variablePath.node.id.type === 'ObjectPattern') {</span><span class="s3">\n                  </span><span class="s1">const pattern = variablePath.get(</span><span class="s3">\n                    </span><span class="s1">'id'</span><span class="s3">\n                  </span><span class="s1">) as NodePath&lt;BabelTypes.ObjectPattern&gt;</span><span class="s3">\n\n                  </span><span class="s1">const beforeCount = count</span><span class="s3">\n                  </span><span class="s1">const properties = pattern.get('properties')</span><span class="s3">\n                  </span><span class="s1">properties.forEach((p) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const local = p.get(</span><span class="s3">\n                      </span><span class="s1">p.node.type === 'ObjectProperty'</span><span class="s3">\n                        </span><span class="s1">? 'value'</span><span class="s3">\n                        </span><span class="s1">: p.node.type === 'RestElement'</span><span class="s3">\n                          </span><span class="s1">? 'argument'</span><span class="s3">\n                          </span><span class="s1">: (function () {</span><span class="s3">\n                              </span><span class="s1">throw new Error('invariant')</span><span class="s3">\n                            </span><span class="s1">})()</span><span class="s3">\n                    </span><span class="s1">) as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n\n                    </span><span class="s1">if (refs.has(local) &amp;&amp; !isIdentifierReferenced(local)) {</span><span class="s3">\n                      </span><span class="s1">++count</span><span class="s3">\n                      </span><span class="s1">p.remove()</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">})</span><span class="s3">\n\n                  </span><span class="s1">if (</span><span class="s3">\n                    </span><span class="s1">beforeCount !== count &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">pattern.get('properties').length &lt; 1</span><span class="s3">\n                  </span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">variablePath.remove()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">} else if (variablePath.node.id.type === 'ArrayPattern') {</span><span class="s3">\n                  </span><span class="s1">const pattern = variablePath.get(</span><span class="s3">\n                    </span><span class="s1">'id'</span><span class="s3">\n                  </span><span class="s1">) as NodePath&lt;BabelTypes.ArrayPattern&gt;</span><span class="s3">\n\n                  </span><span class="s1">const beforeCount = count</span><span class="s3">\n                  </span><span class="s1">const elements = pattern.get('elements')</span><span class="s3">\n                  </span><span class="s1">elements.forEach((e) =&gt; {</span><span class="s3">\n                    </span><span class="s1">let local: NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                    </span><span class="s1">if (e.node?.type === 'Identifier') {</span><span class="s3">\n                      </span><span class="s1">local = e as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                    </span><span class="s1">} else if (e.node?.type === 'RestElement') {</span><span class="s3">\n                      </span><span class="s1">local = e.get(</span><span class="s3">\n                        </span><span class="s1">'argument'</span><span class="s3">\n                      </span><span class="s1">) as NodePath&lt;BabelTypes.Identifier&gt;</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                      </span><span class="s1">return</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n\n                    </span><span class="s1">if (refs.has(local) &amp;&amp; !isIdentifierReferenced(local)) {</span><span class="s3">\n                      </span><span class="s1">++count</span><span class="s3">\n                      </span><span class="s1">e.remove()</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">})</span><span class="s3">\n\n                  </span><span class="s1">if (</span><span class="s3">\n                    </span><span class="s1">beforeCount !== count &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">pattern.get('elements').length &lt; 1</span><span class="s3">\n                  </span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">variablePath.remove()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">FunctionDeclaration: sweepFunction,</span><span class="s3">\n              </span><span class="s1">FunctionExpression: sweepFunction,</span><span class="s3">\n              </span><span class="s1">ArrowFunctionExpression: sweepFunction,</span><span class="s3">\n              </span><span class="s1">ImportSpecifier: sweepImport,</span><span class="s3">\n              </span><span class="s1">ImportDefaultSpecifier: sweepImport,</span><span class="s3">\n              </span><span class="s1">ImportNamespaceSpecifier: sweepImport,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">} while (count)</span><span class="s3">\n\n          </span><span class="s1">decorateSsgExport(t, path, state)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;EXPORT_NAME_GET_SERVER_PROPS&quot;</span><span class="s0">,</span><span class="s1">&quot;EXPORT_NAME_GET_STATIC_PATHS&quot;</span><span class="s0">,</span><span class="s1">&quot;EXPORT_NAME_GET_STATIC_PROPS&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTransformSsg&quot;</span><span class="s0">,</span><span class="s1">&quot;ssgExports&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;decorateSsgExport&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;gsspName&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrerender&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_PROPS_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_PROPS_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;gsspId&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;addGsspExport&quot;</span><span class="s0">,</span><span class="s1">&quot;exportPath&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;pageCompPath&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;exportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportDefaultPath&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isDataIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_PROPS_SSG_CONFLICT&quot;</span><span class="s0">,</span><span class="s1">&quot;isServerProps&quot;</span><span class="s0">,</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;getIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;pp&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifierReferenced&quot;</span><span class="s0">,</span><span class="s1">&quot;ident&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;referenced&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;referencePaths&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;markFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;refs&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;markImport&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Program&quot;</span><span class="s0">,</span><span class="s1">&quot;enter&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;variablePath&quot;</span><span class="s0">,</span><span class="s1">&quot;variableState&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;elements&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamedState&quot;</span><span class="s0">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;decl&quot;</span><span class="s0">,</span><span class="s1">&quot;inner&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;sweepFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;sweepPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;sweepImport&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;crawl&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeCount&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>