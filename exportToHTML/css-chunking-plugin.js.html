<html>
<head>
<title>css-chunking-plugin.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
css-chunking-plugin.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;CssChunkingPlugin&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">CssChunkingPlugin;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">PLUGIN_NAME = </span><span class="s0">'CssChunkingPlugin'</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Merge chunks until they are bigger than the target size.</span>
 <span class="s3">*/ </span><span class="s2">const </span><span class="s1">MIN_CSS_CHUNK_SIZE = </span><span class="s4">30 </span><span class="s1">* </span><span class="s4">1024</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Avoid merging chunks when they would be bigger than this size.</span>
 <span class="s3">*/ </span><span class="s2">const </span><span class="s1">MAX_CSS_CHUNK_SIZE = </span><span class="s4">100 </span><span class="s1">* </span><span class="s4">1024</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">isGlobalCss(module) {</span>
    <span class="s2">return </span><span class="s1">!</span><span class="s5">/\.module\.(css|scss|sass)$/</span><span class="s1">.test(module.nameForCondition() || </span><span class="s0">''</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">CssChunkingPlugin {</span>
    <span class="s1">constructor(strict){</span>
        <span class="s2">this</span><span class="s1">.strict = strict;</span>
    <span class="s1">}</span>
    <span class="s1">apply(compiler) {</span>
        <span class="s2">const </span><span class="s1">strict = </span><span class="s2">this</span><span class="s1">.strict;</span>
        <span class="s2">const </span><span class="s1">summary = !!process.env.CSS_CHUNKING_SUMMARY;</span>
        <span class="s1">compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation)=&gt;{</span>
            <span class="s2">let </span><span class="s1">once = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">compilation.hooks.optimizeChunks.tap({</span>
                <span class="s1">name: PLUGIN_NAME,</span>
                <span class="s1">stage: </span><span class="s4">5</span>
            <span class="s1">}, ()=&gt;{</span>
                <span class="s2">if </span><span class="s1">(once) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">once = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">chunkGraph = compilation.chunkGraph;</span>
                <span class="s2">let </span><span class="s1">changed = undefined;</span>
                <span class="s2">const </span><span class="s1">chunkStates = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s2">const </span><span class="s1">chunkStatesByModule = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s3">// Collect all css modules in chunks and the execpted order of them</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of compilation.chunks){</span>
                    <span class="s2">var </span><span class="s1">_chunk_name;</span>
                    <span class="s2">if </span><span class="s1">((_chunk_name = chunk.name) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _chunk_name.startsWith(</span><span class="s0">'pages/'</span><span class="s1">)) </span><span class="s2">continue</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">modules = [];</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of chunkGraph.getChunkModulesIterable(chunk)){</span>
                        <span class="s2">var </span><span class="s1">_module_type;</span>
                        <span class="s2">if </span><span class="s1">(!((_module_type = module.type) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _module_type.startsWith(</span><span class="s0">'css'</span><span class="s1">))) </span><span class="s2">continue</span><span class="s1">;</span>
                        <span class="s1">modules.push(module);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!modules.length) </span><span class="s2">continue</span><span class="s1">;</span>
                    <span class="s2">const </span><span class="s1">chunkState = {</span>
                        <span class="s1">chunk,</span>
                        <span class="s1">modules,</span>
                        <span class="s1">order: </span><span class="s4">0</span><span class="s1">,</span>
                        <span class="s1">requests: modules.length</span>
                    <span class="s1">};</span>
                    <span class="s1">chunkStates.set(chunk, chunkState);</span>
                    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; modules.length; i++){</span>
                        <span class="s2">const </span><span class="s1">module = modules[i];</span>
                        <span class="s2">let </span><span class="s1">moduleChunkStates = chunkStatesByModule.get(module);</span>
                        <span class="s2">if </span><span class="s1">(!moduleChunkStates) {</span>
                            <span class="s1">moduleChunkStates = </span><span class="s2">new </span><span class="s1">Map();</span>
                            <span class="s1">chunkStatesByModule.set(module, moduleChunkStates);</span>
                        <span class="s1">}</span>
                        <span class="s1">moduleChunkStates.set(chunkState, i);</span>
                        <span class="s1">chunkStatesByModule.set(module, moduleChunkStates);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">// Sort modules by their index sum</span>
                <span class="s2">const </span><span class="s1">orderedModules = [];</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[module, moduleChunkStates] of chunkStatesByModule){</span>
                    <span class="s2">let </span><span class="s1">sum = </span><span class="s4">0</span><span class="s1">;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">i of moduleChunkStates.values()){</span>
                        <span class="s1">sum += i;</span>
                    <span class="s1">}</span>
                    <span class="s1">orderedModules.push({</span>
                        <span class="s1">module,</span>
                        <span class="s1">sum</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">orderedModules.sort((a, b)=&gt;a.sum - b.sum);</span>
                <span class="s3">// A queue of modules that still need to be processed</span>
                <span class="s2">const </span><span class="s1">remainingModules = </span><span class="s2">new </span><span class="s1">Set(orderedModules.map(({ module })=&gt;module));</span>
                <span class="s3">// In loose mode we guess the dependents of modules from the order</span>
                <span class="s3">// assuming that when a module is a dependency of another module</span>
                <span class="s3">// it will always appear before it in every chunk.</span>
                <span class="s2">const </span><span class="s1">allDependents = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.strict) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">b of remainingModules){</span>
                        <span class="s2">const </span><span class="s1">dependent = </span><span class="s2">new </span><span class="s1">Set();</span>
                        <span class="s1">loop: </span><span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">a of remainingModules){</span>
                            <span class="s2">if </span><span class="s1">(a === b) </span><span class="s2">continue</span><span class="s1">;</span>
                            <span class="s3">// check if a depends on b</span>
                            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[chunkState, ia] of chunkStatesByModule.get(a)){</span>
                                <span class="s2">const </span><span class="s1">bChunkStates = chunkStatesByModule.get(b);</span>
                                <span class="s2">const </span><span class="s1">ib = bChunkStates.get(chunkState);</span>
                                <span class="s2">if </span><span class="s1">(ib === undefined) {</span>
                                    <span class="s2">continue </span><span class="s1">loop;</span>
                                <span class="s1">}</span>
                                <span class="s2">if </span><span class="s1">(ib &gt; ia) {</span>
                                    <span class="s2">continue </span><span class="s1">loop;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s1">dependent.add(a);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(dependent.size &gt; </span><span class="s4">0</span><span class="s1">) allDependents.set(b, dependent);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">// Stores the new chunk for every module</span>
                <span class="s2">const </span><span class="s1">newChunksByModule = </span><span class="s2">new </span><span class="s1">Map();</span>
                <span class="s3">// Process through all modules</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">startModule of remainingModules){</span>
                    <span class="s2">let </span><span class="s1">globalCssMode = isGlobalCss(startModule);</span>
                    <span class="s3">// The current position of processing in all selected chunks</span>
                    <span class="s2">let </span><span class="s1">allChunkStates = </span><span class="s2">new </span><span class="s1">Map(chunkStatesByModule.get(startModule));</span>
                    <span class="s3">// The list of modules that goes into the new chunk</span>
                    <span class="s2">const </span><span class="s1">newChunkModules = </span><span class="s2">new </span><span class="s1">Set([</span>
                        <span class="s1">startModule</span>
                    <span class="s1">]);</span>
                    <span class="s3">// The current size of the new chunk</span>
                    <span class="s2">let </span><span class="s1">currentSize = startModule.size();</span>
                    <span class="s3">// A pool of potential modules where the next module is selected from.</span>
                    <span class="s3">// It's filled from the next module of the selected modules in every chunk.</span>
                    <span class="s3">// It also keeps some metadata to improve performance [size, chunkStates].</span>
                    <span class="s2">const </span><span class="s1">potentialNextModules = </span><span class="s2">new </span><span class="s1">Map();</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[chunkState, i] of allChunkStates){</span>
                        <span class="s2">const </span><span class="s1">nextModule = chunkState.modules[i + </span><span class="s4">1</span><span class="s1">];</span>
                        <span class="s2">if </span><span class="s1">(nextModule &amp;&amp; remainingModules.has(nextModule)) {</span>
                            <span class="s1">potentialNextModules.set(nextModule, [</span>
                                <span class="s1">nextModule.size(),</span>
                                <span class="s1">chunkStatesByModule.get(nextModule)</span>
                            <span class="s1">]);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s3">// Try to add modules to the chunk until a break condition is met</span>
                    <span class="s2">let </span><span class="s1">cont;</span>
                    <span class="s2">do </span><span class="s1">{</span>
                        <span class="s1">cont = </span><span class="s2">false</span><span class="s1">;</span>
                        <span class="s3">// We try to select a module that reduces request count and</span>
                        <span class="s3">// has the highest number of requests</span>
                        <span class="s2">const </span><span class="s1">orderedPotentialNextModules = [];</span>
                        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[nextModule, [size, nextChunkStates]] of potentialNextModules){</span>
                            <span class="s2">let </span><span class="s1">maxRequests = </span><span class="s4">0</span><span class="s1">;</span>
                            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunkState of nextChunkStates.keys()){</span>
                                <span class="s3">// There is always some overlap</span>
                                <span class="s2">if </span><span class="s1">(allChunkStates.has(chunkState)) {</span>
                                    <span class="s1">maxRequests = Math.max(maxRequests, chunkState.requests);</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s1">orderedPotentialNextModules.push([</span>
                                <span class="s1">nextModule,</span>
                                <span class="s1">size,</span>
                                <span class="s1">nextChunkStates,</span>
                                <span class="s1">maxRequests</span>
                            <span class="s1">]);</span>
                        <span class="s1">}</span>
                        <span class="s1">orderedPotentialNextModules.sort((a, b)=&gt;b[</span><span class="s4">3</span><span class="s1">] - a[</span><span class="s4">3</span><span class="s1">] || (a[</span><span class="s4">0</span><span class="s1">].identifier() &lt; b[</span><span class="s4">0</span><span class="s1">].identifier() ? -</span><span class="s4">1 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">));</span>
                        <span class="s3">// Try every potential module</span>
                        <span class="s1">loop: </span><span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[nextModule, size, nextChunkStates] of orderedPotentialNextModules){</span>
                            <span class="s2">if </span><span class="s1">(currentSize + size &gt; MAX_CSS_CHUNK_SIZE) {</span>
                                <span class="s2">continue</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s2">if </span><span class="s1">(!strict) {</span>
                                <span class="s3">// In loose mode we only check if the dependencies are not violated</span>
                                <span class="s2">const </span><span class="s1">dependent = allDependents.get(nextModule);</span>
                                <span class="s2">if </span><span class="s1">(dependent) {</span>
                                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dep of dependent){</span>
                                        <span class="s2">if </span><span class="s1">(newChunkModules.has(dep)) {</span>
                                            <span class="s2">continue </span><span class="s1">loop;</span>
                                        <span class="s1">}</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                <span class="s3">// In strict mode we check that none of the order in any chunk is changed by adding the module</span>
                                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[chunkState, i] of nextChunkStates){</span>
                                    <span class="s2">const </span><span class="s1">prevState = allChunkStates.get(chunkState);</span>
                                    <span class="s2">if </span><span class="s1">(prevState === undefined) {</span>
                                        <span class="s3">// New chunk group, can add it, but should we?</span>
                                        <span class="s3">// We only add that if below min size</span>
                                        <span class="s2">if </span><span class="s1">(currentSize &lt; MIN_CSS_CHUNK_SIZE) {</span>
                                            <span class="s2">continue</span><span class="s1">;</span>
                                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                            <span class="s2">continue </span><span class="s1">loop;</span>
                                        <span class="s1">}</span>
                                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prevState + </span><span class="s4">1 </span><span class="s1">=== i) {</span>
                                        <span class="s2">continue</span><span class="s1">;</span>
                                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                        <span class="s2">continue </span><span class="s1">loop;</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s3">// Global CSS must not leak into unrelated chunks</span>
                            <span class="s2">const </span><span class="s1">nextIsGlobalCss = isGlobalCss(nextModule);</span>
                            <span class="s2">if </span><span class="s1">(nextIsGlobalCss &amp;&amp; globalCssMode) {</span>
                                <span class="s2">if </span><span class="s1">(allChunkStates.size !== nextChunkStates.size) {</span>
                                    <span class="s2">continue</span><span class="s1">;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s2">if </span><span class="s1">(globalCssMode) {</span>
                                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunkState of nextChunkStates.keys()){</span>
                                    <span class="s2">if </span><span class="s1">(!allChunkStates.has(chunkState)) {</span>
                                        <span class="s2">continue </span><span class="s1">loop;</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s2">if </span><span class="s1">(nextIsGlobalCss) {</span>
                                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunkState of allChunkStates.keys()){</span>
                                    <span class="s2">if </span><span class="s1">(!nextChunkStates.has(chunkState)) {</span>
                                        <span class="s2">continue </span><span class="s1">loop;</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s1">potentialNextModules.delete(nextModule);</span>
                            <span class="s1">currentSize += size;</span>
                            <span class="s2">if </span><span class="s1">(nextIsGlobalCss) {</span>
                                <span class="s1">globalCssMode = </span><span class="s2">true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[chunkState, i] of nextChunkStates){</span>
                                <span class="s2">if </span><span class="s1">(allChunkStates.has(chunkState)) {</span>
                                    <span class="s3">// This reduces the request count of the chunk group</span>
                                    <span class="s1">chunkState.requests--;</span>
                                <span class="s1">}</span>
                                <span class="s1">allChunkStates.set(chunkState, i);</span>
                                <span class="s2">const </span><span class="s1">newNextModule = chunkState.modules[i + </span><span class="s4">1</span><span class="s1">];</span>
                                <span class="s2">if </span><span class="s1">(newNextModule &amp;&amp; remainingModules.has(newNextModule) &amp;&amp; !newChunkModules.has(newNextModule)) {</span>
                                    <span class="s1">potentialNextModules.set(newNextModule, [</span>
                                        <span class="s1">newNextModule.size(),</span>
                                        <span class="s1">chunkStatesByModule.get(newNextModule)</span>
                                    <span class="s1">]);</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s1">newChunkModules.add(nextModule);</span>
                            <span class="s1">cont = </span><span class="s2">true</span><span class="s1">;</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span><span class="s2">while </span><span class="s1">(cont);</span>
                    <span class="s2">const </span><span class="s1">newChunk = compilation.addChunk();</span>
                    <span class="s1">newChunk.preventIntegration = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">newChunk.idNameHints.add(</span><span class="s0">'css'</span><span class="s1">);</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of newChunkModules){</span>
                        <span class="s1">remainingModules.delete(module);</span>
                        <span class="s1">chunkGraph.connectChunkAndModule(newChunk, module);</span>
                        <span class="s1">newChunksByModule.set(module, newChunk);</span>
                    <span class="s1">}</span>
                    <span class="s1">changed = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ chunk, modules } of chunkStates.values()){</span>
                    <span class="s2">const </span><span class="s1">chunks = </span><span class="s2">new </span><span class="s1">Set();</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modules){</span>
                        <span class="s2">const </span><span class="s1">newChunk = newChunksByModule.get(module);</span>
                        <span class="s2">if </span><span class="s1">(newChunk) {</span>
                            <span class="s1">chunkGraph.disconnectChunkAndModule(chunk, module);</span>
                            <span class="s2">if </span><span class="s1">(chunks.has(newChunk)) </span><span class="s2">continue</span><span class="s1">;</span>
                            <span class="s1">chunks.add(newChunk);</span>
                            <span class="s1">chunk.split(newChunk);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(summary) {</span>
                    <span class="s1">console.log(</span><span class="s0">'Top 20 chunks by request count:'</span><span class="s1">);</span>
                    <span class="s2">const </span><span class="s1">orderedChunkStates = [</span>
                        <span class="s1">...chunkStates.values()</span>
                    <span class="s1">];</span>
                    <span class="s1">orderedChunkStates.sort((a, b)=&gt;b.requests - a.requests);</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ chunk, modules, requests } of orderedChunkStates.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">20</span><span class="s1">)){</span>
                        <span class="s1">console.log(</span><span class="s0">`- </span><span class="s1">${requests} </span><span class="s0">requests for </span><span class="s1">${chunk.name} </span><span class="s0">(has </span><span class="s1">${modules.length} </span><span class="s0">modules)`</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">changed;</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=css-chunking-plugin.js.map</span></pre>
</body>
</html>