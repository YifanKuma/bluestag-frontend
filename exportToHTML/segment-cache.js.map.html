<html>
<head>
<title>segment-cache.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
segment-cache.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/client/components/segment-cache.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Entry point to the Segment Cache implementation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* All code related to the Segment Cache lives `segment-cache-impl` directory.</span><span class="s3">\n </span><span class="s1">* Callers access it through this indirection.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is to ensure the code is dead code eliminated from the bundle if the</span><span class="s3">\n </span><span class="s1">* flag is disabled.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* TODO: This is super tedious. Since experimental flags are an essential part</span><span class="s3">\n </span><span class="s1">* of our workflow, we should establish a better pattern for dead code</span><span class="s3">\n </span><span class="s1">* elimination. Ideally it would be done at the bundler level, like how React's</span><span class="s3">\n </span><span class="s1">* build process works. In the React repo, you don't even need to add any extra</span><span class="s3">\n </span><span class="s1">* configuration per experiment â€” if the code is not reachable, it gets stripped</span><span class="s3">\n </span><span class="s1">* from the build automatically by Rollup. Or, shorter term, we could stub out</span><span class="s3">\n </span><span class="s1">* experimental modules at build time by updating the build config, i.e. a more</span><span class="s3">\n </span><span class="s1">* automated version of what I'm doing manually in this file.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export type { NavigationResult } from './segment-cache-impl/navigation'</span><span class="s3">\n</span><span class="s1">export type { PrefetchTask } from './segment-cache-impl/scheduler'</span><span class="s3">\n</span><span class="s1">export type { NormalizedSearch } from './segment-cache-impl/cache-key'</span><span class="s3">\n\n</span><span class="s1">const notEnabled: any = () =&gt; {</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">'Segment Cache experiment is not enabled. This is a bug in Next.js.'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const prefetch: typeof import('./segment-cache-impl/prefetch').prefetch =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/prefetch') as typeof import('./segment-cache-impl/prefetch')</span><span class="s3">\n        </span><span class="s1">).prefetch(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const navigate: typeof import('./segment-cache-impl/navigation').navigate =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/navigation') as typeof import('./segment-cache-impl/navigation')</span><span class="s3">\n        </span><span class="s1">).navigate(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const revalidateEntireCache: typeof import('./segment-cache-impl/cache').revalidateEntireCache =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/cache') as typeof import('./segment-cache-impl/cache')</span><span class="s3">\n        </span><span class="s1">).revalidateEntireCache(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const getCurrentCacheVersion: typeof import('./segment-cache-impl/cache').getCurrentCacheVersion =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/cache') as typeof import('./segment-cache-impl/cache')</span><span class="s3">\n        </span><span class="s1">).getCurrentCacheVersion(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const schedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').schedulePrefetchTask =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')</span><span class="s3">\n        </span><span class="s1">).schedulePrefetchTask(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const cancelPrefetchTask: typeof import('./segment-cache-impl/scheduler').cancelPrefetchTask =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')</span><span class="s3">\n        </span><span class="s1">).cancelPrefetchTask(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const reschedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').reschedulePrefetchTask =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')</span><span class="s3">\n        </span><span class="s1">).reschedulePrefetchTask(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const isPrefetchTaskDirty: typeof import('./segment-cache-impl/scheduler').isPrefetchTaskDirty =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')</span><span class="s3">\n        </span><span class="s1">).isPrefetchTaskDirty(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">export const createCacheKey: typeof import('./segment-cache-impl/cache-key').createCacheKey =</span><span class="s3">\n  </span><span class="s1">process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n    </span><span class="s1">? function (...args) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">require('./segment-cache-impl/cache-key') as typeof import('./segment-cache-impl/cache-key')</span><span class="s3">\n        </span><span class="s1">).createCacheKey(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: notEnabled</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Below are public constants. They're small enough that we don't need to</span><span class="s3">\n </span><span class="s1">* DCE them.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const enum NavigationResultTag {</span><span class="s3">\n  </span><span class="s1">MPA,</span><span class="s3">\n  </span><span class="s1">Success,</span><span class="s3">\n  </span><span class="s1">NoOp,</span><span class="s3">\n  </span><span class="s1">Async,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The priority of the prefetch task. Higher numbers are higher priority.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const enum PrefetchPriority {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Assigned to the most recently hovered/touched link. Special network</span><span class="s3">\n   </span><span class="s1">* bandwidth is reserved for this task only. There's only ever one Intent-</span><span class="s3">\n   </span><span class="s1">* priority task at a time; when a new Intent task is scheduled, the previous</span><span class="s3">\n   </span><span class="s1">* one is bumped down to Default.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Intent = 2,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The default priority for prefetch tasks.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Default = 1,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Assigned to tasks when they spawn non-blocking background work, like</span><span class="s3">\n   </span><span class="s1">* revalidating a partially cached entry to see if more data is available.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Background = 0,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const enum FetchStrategy {</span><span class="s3">\n  </span><span class="s1">// Deliberately ordered so we can easily compare two segments</span><span class="s3">\n  </span><span class="s1">// and determine if one segment is </span><span class="s3">\&quot;</span><span class="s1">more specific</span><span class="s3">\&quot; </span><span class="s1">than another</span><span class="s3">\n  </span><span class="s1">// (i.e. if it's likely that it contains more data)</span><span class="s3">\n  </span><span class="s1">LoadingBoundary = 0,</span><span class="s3">\n  </span><span class="s1">PPR = 1,</span><span class="s3">\n  </span><span class="s1">PPRRuntime = 2,</span><span class="s3">\n  </span><span class="s1">Full = 3,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A subset of fetch strategies used for prefetch tasks.</span><span class="s3">\n </span><span class="s1">* A prefetch task can't know if it should use `PPR` or `LoadingBoundary`</span><span class="s3">\n </span><span class="s1">* until we complete the initial tree prefetch request, so we use `PPR` to signal both cases</span><span class="s3">\n </span><span class="s1">* and adjust it based on the route when actually fetching.</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">export type PrefetchTaskFetchStrategy =</span><span class="s3">\n  </span><span class="s1">| FetchStrategy.PPR</span><span class="s3">\n  </span><span class="s1">| FetchStrategy.PPRRuntime</span><span class="s3">\n  </span><span class="s1">| FetchStrategy.Full</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;FetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;NavigationResultTag&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchPriority&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;createCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentCacheVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchTaskDirty&quot;</span><span class="s0">,</span><span class="s1">&quot;navigate&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;reschedulePrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateEntireCache&quot;</span><span class="s0">,</span><span class="s1">&quot;schedulePrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;notEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>