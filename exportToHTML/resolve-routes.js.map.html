<html>
<head>
<title>resolve-routes.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve-routes.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/lib/router-utils/resolve-routes.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FsOutput } from './filesystem'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextConfigComplete } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import type { RenderServer, initialize } from '../router-server'</span><span class="s3">\n</span><span class="s1">import type { PatchMatcher } from '../../../shared/lib/router/utils/path-match'</span><span class="s3">\n</span><span class="s1">import type { Redirect } from '../../../types'</span><span class="s3">\n</span><span class="s1">import type { Header, Rewrite } from '../../../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { UnwrapPromise } from '../../../lib/coalesced-function'</span><span class="s3">\n</span><span class="s1">import type { NextUrlWithParsedQuery } from '../../request-meta'</span><span class="s3">\n\n</span><span class="s1">import url from 'url'</span><span class="s3">\n</span><span class="s1">import path from 'node:path'</span><span class="s3">\n</span><span class="s1">import setupDebug from 'next/dist/compiled/debug'</span><span class="s3">\n</span><span class="s1">import { getCloneableBody } from '../../body-streams'</span><span class="s3">\n</span><span class="s1">import { filterReqHeaders, ipcForbiddenHeaders } from '../server-ipc/utils'</span><span class="s3">\n</span><span class="s1">import { stringifyQuery } from '../../server-route-utils'</span><span class="s3">\n</span><span class="s1">import { formatHostname } from '../format-hostname'</span><span class="s3">\n</span><span class="s1">import { toNodeOutgoingHttpHeaders } from '../../web/utils'</span><span class="s3">\n</span><span class="s1">import { isAbortError } from '../../pipe-readable'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../../../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getRedirectStatus,</span><span class="s3">\n  </span><span class="s1">allowedStatusCodes,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/redirect-status'</span><span class="s3">\n</span><span class="s1">import { normalizeRepeatedSlashes } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { getRelativeURL } from '../../../shared/lib/router/utils/relativize-url'</span><span class="s3">\n</span><span class="s1">import { addPathPrefix } from '../../../shared/lib/router/utils/add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from '../../../shared/lib/router/utils/path-has-prefix'</span><span class="s3">\n</span><span class="s1">import { detectDomainLocale } from '../../../shared/lib/i18n/detect-domain-locale'</span><span class="s3">\n</span><span class="s1">import { normalizeLocalePath } from '../../../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from '../../../shared/lib/router/utils/remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { NextDataPathnameNormalizer } from '../../normalizers/request/next-data'</span><span class="s3">\n</span><span class="s1">import { BasePathPathnameNormalizer } from '../../normalizers/request/base-path'</span><span class="s3">\n\n</span><span class="s1">import { addRequestMeta } from '../../request-meta'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">compileNonPath,</span><span class="s3">\n  </span><span class="s1">matchHas,</span><span class="s3">\n  </span><span class="s1">prepareDestination,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/router/utils/prepare-destination'</span><span class="s3">\n</span><span class="s1">import type { TLSSocket } from 'tls'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_REWRITTEN_PATH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_REWRITTEN_QUERY_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { getSelectedParams } from '../../../client/components/router-reducer/compute-changed-path'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../../../lib/generate-interception-routes-rewrites'</span><span class="s3">\n</span><span class="s1">import { parseAndValidateFlightRouterState } from '../../app-render/parse-and-validate-flight-router-state'</span><span class="s3">\n\n</span><span class="s1">const debug = setupDebug('next:router-server:resolve-routes')</span><span class="s3">\n\n</span><span class="s1">export function getResolveRoutes(</span><span class="s3">\n  </span><span class="s1">fsChecker: UnwrapPromise&lt;</span><span class="s3">\n    </span><span class="s1">ReturnType&lt;typeof import('./filesystem').setupFsCheck&gt;</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">config: NextConfigComplete,</span><span class="s3">\n  </span><span class="s1">opts: Parameters&lt;typeof initialize&gt;[0],</span><span class="s3">\n  </span><span class="s1">renderServer: RenderServer,</span><span class="s3">\n  </span><span class="s1">renderServerOpts: Parameters&lt;RenderServer['initialize']&gt;[0],</span><span class="s3">\n  </span><span class="s1">ensureMiddleware?: (url?: string) =&gt; Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">type Route = {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The path matcher to check if this route applies to this request.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">match: PatchMatcher</span><span class="s3">\n    </span><span class="s1">check?: boolean</span><span class="s3">\n    </span><span class="s1">name?: string</span><span class="s3">\n  </span><span class="s1">} &amp; Partial&lt;Header&gt; &amp;</span><span class="s3">\n    </span><span class="s1">Partial&lt;Redirect&gt;</span><span class="s3">\n\n  </span><span class="s1">const routes: Route[] = [</span><span class="s3">\n    </span><span class="s1">// _next/data with middleware handling</span><span class="s3">\n    </span><span class="s1">{ match: () =&gt; ({}), name: 'middleware_next_data' },</span><span class="s3">\n\n    </span><span class="s1">...(opts.minimalMode ? [] : fsChecker.headers),</span><span class="s3">\n    </span><span class="s1">...(opts.minimalMode ? [] : fsChecker.redirects),</span><span class="s3">\n\n    </span><span class="s1">// check middleware (using matchers)</span><span class="s3">\n    </span><span class="s1">{ match: () =&gt; ({}), name: 'middleware' },</span><span class="s3">\n\n    </span><span class="s1">...(opts.minimalMode ? [] : fsChecker.rewrites.beforeFiles),</span><span class="s3">\n\n    </span><span class="s1">// check middleware (using matchers)</span><span class="s3">\n    </span><span class="s1">{ match: () =&gt; ({}), name: 'before_files_end' },</span><span class="s3">\n\n    </span><span class="s1">// we check exact matches on fs before continuing to</span><span class="s3">\n    </span><span class="s1">// after files rewrites</span><span class="s3">\n    </span><span class="s1">{ match: () =&gt; ({}), name: 'check_fs' },</span><span class="s3">\n\n    </span><span class="s1">...(opts.minimalMode ? [] : fsChecker.rewrites.afterFiles),</span><span class="s3">\n\n    </span><span class="s1">// we always do the check: true handling before continuing to</span><span class="s3">\n    </span><span class="s1">// fallback rewrites</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">check: true,</span><span class="s3">\n      </span><span class="s1">match: () =&gt; ({}),</span><span class="s3">\n      </span><span class="s1">name: 'after files check: true',</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">...(opts.minimalMode ? [] : fsChecker.rewrites.fallback),</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">async function resolveRoutes({</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">isUpgradeReq,</span><span class="s3">\n    </span><span class="s1">invokedOutputs,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage</span><span class="s3">\n    </span><span class="s1">res: ServerResponse</span><span class="s3">\n    </span><span class="s1">isUpgradeReq: boolean</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n    </span><span class="s1">invokedOutputs?: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">}): Promise&lt;{</span><span class="s3">\n    </span><span class="s1">finished: boolean</span><span class="s3">\n    </span><span class="s1">statusCode?: number</span><span class="s3">\n    </span><span class="s1">bodyStream?: ReadableStream | null</span><span class="s3">\n    </span><span class="s1">resHeaders: Record&lt;string, string | string[]&gt;</span><span class="s3">\n    </span><span class="s1">parsedUrl: NextUrlWithParsedQuery</span><span class="s3">\n    </span><span class="s1">matchedOutput?: FsOutput | null</span><span class="s3">\n  </span><span class="s1">}&gt; {</span><span class="s3">\n    </span><span class="s1">let finished = false</span><span class="s3">\n    </span><span class="s1">let resHeaders: Record&lt;string, string | string[]&gt; = {}</span><span class="s3">\n    </span><span class="s1">let matchedOutput: FsOutput | null = null</span><span class="s3">\n    </span><span class="s1">let parsedUrl = url.parse(req.url || '', true) as NextUrlWithParsedQuery</span><span class="s3">\n    </span><span class="s1">let didRewrite = false</span><span class="s3">\n\n    </span><span class="s1">const urlParts = (req.url || '').split('?', 1)</span><span class="s3">\n    </span><span class="s1">const urlNoQuery = urlParts[0]</span><span class="s3">\n\n    </span><span class="s1">// this normalizes repeated slashes in the path e.g. hello//world -&gt;</span><span class="s3">\n    </span><span class="s1">// hello/world or backslashes to forward slashes, this does not</span><span class="s3">\n    </span><span class="s1">// handle trailing slash as that is handled the same as a next.config.js</span><span class="s3">\n    </span><span class="s1">// redirect</span><span class="s3">\n    </span><span class="s1">if (urlNoQuery?.match(/(</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)/)) {</span><span class="s3">\n      </span><span class="s1">parsedUrl = url.parse(normalizeRepeatedSlashes(req.url!), true)</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">parsedUrl,</span><span class="s3">\n        </span><span class="s1">resHeaders,</span><span class="s3">\n        </span><span class="s1">finished: true,</span><span class="s3">\n        </span><span class="s1">statusCode: 308,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO: inherit this from higher up</span><span class="s3">\n    </span><span class="s1">const protocol =</span><span class="s3">\n      </span><span class="s1">(req?.socket as TLSSocket)?.encrypted ||</span><span class="s3">\n      </span><span class="s1">req.headers['x-forwarded-proto']?.includes('https')</span><span class="s3">\n        </span><span class="s1">? 'https'</span><span class="s3">\n        </span><span class="s1">: 'http'</span><span class="s3">\n\n    </span><span class="s1">// When there are hostname and port we build an absolute URL</span><span class="s3">\n    </span><span class="s1">const initUrl = (config.experimental as any).trustHostHeader</span><span class="s3">\n      </span><span class="s1">? `https://${req.headers.host || 'localhost'}${req.url}`</span><span class="s3">\n      </span><span class="s1">: opts.port</span><span class="s3">\n        </span><span class="s1">? `${protocol}://${formatHostname(opts.hostname || 'localhost')}:${</span><span class="s3">\n            </span><span class="s1">opts.port</span><span class="s3">\n          </span><span class="s1">}${req.url}`</span><span class="s3">\n        </span><span class="s1">: req.url || ''</span><span class="s3">\n\n    </span><span class="s1">addRequestMeta(req, 'initURL', initUrl)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req, 'initQuery', { ...parsedUrl.query })</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req, 'initProtocol', protocol)</span><span class="s3">\n\n    </span><span class="s1">if (!isUpgradeReq) {</span><span class="s3">\n      </span><span class="s1">addRequestMeta(req, 'clonableBody', getCloneableBody(req))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const maybeAddTrailingSlash = (pathname: string) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">config.trailingSlash &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!config.skipMiddlewareUrlNormalize &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!pathname.endsWith('/')</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return `${pathname}/`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return pathname</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let domainLocale: ReturnType&lt;typeof detectDomainLocale&gt; | undefined</span><span class="s3">\n    </span><span class="s1">let defaultLocale: string | undefined</span><span class="s3">\n    </span><span class="s1">let initialLocaleResult:</span><span class="s3">\n      </span><span class="s1">| ReturnType&lt;typeof normalizeLocalePath&gt;</span><span class="s3">\n      </span><span class="s1">| undefined = undefined</span><span class="s3">\n\n    </span><span class="s1">if (config.i18n) {</span><span class="s3">\n      </span><span class="s1">const hadTrailingSlash = parsedUrl.pathname?.endsWith('/')</span><span class="s3">\n      </span><span class="s1">const hadBasePath = pathHasPrefix(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '',</span><span class="s3">\n        </span><span class="s1">config.basePath</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">let normalizedPath = parsedUrl.pathname || '/'</span><span class="s3">\n\n      </span><span class="s1">if (config.basePath &amp;&amp; pathHasPrefix(normalizedPath, config.basePath)) {</span><span class="s3">\n        </span><span class="s1">normalizedPath = removePathPrefix(normalizedPath, config.basePath)</span><span class="s3">\n      </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">config.assetPrefix &amp;&amp;</span><span class="s3">\n        </span><span class="s1">pathHasPrefix(normalizedPath, config.assetPrefix)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">normalizedPath = removePathPrefix(normalizedPath, config.assetPrefix)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">initialLocaleResult = normalizeLocalePath(</span><span class="s3">\n        </span><span class="s1">normalizedPath,</span><span class="s3">\n        </span><span class="s1">config.i18n.locales</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">domainLocale = detectDomainLocale(</span><span class="s3">\n        </span><span class="s1">config.i18n.domains,</span><span class="s3">\n        </span><span class="s1">getHostname(parsedUrl, req.headers)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">defaultLocale = domainLocale?.defaultLocale || config.i18n.defaultLocale</span><span class="s3">\n\n      </span><span class="s1">addRequestMeta(req, 'defaultLocale', defaultLocale)</span><span class="s3">\n      </span><span class="s1">addRequestMeta(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">'locale',</span><span class="s3">\n        </span><span class="s1">initialLocaleResult.detectedLocale || defaultLocale</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// ensure locale is present for resolving routes</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!initialLocaleResult.detectedLocale &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!initialLocaleResult.pathname.startsWith('/_next/')</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname = addPathPrefix(</span><span class="s3">\n          </span><span class="s1">initialLocaleResult.pathname === '/'</span><span class="s3">\n            </span><span class="s1">? `/${defaultLocale}`</span><span class="s3">\n            </span><span class="s1">: addPathPrefix(</span><span class="s3">\n                </span><span class="s1">initialLocaleResult.pathname || '',</span><span class="s3">\n                </span><span class="s1">`/${defaultLocale}`</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">hadBasePath ? config.basePath : ''</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (hadTrailingSlash) {</span><span class="s3">\n          </span><span class="s1">parsedUrl.pathname = maybeAddTrailingSlash(parsedUrl.pathname)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const checkLocaleApi = (pathname: string) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">config.i18n &amp;&amp;</span><span class="s3">\n        </span><span class="s1">pathname === urlNoQuery &amp;&amp;</span><span class="s3">\n        </span><span class="s1">initialLocaleResult?.detectedLocale &amp;&amp;</span><span class="s3">\n        </span><span class="s1">pathHasPrefix(initialLocaleResult.pathname, '/api')</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">async function checkTrue() {</span><span class="s3">\n      </span><span class="s1">const pathname = parsedUrl.pathname || '/'</span><span class="s3">\n\n      </span><span class="s1">if (checkLocaleApi(pathname)) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!invokedOutputs?.has(pathname)) {</span><span class="s3">\n        </span><span class="s1">const output = await fsChecker.getItem(pathname)</span><span class="s3">\n\n        </span><span class="s1">if (output) {</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">config.useFileSystemPublicRoutes ||</span><span class="s3">\n            </span><span class="s1">didRewrite ||</span><span class="s3">\n            </span><span class="s1">(output.type !== 'appFile' &amp;&amp; output.type !== 'pageFile')</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return output</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const dynamicRoutes = fsChecker.getDynamicRoutes()</span><span class="s3">\n      </span><span class="s1">let curPathname = parsedUrl.pathname</span><span class="s3">\n\n      </span><span class="s1">if (config.basePath) {</span><span class="s3">\n        </span><span class="s1">if (!pathHasPrefix(curPathname || '', config.basePath)) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">curPathname = curPathname?.substring(config.basePath.length) || '/'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const localeResult = fsChecker.handleLocale(curPathname || '')</span><span class="s3">\n\n      </span><span class="s1">for (const route of dynamicRoutes) {</span><span class="s3">\n        </span><span class="s1">// when resolving fallback: false the</span><span class="s3">\n        </span><span class="s1">// render worker may return a no-fallback response</span><span class="s3">\n        </span><span class="s1">// which signals we need to continue resolving.</span><span class="s3">\n        </span><span class="s1">// TODO: optimize this to collect static paths</span><span class="s3">\n        </span><span class="s1">// to use at the routing layer</span><span class="s3">\n        </span><span class="s1">if (invokedOutputs?.has(route.page)) {</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const params = route.match(localeResult.pathname)</span><span class="s3">\n\n        </span><span class="s1">if (params) {</span><span class="s3">\n          </span><span class="s1">const pageOutput = await fsChecker.getItem(</span><span class="s3">\n            </span><span class="s1">addPathPrefix(route.page, config.basePath || '')</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// i18n locales aren't matched for app dir</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">pageOutput?.type === 'appFile' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">initialLocaleResult?.detectedLocale</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">continue</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (pageOutput &amp;&amp; curPathname?.startsWith('/_next/data')) {</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'isNextDataReq', true)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (config.useFileSystemPublicRoutes || didRewrite) {</span><span class="s3">\n            </span><span class="s1">return pageOutput</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const normalizers = {</span><span class="s3">\n      </span><span class="s1">basePath:</span><span class="s3">\n        </span><span class="s1">config.basePath &amp;&amp; config.basePath !== '/'</span><span class="s3">\n          </span><span class="s1">? new BasePathPathnameNormalizer(config.basePath)</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">data: new NextDataPathnameNormalizer(fsChecker.buildId),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">async function handleRoute(</span><span class="s3">\n      </span><span class="s1">route: Route</span><span class="s3">\n    </span><span class="s1">): Promise&lt;UnwrapPromise&lt;ReturnType&lt;typeof resolveRoutes&gt;&gt; | void&gt; {</span><span class="s3">\n      </span><span class="s1">let curPathname = parsedUrl.pathname || '/'</span><span class="s3">\n\n      </span><span class="s1">if (config.i18n &amp;&amp; route.internal) {</span><span class="s3">\n        </span><span class="s1">const hadTrailingSlash = curPathname.endsWith('/')</span><span class="s3">\n\n        </span><span class="s1">if (config.basePath) {</span><span class="s3">\n          </span><span class="s1">curPathname = removePathPrefix(curPathname, config.basePath)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const hadBasePath = curPathname !== parsedUrl.pathname</span><span class="s3">\n\n        </span><span class="s1">const localeResult = normalizeLocalePath(</span><span class="s3">\n          </span><span class="s1">curPathname,</span><span class="s3">\n          </span><span class="s1">config.i18n.locales</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">const isDefaultLocale = localeResult.detectedLocale === defaultLocale</span><span class="s3">\n\n        </span><span class="s1">if (isDefaultLocale) {</span><span class="s3">\n          </span><span class="s1">curPathname =</span><span class="s3">\n            </span><span class="s1">localeResult.pathname === '/' &amp;&amp; hadBasePath</span><span class="s3">\n              </span><span class="s1">? config.basePath</span><span class="s3">\n              </span><span class="s1">: addPathPrefix(</span><span class="s3">\n                  </span><span class="s1">localeResult.pathname,</span><span class="s3">\n                  </span><span class="s1">hadBasePath ? config.basePath : ''</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else if (hadBasePath) {</span><span class="s3">\n          </span><span class="s1">curPathname =</span><span class="s3">\n            </span><span class="s1">curPathname === '/'</span><span class="s3">\n              </span><span class="s1">? config.basePath</span><span class="s3">\n              </span><span class="s1">: addPathPrefix(curPathname, config.basePath)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if ((isDefaultLocale || hadBasePath) &amp;&amp; hadTrailingSlash) {</span><span class="s3">\n          </span><span class="s1">curPathname = maybeAddTrailingSlash(curPathname)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">let params = route.match(curPathname)</span><span class="s3">\n\n      </span><span class="s1">if ((route.has || route.missing) &amp;&amp; params) {</span><span class="s3">\n        </span><span class="s1">const hasParams = matchHas(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">parsedUrl.query,</span><span class="s3">\n          </span><span class="s1">route.has,</span><span class="s3">\n          </span><span class="s1">route.missing</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (hasParams) {</span><span class="s3">\n          </span><span class="s1">Object.assign(params, hasParams)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (params) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">fsChecker.exportPathMapRoutes &amp;&amp;</span><span class="s3">\n          </span><span class="s1">route.name === 'before_files_end'</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">for (const exportPathMapRoute of fsChecker.exportPathMapRoutes) {</span><span class="s3">\n            </span><span class="s1">const result = await handleRoute(exportPathMapRoute)</span><span class="s3">\n\n            </span><span class="s1">if (result) {</span><span class="s3">\n              </span><span class="s1">return result</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (route.name === 'middleware_next_data' &amp;&amp; parsedUrl.pathname) {</span><span class="s3">\n          </span><span class="s1">if (fsChecker.getMiddlewareMatchers()?.length) {</span><span class="s3">\n            </span><span class="s1">let normalized = parsedUrl.pathname</span><span class="s3">\n\n            </span><span class="s1">// Remove the base path if it exists.</span><span class="s3">\n            </span><span class="s1">const hadBasePath = normalizers.basePath?.match(parsedUrl.pathname)</span><span class="s3">\n            </span><span class="s1">if (hadBasePath &amp;&amp; normalizers.basePath) {</span><span class="s3">\n              </span><span class="s1">normalized = normalizers.basePath.normalize(normalized, true)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">let updated = false</span><span class="s3">\n            </span><span class="s1">if (normalizers.data.match(normalized)) {</span><span class="s3">\n              </span><span class="s1">updated = true</span><span class="s3">\n              </span><span class="s1">addRequestMeta(req, 'isNextDataReq', true)</span><span class="s3">\n              </span><span class="s1">normalized = normalizers.data.normalize(normalized, true)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (config.i18n) {</span><span class="s3">\n              </span><span class="s1">const curLocaleResult = normalizeLocalePath(</span><span class="s3">\n                </span><span class="s1">normalized,</span><span class="s3">\n                </span><span class="s1">config.i18n.locales</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">if (curLocaleResult.detectedLocale) {</span><span class="s3">\n                </span><span class="s1">addRequestMeta(req, 'locale', curLocaleResult.detectedLocale)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// If we updated the pathname, and it had a base path, re-add the</span><span class="s3">\n            </span><span class="s1">// base path.</span><span class="s3">\n            </span><span class="s1">if (updated) {</span><span class="s3">\n              </span><span class="s1">if (hadBasePath) {</span><span class="s3">\n                </span><span class="s1">normalized =</span><span class="s3">\n                  </span><span class="s1">normalized === '/'</span><span class="s3">\n                    </span><span class="s1">? config.basePath</span><span class="s3">\n                    </span><span class="s1">: path.posix.join(config.basePath, normalized)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">// Re-add the trailing slash (if required).</span><span class="s3">\n              </span><span class="s1">normalized = maybeAddTrailingSlash(normalized)</span><span class="s3">\n\n              </span><span class="s1">parsedUrl.pathname = normalized</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (route.name === 'check_fs') {</span><span class="s3">\n          </span><span class="s1">const pathname = parsedUrl.pathname || '/'</span><span class="s3">\n\n          </span><span class="s1">if (invokedOutputs?.has(pathname) || checkLocaleApi(pathname)) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">const output = await fsChecker.getItem(pathname)</span><span class="s3">\n\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">output &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!(</span><span class="s3">\n              </span><span class="s1">config.i18n &amp;&amp;</span><span class="s3">\n              </span><span class="s1">initialLocaleResult?.detectedLocale &amp;&amp;</span><span class="s3">\n              </span><span class="s1">pathHasPrefix(pathname, '/api')</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">config.useFileSystemPublicRoutes ||</span><span class="s3">\n              </span><span class="s1">didRewrite ||</span><span class="s3">\n              </span><span class="s1">(output.type !== 'appFile' &amp;&amp; output.type !== 'pageFile')</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">matchedOutput = output</span><span class="s3">\n\n              </span><span class="s1">if (output.locale) {</span><span class="s3">\n                </span><span class="s1">addRequestMeta(req, 'locale', output.locale)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">parsedUrl,</span><span class="s3">\n                </span><span class="s1">resHeaders,</span><span class="s3">\n                </span><span class="s1">finished: true,</span><span class="s3">\n                </span><span class="s1">matchedOutput,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (!opts.minimalMode &amp;&amp; route.name === 'middleware') {</span><span class="s3">\n          </span><span class="s1">const match = fsChecker.getMiddlewareMatchers()</span><span class="s3">\n          </span><span class="s1">let maybeDecodedPathname = parsedUrl.pathname || '/'</span><span class="s3">\n\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">maybeDecodedPathname = decodeURIComponent(maybeDecodedPathname)</span><span class="s3">\n          </span><span class="s1">} catch {</span><span class="s3">\n            </span><span class="s1">/* non-fatal we can't decode so can't match it */</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error BaseNextRequest stuff</span><span class="s3">\n            </span><span class="s1">match?.(parsedUrl.pathname, req, parsedUrl.query) ||</span><span class="s3">\n            </span><span class="s1">match?.(</span><span class="s3">\n              </span><span class="s1">maybeDecodedPathname,</span><span class="s3">\n              </span><span class="s1">// @ts-expect-error BaseNextRequest stuff</span><span class="s3">\n              </span><span class="s1">req,</span><span class="s3">\n              </span><span class="s1">parsedUrl.query</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (ensureMiddleware) {</span><span class="s3">\n              </span><span class="s1">await ensureMiddleware(req.url)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const serverResult =</span><span class="s3">\n              </span><span class="s1">await renderServer?.initialize(renderServerOpts)</span><span class="s3">\n\n            </span><span class="s1">if (!serverResult) {</span><span class="s3">\n              </span><span class="s1">throw new Error(`Failed to initialize render server </span><span class="s3">\&quot;</span><span class="s1">middleware</span><span class="s3">\&quot;</span><span class="s1">`)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">addRequestMeta(req, 'invokePath', '')</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'invokeOutput', '')</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'invokeQuery', {})</span><span class="s3">\n            </span><span class="s1">addRequestMeta(req, 'middlewareInvoke', true)</span><span class="s3">\n            </span><span class="s1">debug('invoking middleware', req.url, req.headers)</span><span class="s3">\n\n            </span><span class="s1">let middlewareRes: Response | undefined = undefined</span><span class="s3">\n            </span><span class="s1">let bodyStream: ReadableStream | undefined = undefined</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">await serverResult.requestHandler(req, res, parsedUrl)</span><span class="s3">\n              </span><span class="s1">} catch (err: any) {</span><span class="s3">\n                </span><span class="s1">if (!('result' in err) || !('response' in err.result)) {</span><span class="s3">\n                  </span><span class="s1">throw err</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">middlewareRes = err.result.response as Response</span><span class="s3">\n                </span><span class="s1">res.statusCode = middlewareRes.status</span><span class="s3">\n\n                </span><span class="s1">if (middlewareRes.body) {</span><span class="s3">\n                  </span><span class="s1">bodyStream = middlewareRes.body</span><span class="s3">\n                </span><span class="s1">} else if (middlewareRes.status) {</span><span class="s3">\n                  </span><span class="s1">bodyStream = new ReadableStream({</span><span class="s3">\n                    </span><span class="s1">start(controller) {</span><span class="s3">\n                      </span><span class="s1">controller.enqueue('')</span><span class="s3">\n                      </span><span class="s1">controller.close()</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                  </span><span class="s1">})</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} catch (e) {</span><span class="s3">\n              </span><span class="s1">// If the client aborts before we can receive a response object</span><span class="s3">\n              </span><span class="s1">// (when the headers are flushed), then we can early exit without</span><span class="s3">\n              </span><span class="s1">// further processing.</span><span class="s3">\n              </span><span class="s1">if (isAbortError(e)) {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                  </span><span class="s1">parsedUrl,</span><span class="s3">\n                  </span><span class="s1">resHeaders,</span><span class="s3">\n                  </span><span class="s1">finished: true,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">throw e</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (res.closed || res.finished || !middlewareRes) {</span><span class="s3">\n              </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">parsedUrl,</span><span class="s3">\n                </span><span class="s1">resHeaders,</span><span class="s3">\n                </span><span class="s1">finished: true,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const middlewareHeaders = toNodeOutgoingHttpHeaders(</span><span class="s3">\n              </span><span class="s1">middlewareRes.headers</span><span class="s3">\n            </span><span class="s1">) as Record&lt;string, string | string[] | undefined&gt;</span><span class="s3">\n\n            </span><span class="s1">debug('middleware res', middlewareRes.status, middlewareHeaders)</span><span class="s3">\n\n            </span><span class="s1">if (middlewareHeaders['x-middleware-override-headers']) {</span><span class="s3">\n              </span><span class="s1">const overriddenHeaders: Set&lt;string&gt; = new Set()</span><span class="s3">\n              </span><span class="s1">let overrideHeaders: string | string[] =</span><span class="s3">\n                </span><span class="s1">middlewareHeaders['x-middleware-override-headers']</span><span class="s3">\n\n              </span><span class="s1">if (typeof overrideHeaders === 'string') {</span><span class="s3">\n                </span><span class="s1">overrideHeaders = overrideHeaders.split(',')</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">for (const key of overrideHeaders) {</span><span class="s3">\n                </span><span class="s1">overriddenHeaders.add(key.trim())</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">delete middlewareHeaders['x-middleware-override-headers']</span><span class="s3">\n\n              </span><span class="s1">// Delete headers.</span><span class="s3">\n              </span><span class="s1">for (const key of Object.keys(req.headers)) {</span><span class="s3">\n                </span><span class="s1">if (!overriddenHeaders.has(key)) {</span><span class="s3">\n                  </span><span class="s1">delete req.headers[key]</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">// Update or add headers.</span><span class="s3">\n              </span><span class="s1">for (const key of overriddenHeaders.keys()) {</span><span class="s3">\n                </span><span class="s1">const valueKey = 'x-middleware-request-' + key</span><span class="s3">\n                </span><span class="s1">const newValue = middlewareHeaders[valueKey]</span><span class="s3">\n                </span><span class="s1">const oldValue = req.headers[key]</span><span class="s3">\n\n                </span><span class="s1">if (oldValue !== newValue) {</span><span class="s3">\n                  </span><span class="s1">req.headers[key] = newValue === null ? undefined : newValue</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">delete middlewareHeaders[valueKey]</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">!middlewareHeaders['x-middleware-rewrite'] &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!middlewareHeaders['x-middleware-next'] &amp;&amp;</span><span class="s3">\n              </span><span class="s1">!middlewareHeaders['location']</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">middlewareHeaders['x-middleware-refresh'] = '1'</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">delete middlewareHeaders['x-middleware-next']</span><span class="s3">\n\n            </span><span class="s1">for (const [key, value] of Object.entries({</span><span class="s3">\n              </span><span class="s1">...filterReqHeaders(middlewareHeaders, ipcForbiddenHeaders),</span><span class="s3">\n            </span><span class="s1">})) {</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">[</span><span class="s3">\n                  </span><span class="s1">'content-length',</span><span class="s3">\n                  </span><span class="s1">'x-middleware-rewrite',</span><span class="s3">\n                  </span><span class="s1">'x-middleware-redirect',</span><span class="s3">\n                  </span><span class="s1">'x-middleware-refresh',</span><span class="s3">\n                </span><span class="s1">].includes(key)</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">continue</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">// for set-cookie, the header shouldn't be added to the response</span><span class="s3">\n              </span><span class="s1">// as it's only needed for the request to the middleware function.</span><span class="s3">\n              </span><span class="s1">if (key === 'x-middleware-set-cookie') {</span><span class="s3">\n                </span><span class="s1">req.headers[key] = value</span><span class="s3">\n                </span><span class="s1">continue</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (value) {</span><span class="s3">\n                </span><span class="s1">resHeaders[key] = value</span><span class="s3">\n                </span><span class="s1">req.headers[key] = value</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (middlewareHeaders['x-middleware-rewrite']) {</span><span class="s3">\n              </span><span class="s1">const value = middlewareHeaders['x-middleware-rewrite'] as string</span><span class="s3">\n              </span><span class="s1">const destination = getRelativeURL(value, initUrl)</span><span class="s3">\n              </span><span class="s1">resHeaders['x-middleware-rewrite'] = destination</span><span class="s3">\n\n              </span><span class="s1">parsedUrl = url.parse(destination, true)</span><span class="s3">\n\n              </span><span class="s1">if (parsedUrl.protocol) {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                  </span><span class="s1">parsedUrl,</span><span class="s3">\n                  </span><span class="s1">resHeaders,</span><span class="s3">\n                  </span><span class="s1">finished: true,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (config.i18n) {</span><span class="s3">\n                </span><span class="s1">const curLocaleResult = normalizeLocalePath(</span><span class="s3">\n                  </span><span class="s1">parsedUrl.pathname || '',</span><span class="s3">\n                  </span><span class="s1">config.i18n.locales</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">if (curLocaleResult.detectedLocale) {</span><span class="s3">\n                  </span><span class="s1">addRequestMeta(req, 'locale', curLocaleResult.detectedLocale)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (middlewareHeaders['location']) {</span><span class="s3">\n              </span><span class="s1">const value = middlewareHeaders['location'] as string</span><span class="s3">\n\n              </span><span class="s1">// Only process Location header as a redirect if it has a proper redirect status</span><span class="s3">\n              </span><span class="s1">// This prevents a Location header with non-redirect status from being treated as a redirect</span><span class="s3">\n              </span><span class="s1">const isRedirectStatus = allowedStatusCodes.has(</span><span class="s3">\n                </span><span class="s1">middlewareRes.status</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">if (isRedirectStatus) {</span><span class="s3">\n                </span><span class="s1">// Process as redirect: update parsedUrl and convert to relative URL</span><span class="s3">\n                </span><span class="s1">const rel = getRelativeURL(value, initUrl)</span><span class="s3">\n                </span><span class="s1">resHeaders['location'] = rel</span><span class="s3">\n                </span><span class="s1">parsedUrl = url.parse(rel, true)</span><span class="s3">\n\n                </span><span class="s1">return {</span><span class="s3">\n                  </span><span class="s1">parsedUrl,</span><span class="s3">\n                  </span><span class="s1">resHeaders,</span><span class="s3">\n                  </span><span class="s1">finished: true,</span><span class="s3">\n                  </span><span class="s1">statusCode: middlewareRes.status,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">// Not a redirect: just pass through the Location header</span><span class="s3">\n                </span><span class="s1">resHeaders['location'] = value</span><span class="s3">\n\n                </span><span class="s1">return {</span><span class="s3">\n                  </span><span class="s1">parsedUrl,</span><span class="s3">\n                  </span><span class="s1">resHeaders,</span><span class="s3">\n                  </span><span class="s1">finished: true,</span><span class="s3">\n                  </span><span class="s1">bodyStream,</span><span class="s3">\n                  </span><span class="s1">statusCode: middlewareRes.status,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (middlewareHeaders['x-middleware-refresh']) {</span><span class="s3">\n              </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">parsedUrl,</span><span class="s3">\n                </span><span class="s1">resHeaders,</span><span class="s3">\n                </span><span class="s1">finished: true,</span><span class="s3">\n                </span><span class="s1">bodyStream,</span><span class="s3">\n                </span><span class="s1">statusCode: middlewareRes.status,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// handle redirect</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">('statusCode' in route || 'permanent' in route) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">route.destination</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const { parsedDestination } = prepareDestination({</span><span class="s3">\n            </span><span class="s1">appendParamsToQuery: false,</span><span class="s3">\n            </span><span class="s1">destination: route.destination,</span><span class="s3">\n            </span><span class="s1">params: params,</span><span class="s3">\n            </span><span class="s1">query: parsedUrl.query,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">const { query } = parsedDestination</span><span class="s3">\n          </span><span class="s1">delete (parsedDestination as any).query</span><span class="s3">\n\n          </span><span class="s1">parsedDestination.search = stringifyQuery(req as any, query)</span><span class="s3">\n\n          </span><span class="s1">parsedDestination.pathname = normalizeRepeatedSlashes(</span><span class="s3">\n            </span><span class="s1">parsedDestination.pathname</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">finished: true,</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error custom ParsedUrl</span><span class="s3">\n            </span><span class="s1">parsedUrl: parsedDestination,</span><span class="s3">\n            </span><span class="s1">statusCode: getRedirectStatus(route),</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// handle headers</span><span class="s3">\n        </span><span class="s1">if (route.headers) {</span><span class="s3">\n          </span><span class="s1">const hasParams = Object.keys(params).length &gt; 0</span><span class="s3">\n          </span><span class="s1">for (const header of route.headers) {</span><span class="s3">\n            </span><span class="s1">let { key, value } = header</span><span class="s3">\n            </span><span class="s1">if (hasParams) {</span><span class="s3">\n              </span><span class="s1">key = compileNonPath(key, params)</span><span class="s3">\n              </span><span class="s1">value = compileNonPath(value, params)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (key.toLowerCase() === 'set-cookie') {</span><span class="s3">\n              </span><span class="s1">if (!Array.isArray(resHeaders[key])) {</span><span class="s3">\n                </span><span class="s1">const val = resHeaders[key]</span><span class="s3">\n                </span><span class="s1">resHeaders[key] = typeof val === 'string' ? [val] : []</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">;(resHeaders[key] as string[]).push(value)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">resHeaders[key] = value</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// handle rewrite</span><span class="s3">\n        </span><span class="s1">if (route.destination) {</span><span class="s3">\n          </span><span class="s1">let rewriteParams = params</span><span class="s3">\n\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// An interception rewrite might reference a dynamic param for a route the user</span><span class="s3">\n            </span><span class="s1">// is currently on, which wouldn't be extractable from the matched route params.</span><span class="s3">\n            </span><span class="s1">// This attempts to extract the dynamic params from the provided router state.</span><span class="s3">\n            </span><span class="s1">if (isInterceptionRouteRewrite(route as Rewrite)) {</span><span class="s3">\n              </span><span class="s1">const stateHeader = req.headers[NEXT_ROUTER_STATE_TREE_HEADER]</span><span class="s3">\n\n              </span><span class="s1">if (stateHeader) {</span><span class="s3">\n                </span><span class="s1">rewriteParams = {</span><span class="s3">\n                  </span><span class="s1">...getSelectedParams(</span><span class="s3">\n                    </span><span class="s1">parseAndValidateFlightRouterState(stateHeader)</span><span class="s3">\n                  </span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">...params,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">// this is a no-op -- we couldn't extract dynamic params from the provided router state,</span><span class="s3">\n            </span><span class="s1">// so we'll just use the params from the route matcher</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const { parsedDestination } = prepareDestination({</span><span class="s3">\n            </span><span class="s1">appendParamsToQuery: true,</span><span class="s3">\n            </span><span class="s1">destination: route.destination,</span><span class="s3">\n            </span><span class="s1">params: rewriteParams,</span><span class="s3">\n            </span><span class="s1">query: parsedUrl.query,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">if (parsedDestination.protocol) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n              </span><span class="s1">// @ts-expect-error custom ParsedUrl</span><span class="s3">\n              </span><span class="s1">parsedUrl: parsedDestination,</span><span class="s3">\n              </span><span class="s1">finished: true,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Set the rewrite headers only if this is a RSC request.</span><span class="s3">\n          </span><span class="s1">if (req.headers[RSC_HEADER] === '1') {</span><span class="s3">\n            </span><span class="s1">// We set the rewritten path and query headers on the response now</span><span class="s3">\n            </span><span class="s1">// that we know that the it's not an external rewrite.</span><span class="s3">\n            </span><span class="s1">if (parsedUrl.pathname !== parsedDestination.pathname) {</span><span class="s3">\n              </span><span class="s1">res.setHeader(</span><span class="s3">\n                </span><span class="s1">NEXT_REWRITTEN_PATH_HEADER,</span><span class="s3">\n                </span><span class="s1">parsedDestination.pathname</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (parsedUrl.search !== parsedDestination.search) {</span><span class="s3">\n              </span><span class="s1">res.setHeader(</span><span class="s3">\n                </span><span class="s1">NEXT_REWRITTEN_QUERY_HEADER,</span><span class="s3">\n                </span><span class="s1">// remove the leading ? from the search</span><span class="s3">\n                </span><span class="s1">parsedDestination.search.slice(1)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (config.i18n) {</span><span class="s3">\n            </span><span class="s1">const curLocaleResult = normalizeLocalePath(</span><span class="s3">\n              </span><span class="s1">removePathPrefix(parsedDestination.pathname, config.basePath),</span><span class="s3">\n              </span><span class="s1">config.i18n.locales</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">if (curLocaleResult.detectedLocale) {</span><span class="s3">\n              </span><span class="s1">addRequestMeta(req, 'locale', curLocaleResult.detectedLocale)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">didRewrite = true</span><span class="s3">\n          </span><span class="s1">parsedUrl.pathname = parsedDestination.pathname</span><span class="s3">\n          </span><span class="s1">Object.assign(parsedUrl.query, parsedDestination.query)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// handle check: true</span><span class="s3">\n        </span><span class="s1">if (route.check) {</span><span class="s3">\n          </span><span class="s1">const output = await checkTrue()</span><span class="s3">\n\n          </span><span class="s1">if (output) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n              </span><span class="s1">parsedUrl,</span><span class="s3">\n              </span><span class="s1">resHeaders,</span><span class="s3">\n              </span><span class="s1">finished: true,</span><span class="s3">\n              </span><span class="s1">matchedOutput: output,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const route of routes) {</span><span class="s3">\n      </span><span class="s1">const result = await handleRoute(route)</span><span class="s3">\n      </span><span class="s1">if (result) {</span><span class="s3">\n        </span><span class="s1">return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">finished,</span><span class="s3">\n      </span><span class="s1">parsedUrl,</span><span class="s3">\n      </span><span class="s1">resHeaders,</span><span class="s3">\n      </span><span class="s1">matchedOutput,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return resolveRoutes</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getResolveRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;setupDebug&quot;</span><span class="s0">,</span><span class="s1">&quot;fsChecker&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;renderServer&quot;</span><span class="s0">,</span><span class="s1">&quot;renderServerOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalMode&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;redirects&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;check&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpgradeReq&quot;</span><span class="s0">,</span><span class="s1">&quot;invokedOutputs&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;resHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;didRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;urlParts&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;urlNoQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRepeatedSlashes&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;socket&quot;</span><span class="s0">,</span><span class="s1">&quot;encrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;initUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;trustHostHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;formatHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;addRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;getCloneableBody&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeAddTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;skipMiddlewareUrlNormalize&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;initialLocaleResult&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;hadTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;hadBasePath&quot;</span><span class="s0">,</span><span class="s1">&quot;pathHasPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;removePathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeLocalePath&quot;</span><span class="s0">,</span><span class="s1">&quot;locales&quot;</span><span class="s0">,</span><span class="s1">&quot;detectDomainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domains&quot;</span><span class="s0">,</span><span class="s1">&quot;getHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;checkLocaleApi&quot;</span><span class="s0">,</span><span class="s1">&quot;checkTrue&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;output&quot;</span><span class="s0">,</span><span class="s1">&quot;getItem&quot;</span><span class="s0">,</span><span class="s1">&quot;useFileSystemPublicRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;curPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;localeResult&quot;</span><span class="s0">,</span><span class="s1">&quot;handleLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;pageOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizers&quot;</span><span class="s0">,</span><span class="s1">&quot;BasePathPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;NextDataPathnameNormalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;internal&quot;</span><span class="s0">,</span><span class="s1">&quot;isDefaultLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;missing&quot;</span><span class="s0">,</span><span class="s1">&quot;hasParams&quot;</span><span class="s0">,</span><span class="s1">&quot;matchHas&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;exportPathMapRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;exportPathMapRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;getMiddlewareMatchers&quot;</span><span class="s0">,</span><span class="s1">&quot;normalized&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;updated&quot;</span><span class="s0">,</span><span class="s1">&quot;curLocaleResult&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;posix&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;locale&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeDecodedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;serverResult&quot;</span><span class="s0">,</span><span class="s1">&quot;initialize&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareRes&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyStream&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbortError&quot;</span><span class="s0">,</span><span class="s1">&quot;closed&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;toNodeOutgoingHttpHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;overriddenHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;overrideHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;valueKey&quot;</span><span class="s0">,</span><span class="s1">&quot;newValue&quot;</span><span class="s0">,</span><span class="s1">&quot;oldValue&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;filterReqHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;ipcForbiddenHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;getRelativeURL&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedStatusCodes&quot;</span><span class="s0">,</span><span class="s1">&quot;rel&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;appendParamsToQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;header&quot;</span><span class="s0">,</span><span class="s1">&quot;compileNonPath&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;stateHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndValidateFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REWRITTEN_PATH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REWRITTEN_QUERY_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>