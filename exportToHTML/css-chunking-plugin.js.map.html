<html>
<head>
<title>css-chunking-plugin.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
css-chunking-plugin.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/build/webpack/plugins/css-chunking-plugin.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { Chunk, Compiler, Module } from 'webpack'</span><span class="s3">\n\n</span><span class="s1">const PLUGIN_NAME = 'CssChunkingPlugin'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Merge chunks until they are bigger than the target size.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MIN_CSS_CHUNK_SIZE = 30 * 1024</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Avoid merging chunks when they would be bigger than this size.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MAX_CSS_CHUNK_SIZE = 100 * 1024</span><span class="s3">\n\n</span><span class="s1">function isGlobalCss(module: Module) {</span><span class="s3">\n  </span><span class="s1">return !/</span><span class="s3">\\</span><span class="s1">.module</span><span class="s3">\\</span><span class="s1">.(css|scss|sass)$/.test(module.nameForCondition() || '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ChunkState = {</span><span class="s3">\n  </span><span class="s1">chunk: Chunk</span><span class="s3">\n  </span><span class="s1">modules: Module[]</span><span class="s3">\n  </span><span class="s1">order: number</span><span class="s3">\n  </span><span class="s1">requests: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class CssChunkingPlugin {</span><span class="s3">\n  </span><span class="s1">private strict: boolean</span><span class="s3">\n  </span><span class="s1">constructor(strict: boolean) {</span><span class="s3">\n    </span><span class="s1">this.strict = strict</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public apply(compiler: Compiler) {</span><span class="s3">\n    </span><span class="s1">const strict = this.strict</span><span class="s3">\n    </span><span class="s1">const summary = !!process.env.CSS_CHUNKING_SUMMARY</span><span class="s3">\n    </span><span class="s1">compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) =&gt; {</span><span class="s3">\n      </span><span class="s1">let once = false</span><span class="s3">\n      </span><span class="s1">compilation.hooks.optimizeChunks.tap(</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">name: PLUGIN_NAME,</span><span class="s3">\n          </span><span class="s1">stage: 5,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">if (once) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">once = true</span><span class="s3">\n          </span><span class="s1">const chunkGraph = compilation.chunkGraph</span><span class="s3">\n          </span><span class="s1">let changed: undefined | true = undefined</span><span class="s3">\n\n          </span><span class="s1">const chunkStates = new Map&lt;Chunk, ChunkState&gt;()</span><span class="s3">\n          </span><span class="s1">const chunkStatesByModule = new Map&lt;Module, Map&lt;ChunkState, number&gt;&gt;()</span><span class="s3">\n\n          </span><span class="s1">// Collect all css modules in chunks and the execpted order of them</span><span class="s3">\n          </span><span class="s1">for (const chunk of compilation.chunks) {</span><span class="s3">\n            </span><span class="s1">if (chunk.name?.startsWith('pages/')) continue</span><span class="s3">\n            </span><span class="s1">const modules = []</span><span class="s3">\n            </span><span class="s1">for (const module of chunkGraph.getChunkModulesIterable(chunk)) {</span><span class="s3">\n              </span><span class="s1">if (!module.type?.startsWith('css')) continue</span><span class="s3">\n              </span><span class="s1">modules.push(module)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!modules.length) continue</span><span class="s3">\n            </span><span class="s1">const chunkState = {</span><span class="s3">\n              </span><span class="s1">chunk,</span><span class="s3">\n              </span><span class="s1">modules,</span><span class="s3">\n              </span><span class="s1">order: 0,</span><span class="s3">\n              </span><span class="s1">requests: modules.length,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">chunkStates.set(chunk, chunkState)</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; modules.length; i++) {</span><span class="s3">\n              </span><span class="s1">const module = modules[i]</span><span class="s3">\n              </span><span class="s1">let moduleChunkStates = chunkStatesByModule.get(module)</span><span class="s3">\n              </span><span class="s1">if (!moduleChunkStates) {</span><span class="s3">\n                </span><span class="s1">moduleChunkStates = new Map()</span><span class="s3">\n                </span><span class="s1">chunkStatesByModule.set(module, moduleChunkStates)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">moduleChunkStates.set(chunkState, i)</span><span class="s3">\n              </span><span class="s1">chunkStatesByModule.set(module, moduleChunkStates)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Sort modules by their index sum</span><span class="s3">\n          </span><span class="s1">const orderedModules: { module: Module; sum: number }[] = []</span><span class="s3">\n\n          </span><span class="s1">for (const [module, moduleChunkStates] of chunkStatesByModule) {</span><span class="s3">\n            </span><span class="s1">let sum = 0</span><span class="s3">\n            </span><span class="s1">for (const i of moduleChunkStates.values()) {</span><span class="s3">\n              </span><span class="s1">sum += i</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">orderedModules.push({ module, sum })</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">orderedModules.sort((a, b) =&gt; a.sum - b.sum)</span><span class="s3">\n\n          </span><span class="s1">// A queue of modules that still need to be processed</span><span class="s3">\n          </span><span class="s1">const remainingModules = new Set(</span><span class="s3">\n            </span><span class="s1">orderedModules.map(({ module }) =&gt; module)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// In loose mode we guess the dependents of modules from the order</span><span class="s3">\n          </span><span class="s1">// assuming that when a module is a dependency of another module</span><span class="s3">\n          </span><span class="s1">// it will always appear before it in every chunk.</span><span class="s3">\n          </span><span class="s1">const allDependents = new Map&lt;Module, Set&lt;Module&gt;&gt;()</span><span class="s3">\n\n          </span><span class="s1">if (!this.strict) {</span><span class="s3">\n            </span><span class="s1">for (const b of remainingModules) {</span><span class="s3">\n              </span><span class="s1">const dependent = new Set&lt;Module&gt;()</span><span class="s3">\n              </span><span class="s1">loop: for (const a of remainingModules) {</span><span class="s3">\n                </span><span class="s1">if (a === b) continue</span><span class="s3">\n                </span><span class="s1">// check if a depends on b</span><span class="s3">\n                </span><span class="s1">for (const [chunkState, ia] of chunkStatesByModule.get(a)!) {</span><span class="s3">\n                  </span><span class="s1">const bChunkStates = chunkStatesByModule.get(b)!</span><span class="s3">\n                  </span><span class="s1">const ib = bChunkStates.get(chunkState)</span><span class="s3">\n                  </span><span class="s1">if (ib === undefined) {</span><span class="s3">\n                    </span><span class="s1">// If a would depend on b, it would be included in that chunk group too</span><span class="s3">\n                    </span><span class="s1">continue loop</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">if (ib &gt; ia) {</span><span class="s3">\n                    </span><span class="s1">// If a would depend on b, b would be before a in order</span><span class="s3">\n                    </span><span class="s1">continue loop</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">dependent.add(a)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (dependent.size &gt; 0) allDependents.set(b, dependent)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Stores the new chunk for every module</span><span class="s3">\n          </span><span class="s1">const newChunksByModule = new Map&lt;Module, Chunk&gt;()</span><span class="s3">\n\n          </span><span class="s1">// Process through all modules</span><span class="s3">\n          </span><span class="s1">for (const startModule of remainingModules) {</span><span class="s3">\n            </span><span class="s1">let globalCssMode = isGlobalCss(startModule)</span><span class="s3">\n\n            </span><span class="s1">// The current position of processing in all selected chunks</span><span class="s3">\n            </span><span class="s1">let allChunkStates = new Map(chunkStatesByModule.get(startModule)!)</span><span class="s3">\n\n            </span><span class="s1">// The list of modules that goes into the new chunk</span><span class="s3">\n            </span><span class="s1">const newChunkModules = new Set([startModule])</span><span class="s3">\n\n            </span><span class="s1">// The current size of the new chunk</span><span class="s3">\n            </span><span class="s1">let currentSize = startModule.size()</span><span class="s3">\n\n            </span><span class="s1">// A pool of potential modules where the next module is selected from.</span><span class="s3">\n            </span><span class="s1">// It's filled from the next module of the selected modules in every chunk.</span><span class="s3">\n            </span><span class="s1">// It also keeps some metadata to improve performance [size, chunkStates].</span><span class="s3">\n            </span><span class="s1">const potentialNextModules = new Map&lt;</span><span class="s3">\n              </span><span class="s1">Module,</span><span class="s3">\n              </span><span class="s1">[number, Map&lt;ChunkState, number&gt;]</span><span class="s3">\n            </span><span class="s1">&gt;()</span><span class="s3">\n            </span><span class="s1">for (const [chunkState, i] of allChunkStates) {</span><span class="s3">\n              </span><span class="s1">const nextModule = chunkState.modules[i + 1]</span><span class="s3">\n              </span><span class="s1">if (nextModule &amp;&amp; remainingModules.has(nextModule)) {</span><span class="s3">\n                </span><span class="s1">potentialNextModules.set(nextModule, [</span><span class="s3">\n                  </span><span class="s1">nextModule.size(),</span><span class="s3">\n                  </span><span class="s1">chunkStatesByModule.get(nextModule)!,</span><span class="s3">\n                </span><span class="s1">])</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Try to add modules to the chunk until a break condition is met</span><span class="s3">\n            </span><span class="s1">let cont</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n              </span><span class="s1">cont = false</span><span class="s3">\n              </span><span class="s1">// We try to select a module that reduces request count and</span><span class="s3">\n              </span><span class="s1">// has the highest number of requests</span><span class="s3">\n              </span><span class="s1">const orderedPotentialNextModules = []</span><span class="s3">\n              </span><span class="s1">for (const [</span><span class="s3">\n                </span><span class="s1">nextModule,</span><span class="s3">\n                </span><span class="s1">[size, nextChunkStates],</span><span class="s3">\n              </span><span class="s1">] of potentialNextModules) {</span><span class="s3">\n                </span><span class="s1">let maxRequests = 0</span><span class="s3">\n                </span><span class="s1">for (const chunkState of nextChunkStates.keys()) {</span><span class="s3">\n                  </span><span class="s1">// There is always some overlap</span><span class="s3">\n                  </span><span class="s1">if (allChunkStates.has(chunkState)) {</span><span class="s3">\n                    </span><span class="s1">maxRequests = Math.max(maxRequests, chunkState.requests)</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">orderedPotentialNextModules.push([</span><span class="s3">\n                  </span><span class="s1">nextModule,</span><span class="s3">\n                  </span><span class="s1">size,</span><span class="s3">\n                  </span><span class="s1">nextChunkStates,</span><span class="s3">\n                  </span><span class="s1">maxRequests,</span><span class="s3">\n                </span><span class="s1">] as const)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">orderedPotentialNextModules.sort(</span><span class="s3">\n                </span><span class="s1">(a, b) =&gt;</span><span class="s3">\n                  </span><span class="s1">b[3] - a[3] ||</span><span class="s3">\n                  </span><span class="s1">(a[0].identifier() &lt; b[0].identifier() ? -1 : 1)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">// Try every potential module</span><span class="s3">\n              </span><span class="s1">loop: for (const [</span><span class="s3">\n                </span><span class="s1">nextModule,</span><span class="s3">\n                </span><span class="s1">size,</span><span class="s3">\n                </span><span class="s1">nextChunkStates,</span><span class="s3">\n              </span><span class="s1">] of orderedPotentialNextModules) {</span><span class="s3">\n                </span><span class="s1">if (currentSize + size &gt; MAX_CSS_CHUNK_SIZE) {</span><span class="s3">\n                  </span><span class="s1">// Chunk would be too large</span><span class="s3">\n                  </span><span class="s1">continue</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!strict) {</span><span class="s3">\n                  </span><span class="s1">// In loose mode we only check if the dependencies are not violated</span><span class="s3">\n                  </span><span class="s1">const dependent = allDependents.get(nextModule)</span><span class="s3">\n                  </span><span class="s1">if (dependent) {</span><span class="s3">\n                    </span><span class="s1">for (const dep of dependent) {</span><span class="s3">\n                      </span><span class="s1">if (newChunkModules.has(dep)) {</span><span class="s3">\n                        </span><span class="s1">// A dependent of the module is already in the chunk, which would violate the order</span><span class="s3">\n                        </span><span class="s1">continue loop</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                  </span><span class="s1">// In strict mode we check that none of the order in any chunk is changed by adding the module</span><span class="s3">\n                  </span><span class="s1">for (const [chunkState, i] of nextChunkStates) {</span><span class="s3">\n                    </span><span class="s1">const prevState = allChunkStates.get(chunkState)</span><span class="s3">\n                    </span><span class="s1">if (prevState === undefined) {</span><span class="s3">\n                      </span><span class="s1">// New chunk group, can add it, but should we?</span><span class="s3">\n                      </span><span class="s1">// We only add that if below min size</span><span class="s3">\n                      </span><span class="s1">if (currentSize &lt; MIN_CSS_CHUNK_SIZE) {</span><span class="s3">\n                        </span><span class="s1">continue</span><span class="s3">\n                      </span><span class="s1">} else {</span><span class="s3">\n                        </span><span class="s1">continue loop</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">} else if (prevState + 1 === i) {</span><span class="s3">\n                      </span><span class="s1">// Existing chunk group, order fits</span><span class="s3">\n                      </span><span class="s1">continue</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                      </span><span class="s1">// Existing chunk group, there is something in between or order is reversed</span><span class="s3">\n                      </span><span class="s1">continue loop</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">// Global CSS must not leak into unrelated chunks</span><span class="s3">\n                </span><span class="s1">const nextIsGlobalCss = isGlobalCss(nextModule)</span><span class="s3">\n                </span><span class="s1">if (nextIsGlobalCss &amp;&amp; globalCssMode) {</span><span class="s3">\n                  </span><span class="s1">if (allChunkStates.size !== nextChunkStates.size) {</span><span class="s3">\n                    </span><span class="s1">// Fast check</span><span class="s3">\n                    </span><span class="s1">continue</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (globalCssMode) {</span><span class="s3">\n                  </span><span class="s1">for (const chunkState of nextChunkStates.keys()) {</span><span class="s3">\n                    </span><span class="s1">if (!allChunkStates.has(chunkState)) {</span><span class="s3">\n                      </span><span class="s1">// Global CSS would leak into chunkState</span><span class="s3">\n                      </span><span class="s1">continue loop</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (nextIsGlobalCss) {</span><span class="s3">\n                  </span><span class="s1">for (const chunkState of allChunkStates.keys()) {</span><span class="s3">\n                    </span><span class="s1">if (!nextChunkStates.has(chunkState)) {</span><span class="s3">\n                      </span><span class="s1">// Global CSS would leak into chunkState</span><span class="s3">\n                      </span><span class="s1">continue loop</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">potentialNextModules.delete(nextModule)</span><span class="s3">\n                </span><span class="s1">currentSize += size</span><span class="s3">\n                </span><span class="s1">if (nextIsGlobalCss) {</span><span class="s3">\n                  </span><span class="s1">globalCssMode = true</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">for (const [chunkState, i] of nextChunkStates) {</span><span class="s3">\n                  </span><span class="s1">if (allChunkStates.has(chunkState)) {</span><span class="s3">\n                    </span><span class="s1">// This reduces the request count of the chunk group</span><span class="s3">\n                    </span><span class="s1">chunkState.requests--</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">allChunkStates.set(chunkState, i)</span><span class="s3">\n                  </span><span class="s1">const newNextModule = chunkState.modules[i + 1]</span><span class="s3">\n                  </span><span class="s1">if (</span><span class="s3">\n                    </span><span class="s1">newNextModule &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">remainingModules.has(newNextModule) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">!newChunkModules.has(newNextModule)</span><span class="s3">\n                  </span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">potentialNextModules.set(newNextModule, [</span><span class="s3">\n                      </span><span class="s1">newNextModule.size(),</span><span class="s3">\n                      </span><span class="s1">chunkStatesByModule.get(newNextModule)!,</span><span class="s3">\n                    </span><span class="s1">])</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">newChunkModules.add(nextModule)</span><span class="s3">\n                </span><span class="s1">cont = true</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} while (cont)</span><span class="s3">\n            </span><span class="s1">const newChunk = compilation.addChunk()</span><span class="s3">\n            </span><span class="s1">newChunk.preventIntegration = true</span><span class="s3">\n            </span><span class="s1">newChunk.idNameHints.add('css')</span><span class="s3">\n            </span><span class="s1">for (const module of newChunkModules) {</span><span class="s3">\n              </span><span class="s1">remainingModules.delete(module)</span><span class="s3">\n              </span><span class="s1">chunkGraph.connectChunkAndModule(newChunk, module)</span><span class="s3">\n              </span><span class="s1">newChunksByModule.set(module, newChunk)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">changed = true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">for (const { chunk, modules } of chunkStates.values()) {</span><span class="s3">\n            </span><span class="s1">const chunks = new Set()</span><span class="s3">\n            </span><span class="s1">for (const module of modules) {</span><span class="s3">\n              </span><span class="s1">const newChunk = newChunksByModule.get(module)</span><span class="s3">\n              </span><span class="s1">if (newChunk) {</span><span class="s3">\n                </span><span class="s1">chunkGraph.disconnectChunkAndModule(chunk, module)</span><span class="s3">\n                </span><span class="s1">if (chunks.has(newChunk)) continue</span><span class="s3">\n                </span><span class="s1">chunks.add(newChunk)</span><span class="s3">\n                </span><span class="s1">chunk.split(newChunk)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (summary) {</span><span class="s3">\n            </span><span class="s1">console.log('Top 20 chunks by request count:')</span><span class="s3">\n            </span><span class="s1">const orderedChunkStates = [...chunkStates.values()]</span><span class="s3">\n            </span><span class="s1">orderedChunkStates.sort((a, b) =&gt; b.requests - a.requests)</span><span class="s3">\n            </span><span class="s1">for (const { chunk, modules, requests } of orderedChunkStates.slice(</span><span class="s3">\n              </span><span class="s1">0,</span><span class="s3">\n              </span><span class="s1">20</span><span class="s3">\n            </span><span class="s1">)) {</span><span class="s3">\n              </span><span class="s1">console.log(</span><span class="s3">\n                </span><span class="s1">`- ${requests} requests for ${chunk.name} (has ${modules.length} modules)`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return changed</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;CssChunkingPlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;PLUGIN_NAME&quot;</span><span class="s0">,</span><span class="s1">&quot;MIN_CSS_CHUNK_SIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_CSS_CHUNK_SIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;isGlobalCss&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;nameForCondition&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;compiler&quot;</span><span class="s0">,</span><span class="s1">&quot;summary&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;CSS_CHUNKING_SUMMARY&quot;</span><span class="s0">,</span><span class="s1">&quot;hooks&quot;</span><span class="s0">,</span><span class="s1">&quot;thisCompilation&quot;</span><span class="s0">,</span><span class="s1">&quot;tap&quot;</span><span class="s0">,</span><span class="s1">&quot;compilation&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizeChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;stage&quot;</span><span class="s0">,</span><span class="s1">&quot;chunkGraph&quot;</span><span class="s0">,</span><span class="s1">&quot;changed&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;chunkStates&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;chunkStatesByModule&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;modules&quot;</span><span class="s0">,</span><span class="s1">&quot;getChunkModulesIterable&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;chunkState&quot;</span><span class="s0">,</span><span class="s1">&quot;order&quot;</span><span class="s0">,</span><span class="s1">&quot;requests&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleChunkStates&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;orderedModules&quot;</span><span class="s0">,</span><span class="s1">&quot;sum&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;remainingModules&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;allDependents&quot;</span><span class="s0">,</span><span class="s1">&quot;dependent&quot;</span><span class="s0">,</span><span class="s1">&quot;loop&quot;</span><span class="s0">,</span><span class="s1">&quot;ia&quot;</span><span class="s0">,</span><span class="s1">&quot;bChunkStates&quot;</span><span class="s0">,</span><span class="s1">&quot;ib&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;newChunksByModule&quot;</span><span class="s0">,</span><span class="s1">&quot;startModule&quot;</span><span class="s0">,</span><span class="s1">&quot;globalCssMode&quot;</span><span class="s0">,</span><span class="s1">&quot;allChunkStates&quot;</span><span class="s0">,</span><span class="s1">&quot;newChunkModules&quot;</span><span class="s0">,</span><span class="s1">&quot;currentSize&quot;</span><span class="s0">,</span><span class="s1">&quot;potentialNextModules&quot;</span><span class="s0">,</span><span class="s1">&quot;nextModule&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;cont&quot;</span><span class="s0">,</span><span class="s1">&quot;orderedPotentialNextModules&quot;</span><span class="s0">,</span><span class="s1">&quot;nextChunkStates&quot;</span><span class="s0">,</span><span class="s1">&quot;maxRequests&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;dep&quot;</span><span class="s0">,</span><span class="s1">&quot;prevState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextIsGlobalCss&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;newNextModule&quot;</span><span class="s0">,</span><span class="s1">&quot;newChunk&quot;</span><span class="s0">,</span><span class="s1">&quot;addChunk&quot;</span><span class="s0">,</span><span class="s1">&quot;preventIntegration&quot;</span><span class="s0">,</span><span class="s1">&quot;idNameHints&quot;</span><span class="s0">,</span><span class="s1">&quot;connectChunkAndModule&quot;</span><span class="s0">,</span><span class="s1">&quot;disconnectChunkAndModule&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;orderedChunkStates&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>