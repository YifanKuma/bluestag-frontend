<html>
<head>
<title>argparse.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
argparse.js</font>
</center></td></tr></table>
<pre><span class="s0">// Port of python's argparse module, version 3.9.0:</span>
<span class="s0">// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py</span>

<span class="s2">'use strict'</span>

<span class="s0">// Copyright (C) 2010-2020 Python Software Foundation.</span>
<span class="s0">// Copyright (C) 2020 argparse.js authors</span>

<span class="s0">/* 
 * Command-line parsing library 
 * 
 * This module is an optparse-inspired command-line parsing library that: 
 * 
 *     - handles both optional and positional arguments 
 *     - produces highly informative usage messages 
 *     - supports parsers that dispatch to sub-parsers 
 * 
 * The following is a simple usage example that sums integers from the 
 * command-line and writes the result to a file:: 
 * 
 *     parser = argparse.ArgumentParser( 
 *         description='sum the integers at the command line') 
 *     parser.add_argument( 
 *         'integers', metavar='int', nargs='+', type=int, 
 *         help='an integer to be summed') 
 *     parser.add_argument( 
 *         '--log', default=sys.stdout, type=argparse.FileType('w'), 
 *         help='the file where the sum should be written') 
 *     args = parser.parse_args() 
 *     args.log.write('%s' % sum(args.integers)) 
 *     args.log.close() 
 * 
 * The module contains the following public classes: 
 * 
 *     - ArgumentParser -- The main entry point for command-line parsing. As the 
 *         example above shows, the add_argument() method is used to populate 
 *         the parser with actions for optional and positional arguments. Then 
 *         the parse_args() method is invoked to convert the args at the 
 *         command-line into an object with attributes. 
 * 
 *     - ArgumentError -- The exception raised by ArgumentParser objects when 
 *         there are errors with the parser's actions. Errors raised while 
 *         parsing the command-line are caught by ArgumentParser and emitted 
 *         as command-line messages. 
 * 
 *     - FileType -- A factory for defining types of files to be created. As the 
 *         example above shows, instances of FileType are typically passed as 
 *         the type= argument of add_argument() calls. 
 * 
 *     - Action -- The base class for parser actions. Typically actions are 
 *         selected by passing strings like 'store_true' or 'append_const' to 
 *         the action= argument of add_argument(). However, for greater 
 *         customization of ArgumentParser actions, subclasses of Action may 
 *         be defined and passed as the action= argument. 
 * 
 *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter, 
 *         ArgumentDefaultsHelpFormatter -- Formatter classes which 
 *         may be passed as the formatter_class= argument to the 
 *         ArgumentParser constructor. HelpFormatter is the default, 
 *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser 
 *         not to change the formatting for help text, and 
 *         ArgumentDefaultsHelpFormatter adds information about argument defaults 
 *         to the help. 
 * 
 * All other classes in this module are considered implementation details. 
 * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only 
 * considered public as object names -- the API of the formatter objects is 
 * still considered an implementation detail.) 
 */</span>

<span class="s3">const </span><span class="s1">SUPPRESS = </span><span class="s2">'==SUPPRESS=='</span>

<span class="s3">const </span><span class="s1">OPTIONAL = </span><span class="s2">'?'</span>
<span class="s3">const </span><span class="s1">ZERO_OR_MORE = </span><span class="s2">'*'</span>
<span class="s3">const </span><span class="s1">ONE_OR_MORE = </span><span class="s2">'+'</span>
<span class="s3">const </span><span class="s1">PARSER = </span><span class="s2">'A...'</span>
<span class="s3">const </span><span class="s1">REMAINDER = </span><span class="s2">'...'</span>
<span class="s3">const </span><span class="s1">_UNRECOGNIZED_ARGS_ATTR = </span><span class="s2">'_unrecognized_args'</span>


<span class="s0">// ==================================</span>
<span class="s0">// Utility functions used for porting</span>
<span class="s0">// ==================================</span>
<span class="s3">const </span><span class="s1">assert = require(</span><span class="s2">'assert'</span><span class="s1">)</span>
<span class="s3">const </span><span class="s1">util = require(</span><span class="s2">'util'</span><span class="s1">)</span>
<span class="s3">const </span><span class="s1">fs = require(</span><span class="s2">'fs'</span><span class="s1">)</span>
<span class="s3">const </span><span class="s1">sub = require(</span><span class="s2">'./lib/sub'</span><span class="s1">)</span>
<span class="s3">const </span><span class="s1">path = require(</span><span class="s2">'path'</span><span class="s1">)</span>
<span class="s3">const </span><span class="s1">repr = util.inspect</span>

<span class="s3">function </span><span class="s1">get_argv() {</span>
    <span class="s0">// omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)</span>
    <span class="s3">return </span><span class="s1">process.argv.slice(</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">get_terminal_size() {</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">columns: +process.env.COLUMNS || process.stdout.columns || </span><span class="s4">80</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">hasattr(object, name) {</span>
    <span class="s3">return </span><span class="s1">Object.prototype.hasOwnProperty.call(object, name)</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getattr(object, name, value) {</span>
    <span class="s3">return </span><span class="s1">hasattr(object, name) ? object[name] : value</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">setattr(object, name, value) {</span>
    <span class="s1">object[name] = value</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">setdefault(object, name, value) {</span>
    <span class="s3">if </span><span class="s1">(!hasattr(object, name)) object[name] = value</span>
    <span class="s3">return </span><span class="s1">object[name]</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">delattr(object, name) {</span>
    <span class="s3">delete </span><span class="s1">object[name]</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">range(from, to, step=</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s0">// range(10) is equivalent to range(0, 10)</span>
    <span class="s3">if </span><span class="s1">(arguments.length === </span><span class="s4">1</span><span class="s1">) [ to, from ] = [ from, </span><span class="s4">0 </span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">from !== </span><span class="s2">'number' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">to !== </span><span class="s2">'number' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">step !== </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'argument cannot be interpreted as an integer'</span><span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(step === </span><span class="s4">0</span><span class="s1">) </span><span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'range() arg 3 must not be zero'</span><span class="s1">)</span>

    <span class="s3">let </span><span class="s1">result = []</span>
    <span class="s3">if </span><span class="s1">(step &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = from; i &lt; to; i += step) result.push(i)</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = from; i &gt; to; i += step) result.push(i)</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">result</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">splitlines(str, keepends = </span><span class="s3">false</span><span class="s1">) {</span>
    <span class="s3">let </span><span class="s1">result</span>
    <span class="s3">if </span><span class="s1">(!keepends) {</span>
        <span class="s1">result = str.split(</span><span class="s5">/\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029]/</span><span class="s1">)</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">result = []</span>
        <span class="s3">let </span><span class="s1">parts = str.split(</span><span class="s5">/(\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029])/</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; parts.length; i += </span><span class="s4">2</span><span class="s1">) {</span>
            <span class="s1">result.push(parts[i] + (i + </span><span class="s4">1 </span><span class="s1">&lt; parts.length ? parts[i + </span><span class="s4">1</span><span class="s1">] : </span><span class="s2">''</span><span class="s1">))</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!result[result.length - </span><span class="s4">1</span><span class="s1">]) result.pop()</span>
    <span class="s3">return </span><span class="s1">result</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_string_lstrip(string, prefix_chars) {</span>
    <span class="s3">let </span><span class="s1">idx = </span><span class="s4">0</span>
    <span class="s3">while </span><span class="s1">(idx &lt; string.length &amp;&amp; prefix_chars.includes(string[idx])) idx++</span>
    <span class="s3">return </span><span class="s1">idx ? string.slice(idx) : string</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_string_split(string, sep, maxsplit) {</span>
    <span class="s3">let </span><span class="s1">result = string.split(sep)</span>
    <span class="s3">if </span><span class="s1">(result.length &gt; maxsplit) {</span>
        <span class="s1">result = result.slice(</span><span class="s4">0</span><span class="s1">, maxsplit).concat([ result.slice(maxsplit).join(sep) ])</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">result</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_array_equal(array1, array2) {</span>
    <span class="s3">if </span><span class="s1">(array1.length !== array2.length) </span><span class="s3">return false</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; array1.length; i++) {</span>
        <span class="s3">if </span><span class="s1">(array1[i] !== array2[i]) </span><span class="s3">return false</span>
    <span class="s1">}</span>
    <span class="s3">return true</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_array_remove(array, item) {</span>
    <span class="s3">let </span><span class="s1">idx = array.indexOf(item)</span>
    <span class="s3">if </span><span class="s1">(idx === -</span><span class="s4">1</span><span class="s1">) </span><span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'%r not in list'</span><span class="s1">, item))</span>
    <span class="s1">array.splice(idx, </span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">// normalize choices to array;</span>
<span class="s0">// this isn't required in python because `in` and `map` operators work with anything,</span>
<span class="s0">// but in js dealing with multiple types here is too clunky</span>
<span class="s3">function </span><span class="s1">_choices_to_array(choices) {</span>
    <span class="s3">if </span><span class="s1">(choices === undefined) {</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(Array.isArray(choices)) {</span>
        <span class="s3">return </span><span class="s1">choices</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(choices !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">choices[Symbol.iterator] === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">Array.from(choices)</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">choices === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; choices !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">Object.keys(choices)</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">throw new </span><span class="s1">Error(sub(</span><span class="s2">'invalid choices value: %r'</span><span class="s1">, choices))</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// decorator that allows a class to be called without new</span>
<span class="s3">function </span><span class="s1">_callable(cls) {</span>
    <span class="s3">let </span><span class="s1">result = { </span><span class="s0">// object is needed for inferred class name</span>
        <span class="s1">[cls.name]: </span><span class="s3">function </span><span class="s1">(...args) {</span>
            <span class="s3">let </span><span class="s1">this_class = </span><span class="s3">new</span><span class="s1">.target === result || !</span><span class="s3">new</span><span class="s1">.target</span>
            <span class="s3">return </span><span class="s1">Reflect.construct(cls, args, this_class ? cls : </span><span class="s3">new</span><span class="s1">.target)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">result[cls.name].prototype = cls.prototype</span>
    <span class="s0">// fix default tag for toString, e.g. [object Action] instead of [object Object]</span>
    <span class="s1">cls.prototype[Symbol.toStringTag] = cls.name</span>
    <span class="s3">return </span><span class="s1">result[cls.name]</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_alias(object, from, to) {</span>
    <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">let </span><span class="s1">name = object.constructor.name</span>
        <span class="s1">Object.defineProperty(object, from, {</span>
            <span class="s1">value: util.deprecate(object[to], sub(</span><span class="s2">'%s.%s() is renamed to %s.%s()'</span><span class="s1">,</span>
                <span class="s1">name, from, name, to)),</span>
            <span class="s1">enumerable: </span><span class="s3">false</span>
        <span class="s1">})</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">{}</span>
<span class="s1">}</span>

<span class="s0">// decorator that allows snake_case class methods to be called with camelCase and vice versa</span>
<span class="s3">function </span><span class="s1">_camelcase_alias(_class) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">name of Object.getOwnPropertyNames(_class.prototype)) {</span>
        <span class="s3">let </span><span class="s1">camelcase = name.replace(</span><span class="s5">/\w_[a-z]/g</span><span class="s1">, s =&gt; s[</span><span class="s4">0</span><span class="s1">] + s[</span><span class="s4">2</span><span class="s1">].toUpperCase())</span>
        <span class="s3">if </span><span class="s1">(camelcase !== name) _alias(_class.prototype, camelcase, name)</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">_class</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_to_legacy_name(key) {</span>
    <span class="s1">key = key.replace(</span><span class="s5">/\w_[a-z]/g</span><span class="s1">, s =&gt; s[</span><span class="s4">0</span><span class="s1">] + s[</span><span class="s4">2</span><span class="s1">].toUpperCase())</span>
    <span class="s3">if </span><span class="s1">(key === </span><span class="s2">'default'</span><span class="s1">) key = </span><span class="s2">'defaultValue'</span>
    <span class="s3">if </span><span class="s1">(key === </span><span class="s2">'const'</span><span class="s1">) key = </span><span class="s2">'constant'</span>
    <span class="s3">return </span><span class="s1">key</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_to_new_name(key) {</span>
    <span class="s3">if </span><span class="s1">(key === </span><span class="s2">'defaultValue'</span><span class="s1">) key = </span><span class="s2">'default'</span>
    <span class="s3">if </span><span class="s1">(key === </span><span class="s2">'constant'</span><span class="s1">) key = </span><span class="s2">'const'</span>
    <span class="s1">key = key.replace(</span><span class="s5">/[A-Z]/g</span><span class="s1">, c =&gt; </span><span class="s2">'_' </span><span class="s1">+ c.toLowerCase())</span>
    <span class="s3">return </span><span class="s1">key</span>
<span class="s1">}</span>

<span class="s0">// parse options</span>
<span class="s3">let </span><span class="s1">no_default = Symbol(</span><span class="s2">'no_default_value'</span><span class="s1">)</span>
<span class="s3">function </span><span class="s1">_parse_opts(args, descriptor) {</span>
    <span class="s3">function </span><span class="s1">get_name() {</span>
        <span class="s3">let </span><span class="s1">stack = </span><span class="s3">new </span><span class="s1">Error().stack.split(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">)</span>
            <span class="s1">.map(x =&gt; x.match(</span><span class="s5">/^    at (.*) \(.*\)$/</span><span class="s1">))</span>
            <span class="s1">.filter(Boolean)</span>
            <span class="s1">.map(m =&gt; m[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">.map(fn =&gt; fn.match(</span><span class="s5">/[^ .]*$/</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s3">if </span><span class="s1">(stack.length &amp;&amp; stack[</span><span class="s4">0</span><span class="s1">] === get_name.name) stack.shift()</span>
        <span class="s3">if </span><span class="s1">(stack.length &amp;&amp; stack[</span><span class="s4">0</span><span class="s1">] === _parse_opts.name) stack.shift()</span>
        <span class="s3">return </span><span class="s1">stack.length ? stack[</span><span class="s4">0</span><span class="s1">] : </span><span class="s2">''</span>
    <span class="s1">}</span>

    <span class="s1">args = Array.from(args)</span>
    <span class="s3">let </span><span class="s1">kwargs = {}</span>
    <span class="s3">let </span><span class="s1">result = []</span>
    <span class="s3">let </span><span class="s1">last_opt = args.length &amp;&amp; args[args.length - </span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">last_opt === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; last_opt !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !Array.isArray(last_opt) &amp;&amp;</span>
        <span class="s1">(!last_opt.constructor || last_opt.constructor.name === </span><span class="s2">'Object'</span><span class="s1">)) {</span>
        <span class="s1">kwargs = Object.assign({}, args.pop())</span>
    <span class="s1">}</span>

    <span class="s0">// LEGACY (v1 compatibility): camelcase</span>
    <span class="s3">let </span><span class="s1">renames = []</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">key of Object.keys(descriptor)) {</span>
        <span class="s3">let </span><span class="s1">old_name = _to_legacy_name(key)</span>
        <span class="s3">if </span><span class="s1">(old_name !== key &amp;&amp; (old_name </span><span class="s3">in </span><span class="s1">kwargs)) {</span>
            <span class="s3">if </span><span class="s1">(key </span><span class="s3">in </span><span class="s1">kwargs) {</span>
                <span class="s0">// default and defaultValue specified at the same time, happens often in old tests</span>
                <span class="s0">//throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">kwargs[key] = kwargs[old_name]</span>
            <span class="s1">}</span>
            <span class="s1">renames.push([ old_name, key ])</span>
            <span class="s3">delete </span><span class="s1">kwargs[old_name]</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(renames.length) {</span>
        <span class="s3">let </span><span class="s1">name = get_name()</span>
        <span class="s1">deprecate(</span><span class="s2">'camelcase_' </span><span class="s1">+ name, sub(</span><span class="s2">'%s(): following options are renamed: %s'</span><span class="s1">,</span>
            <span class="s1">name, renames.map(([ a, b ]) =&gt; sub(</span><span class="s2">'%r -&gt; %r'</span><span class="s1">, a, b))))</span>
    <span class="s1">}</span>
    <span class="s0">// end</span>

    <span class="s3">let </span><span class="s1">missing_positionals = []</span>
    <span class="s3">let </span><span class="s1">positional_count = args.length</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[ key, def ] of Object.entries(descriptor)) {</span>
        <span class="s3">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'*'</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(key.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; key[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'*'</span><span class="s1">) {</span>
                <span class="s0">// LEGACY (v1 compatibility): camelcase</span>
                <span class="s3">let </span><span class="s1">renames = []</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">key of Object.keys(kwargs)) {</span>
                    <span class="s3">let </span><span class="s1">new_name = _to_new_name(key)</span>
                    <span class="s3">if </span><span class="s1">(new_name !== key &amp;&amp; (key </span><span class="s3">in </span><span class="s1">kwargs)) {</span>
                        <span class="s3">if </span><span class="s1">(new_name </span><span class="s3">in </span><span class="s1">kwargs) {</span>
                            <span class="s0">// default and defaultValue specified at the same time, happens often in old tests</span>
                            <span class="s0">//throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">kwargs[new_name] = kwargs[key]</span>
                        <span class="s1">}</span>
                        <span class="s1">renames.push([ key, new_name ])</span>
                        <span class="s3">delete </span><span class="s1">kwargs[key]</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(renames.length) {</span>
                    <span class="s3">let </span><span class="s1">name = get_name()</span>
                    <span class="s1">deprecate(</span><span class="s2">'camelcase_' </span><span class="s1">+ name, sub(</span><span class="s2">'%s(): following options are renamed: %s'</span><span class="s1">,</span>
                        <span class="s1">name, renames.map(([ a, b ]) =&gt; sub(</span><span class="s2">'%r -&gt; %r'</span><span class="s1">, a, b))))</span>
                <span class="s1">}</span>
                <span class="s0">// end</span>
                <span class="s1">result.push(kwargs)</span>
                <span class="s1">kwargs = {}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">result.push(args)</span>
                <span class="s1">args = []</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(key </span><span class="s3">in </span><span class="s1">kwargs &amp;&amp; args.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'%s() got multiple values for argument %r'</span><span class="s1">, get_name(), key))</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(key </span><span class="s3">in </span><span class="s1">kwargs) {</span>
            <span class="s1">result.push(kwargs[key])</span>
            <span class="s3">delete </span><span class="s1">kwargs[key]</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(args.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">result.push(args.shift())</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(def !== no_default) {</span>
            <span class="s1">result.push(def)</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">missing_positionals.push(key)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(Object.keys(kwargs).length) {</span>
        <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'%s() got an unexpected keyword argument %r'</span><span class="s1">,</span>
            <span class="s1">get_name(), Object.keys(kwargs)[</span><span class="s4">0</span><span class="s1">]))</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(args.length) {</span>
        <span class="s3">let </span><span class="s1">from = Object.entries(descriptor).filter(([ k, v ]) =&gt; k[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s2">'*' </span><span class="s1">&amp;&amp; v !== no_default).length</span>
        <span class="s3">let </span><span class="s1">to = Object.entries(descriptor).filter(([ k ]) =&gt; k[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s2">'*'</span><span class="s1">).length</span>
        <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'%s() takes %s positional argument%s but %s %s given'</span><span class="s1">,</span>
            <span class="s1">get_name(),</span>
            <span class="s1">from === to ? sub(</span><span class="s2">'from %s to %s'</span><span class="s1">, from, to) : to,</span>
            <span class="s1">from === to &amp;&amp; to === </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: </span><span class="s2">'s'</span><span class="s1">,</span>
            <span class="s1">positional_count,</span>
            <span class="s1">positional_count === </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">'was' </span><span class="s1">: </span><span class="s2">'were'</span><span class="s1">))</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(missing_positionals.length) {</span>
        <span class="s3">let </span><span class="s1">strs = missing_positionals.map(repr)</span>
        <span class="s3">if </span><span class="s1">(strs.length &gt; </span><span class="s4">1</span><span class="s1">) strs[strs.length - </span><span class="s4">1</span><span class="s1">] = </span><span class="s2">'and ' </span><span class="s1">+ strs[strs.length - </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s3">let </span><span class="s1">str_joined = strs.join(strs.length === </span><span class="s4">2 </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: </span><span class="s2">', '</span><span class="s1">)</span>
        <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'%s() missing %i required positional argument%s: %s'</span><span class="s1">,</span>
            <span class="s1">get_name(), strs.length, strs.length === </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: </span><span class="s2">'s'</span><span class="s1">, str_joined))</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">result</span>
<span class="s1">}</span>

<span class="s3">let </span><span class="s1">_deprecations = {}</span>
<span class="s3">function </span><span class="s1">deprecate(id, string) {</span>
    <span class="s1">_deprecations[id] = _deprecations[id] || util.deprecate(() =&gt; {}, string)</span>
    <span class="s1">_deprecations[id]()</span>
<span class="s1">}</span>


<span class="s0">// =============================</span>
<span class="s0">// Utility functions and classes</span>
<span class="s0">// =============================</span>
<span class="s3">function </span><span class="s1">_AttributeHolder(cls = Object) {</span>
    <span class="s0">/* 
     *  Abstract base class that provides __repr__. 
     * 
     *  The __repr__ method returns a string in the format:: 
     *      ClassName(attr=name, attr=name, ...) 
     *  The attributes are determined either by a class-level attribute, 
     *  '_kwarg_names', or by inspecting the instance __dict__. 
     */</span>

    <span class="s3">return class </span><span class="s1">_AttributeHolder </span><span class="s3">extends </span><span class="s1">cls {</span>
        <span class="s1">[util.inspect.custom]() {</span>
            <span class="s3">let </span><span class="s1">type_name = </span><span class="s3">this</span><span class="s1">.constructor.name</span>
            <span class="s3">let </span><span class="s1">arg_strings = []</span>
            <span class="s3">let </span><span class="s1">star_args = {}</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">arg of </span><span class="s3">this</span><span class="s1">._get_args()) {</span>
                <span class="s1">arg_strings.push(repr(arg))</span>
            <span class="s1">}</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[ name, value ] of </span><span class="s3">this</span><span class="s1">._get_kwargs()) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s5">/^[a-z_][a-z0-9_$]*$/i</span><span class="s1">.test(name)) {</span>
                    <span class="s1">arg_strings.push(sub(</span><span class="s2">'%s=%r'</span><span class="s1">, name, value))</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">star_args[name] = value</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(Object.keys(star_args).length) {</span>
                <span class="s1">arg_strings.push(sub(</span><span class="s2">'**%s'</span><span class="s1">, repr(star_args)))</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">sub(</span><span class="s2">'%s(%s)'</span><span class="s1">, type_name, arg_strings.join(</span><span class="s2">', '</span><span class="s1">))</span>
        <span class="s1">}</span>

        <span class="s1">toString() {</span>
            <span class="s3">return this</span><span class="s1">[util.inspect.custom]()</span>
        <span class="s1">}</span>

        <span class="s1">_get_kwargs() {</span>
            <span class="s3">return </span><span class="s1">Object.entries(</span><span class="s3">this</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s1">_get_args() {</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s3">function </span><span class="s1">_copy_items(items) {</span>
    <span class="s3">if </span><span class="s1">(items === undefined) {</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">items.slice(</span><span class="s4">0</span><span class="s1">)</span>
<span class="s1">}</span>


<span class="s0">// ===============</span>
<span class="s0">// Formatting Help</span>
<span class="s0">// ===============</span>
<span class="s3">const </span><span class="s1">HelpFormatter = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">HelpFormatter {</span>
    <span class="s0">/* 
     *  Formatter for generating usage messages and argument help strings. 
     * 
     *  Only the name of this class is considered a public API. All the methods 
     *  provided by the class are considered an implementation detail. 
     */</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">prog,</span>
            <span class="s1">indent_increment,</span>
            <span class="s1">max_help_position,</span>
            <span class="s1">width</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">prog: no_default,</span>
            <span class="s1">indent_increment: </span><span class="s4">2</span><span class="s1">,</span>
            <span class="s1">max_help_position: </span><span class="s4">24</span><span class="s1">,</span>
            <span class="s1">width: undefined</span>
        <span class="s1">})</span>

        <span class="s0">// default setting for width</span>
        <span class="s3">if </span><span class="s1">(width === undefined) {</span>
            <span class="s1">width = get_terminal_size().columns</span>
            <span class="s1">width -= </span><span class="s4">2</span>
        <span class="s1">}</span>

        <span class="s3">this</span><span class="s1">._prog = prog</span>
        <span class="s3">this</span><span class="s1">._indent_increment = indent_increment</span>
        <span class="s3">this</span><span class="s1">._max_help_position = Math.min(max_help_position,</span>
                                      <span class="s1">Math.max(width - </span><span class="s4">20</span><span class="s1">, indent_increment * </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s3">this</span><span class="s1">._width = width</span>

        <span class="s3">this</span><span class="s1">._current_indent = </span><span class="s4">0</span>
        <span class="s3">this</span><span class="s1">._level = </span><span class="s4">0</span>
        <span class="s3">this</span><span class="s1">._action_max_length = </span><span class="s4">0</span>

        <span class="s3">this</span><span class="s1">._root_section = </span><span class="s3">this</span><span class="s1">._Section(</span><span class="s3">this</span><span class="s1">, undefined)</span>
        <span class="s3">this</span><span class="s1">._current_section = </span><span class="s3">this</span><span class="s1">._root_section</span>

        <span class="s3">this</span><span class="s1">._whitespace_matcher = </span><span class="s5">/[ \t\n\r\f\v]+/g </span><span class="s0">// equivalent to python /\s+/ with ASCII flag</span>
        <span class="s3">this</span><span class="s1">._long_break_matcher = </span><span class="s5">/\n\n\n+/g</span>
    <span class="s1">}</span>

    <span class="s0">// ===============================</span>
    <span class="s0">// Section and indentation methods</span>
    <span class="s0">// ===============================</span>
    <span class="s1">_indent() {</span>
        <span class="s3">this</span><span class="s1">._current_indent += </span><span class="s3">this</span><span class="s1">._indent_increment</span>
        <span class="s3">this</span><span class="s1">._level += </span><span class="s4">1</span>
    <span class="s1">}</span>

    <span class="s1">_dedent() {</span>
        <span class="s3">this</span><span class="s1">._current_indent -= </span><span class="s3">this</span><span class="s1">._indent_increment</span>
        <span class="s1">assert(</span><span class="s3">this</span><span class="s1">._current_indent &gt;= </span><span class="s4">0</span><span class="s1">, </span><span class="s2">'Indent decreased below 0.'</span><span class="s1">)</span>
        <span class="s3">this</span><span class="s1">._level -= </span><span class="s4">1</span>
    <span class="s1">}</span>

    <span class="s1">_add_item(func, args) {</span>
        <span class="s3">this</span><span class="s1">._current_section.items.push([ func, args ])</span>
    <span class="s1">}</span>

    <span class="s0">// ========================</span>
    <span class="s0">// Message building methods</span>
    <span class="s0">// ========================</span>
    <span class="s1">start_section(heading) {</span>
        <span class="s3">this</span><span class="s1">._indent()</span>
        <span class="s3">let </span><span class="s1">section = </span><span class="s3">this</span><span class="s1">._Section(</span><span class="s3">this</span><span class="s1">, </span><span class="s3">this</span><span class="s1">._current_section, heading)</span>
        <span class="s3">this</span><span class="s1">._add_item(section.format_help.bind(section), [])</span>
        <span class="s3">this</span><span class="s1">._current_section = section</span>
    <span class="s1">}</span>

    <span class="s1">end_section() {</span>
        <span class="s3">this</span><span class="s1">._current_section = </span><span class="s3">this</span><span class="s1">._current_section.parent</span>
        <span class="s3">this</span><span class="s1">._dedent()</span>
    <span class="s1">}</span>

    <span class="s1">add_text(text) {</span>
        <span class="s3">if </span><span class="s1">(text !== SUPPRESS &amp;&amp; text !== undefined) {</span>
            <span class="s3">this</span><span class="s1">._add_item(</span><span class="s3">this</span><span class="s1">._format_text.bind(</span><span class="s3">this</span><span class="s1">), [text])</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">add_usage(usage, actions, groups, prefix = undefined) {</span>
        <span class="s3">if </span><span class="s1">(usage !== SUPPRESS) {</span>
            <span class="s3">let </span><span class="s1">args = [ usage, actions, groups, prefix ]</span>
            <span class="s3">this</span><span class="s1">._add_item(</span><span class="s3">this</span><span class="s1">._format_usage.bind(</span><span class="s3">this</span><span class="s1">), args)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">add_argument(action) {</span>
        <span class="s3">if </span><span class="s1">(action.help !== SUPPRESS) {</span>

            <span class="s0">// find all invocations</span>
            <span class="s3">let </span><span class="s1">invocations = [</span><span class="s3">this</span><span class="s1">._format_action_invocation(action)]</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">subaction of </span><span class="s3">this</span><span class="s1">._iter_indented_subactions(action)) {</span>
                <span class="s1">invocations.push(</span><span class="s3">this</span><span class="s1">._format_action_invocation(subaction))</span>
            <span class="s1">}</span>

            <span class="s0">// update the maximum item length</span>
            <span class="s3">let </span><span class="s1">invocation_length = Math.max(...invocations.map(invocation =&gt; invocation.length))</span>
            <span class="s3">let </span><span class="s1">action_length = invocation_length + </span><span class="s3">this</span><span class="s1">._current_indent</span>
            <span class="s3">this</span><span class="s1">._action_max_length = Math.max(</span><span class="s3">this</span><span class="s1">._action_max_length,</span>
                                               <span class="s1">action_length)</span>

            <span class="s0">// add the item to the list</span>
            <span class="s3">this</span><span class="s1">._add_item(</span><span class="s3">this</span><span class="s1">._format_action.bind(</span><span class="s3">this</span><span class="s1">), [action])</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">add_arguments(actions) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of actions) {</span>
            <span class="s3">this</span><span class="s1">.add_argument(action)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// =======================</span>
    <span class="s0">// Help-formatting methods</span>
    <span class="s0">// =======================</span>
    <span class="s1">format_help() {</span>
        <span class="s3">let </span><span class="s1">help = </span><span class="s3">this</span><span class="s1">._root_section.format_help()</span>
        <span class="s3">if </span><span class="s1">(help) {</span>
            <span class="s1">help = help.replace(</span><span class="s3">this</span><span class="s1">._long_break_matcher, </span><span class="s2">'</span><span class="s6">\n\n</span><span class="s2">'</span><span class="s1">)</span>
            <span class="s1">help = help.replace(</span><span class="s5">/^\n+|\n+$/g</span><span class="s1">, </span><span class="s2">''</span><span class="s1">) + </span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">help</span>
    <span class="s1">}</span>

    <span class="s1">_join_parts(part_strings) {</span>
        <span class="s3">return </span><span class="s1">part_strings.filter(part =&gt; part &amp;&amp; part !== SUPPRESS).join(</span><span class="s2">''</span><span class="s1">)</span>
    <span class="s1">}</span>

    <span class="s1">_format_usage(usage, actions, groups, prefix) {</span>
        <span class="s3">if </span><span class="s1">(prefix === undefined) {</span>
            <span class="s1">prefix = </span><span class="s2">'usage: '</span>
        <span class="s1">}</span>

        <span class="s0">// if usage is specified, use that</span>
        <span class="s3">if </span><span class="s1">(usage !== undefined) {</span>
            <span class="s1">usage = sub(usage, { prog: </span><span class="s3">this</span><span class="s1">._prog })</span>

        <span class="s0">// if no optionals or positionals are available, usage is just prog</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(usage === undefined &amp;&amp; !actions.length) {</span>
            <span class="s1">usage = sub(</span><span class="s2">'%(prog)s'</span><span class="s1">, { prog: </span><span class="s3">this</span><span class="s1">._prog })</span>

        <span class="s0">// if optionals and positionals are available, calculate usage</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(usage === undefined) {</span>
            <span class="s3">let </span><span class="s1">prog = sub(</span><span class="s2">'%(prog)s'</span><span class="s1">, { prog: </span><span class="s3">this</span><span class="s1">._prog })</span>

            <span class="s0">// split optionals from positionals</span>
            <span class="s3">let </span><span class="s1">optionals = []</span>
            <span class="s3">let </span><span class="s1">positionals = []</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of actions) {</span>
                <span class="s3">if </span><span class="s1">(action.option_strings.length) {</span>
                    <span class="s1">optionals.push(action)</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">positionals.push(action)</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s0">// build full usage string</span>
            <span class="s3">let </span><span class="s1">action_usage = </span><span class="s3">this</span><span class="s1">._format_actions_usage([].concat(optionals).concat(positionals), groups)</span>
            <span class="s1">usage = [ prog, action_usage ].map(String).join(</span><span class="s2">' '</span><span class="s1">)</span>

            <span class="s0">// wrap the usage parts if it's too long</span>
            <span class="s3">let </span><span class="s1">text_width = </span><span class="s3">this</span><span class="s1">._width - </span><span class="s3">this</span><span class="s1">._current_indent</span>
            <span class="s3">if </span><span class="s1">(prefix.length + usage.length &gt; text_width) {</span>

                <span class="s0">// break usage into wrappable parts</span>
                <span class="s3">let </span><span class="s1">part_regexp = </span><span class="s5">/\(.*?\)+(?=\s|$)|\[.*?\]+(?=\s|$)|\S+/g</span>
                <span class="s3">let </span><span class="s1">opt_usage = </span><span class="s3">this</span><span class="s1">._format_actions_usage(optionals, groups)</span>
                <span class="s3">let </span><span class="s1">pos_usage = </span><span class="s3">this</span><span class="s1">._format_actions_usage(positionals, groups)</span>
                <span class="s3">let </span><span class="s1">opt_parts = opt_usage.match(part_regexp) || []</span>
                <span class="s3">let </span><span class="s1">pos_parts = pos_usage.match(part_regexp) || []</span>
                <span class="s1">assert(opt_parts.join(</span><span class="s2">' '</span><span class="s1">) === opt_usage)</span>
                <span class="s1">assert(pos_parts.join(</span><span class="s2">' '</span><span class="s1">) === pos_usage)</span>

                <span class="s0">// helper for wrapping lines</span>
                <span class="s3">let </span><span class="s1">get_lines = (parts, indent, prefix = undefined) =&gt; {</span>
                    <span class="s3">let </span><span class="s1">lines = []</span>
                    <span class="s3">let </span><span class="s1">line = []</span>
                    <span class="s3">let </span><span class="s1">line_len</span>
                    <span class="s3">if </span><span class="s1">(prefix !== undefined) {</span>
                        <span class="s1">line_len = prefix.length - </span><span class="s4">1</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">line_len = indent.length - </span><span class="s4">1</span>
                    <span class="s1">}</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">part of parts) {</span>
                        <span class="s3">if </span><span class="s1">(line_len + </span><span class="s4">1 </span><span class="s1">+ part.length &gt; text_width &amp;&amp; line) {</span>
                            <span class="s1">lines.push(indent + line.join(</span><span class="s2">' '</span><span class="s1">))</span>
                            <span class="s1">line = []</span>
                            <span class="s1">line_len = indent.length - </span><span class="s4">1</span>
                        <span class="s1">}</span>
                        <span class="s1">line.push(part)</span>
                        <span class="s1">line_len += part.length + </span><span class="s4">1</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(line.length) {</span>
                        <span class="s1">lines.push(indent + line.join(</span><span class="s2">' '</span><span class="s1">))</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(prefix !== undefined) {</span>
                        <span class="s1">lines[</span><span class="s4">0</span><span class="s1">] = lines[</span><span class="s4">0</span><span class="s1">].slice(indent.length)</span>
                    <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">lines</span>
                <span class="s1">}</span>

                <span class="s3">let </span><span class="s1">lines</span>

                <span class="s0">// if prog is short, follow it with optionals or positionals</span>
                <span class="s3">if </span><span class="s1">(prefix.length + prog.length &lt;= </span><span class="s4">0.75 </span><span class="s1">* text_width) {</span>
                    <span class="s3">let </span><span class="s1">indent = </span><span class="s2">' '</span><span class="s1">.repeat(prefix.length + prog.length + </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">(opt_parts.length) {</span>
                        <span class="s1">lines = get_lines([prog].concat(opt_parts), indent, prefix)</span>
                        <span class="s1">lines = lines.concat(get_lines(pos_parts, indent))</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(pos_parts.length) {</span>
                        <span class="s1">lines = get_lines([prog].concat(pos_parts), indent, prefix)</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">lines = [prog]</span>
                    <span class="s1">}</span>

                <span class="s0">// if prog is long, put it on its own line</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">let </span><span class="s1">indent = </span><span class="s2">' '</span><span class="s1">.repeat(prefix.length)</span>
                    <span class="s3">let </span><span class="s1">parts = [].concat(opt_parts).concat(pos_parts)</span>
                    <span class="s1">lines = get_lines(parts, indent)</span>
                    <span class="s3">if </span><span class="s1">(lines.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s1">lines = []</span>
                        <span class="s1">lines = lines.concat(get_lines(opt_parts, indent))</span>
                        <span class="s1">lines = lines.concat(get_lines(pos_parts, indent))</span>
                    <span class="s1">}</span>
                    <span class="s1">lines = [prog].concat(lines)</span>
                <span class="s1">}</span>

                <span class="s0">// join lines into usage</span>
                <span class="s1">usage = lines.join(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// prefix with 'usage:'</span>
        <span class="s3">return </span><span class="s1">sub(</span><span class="s2">'%s%s</span><span class="s6">\n\n</span><span class="s2">'</span><span class="s1">, prefix, usage)</span>
    <span class="s1">}</span>

    <span class="s1">_format_actions_usage(actions, groups) {</span>
        <span class="s0">// find group indices and identify actions in groups</span>
        <span class="s3">let </span><span class="s1">group_actions = </span><span class="s3">new </span><span class="s1">Set()</span>
        <span class="s3">let </span><span class="s1">inserts = {}</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">group of groups) {</span>
            <span class="s3">let </span><span class="s1">start = actions.indexOf(group._group_actions[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">(start === -</span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s3">continue</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">let </span><span class="s1">end = start + group._group_actions.length</span>
                <span class="s3">if </span><span class="s1">(_array_equal(actions.slice(start, end), group._group_actions)) {</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of group._group_actions) {</span>
                        <span class="s1">group_actions.add(action)</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(!group.required) {</span>
                        <span class="s3">if </span><span class="s1">(start </span><span class="s3">in </span><span class="s1">inserts) {</span>
                            <span class="s1">inserts[start] += </span><span class="s2">' ['</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">inserts[start] = </span><span class="s2">'['</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(end </span><span class="s3">in </span><span class="s1">inserts) {</span>
                            <span class="s1">inserts[end] += </span><span class="s2">']'</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">inserts[end] = </span><span class="s2">']'</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">if </span><span class="s1">(start </span><span class="s3">in </span><span class="s1">inserts) {</span>
                            <span class="s1">inserts[start] += </span><span class="s2">' ('</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">inserts[start] = </span><span class="s2">'('</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(end </span><span class="s3">in </span><span class="s1">inserts) {</span>
                            <span class="s1">inserts[end] += </span><span class="s2">')'</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">inserts[end] = </span><span class="s2">')'</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i of range(start + </span><span class="s4">1</span><span class="s1">, end)) {</span>
                        <span class="s1">inserts[i] = </span><span class="s2">'|'</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// collect all actions format strings</span>
        <span class="s3">let </span><span class="s1">parts = []</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[ i, action ] of Object.entries(actions)) {</span>

            <span class="s0">// suppressed arguments are marked with None</span>
            <span class="s0">// remove | separators for suppressed arguments</span>
            <span class="s3">if </span><span class="s1">(action.help === SUPPRESS) {</span>
                <span class="s1">parts.push(undefined)</span>
                <span class="s3">if </span><span class="s1">(inserts[+i] === </span><span class="s2">'|'</span><span class="s1">) {</span>
                    <span class="s3">delete </span><span class="s1">inserts[+i]</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(inserts[+i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'|'</span><span class="s1">) {</span>
                    <span class="s3">delete </span><span class="s1">inserts[+i + </span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">}</span>

            <span class="s0">// produce all arg strings</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!action.option_strings.length) {</span>
                <span class="s3">let </span><span class="s1">default_value = </span><span class="s3">this</span><span class="s1">._get_default_metavar_for_positional(action)</span>
                <span class="s3">let </span><span class="s1">part = </span><span class="s3">this</span><span class="s1">._format_args(action, default_value)</span>

                <span class="s0">// if it's in a group, strip the outer []</span>
                <span class="s3">if </span><span class="s1">(group_actions.has(action)) {</span>
                    <span class="s3">if </span><span class="s1">(part[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'[' </span><span class="s1">&amp;&amp; part[part.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s2">']'</span><span class="s1">) {</span>
                        <span class="s1">part = part.slice(</span><span class="s4">1</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s0">// add the action string to the list</span>
                <span class="s1">parts.push(part)</span>

            <span class="s0">// produce the first way to invoke the option in brackets</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">let </span><span class="s1">option_string = action.option_strings[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s3">let </span><span class="s1">part</span>

                <span class="s0">// if the Optional doesn't take a value, format is:</span>
                <span class="s0">//    -s or --long</span>
                <span class="s3">if </span><span class="s1">(action.nargs === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">part = action.format_usage()</span>

                <span class="s0">// if the Optional takes a value, format is:</span>
                <span class="s0">//    -s ARGS or --long ARGS</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">let </span><span class="s1">default_value = </span><span class="s3">this</span><span class="s1">._get_default_metavar_for_optional(action)</span>
                    <span class="s3">let </span><span class="s1">args_string = </span><span class="s3">this</span><span class="s1">._format_args(action, default_value)</span>
                    <span class="s1">part = sub(</span><span class="s2">'%s %s'</span><span class="s1">, option_string, args_string)</span>
                <span class="s1">}</span>

                <span class="s0">// make it look optional if it's not required or in a group</span>
                <span class="s3">if </span><span class="s1">(!action.required &amp;&amp; !group_actions.has(action)) {</span>
                    <span class="s1">part = sub(</span><span class="s2">'[%s]'</span><span class="s1">, part)</span>
                <span class="s1">}</span>

                <span class="s0">// add the action string to the list</span>
                <span class="s1">parts.push(part)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// insert things at the necessary indices</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i of Object.keys(inserts).map(Number).sort((a, b) =&gt; b - a)) {</span>
            <span class="s1">parts.splice(+i, </span><span class="s4">0</span><span class="s1">, inserts[+i])</span>
        <span class="s1">}</span>

        <span class="s0">// join all the action items with spaces</span>
        <span class="s3">let </span><span class="s1">text = parts.filter(Boolean).join(</span><span class="s2">' '</span><span class="s1">)</span>

        <span class="s0">// clean up separators for mutually exclusive groups</span>
        <span class="s1">text = text.replace(</span><span class="s5">/([\[(]) /g</span><span class="s1">, </span><span class="s2">'$1'</span><span class="s1">)</span>
        <span class="s1">text = text.replace(</span><span class="s5">/ ([\])])/g</span><span class="s1">, </span><span class="s2">'$1'</span><span class="s1">)</span>
        <span class="s1">text = text.replace(</span><span class="s5">/[\[(] *[\])]/g</span><span class="s1">, </span><span class="s2">''</span><span class="s1">)</span>
        <span class="s1">text = text.replace(</span><span class="s5">/\(([^|]*)\)/g</span><span class="s1">, </span><span class="s2">'$1'</span><span class="s1">, text)</span>
        <span class="s1">text = text.trim()</span>

        <span class="s0">// return the text</span>
        <span class="s3">return </span><span class="s1">text</span>
    <span class="s1">}</span>

    <span class="s1">_format_text(text) {</span>
        <span class="s3">if </span><span class="s1">(text.includes(</span><span class="s2">'%(prog)'</span><span class="s1">)) {</span>
            <span class="s1">text = sub(text, { prog: </span><span class="s3">this</span><span class="s1">._prog })</span>
        <span class="s1">}</span>
        <span class="s3">let </span><span class="s1">text_width = Math.max(</span><span class="s3">this</span><span class="s1">._width - </span><span class="s3">this</span><span class="s1">._current_indent, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s3">let </span><span class="s1">indent = </span><span class="s2">' '</span><span class="s1">.repeat(</span><span class="s3">this</span><span class="s1">._current_indent)</span>
        <span class="s3">return this</span><span class="s1">._fill_text(text, text_width, indent) + </span><span class="s2">'</span><span class="s6">\n\n</span><span class="s2">'</span>
    <span class="s1">}</span>

    <span class="s1">_format_action(action) {</span>
        <span class="s0">// determine the required width and the entry label</span>
        <span class="s3">let </span><span class="s1">help_position = Math.min(</span><span class="s3">this</span><span class="s1">._action_max_length + </span><span class="s4">2</span><span class="s1">,</span>
                                     <span class="s3">this</span><span class="s1">._max_help_position)</span>
        <span class="s3">let </span><span class="s1">help_width = Math.max(</span><span class="s3">this</span><span class="s1">._width - help_position, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s3">let </span><span class="s1">action_width = help_position - </span><span class="s3">this</span><span class="s1">._current_indent - </span><span class="s4">2</span>
        <span class="s3">let </span><span class="s1">action_header = </span><span class="s3">this</span><span class="s1">._format_action_invocation(action)</span>
        <span class="s3">let </span><span class="s1">indent_first</span>

        <span class="s0">// no help; start on same line and add a final newline</span>
        <span class="s3">if </span><span class="s1">(!action.help) {</span>
            <span class="s3">let </span><span class="s1">tup = [ </span><span class="s3">this</span><span class="s1">._current_indent, </span><span class="s2">''</span><span class="s1">, action_header ]</span>
            <span class="s1">action_header = sub(</span><span class="s2">'%*s%s</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">, ...tup)</span>

        <span class="s0">// short action name; start on the same line and pad two spaces</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action_header.length &lt;= action_width) {</span>
            <span class="s3">let </span><span class="s1">tup = [ </span><span class="s3">this</span><span class="s1">._current_indent, </span><span class="s2">''</span><span class="s1">, action_width, action_header ]</span>
            <span class="s1">action_header = sub(</span><span class="s2">'%*s%-*s  '</span><span class="s1">, ...tup)</span>
            <span class="s1">indent_first = </span><span class="s4">0</span>

        <span class="s0">// long action name; start on the next line</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">let </span><span class="s1">tup = [ </span><span class="s3">this</span><span class="s1">._current_indent, </span><span class="s2">''</span><span class="s1">, action_header ]</span>
            <span class="s1">action_header = sub(</span><span class="s2">'%*s%s</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">, ...tup)</span>
            <span class="s1">indent_first = help_position</span>
        <span class="s1">}</span>

        <span class="s0">// collect the pieces of the action help</span>
        <span class="s3">let </span><span class="s1">parts = [action_header]</span>

        <span class="s0">// if there was help for the action, add lines of help text</span>
        <span class="s3">if </span><span class="s1">(action.help) {</span>
            <span class="s3">let </span><span class="s1">help_text = </span><span class="s3">this</span><span class="s1">._expand_help(action)</span>
            <span class="s3">let </span><span class="s1">help_lines = </span><span class="s3">this</span><span class="s1">._split_lines(help_text, help_width)</span>
            <span class="s1">parts.push(sub(</span><span class="s2">'%*s%s</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">, indent_first, </span><span class="s2">''</span><span class="s1">, help_lines[</span><span class="s4">0</span><span class="s1">]))</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">line of help_lines.slice(</span><span class="s4">1</span><span class="s1">)) {</span>
                <span class="s1">parts.push(sub(</span><span class="s2">'%*s%s</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">, help_position, </span><span class="s2">''</span><span class="s1">, line))</span>
            <span class="s1">}</span>

        <span class="s0">// or add a newline if the description doesn't end with one</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!action_header.endsWith(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">)) {</span>
            <span class="s1">parts.push(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s0">// if there are any sub-actions, add their help as well</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">subaction of </span><span class="s3">this</span><span class="s1">._iter_indented_subactions(action)) {</span>
            <span class="s1">parts.push(</span><span class="s3">this</span><span class="s1">._format_action(subaction))</span>
        <span class="s1">}</span>

        <span class="s0">// return a single string</span>
        <span class="s3">return this</span><span class="s1">._join_parts(parts)</span>
    <span class="s1">}</span>

    <span class="s1">_format_action_invocation(action) {</span>
        <span class="s3">if </span><span class="s1">(!action.option_strings.length) {</span>
            <span class="s3">let </span><span class="s1">default_value = </span><span class="s3">this</span><span class="s1">._get_default_metavar_for_positional(action)</span>
            <span class="s3">let </span><span class="s1">metavar = </span><span class="s3">this</span><span class="s1">._metavar_formatter(action, default_value)(</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s3">return </span><span class="s1">metavar</span>

        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">let </span><span class="s1">parts = []</span>

            <span class="s0">// if the Optional doesn't take a value, format is:</span>
            <span class="s0">//    -s, --long</span>
            <span class="s3">if </span><span class="s1">(action.nargs === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">parts = parts.concat(action.option_strings)</span>

            <span class="s0">// if the Optional takes a value, format is:</span>
            <span class="s0">//    -s ARGS, --long ARGS</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">let </span><span class="s1">default_value = </span><span class="s3">this</span><span class="s1">._get_default_metavar_for_optional(action)</span>
                <span class="s3">let </span><span class="s1">args_string = </span><span class="s3">this</span><span class="s1">._format_args(action, default_value)</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">option_string of action.option_strings) {</span>
                    <span class="s1">parts.push(sub(</span><span class="s2">'%s %s'</span><span class="s1">, option_string, args_string))</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">parts.join(</span><span class="s2">', '</span><span class="s1">)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">_metavar_formatter(action, default_metavar) {</span>
        <span class="s3">let </span><span class="s1">result</span>
        <span class="s3">if </span><span class="s1">(action.metavar !== undefined) {</span>
            <span class="s1">result = action.metavar</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.choices !== undefined) {</span>
            <span class="s3">let </span><span class="s1">choice_strs = _choices_to_array(action.choices).map(String)</span>
            <span class="s1">result = sub(</span><span class="s2">'{%s}'</span><span class="s1">, choice_strs.join(</span><span class="s2">','</span><span class="s1">))</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">result = default_metavar</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">format(tuple_size) {</span>
            <span class="s3">if </span><span class="s1">(Array.isArray(result)) {</span>
                <span class="s3">return </span><span class="s1">result</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s1">Array(tuple_size).fill(result)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">format</span>
    <span class="s1">}</span>

    <span class="s1">_format_args(action, default_metavar) {</span>
        <span class="s3">let </span><span class="s1">get_metavar = </span><span class="s3">this</span><span class="s1">._metavar_formatter(action, default_metavar)</span>
        <span class="s3">let </span><span class="s1">result</span>
        <span class="s3">if </span><span class="s1">(action.nargs === undefined) {</span>
            <span class="s1">result = sub(</span><span class="s2">'%s'</span><span class="s1">, ...get_metavar(</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === OPTIONAL) {</span>
            <span class="s1">result = sub(</span><span class="s2">'[%s]'</span><span class="s1">, ...get_metavar(</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === ZERO_OR_MORE) {</span>
            <span class="s3">let </span><span class="s1">metavar = get_metavar(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">(metavar.length === </span><span class="s4">2</span><span class="s1">) {</span>
                <span class="s1">result = sub(</span><span class="s2">'[%s [%s ...]]'</span><span class="s1">, ...metavar)</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">result = sub(</span><span class="s2">'[%s ...]'</span><span class="s1">, ...metavar)</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === ONE_OR_MORE) {</span>
            <span class="s1">result = sub(</span><span class="s2">'%s [%s ...]'</span><span class="s1">, ...get_metavar(</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === REMAINDER) {</span>
            <span class="s1">result = </span><span class="s2">'...'</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === PARSER) {</span>
            <span class="s1">result = sub(</span><span class="s2">'%s ...'</span><span class="s1">, ...get_metavar(</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === SUPPRESS) {</span>
            <span class="s1">result = </span><span class="s2">''</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">let </span><span class="s1">formats</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">formats = range(action.nargs).map(() =&gt; </span><span class="s2">'%s'</span><span class="s1">)</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'invalid nargs value'</span><span class="s1">)</span>
            <span class="s1">}</span>
            <span class="s1">result = sub(formats.join(</span><span class="s2">' '</span><span class="s1">), ...get_metavar(action.nargs))</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">result</span>
    <span class="s1">}</span>

    <span class="s1">_expand_help(action) {</span>
        <span class="s3">let </span><span class="s1">params = Object.assign({ prog: </span><span class="s3">this</span><span class="s1">._prog }, action)</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">name of Object.keys(params)) {</span>
            <span class="s3">if </span><span class="s1">(params[name] === SUPPRESS) {</span>
                <span class="s3">delete </span><span class="s1">params[name]</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">name of Object.keys(params)) {</span>
            <span class="s3">if </span><span class="s1">(params[name] &amp;&amp; params[name].name) {</span>
                <span class="s1">params[name] = params[name].name</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(params.choices !== undefined) {</span>
            <span class="s3">let </span><span class="s1">choices_str = _choices_to_array(params.choices).map(String).join(</span><span class="s2">', '</span><span class="s1">)</span>
            <span class="s1">params.choices = choices_str</span>
        <span class="s1">}</span>
        <span class="s0">// LEGACY (v1 compatibility): camelcase</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">key of Object.keys(params)) {</span>
            <span class="s3">let </span><span class="s1">old_name = _to_legacy_name(key)</span>
            <span class="s3">if </span><span class="s1">(old_name !== key) {</span>
                <span class="s1">params[old_name] = params[key]</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// end</span>
        <span class="s3">return </span><span class="s1">sub(</span><span class="s3">this</span><span class="s1">._get_help_string(action), params)</span>
    <span class="s1">}</span>

    <span class="s1">* _iter_indented_subactions(action) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">action._get_subactions === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s3">this</span><span class="s1">._indent()</span>
            <span class="s3">yield</span><span class="s1">* action._get_subactions()</span>
            <span class="s3">this</span><span class="s1">._dedent()</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">_split_lines(text, width) {</span>
        <span class="s1">text = text.replace(</span><span class="s3">this</span><span class="s1">._whitespace_matcher, </span><span class="s2">' '</span><span class="s1">).trim()</span>
        <span class="s0">// The textwrap module is used only for formatting help.</span>
        <span class="s0">// Delay its import for speeding up the common usage of argparse.</span>
        <span class="s3">let </span><span class="s1">textwrap = require(</span><span class="s2">'./lib/textwrap'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">textwrap.wrap(text, { width })</span>
    <span class="s1">}</span>

    <span class="s1">_fill_text(text, width, indent) {</span>
        <span class="s1">text = text.replace(</span><span class="s3">this</span><span class="s1">._whitespace_matcher, </span><span class="s2">' '</span><span class="s1">).trim()</span>
        <span class="s3">let </span><span class="s1">textwrap = require(</span><span class="s2">'./lib/textwrap'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">textwrap.fill(text, { width,</span>
                                     <span class="s1">initial_indent: indent,</span>
                                     <span class="s1">subsequent_indent: indent })</span>
    <span class="s1">}</span>

    <span class="s1">_get_help_string(action) {</span>
        <span class="s3">return </span><span class="s1">action.help</span>
    <span class="s1">}</span>

    <span class="s1">_get_default_metavar_for_optional(action) {</span>
        <span class="s3">return </span><span class="s1">action.dest.toUpperCase()</span>
    <span class="s1">}</span>

    <span class="s1">_get_default_metavar_for_positional(action) {</span>
        <span class="s3">return </span><span class="s1">action.dest</span>
    <span class="s1">}</span>
<span class="s1">}))</span>

<span class="s1">HelpFormatter.prototype._Section = _callable(</span><span class="s3">class </span><span class="s1">_Section {</span>

    <span class="s1">constructor(formatter, parent, heading = undefined) {</span>
        <span class="s3">this</span><span class="s1">.formatter = formatter</span>
        <span class="s3">this</span><span class="s1">.parent = parent</span>
        <span class="s3">this</span><span class="s1">.heading = heading</span>
        <span class="s3">this</span><span class="s1">.items = []</span>
    <span class="s1">}</span>

    <span class="s1">format_help() {</span>
        <span class="s0">// format the indented section</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.parent !== undefined) {</span>
            <span class="s3">this</span><span class="s1">.formatter._indent()</span>
        <span class="s1">}</span>
        <span class="s3">let </span><span class="s1">item_help = </span><span class="s3">this</span><span class="s1">.formatter._join_parts(</span><span class="s3">this</span><span class="s1">.items.map(([ func, args ]) =&gt; func.apply(</span><span class="s3">null</span><span class="s1">, args)))</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.parent !== undefined) {</span>
            <span class="s3">this</span><span class="s1">.formatter._dedent()</span>
        <span class="s1">}</span>

        <span class="s0">// return nothing if the section was empty</span>
        <span class="s3">if </span><span class="s1">(!item_help) {</span>
            <span class="s3">return </span><span class="s2">''</span>
        <span class="s1">}</span>

        <span class="s0">// add the heading if the section was non-empty</span>
        <span class="s3">let </span><span class="s1">heading</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.heading !== SUPPRESS &amp;&amp; </span><span class="s3">this</span><span class="s1">.heading !== undefined) {</span>
            <span class="s3">let </span><span class="s1">current_indent = </span><span class="s3">this</span><span class="s1">.formatter._current_indent</span>
            <span class="s1">heading = sub(</span><span class="s2">'%*s%s:</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">, current_indent, </span><span class="s2">''</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.heading)</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">heading = </span><span class="s2">''</span>
        <span class="s1">}</span>

        <span class="s0">// join the section-initial newline, the heading and the help</span>
        <span class="s3">return this</span><span class="s1">.formatter._join_parts([</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">, heading, item_help, </span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">])</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">RawDescriptionHelpFormatter = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">RawDescriptionHelpFormatter </span><span class="s3">extends </span><span class="s1">HelpFormatter {</span>
    <span class="s0">/* 
     *  Help message formatter which retains any formatting in descriptions. 
     * 
     *  Only the name of this class is considered a public API. All the methods 
     *  provided by the class are considered an implementation detail. 
     */</span>

    <span class="s1">_fill_text(text, width, indent) {</span>
        <span class="s3">return </span><span class="s1">splitlines(text, </span><span class="s3">true</span><span class="s1">).map(line =&gt; indent + line).join(</span><span class="s2">''</span><span class="s1">)</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s3">const </span><span class="s1">RawTextHelpFormatter = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">RawTextHelpFormatter </span><span class="s3">extends </span><span class="s1">RawDescriptionHelpFormatter {</span>
    <span class="s0">/* 
     *  Help message formatter which retains formatting of all help text. 
     * 
     *  Only the name of this class is considered a public API. All the methods 
     *  provided by the class are considered an implementation detail. 
     */</span>

    <span class="s1">_split_lines(text</span><span class="s0">/*, width*/</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">splitlines(text)</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s3">const </span><span class="s1">ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">ArgumentDefaultsHelpFormatter </span><span class="s3">extends </span><span class="s1">HelpFormatter {</span>
    <span class="s0">/* 
     *  Help message formatter which adds default values to argument help. 
     * 
     *  Only the name of this class is considered a public API. All the methods 
     *  provided by the class are considered an implementation detail. 
     */</span>

    <span class="s1">_get_help_string(action) {</span>
        <span class="s3">let </span><span class="s1">help = action.help</span>
        <span class="s0">// LEGACY (v1 compatibility): additional check for defaultValue needed</span>
        <span class="s3">if </span><span class="s1">(!action.help.includes(</span><span class="s2">'%(default)'</span><span class="s1">) &amp;&amp; !action.help.includes(</span><span class="s2">'%(defaultValue)'</span><span class="s1">)) {</span>
            <span class="s3">if </span><span class="s1">(action.default !== SUPPRESS) {</span>
                <span class="s3">let </span><span class="s1">defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]</span>
                <span class="s3">if </span><span class="s1">(action.option_strings.length || defaulting_nargs.includes(action.nargs)) {</span>
                    <span class="s1">help += </span><span class="s2">' (default: %(default)s)'</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">help</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s3">const </span><span class="s1">MetavarTypeHelpFormatter = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">MetavarTypeHelpFormatter </span><span class="s3">extends </span><span class="s1">HelpFormatter {</span>
    <span class="s0">/* 
     *  Help message formatter which uses the argument 'type' as the default 
     *  metavar value (instead of the argument 'dest') 
     * 
     *  Only the name of this class is considered a public API. All the methods 
     *  provided by the class are considered an implementation detail. 
     */</span>

    <span class="s1">_get_default_metavar_for_optional(action) {</span>
        <span class="s3">return typeof </span><span class="s1">action.type === </span><span class="s2">'function' </span><span class="s1">? action.type.name : action.type</span>
    <span class="s1">}</span>

    <span class="s1">_get_default_metavar_for_positional(action) {</span>
        <span class="s3">return typeof </span><span class="s1">action.type === </span><span class="s2">'function' </span><span class="s1">? action.type.name : action.type</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s0">// =====================</span>
<span class="s0">// Options and Arguments</span>
<span class="s0">// =====================</span>
<span class="s3">function </span><span class="s1">_get_action_name(argument) {</span>
    <span class="s3">if </span><span class="s1">(argument === undefined) {</span>
        <span class="s3">return </span><span class="s1">undefined</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(argument.option_strings.length) {</span>
        <span class="s3">return </span><span class="s1">argument.option_strings.join(</span><span class="s2">'/'</span><span class="s1">)</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(![ undefined, SUPPRESS ].includes(argument.metavar)) {</span>
        <span class="s3">return </span><span class="s1">argument.metavar</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(![ undefined, SUPPRESS ].includes(argument.dest)) {</span>
        <span class="s3">return </span><span class="s1">argument.dest</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">undefined</span>
    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s3">const </span><span class="s1">ArgumentError = _callable(</span><span class="s3">class </span><span class="s1">ArgumentError </span><span class="s3">extends </span><span class="s1">Error {</span>
    <span class="s0">/* 
     *  An error from creating or using an argument (optional or positional). 
     * 
     *  The string value of this exception is the message, augmented with 
     *  information about the argument that caused it. 
     */</span>

    <span class="s1">constructor(argument, message) {</span>
        <span class="s3">super</span><span class="s1">()</span>
        <span class="s3">this</span><span class="s1">.name = </span><span class="s2">'ArgumentError'</span>
        <span class="s3">this</span><span class="s1">._argument_name = _get_action_name(argument)</span>
        <span class="s3">this</span><span class="s1">._message = message</span>
        <span class="s3">this</span><span class="s1">.message = </span><span class="s3">this</span><span class="s1">.str()</span>
    <span class="s1">}</span>

    <span class="s1">str() {</span>
        <span class="s3">let </span><span class="s1">format</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._argument_name === undefined) {</span>
            <span class="s1">format = </span><span class="s2">'%(message)s'</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">format = </span><span class="s2">'argument %(argument_name)s: %(message)s'</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">sub(format, { message: </span><span class="s3">this</span><span class="s1">._message,</span>
                             <span class="s1">argument_name: </span><span class="s3">this</span><span class="s1">._argument_name })</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">ArgumentTypeError = _callable(</span><span class="s3">class </span><span class="s1">ArgumentTypeError </span><span class="s3">extends </span><span class="s1">Error {</span>
    <span class="s0">/* 
     * An error from trying to convert a command line string to a type. 
     */</span>

    <span class="s1">constructor(message) {</span>
        <span class="s3">super</span><span class="s1">(message)</span>
        <span class="s3">this</span><span class="s1">.name = </span><span class="s2">'ArgumentTypeError'</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s0">// ==============</span>
<span class="s0">// Action classes</span>
<span class="s0">// ==============</span>
<span class="s3">const </span><span class="s1">Action = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">Action </span><span class="s3">extends </span><span class="s1">_AttributeHolder(Function) {</span>
    <span class="s0">/* 
     *  Information about how to convert command line strings to Python objects. 
     * 
     *  Action objects are used by an ArgumentParser to represent the information 
     *  needed to parse a single argument from one or more strings from the 
     *  command line. The keyword arguments to the Action constructor are also 
     *  all attributes of Action instances. 
     * 
     *  Keyword Arguments: 
     * 
     *      - option_strings -- A list of command-line option strings which 
     *          should be associated with this action. 
     * 
     *      - dest -- The name of the attribute to hold the created object(s) 
     * 
     *      - nargs -- The number of command-line arguments that should be 
     *          consumed. By default, one argument will be consumed and a single 
     *          value will be produced.  Other values include: 
     *              - N (an integer) consumes N arguments (and produces a list) 
     *              - '?' consumes zero or one arguments 
     *              - '*' consumes zero or more arguments (and produces a list) 
     *              - '+' consumes one or more arguments (and produces a list) 
     *          Note that the difference between the default and nargs=1 is that 
     *          with the default, a single value will be produced, while with 
     *          nargs=1, a list containing a single value will be produced. 
     * 
     *      - const -- The value to be produced if the option is specified and the 
     *          option uses an action that takes no values. 
     * 
     *      - default -- The value to be produced if the option is not specified. 
     * 
     *      - type -- A callable that accepts a single string argument, and 
     *          returns the converted value.  The standard Python types str, int, 
     *          float, and complex are useful examples of such callables.  If None, 
     *          str is used. 
     * 
     *      - choices -- A container of values that should be allowed. If not None, 
     *          after a command-line argument has been converted to the appropriate 
     *          type, an exception will be raised if it is not a member of this 
     *          collection. 
     * 
     *      - required -- True if the action must always be specified at the 
     *          command line. This is only meaningful for optional command-line 
     *          arguments. 
     * 
     *      - help -- The help string describing the argument. 
     * 
     *      - metavar -- The name to be used for the option's argument with the 
     *          help string. If None, the 'dest' value will be used as the name. 
     */</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs,</span>
            <span class="s1">const_value,</span>
            <span class="s1">default_value,</span>
            <span class="s1">type,</span>
            <span class="s1">choices,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s1">nargs: undefined,</span>
            <span class="s3">const</span><span class="s1">: undefined,</span>
            <span class="s3">default</span><span class="s1">: undefined,</span>
            <span class="s1">type: undefined,</span>
            <span class="s1">choices: undefined,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined,</span>
            <span class="s1">metavar: undefined</span>
        <span class="s1">})</span>

        <span class="s0">// when this class is called as a function, redirect it to .call() method of itself</span>
        <span class="s3">super</span><span class="s1">(</span><span class="s2">'return arguments.callee.call.apply(arguments.callee, arguments)'</span><span class="s1">)</span>

        <span class="s3">this</span><span class="s1">.option_strings = option_strings</span>
        <span class="s3">this</span><span class="s1">.dest = dest</span>
        <span class="s3">this</span><span class="s1">.nargs = nargs</span>
        <span class="s3">this</span><span class="s1">.const = const_value</span>
        <span class="s3">this</span><span class="s1">.default = default_value</span>
        <span class="s3">this</span><span class="s1">.type = type</span>
        <span class="s3">this</span><span class="s1">.choices = choices</span>
        <span class="s3">this</span><span class="s1">.required = required</span>
        <span class="s3">this</span><span class="s1">.help = help</span>
        <span class="s3">this</span><span class="s1">.metavar = metavar</span>
    <span class="s1">}</span>

    <span class="s1">_get_kwargs() {</span>
        <span class="s3">let </span><span class="s1">names = [</span>
            <span class="s2">'option_strings'</span><span class="s1">,</span>
            <span class="s2">'dest'</span><span class="s1">,</span>
            <span class="s2">'nargs'</span><span class="s1">,</span>
            <span class="s2">'const'</span><span class="s1">,</span>
            <span class="s2">'default'</span><span class="s1">,</span>
            <span class="s2">'type'</span><span class="s1">,</span>
            <span class="s2">'choices'</span><span class="s1">,</span>
            <span class="s2">'help'</span><span class="s1">,</span>
            <span class="s2">'metavar'</span>
        <span class="s1">]</span>
        <span class="s3">return </span><span class="s1">names.map(name =&gt; [ name, getattr(</span><span class="s3">this</span><span class="s1">, name) ])</span>
    <span class="s1">}</span>

    <span class="s1">format_usage() {</span>
        <span class="s3">return this</span><span class="s1">.option_strings[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">}</span>

    <span class="s1">call(</span><span class="s0">/*parser, namespace, values, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'.call() not defined'</span><span class="s1">)</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s3">const </span><span class="s1">BooleanOptionalAction = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">BooleanOptionalAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">default_value,</span>
            <span class="s1">type,</span>
            <span class="s1">choices,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s3">default</span><span class="s1">: undefined,</span>
            <span class="s1">type: undefined,</span>
            <span class="s1">choices: undefined,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined,</span>
            <span class="s1">metavar: undefined</span>
        <span class="s1">})</span>

        <span class="s3">let </span><span class="s1">_option_strings = []</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">option_string of option_strings) {</span>
            <span class="s1">_option_strings.push(option_string)</span>

            <span class="s3">if </span><span class="s1">(option_string.startsWith(</span><span class="s2">'--'</span><span class="s1">)) {</span>
                <span class="s1">option_string = </span><span class="s2">'--no-' </span><span class="s1">+ option_string.slice(</span><span class="s4">2</span><span class="s1">)</span>
                <span class="s1">_option_strings.push(option_string)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(help !== undefined &amp;&amp; default_value !== undefined) {</span>
            <span class="s1">help += </span><span class="s2">` (default: </span><span class="s1">${default_value}</span><span class="s2">)`</span>
        <span class="s1">}</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings: _option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">type,</span>
            <span class="s1">choices,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s1">call(parser, namespace, values, option_string = undefined) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.option_strings.includes(option_string)) {</span>
            <span class="s1">setattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, !option_string.startsWith(</span><span class="s2">'--no-'</span><span class="s1">))</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">format_usage() {</span>
        <span class="s3">return this</span><span class="s1">.option_strings.join(</span><span class="s2">' | '</span><span class="s1">)</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s3">const </span><span class="s1">_StoreAction = _callable(</span><span class="s3">class </span><span class="s1">_StoreAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs,</span>
            <span class="s1">const_value,</span>
            <span class="s1">default_value,</span>
            <span class="s1">type,</span>
            <span class="s1">choices,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s1">nargs: undefined,</span>
            <span class="s3">const</span><span class="s1">: undefined,</span>
            <span class="s3">default</span><span class="s1">: undefined,</span>
            <span class="s1">type: undefined,</span>
            <span class="s1">choices: undefined,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined,</span>
            <span class="s1">metavar: undefined</span>
        <span class="s1">})</span>

        <span class="s3">if </span><span class="s1">(nargs === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'nargs for store actions must be != 0; if you ' </span><span class="s1">+</span>
                        <span class="s2">'have nothing to store, actions such as store ' </span><span class="s1">+</span>
                        <span class="s2">'true or store const may be more appropriate'</span><span class="s1">)</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(const_value !== undefined &amp;&amp; nargs !== OPTIONAL) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'nargs must be %r to supply const'</span><span class="s1">, OPTIONAL))</span>
        <span class="s1">}</span>
        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs,</span>
            <span class="s3">const</span><span class="s1">: const_value,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">type,</span>
            <span class="s1">choices,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s1">call(parser, namespace, values</span><span class="s0">/*, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s1">setattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, values)</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_StoreConstAction = _callable(</span><span class="s3">class </span><span class="s1">_StoreConstAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">const_value,</span>
            <span class="s1">default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help</span>
            <span class="s0">//, metavar</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s3">const</span><span class="s1">: no_default,</span>
            <span class="s3">default</span><span class="s1">: undefined,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined,</span>
            <span class="s1">metavar: undefined</span>
        <span class="s1">})</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s3">const</span><span class="s1">: const_value,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help</span>
        <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s1">call(parser, namespace</span><span class="s0">/*, values, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s1">setattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, </span><span class="s3">this</span><span class="s1">.const)</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_StoreTrueAction = _callable(</span><span class="s3">class </span><span class="s1">_StoreTrueAction </span><span class="s3">extends </span><span class="s1">_StoreConstAction {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s3">default</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined</span>
        <span class="s1">})</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s3">const</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help</span>
        <span class="s1">})</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_StoreFalseAction = _callable(</span><span class="s3">class </span><span class="s1">_StoreFalseAction </span><span class="s3">extends </span><span class="s1">_StoreConstAction {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s3">default</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined</span>
        <span class="s1">})</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s3">const</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help</span>
        <span class="s1">})</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_AppendAction = _callable(</span><span class="s3">class </span><span class="s1">_AppendAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs,</span>
            <span class="s1">const_value,</span>
            <span class="s1">default_value,</span>
            <span class="s1">type,</span>
            <span class="s1">choices,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s1">nargs: undefined,</span>
            <span class="s3">const</span><span class="s1">: undefined,</span>
            <span class="s3">default</span><span class="s1">: undefined,</span>
            <span class="s1">type: undefined,</span>
            <span class="s1">choices: undefined,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined,</span>
            <span class="s1">metavar: undefined</span>
        <span class="s1">})</span>

        <span class="s3">if </span><span class="s1">(nargs === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'nargs for append actions must be != 0; if arg ' </span><span class="s1">+</span>
                        <span class="s2">'strings are not supplying the value to append, ' </span><span class="s1">+</span>
                        <span class="s2">'the append const action may be more appropriate'</span><span class="s1">)</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(const_value !== undefined &amp;&amp; nargs !== OPTIONAL) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'nargs must be %r to supply const'</span><span class="s1">, OPTIONAL))</span>
        <span class="s1">}</span>
        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs,</span>
            <span class="s3">const</span><span class="s1">: const_value,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">type,</span>
            <span class="s1">choices,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s1">call(parser, namespace, values</span><span class="s0">/*, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s3">let </span><span class="s1">items = getattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, undefined)</span>
        <span class="s1">items = _copy_items(items)</span>
        <span class="s1">items.push(values)</span>
        <span class="s1">setattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, items)</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_AppendConstAction = _callable(</span><span class="s3">class </span><span class="s1">_AppendConstAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">const_value,</span>
            <span class="s1">default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s3">const</span><span class="s1">: no_default,</span>
            <span class="s3">default</span><span class="s1">: undefined,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined,</span>
            <span class="s1">metavar: undefined</span>
        <span class="s1">})</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s3">const</span><span class="s1">: const_value,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s1">call(parser, namespace</span><span class="s0">/*, values, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s3">let </span><span class="s1">items = getattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, undefined)</span>
        <span class="s1">items = _copy_items(items)</span>
        <span class="s1">items.push(</span><span class="s3">this</span><span class="s1">.const)</span>
        <span class="s1">setattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, items)</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_CountAction = _callable(</span><span class="s3">class </span><span class="s1">_CountAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: no_default,</span>
            <span class="s3">default</span><span class="s1">: undefined,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined</span>
        <span class="s1">})</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">required,</span>
            <span class="s1">help</span>
        <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s1">call(parser, namespace</span><span class="s0">/*, values, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s3">let </span><span class="s1">count = getattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, undefined)</span>
        <span class="s3">if </span><span class="s1">(count === undefined) {</span>
            <span class="s1">count = </span><span class="s4">0</span>
        <span class="s1">}</span>
        <span class="s1">setattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, count + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_HelpAction = _callable(</span><span class="s3">class </span><span class="s1">_HelpAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">default_value,</span>
            <span class="s1">help</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">dest: SUPPRESS,</span>
            <span class="s3">default</span><span class="s1">: SUPPRESS,</span>
            <span class="s1">help: undefined</span>
        <span class="s1">})</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">nargs: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">help</span>
        <span class="s1">})</span>
    <span class="s1">}</span>

    <span class="s1">call(parser</span><span class="s0">/*, namespace, values, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s1">parser.print_help()</span>
        <span class="s1">parser.exit()</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_VersionAction = _callable(</span><span class="s3">class </span><span class="s1">_VersionAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">version,</span>
            <span class="s1">dest,</span>
            <span class="s1">default_value,</span>
            <span class="s1">help</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">version: undefined,</span>
            <span class="s1">dest: SUPPRESS,</span>
            <span class="s3">default</span><span class="s1">: SUPPRESS,</span>
            <span class="s1">help: </span><span class="s2">&quot;show program's version number and exit&quot;</span>
        <span class="s1">})</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s3">default</span><span class="s1">: default_value,</span>
            <span class="s1">nargs: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">help</span>
        <span class="s1">})</span>
        <span class="s3">this</span><span class="s1">.version = version</span>
    <span class="s1">}</span>

    <span class="s1">call(parser</span><span class="s0">/*, namespace, values, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s3">let </span><span class="s1">version = </span><span class="s3">this</span><span class="s1">.version</span>
        <span class="s3">if </span><span class="s1">(version === undefined) {</span>
            <span class="s1">version = parser.version</span>
        <span class="s1">}</span>
        <span class="s3">let </span><span class="s1">formatter = parser._get_formatter()</span>
        <span class="s1">formatter.add_text(version)</span>
        <span class="s1">parser._print_message(formatter.format_help(), process.stdout)</span>
        <span class="s1">parser.exit()</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_SubParsersAction = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">_SubParsersAction </span><span class="s3">extends </span><span class="s1">Action {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">option_strings,</span>
            <span class="s1">prog,</span>
            <span class="s1">parser_class,</span>
            <span class="s1">dest,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">option_strings: no_default,</span>
            <span class="s1">prog: no_default,</span>
            <span class="s1">parser_class: no_default,</span>
            <span class="s1">dest: SUPPRESS,</span>
            <span class="s1">required: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">help: undefined,</span>
            <span class="s1">metavar: undefined</span>
        <span class="s1">})</span>

        <span class="s3">let </span><span class="s1">name_parser_map = {}</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">option_strings,</span>
            <span class="s1">dest,</span>
            <span class="s1">nargs: PARSER,</span>
            <span class="s1">choices: name_parser_map,</span>
            <span class="s1">required,</span>
            <span class="s1">help,</span>
            <span class="s1">metavar</span>
        <span class="s1">})</span>

        <span class="s3">this</span><span class="s1">._prog_prefix = prog</span>
        <span class="s3">this</span><span class="s1">._parser_class = parser_class</span>
        <span class="s3">this</span><span class="s1">._name_parser_map = name_parser_map</span>
        <span class="s3">this</span><span class="s1">._choices_actions = []</span>
    <span class="s1">}</span>

    <span class="s1">add_parser() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">name,</span>
            <span class="s1">kwargs</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">name: no_default,</span>
            <span class="s2">'**kwargs'</span><span class="s1">: no_default</span>
        <span class="s1">})</span>

        <span class="s0">// set prog from the existing prefix</span>
        <span class="s3">if </span><span class="s1">(kwargs.prog === undefined) {</span>
            <span class="s1">kwargs.prog = sub(</span><span class="s2">'%s %s'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">._prog_prefix, name)</span>
        <span class="s1">}</span>

        <span class="s3">let </span><span class="s1">aliases = getattr(kwargs, </span><span class="s2">'aliases'</span><span class="s1">, [])</span>
        <span class="s3">delete </span><span class="s1">kwargs.aliases</span>

        <span class="s0">// create a pseudo-action to hold the choice help</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">'help' </span><span class="s3">in </span><span class="s1">kwargs) {</span>
            <span class="s3">let </span><span class="s1">help = kwargs.help</span>
            <span class="s3">delete </span><span class="s1">kwargs.help</span>
            <span class="s3">let </span><span class="s1">choice_action = </span><span class="s3">this</span><span class="s1">._ChoicesPseudoAction(name, aliases, help)</span>
            <span class="s3">this</span><span class="s1">._choices_actions.push(choice_action)</span>
        <span class="s1">}</span>

        <span class="s0">// create the parser and add it to the map</span>
        <span class="s3">let </span><span class="s1">parser = </span><span class="s3">new this</span><span class="s1">._parser_class(kwargs)</span>
        <span class="s3">this</span><span class="s1">._name_parser_map[name] = parser</span>

        <span class="s0">// make parser available under aliases also</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">alias of aliases) {</span>
            <span class="s3">this</span><span class="s1">._name_parser_map[alias] = parser</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">parser</span>
    <span class="s1">}</span>

    <span class="s1">_get_subactions() {</span>
        <span class="s3">return this</span><span class="s1">._choices_actions</span>
    <span class="s1">}</span>

    <span class="s1">call(parser, namespace, values</span><span class="s0">/*, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s3">let </span><span class="s1">parser_name = values[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">let </span><span class="s1">arg_strings = values.slice(</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0">// set the parser name if requested</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.dest !== SUPPRESS) {</span>
            <span class="s1">setattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, parser_name)</span>
        <span class="s1">}</span>

        <span class="s0">// select the parser</span>
        <span class="s3">if </span><span class="s1">(hasattr(</span><span class="s3">this</span><span class="s1">._name_parser_map, parser_name)) {</span>
            <span class="s1">parser = </span><span class="s3">this</span><span class="s1">._name_parser_map[parser_name]</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">let </span><span class="s1">args = {parser_name,</span>
                        <span class="s1">choices: </span><span class="s3">this</span><span class="s1">._name_parser_map.join(</span><span class="s2">', '</span><span class="s1">)}</span>
            <span class="s3">let </span><span class="s1">msg = sub(</span><span class="s2">'unknown parser %(parser_name)r (choices: %(choices)s)'</span><span class="s1">, args)</span>
            <span class="s3">throw new </span><span class="s1">ArgumentError(</span><span class="s3">this</span><span class="s1">, msg)</span>
        <span class="s1">}</span>

        <span class="s0">// parse all the remaining options into the namespace</span>
        <span class="s0">// store any unrecognized options on the object, so that the top</span>
        <span class="s0">// level parser can decide what to do with them</span>

        <span class="s0">// In case this subparser defines new defaults, we parse them</span>
        <span class="s0">// in a new namespace object and then update the original</span>
        <span class="s0">// namespace for the relevant parts.</span>
        <span class="s3">let </span><span class="s1">subnamespace</span>
        <span class="s1">[ subnamespace, arg_strings ] = parser.parse_known_args(arg_strings, undefined)</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[ key, value ] of Object.entries(subnamespace)) {</span>
            <span class="s1">setattr(namespace, key, value)</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(arg_strings.length) {</span>
            <span class="s1">setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, [])</span>
            <span class="s1">getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).push(...arg_strings)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s1">_SubParsersAction.prototype._ChoicesPseudoAction = _callable(</span><span class="s3">class </span><span class="s1">_ChoicesPseudoAction </span><span class="s3">extends </span><span class="s1">Action {</span>
    <span class="s1">constructor(name, aliases, help) {</span>
        <span class="s3">let </span><span class="s1">metavar = name, dest = name</span>
        <span class="s3">if </span><span class="s1">(aliases.length) {</span>
            <span class="s1">metavar += sub(</span><span class="s2">' (%s)'</span><span class="s1">, aliases.join(</span><span class="s2">', '</span><span class="s1">))</span>
        <span class="s1">}</span>
        <span class="s3">super</span><span class="s1">({ option_strings: [], dest, help, metavar })</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_ExtendAction = _callable(</span><span class="s3">class </span><span class="s1">_ExtendAction </span><span class="s3">extends </span><span class="s1">_AppendAction {</span>
    <span class="s1">call(parser, namespace, values</span><span class="s0">/*, option_string = undefined*/</span><span class="s1">) {</span>
        <span class="s3">let </span><span class="s1">items = getattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, undefined)</span>
        <span class="s1">items = _copy_items(items)</span>
        <span class="s1">items = items.concat(values)</span>
        <span class="s1">setattr(namespace, </span><span class="s3">this</span><span class="s1">.dest, items)</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s0">// ==============</span>
<span class="s0">// Type classes</span>
<span class="s0">// ==============</span>
<span class="s3">const </span><span class="s1">FileType = _callable(</span><span class="s3">class </span><span class="s1">FileType </span><span class="s3">extends </span><span class="s1">Function {</span>
    <span class="s0">/* 
     *  Factory for creating file object types 
     * 
     *  Instances of FileType are typically passed as type= arguments to the 
     *  ArgumentParser add_argument() method. 
     * 
     *  Keyword Arguments: 
     *      - mode -- A string indicating how the file is to be opened. Accepts the 
     *          same values as the builtin open() function. 
     *      - bufsize -- The file's desired buffer size. Accepts the same values as 
     *          the builtin open() function. 
     *      - encoding -- The file's encoding. Accepts the same values as the 
     *          builtin open() function. 
     *      - errors -- A string indicating how encoding and decoding errors are to 
     *          be handled. Accepts the same value as the builtin open() function. 
     */</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">flags,</span>
            <span class="s1">encoding,</span>
            <span class="s1">mode,</span>
            <span class="s1">autoClose,</span>
            <span class="s1">emitClose,</span>
            <span class="s1">start,</span>
            <span class="s1">end,</span>
            <span class="s1">highWaterMark,</span>
            <span class="s1">fs</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">flags: </span><span class="s2">'r'</span><span class="s1">,</span>
            <span class="s1">encoding: undefined,</span>
            <span class="s1">mode: undefined, </span><span class="s0">// 0o666</span>
            <span class="s1">autoClose: undefined, </span><span class="s0">// true</span>
            <span class="s1">emitClose: undefined, </span><span class="s0">// false</span>
            <span class="s1">start: undefined, </span><span class="s0">// 0</span>
            <span class="s1">end: undefined, </span><span class="s0">// Infinity</span>
            <span class="s1">highWaterMark: undefined, </span><span class="s0">// 64 * 1024</span>
            <span class="s1">fs: undefined</span>
        <span class="s1">})</span>

        <span class="s0">// when this class is called as a function, redirect it to .call() method of itself</span>
        <span class="s3">super</span><span class="s1">(</span><span class="s2">'return arguments.callee.call.apply(arguments.callee, arguments)'</span><span class="s1">)</span>

        <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'name'</span><span class="s1">, {</span>
            <span class="s1">get() {</span>
                <span class="s3">return </span><span class="s1">sub(</span><span class="s2">'FileType(%r)'</span><span class="s1">, flags)</span>
            <span class="s1">}</span>
        <span class="s1">})</span>
        <span class="s3">this</span><span class="s1">._flags = flags</span>
        <span class="s3">this</span><span class="s1">._options = {}</span>
        <span class="s3">if </span><span class="s1">(encoding !== undefined) </span><span class="s3">this</span><span class="s1">._options.encoding = encoding</span>
        <span class="s3">if </span><span class="s1">(mode !== undefined) </span><span class="s3">this</span><span class="s1">._options.mode = mode</span>
        <span class="s3">if </span><span class="s1">(autoClose !== undefined) </span><span class="s3">this</span><span class="s1">._options.autoClose = autoClose</span>
        <span class="s3">if </span><span class="s1">(emitClose !== undefined) </span><span class="s3">this</span><span class="s1">._options.emitClose = emitClose</span>
        <span class="s3">if </span><span class="s1">(start !== undefined) </span><span class="s3">this</span><span class="s1">._options.start = start</span>
        <span class="s3">if </span><span class="s1">(end !== undefined) </span><span class="s3">this</span><span class="s1">._options.end = end</span>
        <span class="s3">if </span><span class="s1">(highWaterMark !== undefined) </span><span class="s3">this</span><span class="s1">._options.highWaterMark = highWaterMark</span>
        <span class="s3">if </span><span class="s1">(fs !== undefined) </span><span class="s3">this</span><span class="s1">._options.fs = fs</span>
    <span class="s1">}</span>

    <span class="s1">call(string) {</span>
        <span class="s0">// the special argument &quot;-&quot; means sys.std{in,out}</span>
        <span class="s3">if </span><span class="s1">(string === </span><span class="s2">'-'</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._flags.includes(</span><span class="s2">'r'</span><span class="s1">)) {</span>
                <span class="s3">return </span><span class="s1">process.stdin</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._flags.includes(</span><span class="s2">'w'</span><span class="s1">)) {</span>
                <span class="s3">return </span><span class="s1">process.stdout</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">let </span><span class="s1">msg = sub(</span><span class="s2">'argument &quot;-&quot; with mode %r'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">._flags)</span>
                <span class="s3">throw new </span><span class="s1">TypeError(msg)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// all other arguments are used as file names</span>
        <span class="s3">let </span><span class="s1">fd</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">fd = fs.openSync(string, </span><span class="s3">this</span><span class="s1">._flags, </span><span class="s3">this</span><span class="s1">._options.mode)</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
            <span class="s3">let </span><span class="s1">args = { filename: string, error: e.message }</span>
            <span class="s3">let </span><span class="s1">message = </span><span class="s2">&quot;can't open '%(filename)s': %(error)s&quot;</span>
            <span class="s3">throw new </span><span class="s1">ArgumentTypeError(sub(message, args))</span>
        <span class="s1">}</span>

        <span class="s3">let </span><span class="s1">options = Object.assign({ fd, flags: </span><span class="s3">this</span><span class="s1">._flags }, </span><span class="s3">this</span><span class="s1">._options)</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._flags.includes(</span><span class="s2">'r'</span><span class="s1">)) {</span>
            <span class="s3">return </span><span class="s1">fs.createReadStream(undefined, options)</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._flags.includes(</span><span class="s2">'w'</span><span class="s1">)) {</span>
            <span class="s3">return </span><span class="s1">fs.createWriteStream(undefined, options)</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">let </span><span class="s1">msg = sub(</span><span class="s2">'argument &quot;%s&quot; with mode %r'</span><span class="s1">, string, </span><span class="s3">this</span><span class="s1">._flags)</span>
            <span class="s3">throw new </span><span class="s1">TypeError(msg)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">[util.inspect.custom]() {</span>
        <span class="s3">let </span><span class="s1">args = [ </span><span class="s3">this</span><span class="s1">._flags ]</span>
        <span class="s3">let </span><span class="s1">kwargs = Object.entries(</span><span class="s3">this</span><span class="s1">._options).map(([ k, v ]) =&gt; {</span>
            <span class="s3">if </span><span class="s1">(k === </span><span class="s2">'mode'</span><span class="s1">) v = { value: v, [util.inspect.custom]() { </span><span class="s3">return </span><span class="s2">'0o' </span><span class="s1">+ </span><span class="s3">this</span><span class="s1">.value.toString(</span><span class="s4">8</span><span class="s1">) } }</span>
            <span class="s3">return </span><span class="s1">[ k, v ]</span>
        <span class="s1">})</span>
        <span class="s3">let </span><span class="s1">args_str = []</span>
                <span class="s1">.concat(args.filter(arg =&gt; arg !== -</span><span class="s4">1</span><span class="s1">).map(repr))</span>
                <span class="s1">.concat(kwargs.filter(([</span><span class="s0">/*kw*/</span><span class="s1">, arg]) =&gt; arg !== undefined)</span>
                    <span class="s1">.map(([kw, arg]) =&gt; sub(</span><span class="s2">'%s=%r'</span><span class="s1">, kw, arg)))</span>
                <span class="s1">.join(</span><span class="s2">', '</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">sub(</span><span class="s2">'%s(%s)'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.constructor.name, args_str)</span>
    <span class="s1">}</span>

    <span class="s1">toString() {</span>
        <span class="s3">return this</span><span class="s1">[util.inspect.custom]()</span>
    <span class="s1">}</span>
<span class="s1">})</span>

<span class="s0">// ===========================</span>
<span class="s0">// Optional and Positional Parsing</span>
<span class="s0">// ===========================</span>
<span class="s3">const </span><span class="s1">Namespace = _callable(</span><span class="s3">class </span><span class="s1">Namespace </span><span class="s3">extends </span><span class="s1">_AttributeHolder() {</span>
    <span class="s0">/* 
     *  Simple object for storing attributes. 
     * 
     *  Implements equality by attribute names and values, and provides a simple 
     *  string representation. 
     */</span>

    <span class="s1">constructor(options = {}) {</span>
        <span class="s3">super</span><span class="s1">()</span>
        <span class="s1">Object.assign(</span><span class="s3">this</span><span class="s1">, options)</span>
    <span class="s1">}</span>
<span class="s1">})</span>

<span class="s0">// unset string tag to mimic plain object</span>
<span class="s1">Namespace.prototype[Symbol.toStringTag] = undefined</span>


<span class="s3">const </span><span class="s1">_ActionsContainer = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">_ActionsContainer {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">description,</span>
            <span class="s1">prefix_chars,</span>
            <span class="s1">argument_default,</span>
            <span class="s1">conflict_handler</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">description: no_default,</span>
            <span class="s1">prefix_chars: no_default,</span>
            <span class="s1">argument_default: no_default,</span>
            <span class="s1">conflict_handler: no_default</span>
        <span class="s1">})</span>

        <span class="s3">this</span><span class="s1">.description = description</span>
        <span class="s3">this</span><span class="s1">.argument_default = argument_default</span>
        <span class="s3">this</span><span class="s1">.prefix_chars = prefix_chars</span>
        <span class="s3">this</span><span class="s1">.conflict_handler = conflict_handler</span>

        <span class="s0">// set up registries</span>
        <span class="s3">this</span><span class="s1">._registries = {}</span>

        <span class="s0">// register actions</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, undefined, _StoreAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'store'</span><span class="s1">, _StoreAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'store_const'</span><span class="s1">, _StoreConstAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'store_true'</span><span class="s1">, _StoreTrueAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'store_false'</span><span class="s1">, _StoreFalseAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'append'</span><span class="s1">, _AppendAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'append_const'</span><span class="s1">, _AppendConstAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'count'</span><span class="s1">, _CountAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'help'</span><span class="s1">, _HelpAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'version'</span><span class="s1">, _VersionAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'parsers'</span><span class="s1">, _SubParsersAction)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'extend'</span><span class="s1">, _ExtendAction)</span>
        <span class="s0">// LEGACY (v1 compatibility): camelcase variants</span>
        <span class="s1">;[ </span><span class="s2">'storeConst'</span><span class="s1">, </span><span class="s2">'storeTrue'</span><span class="s1">, </span><span class="s2">'storeFalse'</span><span class="s1">, </span><span class="s2">'appendConst' </span><span class="s1">].forEach(old_name =&gt; {</span>
            <span class="s3">let </span><span class="s1">new_name = _to_new_name(old_name)</span>
            <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'action'</span><span class="s1">, old_name, util.deprecate(</span><span class="s3">this</span><span class="s1">._registry_get(</span><span class="s2">'action'</span><span class="s1">, new_name),</span>
                <span class="s1">sub(</span><span class="s2">'{action: &quot;%s&quot;} is renamed to {action: &quot;%s&quot;}'</span><span class="s1">, old_name, new_name)))</span>
        <span class="s1">})</span>
        <span class="s0">// end</span>

        <span class="s0">// raise an exception if the conflict handler is invalid</span>
        <span class="s3">this</span><span class="s1">._get_handler()</span>

        <span class="s0">// action storage</span>
        <span class="s3">this</span><span class="s1">._actions = []</span>
        <span class="s3">this</span><span class="s1">._option_string_actions = {}</span>

        <span class="s0">// groups</span>
        <span class="s3">this</span><span class="s1">._action_groups = []</span>
        <span class="s3">this</span><span class="s1">._mutually_exclusive_groups = []</span>

        <span class="s0">// defaults storage</span>
        <span class="s3">this</span><span class="s1">._defaults = {}</span>

        <span class="s0">// determines whether an &quot;option&quot; looks like a negative number</span>
        <span class="s3">this</span><span class="s1">._negative_number_matcher = </span><span class="s5">/^-\d+$|^-\d*\.\d+$/</span>

        <span class="s0">// whether or not there are any optionals that look like negative</span>
        <span class="s0">// numbers -- uses a list so it can be shared and edited</span>
        <span class="s3">this</span><span class="s1">._has_negative_number_optionals = []</span>
    <span class="s1">}</span>

    <span class="s0">// ====================</span>
    <span class="s0">// Registration methods</span>
    <span class="s0">// ====================</span>
    <span class="s1">register(registry_name, value, object) {</span>
        <span class="s3">let </span><span class="s1">registry = setdefault(</span><span class="s3">this</span><span class="s1">._registries, registry_name, {})</span>
        <span class="s1">registry[value] = object</span>
    <span class="s1">}</span>

    <span class="s1">_registry_get(registry_name, value, default_value = undefined) {</span>
        <span class="s3">return </span><span class="s1">getattr(</span><span class="s3">this</span><span class="s1">._registries[registry_name], value, default_value)</span>
    <span class="s1">}</span>

    <span class="s0">// ==================================</span>
    <span class="s0">// Namespace default accessor methods</span>
    <span class="s0">// ==================================</span>
    <span class="s1">set_defaults(kwargs) {</span>
        <span class="s1">Object.assign(</span><span class="s3">this</span><span class="s1">._defaults, kwargs)</span>

        <span class="s0">// if these defaults match any existing arguments, replace</span>
        <span class="s0">// the previous default on the object with the new one</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of </span><span class="s3">this</span><span class="s1">._actions) {</span>
            <span class="s3">if </span><span class="s1">(action.dest </span><span class="s3">in </span><span class="s1">kwargs) {</span>
                <span class="s1">action.default = kwargs[action.dest]</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">get_default(dest) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of </span><span class="s3">this</span><span class="s1">._actions) {</span>
            <span class="s3">if </span><span class="s1">(action.dest === dest &amp;&amp; action.default !== undefined) {</span>
                <span class="s3">return </span><span class="s1">action.default</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return this</span><span class="s1">._defaults[dest]</span>
    <span class="s1">}</span>


    <span class="s0">// =======================</span>
    <span class="s0">// Adding argument actions</span>
    <span class="s0">// =======================</span>
    <span class="s1">add_argument() {</span>
        <span class="s0">/* 
         *  add_argument(dest, ..., name=value, ...) 
         *  add_argument(option_string, option_string, ..., name=value, ...) 
         */</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">args,</span>
            <span class="s1">kwargs</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s2">'*args'</span><span class="s1">: no_default,</span>
            <span class="s2">'**kwargs'</span><span class="s1">: no_default</span>
        <span class="s1">})</span>
        <span class="s0">// LEGACY (v1 compatibility), old-style add_argument([ args ], { options })</span>
        <span class="s3">if </span><span class="s1">(args.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; Array.isArray(args[</span><span class="s4">0</span><span class="s1">])) {</span>
            <span class="s1">args = args[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">deprecate(</span><span class="s2">'argument-array'</span><span class="s1">,</span>
                <span class="s1">sub(</span><span class="s2">'use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })'</span><span class="s1">, {</span>
                    <span class="s1">args: args.map(repr).join(</span><span class="s2">', '</span><span class="s1">)</span>
                <span class="s1">}))</span>
        <span class="s1">}</span>
        <span class="s0">// end</span>

        <span class="s0">// if no positional args are supplied or only one is supplied and</span>
        <span class="s0">// it doesn't look like an option string, parse a positional</span>
        <span class="s0">// argument</span>
        <span class="s3">let </span><span class="s1">chars = </span><span class="s3">this</span><span class="s1">.prefix_chars</span>
        <span class="s3">if </span><span class="s1">(!args.length || args.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; !chars.includes(args[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])) {</span>
            <span class="s3">if </span><span class="s1">(args.length &amp;&amp; </span><span class="s2">'dest' </span><span class="s3">in </span><span class="s1">kwargs) {</span>
                <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'dest supplied twice for positional argument'</span><span class="s1">)</span>
            <span class="s1">}</span>
            <span class="s1">kwargs = </span><span class="s3">this</span><span class="s1">._get_positional_kwargs(...args, kwargs)</span>

        <span class="s0">// otherwise, we're adding an optional argument</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">kwargs = </span><span class="s3">this</span><span class="s1">._get_optional_kwargs(...args, kwargs)</span>
        <span class="s1">}</span>

        <span class="s0">// if no default was supplied, use the parser-level default</span>
        <span class="s3">if </span><span class="s1">(!(</span><span class="s2">'default' </span><span class="s3">in </span><span class="s1">kwargs)) {</span>
            <span class="s3">let </span><span class="s1">dest = kwargs.dest</span>
            <span class="s3">if </span><span class="s1">(dest </span><span class="s3">in this</span><span class="s1">._defaults) {</span>
                <span class="s1">kwargs.default = </span><span class="s3">this</span><span class="s1">._defaults[dest]</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.argument_default !== undefined) {</span>
                <span class="s1">kwargs.default = </span><span class="s3">this</span><span class="s1">.argument_default</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// create the action object, and add it to the parser</span>
        <span class="s3">let </span><span class="s1">action_class = </span><span class="s3">this</span><span class="s1">._pop_action_class(kwargs)</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">action_class !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'unknown action &quot;%s&quot;'</span><span class="s1">, action_class))</span>
        <span class="s1">}</span>
        <span class="s0">// eslint-disable-next-line new-cap</span>
        <span class="s3">let </span><span class="s1">action = </span><span class="s3">new </span><span class="s1">action_class(kwargs)</span>

        <span class="s0">// raise an error if the action type is not callable</span>
        <span class="s3">let </span><span class="s1">type_func = </span><span class="s3">this</span><span class="s1">._registry_get(</span><span class="s2">'type'</span><span class="s1">, action.type, action.type)</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type_func !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'%r is not callable'</span><span class="s1">, type_func))</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(type_func === FileType) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'%r is a FileType class object, instance of it' </span><span class="s1">+</span>
                                    <span class="s2">' must be passed'</span><span class="s1">, type_func))</span>
        <span class="s1">}</span>

        <span class="s0">// raise an error if the metavar does not match the type</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">'_get_formatter' </span><span class="s3">in this</span><span class="s1">) {</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">this</span><span class="s1">._get_formatter()._format_args(action, undefined)</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                <span class="s0">// check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same</span>
                <span class="s3">if </span><span class="s1">(err </span><span class="s3">instanceof </span><span class="s1">TypeError &amp;&amp; err.message !== </span><span class="s2">'invalid nargs value'</span><span class="s1">) {</span>
                    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'length of metavar tuple does not match nargs'</span><span class="s1">)</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">throw </span><span class="s1">err</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return this</span><span class="s1">._add_action(action)</span>
    <span class="s1">}</span>

    <span class="s1">add_argument_group() {</span>
        <span class="s3">let </span><span class="s1">group = _ArgumentGroup(</span><span class="s3">this</span><span class="s1">, ...arguments)</span>
        <span class="s3">this</span><span class="s1">._action_groups.push(group)</span>
        <span class="s3">return </span><span class="s1">group</span>
    <span class="s1">}</span>

    <span class="s1">add_mutually_exclusive_group() {</span>
        <span class="s0">// eslint-disable-next-line no-use-before-define</span>
        <span class="s3">let </span><span class="s1">group = _MutuallyExclusiveGroup(</span><span class="s3">this</span><span class="s1">, ...arguments)</span>
        <span class="s3">this</span><span class="s1">._mutually_exclusive_groups.push(group)</span>
        <span class="s3">return </span><span class="s1">group</span>
    <span class="s1">}</span>

    <span class="s1">_add_action(action) {</span>
        <span class="s0">// resolve any conflicts</span>
        <span class="s3">this</span><span class="s1">._check_conflict(action)</span>

        <span class="s0">// add to actions list</span>
        <span class="s3">this</span><span class="s1">._actions.push(action)</span>
        <span class="s1">action.container = </span><span class="s3">this</span>

        <span class="s0">// index the action by any option strings it has</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">option_string of action.option_strings) {</span>
            <span class="s3">this</span><span class="s1">._option_string_actions[option_string] = action</span>
        <span class="s1">}</span>

        <span class="s0">// set the flag if any option strings look like negative numbers</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">option_string of action.option_strings) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._negative_number_matcher.test(option_string)) {</span>
                <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">._has_negative_number_optionals.length) {</span>
                    <span class="s3">this</span><span class="s1">._has_negative_number_optionals.push(</span><span class="s3">true</span><span class="s1">)</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// return the created action</span>
        <span class="s3">return </span><span class="s1">action</span>
    <span class="s1">}</span>

    <span class="s1">_remove_action(action) {</span>
        <span class="s1">_array_remove(</span><span class="s3">this</span><span class="s1">._actions, action)</span>
    <span class="s1">}</span>

    <span class="s1">_add_container_actions(container) {</span>
        <span class="s0">// collect groups by titles</span>
        <span class="s3">let </span><span class="s1">title_group_map = {}</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">group of </span><span class="s3">this</span><span class="s1">._action_groups) {</span>
            <span class="s3">if </span><span class="s1">(group.title </span><span class="s3">in </span><span class="s1">title_group_map) {</span>
                <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'cannot merge actions - two groups are named %r'</span>
                <span class="s3">throw new </span><span class="s1">TypeError(sub(msg, group.title))</span>
            <span class="s1">}</span>
            <span class="s1">title_group_map[group.title] = group</span>
        <span class="s1">}</span>

        <span class="s0">// map each action to its group</span>
        <span class="s3">let </span><span class="s1">group_map = </span><span class="s3">new </span><span class="s1">Map()</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">group of container._action_groups) {</span>

            <span class="s0">// if a group with the title exists, use that, otherwise</span>
            <span class="s0">// create a new group matching the container's group</span>
            <span class="s3">if </span><span class="s1">(!(group.title </span><span class="s3">in </span><span class="s1">title_group_map)) {</span>
                <span class="s1">title_group_map[group.title] = </span><span class="s3">this</span><span class="s1">.add_argument_group({</span>
                    <span class="s1">title: group.title,</span>
                    <span class="s1">description: group.description,</span>
                    <span class="s1">conflict_handler: group.conflict_handler</span>
                <span class="s1">})</span>
            <span class="s1">}</span>

            <span class="s0">// map the actions to their new group</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of group._group_actions) {</span>
                <span class="s1">group_map.set(action, title_group_map[group.title])</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// add container's mutually exclusive groups</span>
        <span class="s0">// NOTE: if add_mutually_exclusive_group ever gains title= and</span>
        <span class="s0">// description= then this code will need to be expanded as above</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">group of container._mutually_exclusive_groups) {</span>
            <span class="s3">let </span><span class="s1">mutex_group = </span><span class="s3">this</span><span class="s1">.add_mutually_exclusive_group({</span>
                <span class="s1">required: group.required</span>
            <span class="s1">})</span>

            <span class="s0">// map the actions to their new mutex group</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of group._group_actions) {</span>
                <span class="s1">group_map.set(action, mutex_group)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// add all actions to this container or their group</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of container._actions) {</span>
            <span class="s1">group_map.get(action)._add_action(action)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">_get_positional_kwargs() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">dest,</span>
            <span class="s1">kwargs</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">dest: no_default,</span>
            <span class="s2">'**kwargs'</span><span class="s1">: no_default</span>
        <span class="s1">})</span>

        <span class="s0">// make sure required is not specified</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">'required' </span><span class="s3">in </span><span class="s1">kwargs) {</span>
            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">&quot;'required' is an invalid argument for positionals&quot;</span>
            <span class="s3">throw new </span><span class="s1">TypeError(msg)</span>
        <span class="s1">}</span>

        <span class="s0">// mark positional arguments as required if at least one is</span>
        <span class="s0">// always required</span>
        <span class="s3">if </span><span class="s1">(![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {</span>
            <span class="s1">kwargs.required = </span><span class="s3">true</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(kwargs.nargs === ZERO_OR_MORE &amp;&amp; !(</span><span class="s2">'default' </span><span class="s3">in </span><span class="s1">kwargs)) {</span>
            <span class="s1">kwargs.required = </span><span class="s3">true</span>
        <span class="s1">}</span>

        <span class="s0">// return the keyword arguments with no option strings</span>
        <span class="s3">return </span><span class="s1">Object.assign(kwargs, { dest, option_strings: [] })</span>
    <span class="s1">}</span>

    <span class="s1">_get_optional_kwargs() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">args,</span>
            <span class="s1">kwargs</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s2">'*args'</span><span class="s1">: no_default,</span>
            <span class="s2">'**kwargs'</span><span class="s1">: no_default</span>
        <span class="s1">})</span>

        <span class="s0">// determine short and long option strings</span>
        <span class="s3">let </span><span class="s1">option_strings = []</span>
        <span class="s3">let </span><span class="s1">long_option_strings = []</span>
        <span class="s3">let </span><span class="s1">option_string</span>
        <span class="s3">for </span><span class="s1">(option_string of args) {</span>
            <span class="s0">// error on strings that don't start with an appropriate prefix</span>
            <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.prefix_chars.includes(option_string[</span><span class="s4">0</span><span class="s1">])) {</span>
                <span class="s3">let </span><span class="s1">args = {option: option_string,</span>
                            <span class="s1">prefix_chars: </span><span class="s3">this</span><span class="s1">.prefix_chars}</span>
                <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'invalid option string %(option)r: ' </span><span class="s1">+</span>
                          <span class="s2">'must start with a character %(prefix_chars)r'</span>
                <span class="s3">throw new </span><span class="s1">TypeError(sub(msg, args))</span>
            <span class="s1">}</span>

            <span class="s0">// strings starting with two prefix characters are long options</span>
            <span class="s1">option_strings.push(option_string)</span>
            <span class="s3">if </span><span class="s1">(option_string.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.prefix_chars.includes(option_string[</span><span class="s4">1</span><span class="s1">])) {</span>
                <span class="s1">long_option_strings.push(option_string)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// infer destination, '--foo-bar' -&gt; 'foo_bar' and '-x' -&gt; 'x'</span>
        <span class="s3">let </span><span class="s1">dest = kwargs.dest</span>
        <span class="s3">delete </span><span class="s1">kwargs.dest</span>
        <span class="s3">if </span><span class="s1">(dest === undefined) {</span>
            <span class="s3">let </span><span class="s1">dest_option_string</span>
            <span class="s3">if </span><span class="s1">(long_option_strings.length) {</span>
                <span class="s1">dest_option_string = long_option_strings[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">dest_option_string = option_strings[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">}</span>
            <span class="s1">dest = _string_lstrip(dest_option_string, </span><span class="s3">this</span><span class="s1">.prefix_chars)</span>
            <span class="s3">if </span><span class="s1">(!dest) {</span>
                <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'dest= is required for options like %r'</span>
                <span class="s3">throw new </span><span class="s1">TypeError(sub(msg, option_string))</span>
            <span class="s1">}</span>
            <span class="s1">dest = dest.replace(</span><span class="s5">/-/g</span><span class="s1">, </span><span class="s2">'_'</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s0">// return the updated keyword arguments</span>
        <span class="s3">return </span><span class="s1">Object.assign(kwargs, { dest, option_strings })</span>
    <span class="s1">}</span>

    <span class="s1">_pop_action_class(kwargs, default_value = undefined) {</span>
        <span class="s3">let </span><span class="s1">action = getattr(kwargs, </span><span class="s2">'action'</span><span class="s1">, default_value)</span>
        <span class="s3">delete </span><span class="s1">kwargs.action</span>
        <span class="s3">return this</span><span class="s1">._registry_get(</span><span class="s2">'action'</span><span class="s1">, action, action)</span>
    <span class="s1">}</span>

    <span class="s1">_get_handler() {</span>
        <span class="s0">// determine function from conflict handler string</span>
        <span class="s3">let </span><span class="s1">handler_func_name = sub(</span><span class="s2">'_handle_conflict_%s'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.conflict_handler)</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof this</span><span class="s1">[handler_func_name] === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s3">return this</span><span class="s1">[handler_func_name]</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'invalid conflict_resolution value: %r'</span>
            <span class="s3">throw new </span><span class="s1">TypeError(sub(msg, </span><span class="s3">this</span><span class="s1">.conflict_handler))</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">_check_conflict(action) {</span>

        <span class="s0">// find all options that conflict with this option</span>
        <span class="s3">let </span><span class="s1">confl_optionals = []</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">option_string of action.option_strings) {</span>
            <span class="s3">if </span><span class="s1">(hasattr(</span><span class="s3">this</span><span class="s1">._option_string_actions, option_string)) {</span>
                <span class="s3">let </span><span class="s1">confl_optional = </span><span class="s3">this</span><span class="s1">._option_string_actions[option_string]</span>
                <span class="s1">confl_optionals.push([ option_string, confl_optional ])</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// resolve any conflicts</span>
        <span class="s3">if </span><span class="s1">(confl_optionals.length) {</span>
            <span class="s3">let </span><span class="s1">conflict_handler = </span><span class="s3">this</span><span class="s1">._get_handler()</span>
            <span class="s1">conflict_handler.call(</span><span class="s3">this</span><span class="s1">, action, confl_optionals)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">_handle_conflict_error(action, conflicting_actions) {</span>
        <span class="s3">let </span><span class="s1">message = conflicting_actions.length === </span><span class="s4">1 </span><span class="s1">?</span>
            <span class="s2">'conflicting option string: %s' </span><span class="s1">:</span>
            <span class="s2">'conflicting option strings: %s'</span>
        <span class="s3">let </span><span class="s1">conflict_string = conflicting_actions.map(([ option_string</span><span class="s0">/*, action*/ </span><span class="s1">]) =&gt; option_string).join(</span><span class="s2">', '</span><span class="s1">)</span>
        <span class="s3">throw new </span><span class="s1">ArgumentError(action, sub(message, conflict_string))</span>
    <span class="s1">}</span>

    <span class="s1">_handle_conflict_resolve(action, conflicting_actions) {</span>

        <span class="s0">// remove all conflicting options</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[ option_string, action ] of conflicting_actions) {</span>

            <span class="s0">// remove the conflicting option</span>
            <span class="s1">_array_remove(action.option_strings, option_string)</span>
            <span class="s3">delete this</span><span class="s1">._option_string_actions[option_string]</span>

            <span class="s0">// if the option now has no option string, remove it from the</span>
            <span class="s0">// container holding it</span>
            <span class="s3">if </span><span class="s1">(!action.option_strings.length) {</span>
                <span class="s1">action.container._remove_action(action)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s3">const </span><span class="s1">_ArgumentGroup = _callable(</span><span class="s3">class </span><span class="s1">_ArgumentGroup </span><span class="s3">extends </span><span class="s1">_ActionsContainer {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">container,</span>
            <span class="s1">title,</span>
            <span class="s1">description,</span>
            <span class="s1">kwargs</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">container: no_default,</span>
            <span class="s1">title: undefined,</span>
            <span class="s1">description: undefined,</span>
            <span class="s2">'**kwargs'</span><span class="s1">: no_default</span>
        <span class="s1">})</span>

        <span class="s0">// add any missing keyword arguments by checking the container</span>
        <span class="s1">setdefault(kwargs, </span><span class="s2">'conflict_handler'</span><span class="s1">, container.conflict_handler)</span>
        <span class="s1">setdefault(kwargs, </span><span class="s2">'prefix_chars'</span><span class="s1">, container.prefix_chars)</span>
        <span class="s1">setdefault(kwargs, </span><span class="s2">'argument_default'</span><span class="s1">, container.argument_default)</span>
        <span class="s3">super</span><span class="s1">(Object.assign({ description }, kwargs))</span>

        <span class="s0">// group attributes</span>
        <span class="s3">this</span><span class="s1">.title = title</span>
        <span class="s3">this</span><span class="s1">._group_actions = []</span>

        <span class="s0">// share most attributes with the container</span>
        <span class="s3">this</span><span class="s1">._registries = container._registries</span>
        <span class="s3">this</span><span class="s1">._actions = container._actions</span>
        <span class="s3">this</span><span class="s1">._option_string_actions = container._option_string_actions</span>
        <span class="s3">this</span><span class="s1">._defaults = container._defaults</span>
        <span class="s3">this</span><span class="s1">._has_negative_number_optionals =</span>
            <span class="s1">container._has_negative_number_optionals</span>
        <span class="s3">this</span><span class="s1">._mutually_exclusive_groups = container._mutually_exclusive_groups</span>
    <span class="s1">}</span>

    <span class="s1">_add_action(action) {</span>
        <span class="s1">action = </span><span class="s3">super</span><span class="s1">._add_action(action)</span>
        <span class="s3">this</span><span class="s1">._group_actions.push(action)</span>
        <span class="s3">return </span><span class="s1">action</span>
    <span class="s1">}</span>

    <span class="s1">_remove_action(action) {</span>
        <span class="s3">super</span><span class="s1">._remove_action(action)</span>
        <span class="s1">_array_remove(</span><span class="s3">this</span><span class="s1">._group_actions, action)</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">_MutuallyExclusiveGroup = _callable(</span><span class="s3">class </span><span class="s1">_MutuallyExclusiveGroup </span><span class="s3">extends </span><span class="s1">_ArgumentGroup {</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">container,</span>
            <span class="s1">required</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">container: no_default,</span>
            <span class="s1">required: </span><span class="s3">false</span>
        <span class="s1">})</span>

        <span class="s3">super</span><span class="s1">(container)</span>
        <span class="s3">this</span><span class="s1">.required = required</span>
        <span class="s3">this</span><span class="s1">._container = container</span>
    <span class="s1">}</span>

    <span class="s1">_add_action(action) {</span>
        <span class="s3">if </span><span class="s1">(action.required) {</span>
            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'mutually exclusive arguments must be optional'</span>
            <span class="s3">throw new </span><span class="s1">TypeError(msg)</span>
        <span class="s1">}</span>
        <span class="s1">action = </span><span class="s3">this</span><span class="s1">._container._add_action(action)</span>
        <span class="s3">this</span><span class="s1">._group_actions.push(action)</span>
        <span class="s3">return </span><span class="s1">action</span>
    <span class="s1">}</span>

    <span class="s1">_remove_action(action) {</span>
        <span class="s3">this</span><span class="s1">._container._remove_action(action)</span>
        <span class="s1">_array_remove(</span><span class="s3">this</span><span class="s1">._group_actions, action)</span>
    <span class="s1">}</span>
<span class="s1">})</span>


<span class="s3">const </span><span class="s1">ArgumentParser = _camelcase_alias(_callable(</span><span class="s3">class </span><span class="s1">ArgumentParser </span><span class="s3">extends </span><span class="s1">_AttributeHolder(_ActionsContainer) {</span>
    <span class="s0">/* 
     *  Object for parsing command line strings into Python objects. 
     * 
     *  Keyword Arguments: 
     *      - prog -- The name of the program (default: sys.argv[0]) 
     *      - usage -- A usage message (default: auto-generated from arguments) 
     *      - description -- A description of what the program does 
     *      - epilog -- Text following the argument descriptions 
     *      - parents -- Parsers whose arguments should be copied into this one 
     *      - formatter_class -- HelpFormatter class for printing help messages 
     *      - prefix_chars -- Characters that prefix optional arguments 
     *      - fromfile_prefix_chars -- Characters that prefix files containing 
     *          additional arguments 
     *      - argument_default -- The default value for all arguments 
     *      - conflict_handler -- String indicating how to handle conflicts 
     *      - add_help -- Add a -h/-help option 
     *      - allow_abbrev -- Allow long options to be abbreviated unambiguously 
     *      - exit_on_error -- Determines whether or not ArgumentParser exits with 
     *          error info when an error occurs 
     */</span>

    <span class="s1">constructor() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">prog,</span>
            <span class="s1">usage,</span>
            <span class="s1">description,</span>
            <span class="s1">epilog,</span>
            <span class="s1">parents,</span>
            <span class="s1">formatter_class,</span>
            <span class="s1">prefix_chars,</span>
            <span class="s1">fromfile_prefix_chars,</span>
            <span class="s1">argument_default,</span>
            <span class="s1">conflict_handler,</span>
            <span class="s1">add_help,</span>
            <span class="s1">allow_abbrev,</span>
            <span class="s1">exit_on_error,</span>
            <span class="s1">debug, </span><span class="s0">// LEGACY (v1 compatibility), debug mode</span>
            <span class="s1">version </span><span class="s0">// LEGACY (v1 compatibility), version</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s1">prog: undefined,</span>
            <span class="s1">usage: undefined,</span>
            <span class="s1">description: undefined,</span>
            <span class="s1">epilog: undefined,</span>
            <span class="s1">parents: [],</span>
            <span class="s1">formatter_class: HelpFormatter,</span>
            <span class="s1">prefix_chars: </span><span class="s2">'-'</span><span class="s1">,</span>
            <span class="s1">fromfile_prefix_chars: undefined,</span>
            <span class="s1">argument_default: undefined,</span>
            <span class="s1">conflict_handler: </span><span class="s2">'error'</span><span class="s1">,</span>
            <span class="s1">add_help: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s1">allow_abbrev: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s1">exit_on_error: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s1">debug: undefined, </span><span class="s0">// LEGACY (v1 compatibility), debug mode</span>
            <span class="s1">version: undefined </span><span class="s0">// LEGACY (v1 compatibility), version</span>
        <span class="s1">})</span>

        <span class="s0">// LEGACY (v1 compatibility)</span>
        <span class="s3">if </span><span class="s1">(debug !== undefined) {</span>
            <span class="s1">deprecate(</span><span class="s2">'debug'</span><span class="s1">,</span>
                <span class="s2">'The &quot;debug&quot; argument to ArgumentParser is deprecated. Please ' </span><span class="s1">+</span>
                <span class="s2">'override ArgumentParser.exit function instead.'</span>
            <span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(version !== undefined) {</span>
            <span class="s1">deprecate(</span><span class="s2">'version'</span><span class="s1">,</span>
                <span class="s2">'The &quot;version&quot; argument to ArgumentParser is deprecated. Please use ' </span><span class="s1">+</span>
                <span class="s2">&quot;add_argument(..., { action: 'version', version: 'N', ... }) instead.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">}</span>
        <span class="s0">// end</span>

        <span class="s3">super</span><span class="s1">({</span>
            <span class="s1">description,</span>
            <span class="s1">prefix_chars,</span>
            <span class="s1">argument_default,</span>
            <span class="s1">conflict_handler</span>
        <span class="s1">})</span>

        <span class="s0">// default setting for prog</span>
        <span class="s3">if </span><span class="s1">(prog === undefined) {</span>
            <span class="s1">prog = path.basename(get_argv()[</span><span class="s4">0</span><span class="s1">] || </span><span class="s2">''</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s3">this</span><span class="s1">.prog = prog</span>
        <span class="s3">this</span><span class="s1">.usage = usage</span>
        <span class="s3">this</span><span class="s1">.epilog = epilog</span>
        <span class="s3">this</span><span class="s1">.formatter_class = formatter_class</span>
        <span class="s3">this</span><span class="s1">.fromfile_prefix_chars = fromfile_prefix_chars</span>
        <span class="s3">this</span><span class="s1">.add_help = add_help</span>
        <span class="s3">this</span><span class="s1">.allow_abbrev = allow_abbrev</span>
        <span class="s3">this</span><span class="s1">.exit_on_error = exit_on_error</span>
        <span class="s0">// LEGACY (v1 compatibility), debug mode</span>
        <span class="s3">this</span><span class="s1">.debug = debug</span>
        <span class="s0">// end</span>

        <span class="s3">this</span><span class="s1">._positionals = </span><span class="s3">this</span><span class="s1">.add_argument_group(</span><span class="s2">'positional arguments'</span><span class="s1">)</span>
        <span class="s3">this</span><span class="s1">._optionals = </span><span class="s3">this</span><span class="s1">.add_argument_group(</span><span class="s2">'optional arguments'</span><span class="s1">)</span>
        <span class="s3">this</span><span class="s1">._subparsers = undefined</span>

        <span class="s0">// register types</span>
        <span class="s3">function </span><span class="s1">identity(string) {</span>
            <span class="s3">return </span><span class="s1">string</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, undefined, identity)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, identity)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'auto'</span><span class="s1">, identity)</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'int'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">(x) {</span>
            <span class="s3">let </span><span class="s1">result = Number(x)</span>
            <span class="s3">if </span><span class="s1">(!Number.isInteger(result)) {</span>
                <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'could not convert string to int: %r'</span><span class="s1">, x))</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">result</span>
        <span class="s1">})</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'float'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">(x) {</span>
            <span class="s3">let </span><span class="s1">result = Number(x)</span>
            <span class="s3">if </span><span class="s1">(isNaN(result)) {</span>
                <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'could not convert string to float: %r'</span><span class="s1">, x))</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">result</span>
        <span class="s1">})</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'str'</span><span class="s1">, String)</span>
        <span class="s0">// LEGACY (v1 compatibility): custom types</span>
        <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'string'</span><span class="s1">,</span>
            <span class="s1">util.deprecate(String, </span><span class="s2">'use {type:&quot;str&quot;} or {type:String} instead of {type:&quot;string&quot;}'</span><span class="s1">))</span>
        <span class="s0">// end</span>

        <span class="s0">// add help argument if necessary</span>
        <span class="s0">// (using explicit default to override global argument_default)</span>
        <span class="s3">let </span><span class="s1">default_prefix = prefix_chars.includes(</span><span class="s2">'-'</span><span class="s1">) ? </span><span class="s2">'-' </span><span class="s1">: prefix_chars[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.add_help) {</span>
            <span class="s3">this</span><span class="s1">.add_argument(</span>
                <span class="s1">default_prefix + </span><span class="s2">'h'</span><span class="s1">,</span>
                <span class="s1">default_prefix.repeat(</span><span class="s4">2</span><span class="s1">) + </span><span class="s2">'help'</span><span class="s1">,</span>
                <span class="s1">{</span>
                    <span class="s1">action: </span><span class="s2">'help'</span><span class="s1">,</span>
                    <span class="s3">default</span><span class="s1">: SUPPRESS,</span>
                    <span class="s1">help: </span><span class="s2">'show this help message and exit'</span>
                <span class="s1">}</span>
            <span class="s1">)</span>
        <span class="s1">}</span>
        <span class="s0">// LEGACY (v1 compatibility), version</span>
        <span class="s3">if </span><span class="s1">(version) {</span>
            <span class="s3">this</span><span class="s1">.add_argument(</span>
                <span class="s1">default_prefix + </span><span class="s2">'v'</span><span class="s1">,</span>
                <span class="s1">default_prefix.repeat(</span><span class="s4">2</span><span class="s1">) + </span><span class="s2">'version'</span><span class="s1">,</span>
                <span class="s1">{</span>
                    <span class="s1">action: </span><span class="s2">'version'</span><span class="s1">,</span>
                    <span class="s3">default</span><span class="s1">: SUPPRESS,</span>
                    <span class="s1">version: </span><span class="s3">this</span><span class="s1">.version,</span>
                    <span class="s1">help: </span><span class="s2">&quot;show program's version number and exit&quot;</span>
                <span class="s1">}</span>
            <span class="s1">)</span>
        <span class="s1">}</span>
        <span class="s0">// end</span>

        <span class="s0">// add parent arguments and defaults</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">parent of parents) {</span>
            <span class="s3">this</span><span class="s1">._add_container_actions(parent)</span>
            <span class="s1">Object.assign(</span><span class="s3">this</span><span class="s1">._defaults, parent._defaults)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// =======================</span>
    <span class="s0">// Pretty __repr__ methods</span>
    <span class="s0">// =======================</span>
    <span class="s1">_get_kwargs() {</span>
        <span class="s3">let </span><span class="s1">names = [</span>
            <span class="s2">'prog'</span><span class="s1">,</span>
            <span class="s2">'usage'</span><span class="s1">,</span>
            <span class="s2">'description'</span><span class="s1">,</span>
            <span class="s2">'formatter_class'</span><span class="s1">,</span>
            <span class="s2">'conflict_handler'</span><span class="s1">,</span>
            <span class="s2">'add_help'</span>
        <span class="s1">]</span>
        <span class="s3">return </span><span class="s1">names.map(name =&gt; [ name, getattr(</span><span class="s3">this</span><span class="s1">, name) ])</span>
    <span class="s1">}</span>

    <span class="s0">// ==================================</span>
    <span class="s0">// Optional/Positional adding methods</span>
    <span class="s0">// ==================================</span>
    <span class="s1">add_subparsers() {</span>
        <span class="s3">let </span><span class="s1">[</span>
            <span class="s1">kwargs</span>
        <span class="s1">] = _parse_opts(arguments, {</span>
            <span class="s2">'**kwargs'</span><span class="s1">: no_default</span>
        <span class="s1">})</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._subparsers !== undefined) {</span>
            <span class="s3">this</span><span class="s1">.error(</span><span class="s2">'cannot have multiple subparser arguments'</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s0">// add the parser class to the arguments if it's not present</span>
        <span class="s1">setdefault(kwargs, </span><span class="s2">'parser_class'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.constructor)</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s2">'title' </span><span class="s3">in </span><span class="s1">kwargs || </span><span class="s2">'description' </span><span class="s3">in </span><span class="s1">kwargs) {</span>
            <span class="s3">let </span><span class="s1">title = getattr(kwargs, </span><span class="s2">'title'</span><span class="s1">, </span><span class="s2">'subcommands'</span><span class="s1">)</span>
            <span class="s3">let </span><span class="s1">description = getattr(kwargs, </span><span class="s2">'description'</span><span class="s1">, undefined)</span>
            <span class="s3">delete </span><span class="s1">kwargs.title</span>
            <span class="s3">delete </span><span class="s1">kwargs.description</span>
            <span class="s3">this</span><span class="s1">._subparsers = </span><span class="s3">this</span><span class="s1">.add_argument_group(title, description)</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">this</span><span class="s1">._subparsers = </span><span class="s3">this</span><span class="s1">._positionals</span>
        <span class="s1">}</span>

        <span class="s0">// prog defaults to the usage message of this parser, skipping</span>
        <span class="s0">// optional arguments and with no &quot;usage:&quot; prefix</span>
        <span class="s3">if </span><span class="s1">(kwargs.prog === undefined) {</span>
            <span class="s3">let </span><span class="s1">formatter = </span><span class="s3">this</span><span class="s1">._get_formatter()</span>
            <span class="s3">let </span><span class="s1">positionals = </span><span class="s3">this</span><span class="s1">._get_positional_actions()</span>
            <span class="s3">let </span><span class="s1">groups = </span><span class="s3">this</span><span class="s1">._mutually_exclusive_groups</span>
            <span class="s1">formatter.add_usage(</span><span class="s3">this</span><span class="s1">.usage, positionals, groups, </span><span class="s2">''</span><span class="s1">)</span>
            <span class="s1">kwargs.prog = formatter.format_help().trim()</span>
        <span class="s1">}</span>

        <span class="s0">// create the parsers action and add it to the positionals list</span>
        <span class="s3">let </span><span class="s1">parsers_class = </span><span class="s3">this</span><span class="s1">._pop_action_class(kwargs, </span><span class="s2">'parsers'</span><span class="s1">)</span>
        <span class="s0">// eslint-disable-next-line new-cap</span>
        <span class="s3">let </span><span class="s1">action = </span><span class="s3">new </span><span class="s1">parsers_class(Object.assign({ option_strings: [] }, kwargs))</span>
        <span class="s3">this</span><span class="s1">._subparsers._add_action(action)</span>

        <span class="s0">// return the created parsers action</span>
        <span class="s3">return </span><span class="s1">action</span>
    <span class="s1">}</span>

    <span class="s1">_add_action(action) {</span>
        <span class="s3">if </span><span class="s1">(action.option_strings.length) {</span>
            <span class="s3">this</span><span class="s1">._optionals._add_action(action)</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">this</span><span class="s1">._positionals._add_action(action)</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">action</span>
    <span class="s1">}</span>

    <span class="s1">_get_optional_actions() {</span>
        <span class="s3">return this</span><span class="s1">._actions.filter(action =&gt; action.option_strings.length)</span>
    <span class="s1">}</span>

    <span class="s1">_get_positional_actions() {</span>
        <span class="s3">return this</span><span class="s1">._actions.filter(action =&gt; !action.option_strings.length)</span>
    <span class="s1">}</span>

    <span class="s0">// =====================================</span>
    <span class="s0">// Command line argument parsing methods</span>
    <span class="s0">// =====================================</span>
    <span class="s1">parse_args(args = undefined, namespace = undefined) {</span>
        <span class="s3">let </span><span class="s1">argv</span>
        <span class="s1">[ args, argv ] = </span><span class="s3">this</span><span class="s1">.parse_known_args(args, namespace)</span>
        <span class="s3">if </span><span class="s1">(argv &amp;&amp; argv.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'unrecognized arguments: %s'</span>
            <span class="s3">this</span><span class="s1">.error(sub(msg, argv.join(</span><span class="s2">' '</span><span class="s1">)))</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">args</span>
    <span class="s1">}</span>

    <span class="s1">parse_known_args(args = undefined, namespace = undefined) {</span>
        <span class="s3">if </span><span class="s1">(args === undefined) {</span>
            <span class="s1">args = get_argv().slice(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s0">// default Namespace built from parser defaults</span>
        <span class="s3">if </span><span class="s1">(namespace === undefined) {</span>
            <span class="s1">namespace = </span><span class="s3">new </span><span class="s1">Namespace()</span>
        <span class="s1">}</span>

        <span class="s0">// add any action defaults that aren't present</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of </span><span class="s3">this</span><span class="s1">._actions) {</span>
            <span class="s3">if </span><span class="s1">(action.dest !== SUPPRESS) {</span>
                <span class="s3">if </span><span class="s1">(!hasattr(namespace, action.dest)) {</span>
                    <span class="s3">if </span><span class="s1">(action.default !== SUPPRESS) {</span>
                        <span class="s1">setattr(namespace, action.dest, action.default)</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// add any parser defaults that aren't present</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">dest of Object.keys(</span><span class="s3">this</span><span class="s1">._defaults)) {</span>
            <span class="s3">if </span><span class="s1">(!hasattr(namespace, dest)) {</span>
                <span class="s1">setattr(namespace, dest, </span><span class="s3">this</span><span class="s1">._defaults[dest])</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// parse the arguments and exit if there are any errors</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.exit_on_error) {</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">[ namespace, args ] = </span><span class="s3">this</span><span class="s1">._parse_known_args(args, namespace)</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                <span class="s3">if </span><span class="s1">(err </span><span class="s3">instanceof </span><span class="s1">ArgumentError) {</span>
                    <span class="s3">this</span><span class="s1">.error(err.message)</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">throw </span><span class="s1">err</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">[ namespace, args ] = </span><span class="s3">this</span><span class="s1">._parse_known_args(args, namespace)</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {</span>
            <span class="s1">args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))</span>
            <span class="s1">delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">[ namespace, args ]</span>
    <span class="s1">}</span>

    <span class="s1">_parse_known_args(arg_strings, namespace) {</span>
        <span class="s0">// replace arg strings that are file references</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.fromfile_prefix_chars !== undefined) {</span>
            <span class="s1">arg_strings = </span><span class="s3">this</span><span class="s1">._read_args_from_files(arg_strings)</span>
        <span class="s1">}</span>

        <span class="s0">// map all mutually exclusive arguments to the other arguments</span>
        <span class="s0">// they can't occur with</span>
        <span class="s3">let </span><span class="s1">action_conflicts = </span><span class="s3">new </span><span class="s1">Map()</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">mutex_group of </span><span class="s3">this</span><span class="s1">._mutually_exclusive_groups) {</span>
            <span class="s3">let </span><span class="s1">group_actions = mutex_group._group_actions</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[ i, mutex_action ] of Object.entries(mutex_group._group_actions)) {</span>
                <span class="s3">let </span><span class="s1">conflicts = action_conflicts.get(mutex_action) || []</span>
                <span class="s1">conflicts = conflicts.concat(group_actions.slice(</span><span class="s4">0</span><span class="s1">, +i))</span>
                <span class="s1">conflicts = conflicts.concat(group_actions.slice(+i + </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">action_conflicts.set(mutex_action, conflicts)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// find all option indices, and determine the arg_string_pattern</span>
        <span class="s0">// which has an 'O' if there is an option at an index,</span>
        <span class="s0">// an 'A' if there is an argument, or a '-' if there is a '--'</span>
        <span class="s3">let </span><span class="s1">option_string_indices = {}</span>
        <span class="s3">let </span><span class="s1">arg_string_pattern_parts = []</span>
        <span class="s3">let </span><span class="s1">arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]()</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[ i, arg_string ] of arg_strings_iter) {</span>

            <span class="s0">// all args after -- are non-options</span>
            <span class="s3">if </span><span class="s1">(arg_string === </span><span class="s2">'--'</span><span class="s1">) {</span>
                <span class="s1">arg_string_pattern_parts.push(</span><span class="s2">'-'</span><span class="s1">)</span>
                <span class="s3">for </span><span class="s1">([ i, arg_string ] of arg_strings_iter) {</span>
                    <span class="s1">arg_string_pattern_parts.push(</span><span class="s2">'A'</span><span class="s1">)</span>
                <span class="s1">}</span>

            <span class="s0">// otherwise, add the arg to the arg strings</span>
            <span class="s0">// and note the index if it was an option</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">let </span><span class="s1">option_tuple = </span><span class="s3">this</span><span class="s1">._parse_optional(arg_string)</span>
                <span class="s3">let </span><span class="s1">pattern</span>
                <span class="s3">if </span><span class="s1">(option_tuple === undefined) {</span>
                    <span class="s1">pattern = </span><span class="s2">'A'</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">option_string_indices[i] = option_tuple</span>
                    <span class="s1">pattern = </span><span class="s2">'O'</span>
                <span class="s1">}</span>
                <span class="s1">arg_string_pattern_parts.push(pattern)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// join the pieces together to form the pattern</span>
        <span class="s3">let </span><span class="s1">arg_strings_pattern = arg_string_pattern_parts.join(</span><span class="s2">''</span><span class="s1">)</span>

        <span class="s0">// converts arg strings to the appropriate and then takes the action</span>
        <span class="s3">let </span><span class="s1">seen_actions = </span><span class="s3">new </span><span class="s1">Set()</span>
        <span class="s3">let </span><span class="s1">seen_non_default_actions = </span><span class="s3">new </span><span class="s1">Set()</span>
        <span class="s3">let </span><span class="s1">extras</span>

        <span class="s3">let </span><span class="s1">take_action = (action, argument_strings, option_string = undefined) =&gt; {</span>
            <span class="s1">seen_actions.add(action)</span>
            <span class="s3">let </span><span class="s1">argument_values = </span><span class="s3">this</span><span class="s1">._get_values(action, argument_strings)</span>

            <span class="s0">// error if this argument is not allowed with other previously</span>
            <span class="s0">// seen arguments, assuming that actions that use the default</span>
            <span class="s0">// value don't really count as &quot;present&quot;</span>
            <span class="s3">if </span><span class="s1">(argument_values !== action.default) {</span>
                <span class="s1">seen_non_default_actions.add(action)</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">conflict_action of action_conflicts.get(action) || []) {</span>
                    <span class="s3">if </span><span class="s1">(seen_non_default_actions.has(conflict_action)) {</span>
                        <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'not allowed with argument %s'</span>
                        <span class="s3">let </span><span class="s1">action_name = _get_action_name(conflict_action)</span>
                        <span class="s3">throw new </span><span class="s1">ArgumentError(action, sub(msg, action_name))</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s0">// take the action if we didn't receive a SUPPRESS value</span>
            <span class="s0">// (e.g. from a default)</span>
            <span class="s3">if </span><span class="s1">(argument_values !== SUPPRESS) {</span>
                <span class="s1">action(</span><span class="s3">this</span><span class="s1">, namespace, argument_values, option_string)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// function to convert arg_strings into an optional action</span>
        <span class="s3">let </span><span class="s1">consume_optional = start_index =&gt; {</span>

            <span class="s0">// get the optional identified at this index</span>
            <span class="s3">let </span><span class="s1">option_tuple = option_string_indices[start_index]</span>
            <span class="s3">let </span><span class="s1">[ action, option_string, explicit_arg ] = option_tuple</span>

            <span class="s0">// identify additional optionals in the same arg string</span>
            <span class="s0">// (e.g. -xyz is the same as -x -y -z if no args are required)</span>
            <span class="s3">let </span><span class="s1">action_tuples = []</span>
            <span class="s3">let </span><span class="s1">stop</span>
            <span class="s3">for </span><span class="s1">(;;) {</span>

                <span class="s0">// if we found no optional action, skip it</span>
                <span class="s3">if </span><span class="s1">(action === undefined) {</span>
                    <span class="s1">extras.push(arg_strings[start_index])</span>
                    <span class="s3">return </span><span class="s1">start_index + </span><span class="s4">1</span>
                <span class="s1">}</span>

                <span class="s0">// if there is an explicit argument, try to match the</span>
                <span class="s0">// optional's string arguments to only this</span>
                <span class="s3">if </span><span class="s1">(explicit_arg !== undefined) {</span>
                    <span class="s3">let </span><span class="s1">arg_count = </span><span class="s3">this</span><span class="s1">._match_argument(action, </span><span class="s2">'A'</span><span class="s1">)</span>

                    <span class="s0">// if the action is a single-dash option and takes no</span>
                    <span class="s0">// arguments, try to parse more single-dash options out</span>
                    <span class="s0">// of the tail of the option string</span>
                    <span class="s3">let </span><span class="s1">chars = </span><span class="s3">this</span><span class="s1">.prefix_chars</span>
                    <span class="s3">if </span><span class="s1">(arg_count === </span><span class="s4">0 </span><span class="s1">&amp;&amp; !chars.includes(option_string[</span><span class="s4">1</span><span class="s1">])) {</span>
                        <span class="s1">action_tuples.push([ action, [], option_string ])</span>
                        <span class="s3">let </span><span class="s1">char = option_string[</span><span class="s4">0</span><span class="s1">]</span>
                        <span class="s1">option_string = char + explicit_arg[</span><span class="s4">0</span><span class="s1">]</span>
                        <span class="s3">let </span><span class="s1">new_explicit_arg = explicit_arg.slice(</span><span class="s4">1</span><span class="s1">) || undefined</span>
                        <span class="s3">let </span><span class="s1">optionals_map = </span><span class="s3">this</span><span class="s1">._option_string_actions</span>
                        <span class="s3">if </span><span class="s1">(hasattr(optionals_map, option_string)) {</span>
                            <span class="s1">action = optionals_map[option_string]</span>
                            <span class="s1">explicit_arg = new_explicit_arg</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'ignored explicit argument %r'</span>
                            <span class="s3">throw new </span><span class="s1">ArgumentError(action, sub(msg, explicit_arg))</span>
                        <span class="s1">}</span>

                    <span class="s0">// if the action expect exactly one argument, we've</span>
                    <span class="s0">// successfully matched the option; exit the loop</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(arg_count === </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s1">stop = start_index + </span><span class="s4">1</span>
                        <span class="s3">let </span><span class="s1">args = [ explicit_arg ]</span>
                        <span class="s1">action_tuples.push([ action, args, option_string ])</span>
                        <span class="s3">break</span>

                    <span class="s0">// error if a double-dash option did not use the</span>
                    <span class="s0">// explicit argument</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'ignored explicit argument %r'</span>
                        <span class="s3">throw new </span><span class="s1">ArgumentError(action, sub(msg, explicit_arg))</span>
                    <span class="s1">}</span>

                <span class="s0">// if there is no explicit argument, try to match the</span>
                <span class="s0">// optional's string arguments with the following strings</span>
                <span class="s0">// if successful, exit the loop</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">let </span><span class="s1">start = start_index + </span><span class="s4">1</span>
                    <span class="s3">let </span><span class="s1">selected_patterns = arg_strings_pattern.slice(start)</span>
                    <span class="s3">let </span><span class="s1">arg_count = </span><span class="s3">this</span><span class="s1">._match_argument(action, selected_patterns)</span>
                    <span class="s1">stop = start + arg_count</span>
                    <span class="s3">let </span><span class="s1">args = arg_strings.slice(start, stop)</span>
                    <span class="s1">action_tuples.push([ action, args, option_string ])</span>
                    <span class="s3">break</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s0">// add the Optional to the list and return the index at which</span>
            <span class="s0">// the Optional's string args stopped</span>
            <span class="s1">assert(action_tuples.length)</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">[ action, args, option_string ] of action_tuples) {</span>
                <span class="s1">take_action(action, args, option_string)</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">stop</span>
        <span class="s1">}</span>

        <span class="s0">// the list of Positionals left to be parsed; this is modified</span>
        <span class="s0">// by consume_positionals()</span>
        <span class="s3">let </span><span class="s1">positionals = </span><span class="s3">this</span><span class="s1">._get_positional_actions()</span>

        <span class="s0">// function to convert arg_strings into positional actions</span>
        <span class="s3">let </span><span class="s1">consume_positionals = start_index =&gt; {</span>
            <span class="s0">// match as many Positionals as possible</span>
            <span class="s3">let </span><span class="s1">selected_pattern = arg_strings_pattern.slice(start_index)</span>
            <span class="s3">let </span><span class="s1">arg_counts = </span><span class="s3">this</span><span class="s1">._match_arguments_partial(positionals, selected_pattern)</span>

            <span class="s0">// slice off the appropriate arg strings for each Positional</span>
            <span class="s0">// and add the Positional and its args to the list</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; positionals.length &amp;&amp; i &lt; arg_counts.length; i++) {</span>
                <span class="s3">let </span><span class="s1">action = positionals[i]</span>
                <span class="s3">let </span><span class="s1">arg_count = arg_counts[i]</span>
                <span class="s3">let </span><span class="s1">args = arg_strings.slice(start_index, start_index + arg_count)</span>
                <span class="s1">start_index += arg_count</span>
                <span class="s1">take_action(action, args)</span>
            <span class="s1">}</span>

            <span class="s0">// slice off the Positionals that we just parsed and return the</span>
            <span class="s0">// index at which the Positionals' string args stopped</span>
            <span class="s1">positionals = positionals.slice(arg_counts.length)</span>
            <span class="s3">return </span><span class="s1">start_index</span>
        <span class="s1">}</span>

        <span class="s0">// consume Positionals and Optionals alternately, until we have</span>
        <span class="s0">// passed the last option string</span>
        <span class="s1">extras = []</span>
        <span class="s3">let </span><span class="s1">start_index = </span><span class="s4">0</span>
        <span class="s3">let </span><span class="s1">max_option_string_index = Math.max(-</span><span class="s4">1</span><span class="s1">, ...Object.keys(option_string_indices).map(Number))</span>
        <span class="s3">while </span><span class="s1">(start_index &lt;= max_option_string_index) {</span>

            <span class="s0">// consume any Positionals preceding the next option</span>
            <span class="s3">let </span><span class="s1">next_option_string_index = Math.min(</span>
                <span class="s0">// eslint-disable-next-line no-loop-func</span>
                <span class="s1">...Object.keys(option_string_indices).map(Number).filter(index =&gt; index &gt;= start_index)</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">(start_index !== next_option_string_index) {</span>
                <span class="s3">let </span><span class="s1">positionals_end_index = consume_positionals(start_index)</span>

                <span class="s0">// only try to parse the next optional if we didn't consume</span>
                <span class="s0">// the option string during the positionals parsing</span>
                <span class="s3">if </span><span class="s1">(positionals_end_index &gt; start_index) {</span>
                    <span class="s1">start_index = positionals_end_index</span>
                    <span class="s3">continue</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">start_index = positionals_end_index</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s0">// if we consumed all the positionals we could and we're not</span>
            <span class="s0">// at the index of an option string, there were extra arguments</span>
            <span class="s3">if </span><span class="s1">(!(start_index </span><span class="s3">in </span><span class="s1">option_string_indices)) {</span>
                <span class="s3">let </span><span class="s1">strings = arg_strings.slice(start_index, next_option_string_index)</span>
                <span class="s1">extras = extras.concat(strings)</span>
                <span class="s1">start_index = next_option_string_index</span>
            <span class="s1">}</span>

            <span class="s0">// consume the next optional and any arguments for it</span>
            <span class="s1">start_index = consume_optional(start_index)</span>
        <span class="s1">}</span>

        <span class="s0">// consume any positionals following the last Optional</span>
        <span class="s3">let </span><span class="s1">stop_index = consume_positionals(start_index)</span>

        <span class="s0">// if we didn't consume all the argument strings, there were extras</span>
        <span class="s1">extras = extras.concat(arg_strings.slice(stop_index))</span>

        <span class="s0">// make sure all required actions were present and also convert</span>
        <span class="s0">// action defaults which were not given as arguments</span>
        <span class="s3">let </span><span class="s1">required_actions = []</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of </span><span class="s3">this</span><span class="s1">._actions) {</span>
            <span class="s3">if </span><span class="s1">(!seen_actions.has(action)) {</span>
                <span class="s3">if </span><span class="s1">(action.required) {</span>
                    <span class="s1">required_actions.push(_get_action_name(action))</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s0">// Convert action default now instead of doing it before</span>
                    <span class="s0">// parsing arguments to avoid calling convert functions</span>
                    <span class="s0">// twice (which may fail) if the argument was given, but</span>
                    <span class="s0">// only if it was defined already in the namespace</span>
                    <span class="s3">if </span><span class="s1">(action.default !== undefined &amp;&amp;</span>
                        <span class="s3">typeof </span><span class="s1">action.default === </span><span class="s2">'string' </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">hasattr(namespace, action.dest) &amp;&amp;</span>
                        <span class="s1">action.default === getattr(namespace, action.dest)) {</span>
                        <span class="s1">setattr(namespace, action.dest,</span>
                                <span class="s3">this</span><span class="s1">._get_value(action, action.default))</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(required_actions.length) {</span>
            <span class="s3">this</span><span class="s1">.error(sub(</span><span class="s2">'the following arguments are required: %s'</span><span class="s1">,</span>
                       <span class="s1">required_actions.join(</span><span class="s2">', '</span><span class="s1">)))</span>
        <span class="s1">}</span>

        <span class="s0">// make sure all required groups had one option present</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">group of </span><span class="s3">this</span><span class="s1">._mutually_exclusive_groups) {</span>
            <span class="s3">if </span><span class="s1">(group.required) {</span>
                <span class="s3">let </span><span class="s1">no_actions_used = </span><span class="s3">true</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of group._group_actions) {</span>
                    <span class="s3">if </span><span class="s1">(seen_non_default_actions.has(action)) {</span>
                        <span class="s1">no_actions_used = </span><span class="s3">false</span>
                        <span class="s3">break</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s0">// if no actions were used, report the error</span>
                <span class="s3">if </span><span class="s1">(no_actions_used) {</span>
                    <span class="s3">let </span><span class="s1">names = group._group_actions</span>
                        <span class="s1">.filter(action =&gt; action.help !== SUPPRESS)</span>
                        <span class="s1">.map(action =&gt; _get_action_name(action))</span>
                    <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'one of the arguments %s is required'</span>
                    <span class="s3">this</span><span class="s1">.error(sub(msg, names.join(</span><span class="s2">' '</span><span class="s1">)))</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// return the updated namespace and the extra arguments</span>
        <span class="s3">return </span><span class="s1">[ namespace, extras ]</span>
    <span class="s1">}</span>

    <span class="s1">_read_args_from_files(arg_strings) {</span>
        <span class="s0">// expand arguments referencing files</span>
        <span class="s3">let </span><span class="s1">new_arg_strings = []</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">arg_string of arg_strings) {</span>

            <span class="s0">// for regular arguments, just add them back into the list</span>
            <span class="s3">if </span><span class="s1">(!arg_string || !</span><span class="s3">this</span><span class="s1">.fromfile_prefix_chars.includes(arg_string[</span><span class="s4">0</span><span class="s1">])) {</span>
                <span class="s1">new_arg_strings.push(arg_string)</span>

            <span class="s0">// replace arguments referencing files with the file content</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s3">let </span><span class="s1">args_file = fs.readFileSync(arg_string.slice(</span><span class="s4">1</span><span class="s1">), </span><span class="s2">'utf8'</span><span class="s1">)</span>
                    <span class="s3">let </span><span class="s1">arg_strings = []</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">arg_line of splitlines(args_file)) {</span>
                        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">arg of </span><span class="s3">this</span><span class="s1">.convert_arg_line_to_args(arg_line)) {</span>
                            <span class="s1">arg_strings.push(arg)</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">arg_strings = </span><span class="s3">this</span><span class="s1">._read_args_from_files(arg_strings)</span>
                    <span class="s1">new_arg_strings = new_arg_strings.concat(arg_strings)</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                    <span class="s3">this</span><span class="s1">.error(err.message)</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// return the modified argument list</span>
        <span class="s3">return </span><span class="s1">new_arg_strings</span>
    <span class="s1">}</span>

    <span class="s1">convert_arg_line_to_args(arg_line) {</span>
        <span class="s3">return </span><span class="s1">[arg_line]</span>
    <span class="s1">}</span>

    <span class="s1">_match_argument(action, arg_strings_pattern) {</span>
        <span class="s0">// match the pattern for this action to the arg strings</span>
        <span class="s3">let </span><span class="s1">nargs_pattern = </span><span class="s3">this</span><span class="s1">._get_nargs_pattern(action)</span>
        <span class="s3">let </span><span class="s1">match = arg_strings_pattern.match(</span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^' </span><span class="s1">+ nargs_pattern))</span>

        <span class="s0">// raise an exception if we weren't able to find a match</span>
        <span class="s3">if </span><span class="s1">(match === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">let </span><span class="s1">nargs_errors = {</span>
                <span class="s1">undefined: </span><span class="s2">'expected one argument'</span><span class="s1">,</span>
                <span class="s1">[OPTIONAL]: </span><span class="s2">'expected at most one argument'</span><span class="s1">,</span>
                <span class="s1">[ONE_OR_MORE]: </span><span class="s2">'expected at least one argument'</span>
            <span class="s1">}</span>
            <span class="s3">let </span><span class="s1">msg = nargs_errors[action.nargs]</span>
            <span class="s3">if </span><span class="s1">(msg === undefined) {</span>
                <span class="s1">msg = sub(action.nargs === </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">'expected %s argument' </span><span class="s1">: </span><span class="s2">'expected %s arguments'</span><span class="s1">, action.nargs)</span>
            <span class="s1">}</span>
            <span class="s3">throw new </span><span class="s1">ArgumentError(action, msg)</span>
        <span class="s1">}</span>

        <span class="s0">// return the number of arguments matched</span>
        <span class="s3">return </span><span class="s1">match[</span><span class="s4">1</span><span class="s1">].length</span>
    <span class="s1">}</span>

    <span class="s1">_match_arguments_partial(actions, arg_strings_pattern) {</span>
        <span class="s0">// progressively shorten the actions list by slicing off the</span>
        <span class="s0">// final actions until we find a match</span>
        <span class="s3">let </span><span class="s1">result = []</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">i of range(actions.length, </span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">)) {</span>
            <span class="s3">let </span><span class="s1">actions_slice = actions.slice(</span><span class="s4">0</span><span class="s1">, i)</span>
            <span class="s3">let </span><span class="s1">pattern = actions_slice.map(action =&gt; </span><span class="s3">this</span><span class="s1">._get_nargs_pattern(action)).join(</span><span class="s2">''</span><span class="s1">)</span>
            <span class="s3">let </span><span class="s1">match = arg_strings_pattern.match(</span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^' </span><span class="s1">+ pattern))</span>
            <span class="s3">if </span><span class="s1">(match !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">result = result.concat(match.slice(</span><span class="s4">1</span><span class="s1">).map(string =&gt; string.length))</span>
                <span class="s3">break</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// return the list of arg string counts</span>
        <span class="s3">return </span><span class="s1">result</span>
    <span class="s1">}</span>

    <span class="s1">_parse_optional(arg_string) {</span>
        <span class="s0">// if it's an empty string, it was meant to be a positional</span>
        <span class="s3">if </span><span class="s1">(!arg_string) {</span>
            <span class="s3">return </span><span class="s1">undefined</span>
        <span class="s1">}</span>

        <span class="s0">// if it doesn't start with a prefix, it was meant to be positional</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.prefix_chars.includes(arg_string[</span><span class="s4">0</span><span class="s1">])) {</span>
            <span class="s3">return </span><span class="s1">undefined</span>
        <span class="s1">}</span>

        <span class="s0">// if the option string is present in the parser, return the action</span>
        <span class="s3">if </span><span class="s1">(arg_string </span><span class="s3">in this</span><span class="s1">._option_string_actions) {</span>
            <span class="s3">let </span><span class="s1">action = </span><span class="s3">this</span><span class="s1">._option_string_actions[arg_string]</span>
            <span class="s3">return </span><span class="s1">[ action, arg_string, undefined ]</span>
        <span class="s1">}</span>

        <span class="s0">// if it's just a single character, it was meant to be positional</span>
        <span class="s3">if </span><span class="s1">(arg_string.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">undefined</span>
        <span class="s1">}</span>

        <span class="s0">// if the option string before the &quot;=&quot; is present, return the action</span>
        <span class="s3">if </span><span class="s1">(arg_string.includes(</span><span class="s2">'='</span><span class="s1">)) {</span>
            <span class="s3">let </span><span class="s1">[ option_string, explicit_arg ] = _string_split(arg_string, </span><span class="s2">'='</span><span class="s1">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">(option_string </span><span class="s3">in this</span><span class="s1">._option_string_actions) {</span>
                <span class="s3">let </span><span class="s1">action = </span><span class="s3">this</span><span class="s1">._option_string_actions[option_string]</span>
                <span class="s3">return </span><span class="s1">[ action, option_string, explicit_arg ]</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// search through all possible prefixes of the option string</span>
        <span class="s0">// and all actions in the parser for possible interpretations</span>
        <span class="s3">let </span><span class="s1">option_tuples = </span><span class="s3">this</span><span class="s1">._get_option_tuples(arg_string)</span>

        <span class="s0">// if multiple actions match, the option string was ambiguous</span>
        <span class="s3">if </span><span class="s1">(option_tuples.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">let </span><span class="s1">options = option_tuples.map(([ </span><span class="s0">/*action*/</span><span class="s1">, option_string</span><span class="s0">/*, explicit_arg*/ </span><span class="s1">]) =&gt; option_string).join(</span><span class="s2">', '</span><span class="s1">)</span>
            <span class="s3">let </span><span class="s1">args = {option: arg_string, matches: options}</span>
            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'ambiguous option: %(option)s could match %(matches)s'</span>
            <span class="s3">this</span><span class="s1">.error(sub(msg, args))</span>

        <span class="s0">// if exactly one action matched, this segmentation is good,</span>
        <span class="s0">// so return the parsed action</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(option_tuples.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">let </span><span class="s1">[ option_tuple ] = option_tuples</span>
            <span class="s3">return </span><span class="s1">option_tuple</span>
        <span class="s1">}</span>

        <span class="s0">// if it was not found as an option, but it looks like a negative</span>
        <span class="s0">// number, it was meant to be positional</span>
        <span class="s0">// unless there are negative-number-like options</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._negative_number_matcher.test(arg_string)) {</span>
            <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">._has_negative_number_optionals.length) {</span>
                <span class="s3">return </span><span class="s1">undefined</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// if it contains a space, it was meant to be a positional</span>
        <span class="s3">if </span><span class="s1">(arg_string.includes(</span><span class="s2">' '</span><span class="s1">)) {</span>
            <span class="s3">return </span><span class="s1">undefined</span>
        <span class="s1">}</span>

        <span class="s0">// it was meant to be an optional but there is no such option</span>
        <span class="s0">// in this parser (though it might be a valid option in a subparser)</span>
        <span class="s3">return </span><span class="s1">[ undefined, arg_string, undefined ]</span>
    <span class="s1">}</span>

    <span class="s1">_get_option_tuples(option_string) {</span>
        <span class="s3">let </span><span class="s1">result = []</span>

        <span class="s0">// option strings starting with two prefix characters are only</span>
        <span class="s0">// split at the '='</span>
        <span class="s3">let </span><span class="s1">chars = </span><span class="s3">this</span><span class="s1">.prefix_chars</span>
        <span class="s3">if </span><span class="s1">(chars.includes(option_string[</span><span class="s4">0</span><span class="s1">]) &amp;&amp; chars.includes(option_string[</span><span class="s4">1</span><span class="s1">])) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.allow_abbrev) {</span>
                <span class="s3">let </span><span class="s1">option_prefix, explicit_arg</span>
                <span class="s3">if </span><span class="s1">(option_string.includes(</span><span class="s2">'='</span><span class="s1">)) {</span>
                    <span class="s1">[ option_prefix, explicit_arg ] = _string_split(option_string, </span><span class="s2">'='</span><span class="s1">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">option_prefix = option_string</span>
                    <span class="s1">explicit_arg = undefined</span>
                <span class="s1">}</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">option_string of Object.keys(</span><span class="s3">this</span><span class="s1">._option_string_actions)) {</span>
                    <span class="s3">if </span><span class="s1">(option_string.startsWith(option_prefix)) {</span>
                        <span class="s3">let </span><span class="s1">action = </span><span class="s3">this</span><span class="s1">._option_string_actions[option_string]</span>
                        <span class="s3">let </span><span class="s1">tup = [ action, option_string, explicit_arg ]</span>
                        <span class="s1">result.push(tup)</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

        <span class="s0">// single character options can be concatenated with their arguments</span>
        <span class="s0">// but multiple character options always have to have their argument</span>
        <span class="s0">// separate</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(chars.includes(option_string[</span><span class="s4">0</span><span class="s1">]) &amp;&amp; !chars.includes(option_string[</span><span class="s4">1</span><span class="s1">])) {</span>
            <span class="s3">let </span><span class="s1">option_prefix = option_string</span>
            <span class="s3">let </span><span class="s1">explicit_arg = undefined</span>
            <span class="s3">let </span><span class="s1">short_option_prefix = option_string.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">let </span><span class="s1">short_explicit_arg = option_string.slice(</span><span class="s4">2</span><span class="s1">)</span>

            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">option_string of Object.keys(</span><span class="s3">this</span><span class="s1">._option_string_actions)) {</span>
                <span class="s3">if </span><span class="s1">(option_string === short_option_prefix) {</span>
                    <span class="s3">let </span><span class="s1">action = </span><span class="s3">this</span><span class="s1">._option_string_actions[option_string]</span>
                    <span class="s3">let </span><span class="s1">tup = [ action, option_string, short_explicit_arg ]</span>
                    <span class="s1">result.push(tup)</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(option_string.startsWith(option_prefix)) {</span>
                    <span class="s3">let </span><span class="s1">action = </span><span class="s3">this</span><span class="s1">._option_string_actions[option_string]</span>
                    <span class="s3">let </span><span class="s1">tup = [ action, option_string, explicit_arg ]</span>
                    <span class="s1">result.push(tup)</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

        <span class="s0">// shouldn't ever get here</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">this</span><span class="s1">.error(sub(</span><span class="s2">'unexpected option string: %s'</span><span class="s1">, option_string))</span>
        <span class="s1">}</span>

        <span class="s0">// return the collected option tuples</span>
        <span class="s3">return </span><span class="s1">result</span>
    <span class="s1">}</span>

    <span class="s1">_get_nargs_pattern(action) {</span>
        <span class="s0">// in all examples below, we have to allow for '--' args</span>
        <span class="s0">// which are represented as '-' in the pattern</span>
        <span class="s3">let </span><span class="s1">nargs = action.nargs</span>
        <span class="s3">let </span><span class="s1">nargs_pattern</span>

        <span class="s0">// the default (None) is assumed to be a single argument</span>
        <span class="s3">if </span><span class="s1">(nargs === undefined) {</span>
            <span class="s1">nargs_pattern = </span><span class="s2">'(-*A-*)'</span>

        <span class="s0">// allow zero or one arguments</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nargs === OPTIONAL) {</span>
            <span class="s1">nargs_pattern = </span><span class="s2">'(-*A?-*)'</span>

        <span class="s0">// allow zero or more arguments</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nargs === ZERO_OR_MORE) {</span>
            <span class="s1">nargs_pattern = </span><span class="s2">'(-*[A-]*)'</span>

        <span class="s0">// allow one or more arguments</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nargs === ONE_OR_MORE) {</span>
            <span class="s1">nargs_pattern = </span><span class="s2">'(-*A[A-]*)'</span>

        <span class="s0">// allow any number of options or arguments</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nargs === REMAINDER) {</span>
            <span class="s1">nargs_pattern = </span><span class="s2">'([-AO]*)'</span>

        <span class="s0">// allow one argument followed by any number of options or arguments</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nargs === PARSER) {</span>
            <span class="s1">nargs_pattern = </span><span class="s2">'(-*A[-AO]*)'</span>

        <span class="s0">// suppress action, like nargs=0</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nargs === SUPPRESS) {</span>
            <span class="s1">nargs_pattern = </span><span class="s2">'(-*-*)'</span>

        <span class="s0">// all others should be integers</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">nargs_pattern = sub(</span><span class="s2">'(-*%s-*)'</span><span class="s1">, </span><span class="s2">'A'</span><span class="s1">.repeat(nargs).split(</span><span class="s2">''</span><span class="s1">).join(</span><span class="s2">'-*'</span><span class="s1">))</span>
        <span class="s1">}</span>

        <span class="s0">// if this is an optional action, -- is not allowed</span>
        <span class="s3">if </span><span class="s1">(action.option_strings.length) {</span>
            <span class="s1">nargs_pattern = nargs_pattern.replace(</span><span class="s5">/-\*/g</span><span class="s1">, </span><span class="s2">''</span><span class="s1">)</span>
            <span class="s1">nargs_pattern = nargs_pattern.replace(</span><span class="s5">/-/g</span><span class="s1">, </span><span class="s2">''</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s0">// return the pattern</span>
        <span class="s3">return </span><span class="s1">nargs_pattern</span>
    <span class="s1">}</span>

    <span class="s0">// ========================</span>
    <span class="s0">// Alt command line argument parsing, allowing free intermix</span>
    <span class="s0">// ========================</span>

    <span class="s1">parse_intermixed_args(args = undefined, namespace = undefined) {</span>
        <span class="s3">let </span><span class="s1">argv</span>
        <span class="s1">[ args, argv ] = </span><span class="s3">this</span><span class="s1">.parse_known_intermixed_args(args, namespace)</span>
        <span class="s3">if </span><span class="s1">(argv.length) {</span>
            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'unrecognized arguments: %s'</span>
            <span class="s3">this</span><span class="s1">.error(sub(msg, argv.join(</span><span class="s2">' '</span><span class="s1">)))</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">args</span>
    <span class="s1">}</span>

    <span class="s1">parse_known_intermixed_args(args = undefined, namespace = undefined) {</span>
        <span class="s0">// returns a namespace and list of extras</span>
        <span class="s0">//</span>
        <span class="s0">// positional can be freely intermixed with optionals.  optionals are</span>
        <span class="s0">// first parsed with all positional arguments deactivated.  The 'extras'</span>
        <span class="s0">// are then parsed.  If the parser definition is incompatible with the</span>
        <span class="s0">// intermixed assumptions (e.g. use of REMAINDER, subparsers) a</span>
        <span class="s0">// TypeError is raised.</span>
        <span class="s0">//</span>
        <span class="s0">// positionals are 'deactivated' by setting nargs and default to</span>
        <span class="s0">// SUPPRESS.  This blocks the addition of that positional to the</span>
        <span class="s0">// namespace</span>

        <span class="s3">let </span><span class="s1">extras</span>
        <span class="s3">let </span><span class="s1">positionals = </span><span class="s3">this</span><span class="s1">._get_positional_actions()</span>
        <span class="s3">let </span><span class="s1">a = positionals.filter(action =&gt; [ PARSER, REMAINDER ].includes(action.nargs))</span>
        <span class="s3">if </span><span class="s1">(a.length) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(sub(</span><span class="s2">'parse_intermixed_args: positional arg' </span><span class="s1">+</span>
                                    <span class="s2">' with nargs=%s'</span><span class="s1">, a[</span><span class="s4">0</span><span class="s1">].nargs))</span>
        <span class="s1">}</span>

        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">group of </span><span class="s3">this</span><span class="s1">._mutually_exclusive_groups) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of group._group_actions) {</span>
                <span class="s3">if </span><span class="s1">(positionals.includes(action)) {</span>
                    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'parse_intermixed_args: positional in' </span><span class="s1">+</span>
                                        <span class="s2">' mutuallyExclusiveGroup'</span><span class="s1">)</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">let </span><span class="s1">save_usage</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">save_usage = </span><span class="s3">this</span><span class="s1">.usage</span>
            <span class="s3">let </span><span class="s1">remaining_args</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.usage === undefined) {</span>
                    <span class="s0">// capture the full usage for use in error messages</span>
                    <span class="s3">this</span><span class="s1">.usage = </span><span class="s3">this</span><span class="s1">.format_usage().slice(</span><span class="s4">7</span><span class="s1">)</span>
                <span class="s1">}</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of positionals) {</span>
                    <span class="s0">// deactivate positionals</span>
                    <span class="s1">action.save_nargs = action.nargs</span>
                    <span class="s0">// action.nargs = 0</span>
                    <span class="s1">action.nargs = SUPPRESS</span>
                    <span class="s1">action.save_default = action.default</span>
                    <span class="s1">action.default = SUPPRESS</span>
                <span class="s1">}</span>
                <span class="s1">[ namespace, remaining_args ] = </span><span class="s3">this</span><span class="s1">.parse_known_args(args,</span>
                                                                      <span class="s1">namespace)</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of positionals) {</span>
                    <span class="s0">// remove the empty positional values from namespace</span>
                    <span class="s3">let </span><span class="s1">attr = getattr(namespace, action.dest)</span>
                    <span class="s3">if </span><span class="s1">(Array.isArray(attr) &amp;&amp; attr.length === </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s0">// eslint-disable-next-line no-console</span>
                        <span class="s1">console.warn(sub(</span><span class="s2">'Do not expect %s in %s'</span><span class="s1">, action.dest, namespace))</span>
                        <span class="s1">delattr(namespace, action.dest)</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                <span class="s0">// restore nargs and usage before exiting</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of positionals) {</span>
                    <span class="s1">action.nargs = action.save_nargs</span>
                    <span class="s1">action.default = action.save_default</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">let </span><span class="s1">optionals = </span><span class="s3">this</span><span class="s1">._get_optional_actions()</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s0">// parse positionals.  optionals aren't normally required, but</span>
                <span class="s0">// they could be, so make sure they aren't.</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of optionals) {</span>
                    <span class="s1">action.save_required = action.required</span>
                    <span class="s1">action.required = </span><span class="s3">false</span>
                <span class="s1">}</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">group of </span><span class="s3">this</span><span class="s1">._mutually_exclusive_groups) {</span>
                    <span class="s1">group.save_required = group.required</span>
                    <span class="s1">group.required = </span><span class="s3">false</span>
                <span class="s1">}</span>
                <span class="s1">[ namespace, extras ] = </span><span class="s3">this</span><span class="s1">.parse_known_args(remaining_args,</span>
                                                              <span class="s1">namespace)</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                <span class="s0">// restore parser values before exiting</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action of optionals) {</span>
                    <span class="s1">action.required = action.save_required</span>
                <span class="s1">}</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">group of </span><span class="s3">this</span><span class="s1">._mutually_exclusive_groups) {</span>
                    <span class="s1">group.required = group.save_required</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
            <span class="s3">this</span><span class="s1">.usage = save_usage</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">[ namespace, extras ]</span>
    <span class="s1">}</span>

    <span class="s0">// ========================</span>
    <span class="s0">// Value conversion methods</span>
    <span class="s0">// ========================</span>
    <span class="s1">_get_values(action, arg_strings) {</span>
        <span class="s0">// for everything but PARSER, REMAINDER args, strip out first '--'</span>
        <span class="s3">if </span><span class="s1">(![PARSER, REMAINDER].includes(action.nargs)) {</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">_array_remove(arg_strings, </span><span class="s2">'--'</span><span class="s1">)</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {}</span>
        <span class="s1">}</span>

        <span class="s3">let </span><span class="s1">value</span>
        <span class="s0">// optional argument produces a default when not present</span>
        <span class="s3">if </span><span class="s1">(!arg_strings.length &amp;&amp; action.nargs === OPTIONAL) {</span>
            <span class="s3">if </span><span class="s1">(action.option_strings.length) {</span>
                <span class="s1">value = action.const</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">value = action.default</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'string'</span><span class="s1">) {</span>
                <span class="s1">value = </span><span class="s3">this</span><span class="s1">._get_value(action, value)</span>
                <span class="s3">this</span><span class="s1">._check_value(action, value)</span>
            <span class="s1">}</span>

        <span class="s0">// when nargs='*' on a positional, if there were no command-line</span>
        <span class="s0">// args, use the default if it is anything other than None</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!arg_strings.length &amp;&amp; action.nargs === ZERO_OR_MORE &amp;&amp;</span>
              <span class="s1">!action.option_strings.length) {</span>
            <span class="s3">if </span><span class="s1">(action.default !== undefined) {</span>
                <span class="s1">value = action.default</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">value = arg_strings</span>
            <span class="s1">}</span>
            <span class="s3">this</span><span class="s1">._check_value(action, value)</span>

        <span class="s0">// single argument or optional argument produces a single value</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(arg_strings.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; [undefined, OPTIONAL].includes(action.nargs)) {</span>
            <span class="s3">let </span><span class="s1">arg_string = arg_strings[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">value = </span><span class="s3">this</span><span class="s1">._get_value(action, arg_string)</span>
            <span class="s3">this</span><span class="s1">._check_value(action, value)</span>

        <span class="s0">// REMAINDER arguments convert all values, checking none</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === REMAINDER) {</span>
            <span class="s1">value = arg_strings.map(v =&gt; </span><span class="s3">this</span><span class="s1">._get_value(action, v))</span>

        <span class="s0">// PARSER arguments convert all values, but check only the first</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === PARSER) {</span>
            <span class="s1">value = arg_strings.map(v =&gt; </span><span class="s3">this</span><span class="s1">._get_value(action, v))</span>
            <span class="s3">this</span><span class="s1">._check_value(action, value[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s0">// SUPPRESS argument does not put anything in the namespace</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === SUPPRESS) {</span>
            <span class="s1">value = SUPPRESS</span>

        <span class="s0">// all other types of nargs produce a list</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">value = arg_strings.map(v =&gt; </span><span class="s3">this</span><span class="s1">._get_value(action, v))</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">v of value) {</span>
                <span class="s3">this</span><span class="s1">._check_value(action, v)</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// return the converted value</span>
        <span class="s3">return </span><span class="s1">value</span>
    <span class="s1">}</span>

    <span class="s1">_get_value(action, arg_string) {</span>
        <span class="s3">let </span><span class="s1">type_func = </span><span class="s3">this</span><span class="s1">._registry_get(</span><span class="s2">'type'</span><span class="s1">, action.type, action.type)</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type_func !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'%r is not callable'</span>
            <span class="s3">throw new </span><span class="s1">ArgumentError(action, sub(msg, type_func))</span>
        <span class="s1">}</span>

        <span class="s0">// convert the value to the appropriate type</span>
        <span class="s3">let </span><span class="s1">result</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">result = type_func(arg_string)</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                <span class="s0">// Dear TC39, why would you ever consider making es6 classes not callable?</span>
                <span class="s0">// We had one universal interface, [[Call]], which worked for anything</span>
                <span class="s0">// (with familiar this-instanceof guard for classes). Now we have two.</span>
                <span class="s3">if </span><span class="s1">(err </span><span class="s3">instanceof </span><span class="s1">TypeError &amp;&amp;</span>
                    <span class="s5">/Class constructor .* cannot be invoked without 'new'/</span><span class="s1">.test(err.message)) {</span>
                    <span class="s0">// eslint-disable-next-line new-cap</span>
                    <span class="s1">result = </span><span class="s3">new </span><span class="s1">type_func(arg_string)</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">throw </span><span class="s1">err</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
            <span class="s0">// ArgumentTypeErrors indicate errors</span>
            <span class="s3">if </span><span class="s1">(err </span><span class="s3">instanceof </span><span class="s1">ArgumentTypeError) {</span>
                <span class="s0">//let name = getattr(action.type, 'name', repr(action.type))</span>
                <span class="s3">let </span><span class="s1">msg = err.message</span>
                <span class="s3">throw new </span><span class="s1">ArgumentError(action, msg)</span>

            <span class="s0">// TypeErrors or ValueErrors also indicate errors</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(err </span><span class="s3">instanceof </span><span class="s1">TypeError) {</span>
                <span class="s3">let </span><span class="s1">name = getattr(action.type, </span><span class="s2">'name'</span><span class="s1">, repr(action.type))</span>
                <span class="s3">let </span><span class="s1">args = {type: name, value: arg_string}</span>
                <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'invalid %(type)s value: %(value)r'</span>
                <span class="s3">throw new </span><span class="s1">ArgumentError(action, sub(msg, args))</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">throw </span><span class="s1">err</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// return the converted value</span>
        <span class="s3">return </span><span class="s1">result</span>
    <span class="s1">}</span>

    <span class="s1">_check_value(action, value) {</span>
        <span class="s0">// converted value must be one of the choices (if specified)</span>
        <span class="s3">if </span><span class="s1">(action.choices !== undefined &amp;&amp; !_choices_to_array(action.choices).includes(value)) {</span>
            <span class="s3">let </span><span class="s1">args = {value,</span>
                        <span class="s1">choices: _choices_to_array(action.choices).map(repr).join(</span><span class="s2">', '</span><span class="s1">)}</span>
            <span class="s3">let </span><span class="s1">msg = </span><span class="s2">'invalid choice: %(value)r (choose from %(choices)s)'</span>
            <span class="s3">throw new </span><span class="s1">ArgumentError(action, sub(msg, args))</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// =======================</span>
    <span class="s0">// Help-formatting methods</span>
    <span class="s0">// =======================</span>
    <span class="s1">format_usage() {</span>
        <span class="s3">let </span><span class="s1">formatter = </span><span class="s3">this</span><span class="s1">._get_formatter()</span>
        <span class="s1">formatter.add_usage(</span><span class="s3">this</span><span class="s1">.usage, </span><span class="s3">this</span><span class="s1">._actions,</span>
                            <span class="s3">this</span><span class="s1">._mutually_exclusive_groups)</span>
        <span class="s3">return </span><span class="s1">formatter.format_help()</span>
    <span class="s1">}</span>

    <span class="s1">format_help() {</span>
        <span class="s3">let </span><span class="s1">formatter = </span><span class="s3">this</span><span class="s1">._get_formatter()</span>

        <span class="s0">// usage</span>
        <span class="s1">formatter.add_usage(</span><span class="s3">this</span><span class="s1">.usage, </span><span class="s3">this</span><span class="s1">._actions,</span>
                            <span class="s3">this</span><span class="s1">._mutually_exclusive_groups)</span>

        <span class="s0">// description</span>
        <span class="s1">formatter.add_text(</span><span class="s3">this</span><span class="s1">.description)</span>

        <span class="s0">// positionals, optionals and user-defined groups</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">let </span><span class="s1">action_group of </span><span class="s3">this</span><span class="s1">._action_groups) {</span>
            <span class="s1">formatter.start_section(action_group.title)</span>
            <span class="s1">formatter.add_text(action_group.description)</span>
            <span class="s1">formatter.add_arguments(action_group._group_actions)</span>
            <span class="s1">formatter.end_section()</span>
        <span class="s1">}</span>

        <span class="s0">// epilog</span>
        <span class="s1">formatter.add_text(</span><span class="s3">this</span><span class="s1">.epilog)</span>

        <span class="s0">// determine help from format above</span>
        <span class="s3">return </span><span class="s1">formatter.format_help()</span>
    <span class="s1">}</span>

    <span class="s1">_get_formatter() {</span>
        <span class="s0">// eslint-disable-next-line new-cap</span>
        <span class="s3">return new this</span><span class="s1">.formatter_class({ prog: </span><span class="s3">this</span><span class="s1">.prog })</span>
    <span class="s1">}</span>

    <span class="s0">// =====================</span>
    <span class="s0">// Help-printing methods</span>
    <span class="s0">// =====================</span>
    <span class="s1">print_usage(file = undefined) {</span>
        <span class="s3">if </span><span class="s1">(file === undefined) file = process.stdout</span>
        <span class="s3">this</span><span class="s1">._print_message(</span><span class="s3">this</span><span class="s1">.format_usage(), file)</span>
    <span class="s1">}</span>

    <span class="s1">print_help(file = undefined) {</span>
        <span class="s3">if </span><span class="s1">(file === undefined) file = process.stdout</span>
        <span class="s3">this</span><span class="s1">._print_message(</span><span class="s3">this</span><span class="s1">.format_help(), file)</span>
    <span class="s1">}</span>

    <span class="s1">_print_message(message, file = undefined) {</span>
        <span class="s3">if </span><span class="s1">(message) {</span>
            <span class="s3">if </span><span class="s1">(file === undefined) file = process.stderr</span>
            <span class="s1">file.write(message)</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// ===============</span>
    <span class="s0">// Exiting methods</span>
    <span class="s0">// ===============</span>
    <span class="s1">exit(status = </span><span class="s4">0</span><span class="s1">, message = undefined) {</span>
        <span class="s3">if </span><span class="s1">(message) {</span>
            <span class="s3">this</span><span class="s1">._print_message(message, process.stderr)</span>
        <span class="s1">}</span>
        <span class="s1">process.exit(status)</span>
    <span class="s1">}</span>

    <span class="s1">error(message) {</span>
        <span class="s0">/* 
         *  error(message: string) 
         * 
         *  Prints a usage message incorporating the message to stderr and 
         *  exits. 
         * 
         *  If you override this in a subclass, it should not return -- it 
         *  should either exit or raise an exception. 
         */</span>

        <span class="s0">// LEGACY (v1 compatibility), debug mode</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.debug === </span><span class="s3">true</span><span class="s1">) </span><span class="s3">throw new </span><span class="s1">Error(message)</span>
        <span class="s0">// end</span>
        <span class="s3">this</span><span class="s1">.print_usage(process.stderr)</span>
        <span class="s3">let </span><span class="s1">args = {prog: </span><span class="s3">this</span><span class="s1">.prog, message: message}</span>
        <span class="s3">this</span><span class="s1">.exit(</span><span class="s4">2</span><span class="s1">, sub(</span><span class="s2">'%(prog)s: error: %(message)s</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">, args))</span>
    <span class="s1">}</span>
<span class="s1">}))</span>


<span class="s1">module.exports = {</span>
    <span class="s1">ArgumentParser,</span>
    <span class="s1">ArgumentError,</span>
    <span class="s1">ArgumentTypeError,</span>
    <span class="s1">BooleanOptionalAction,</span>
    <span class="s1">FileType,</span>
    <span class="s1">HelpFormatter,</span>
    <span class="s1">ArgumentDefaultsHelpFormatter,</span>
    <span class="s1">RawDescriptionHelpFormatter,</span>
    <span class="s1">RawTextHelpFormatter,</span>
    <span class="s1">MetavarTypeHelpFormatter,</span>
    <span class="s1">Namespace,</span>
    <span class="s1">Action,</span>
    <span class="s1">ONE_OR_MORE,</span>
    <span class="s1">OPTIONAL,</span>
    <span class="s1">PARSER,</span>
    <span class="s1">REMAINDER,</span>
    <span class="s1">SUPPRESS,</span>
    <span class="s1">ZERO_OR_MORE</span>
<span class="s1">}</span>

<span class="s0">// LEGACY (v1 compatibility), Const alias</span>
<span class="s1">Object.defineProperty(module.exports, </span><span class="s2">'Const'</span><span class="s1">, {</span>
    <span class="s1">get() {</span>
        <span class="s3">let </span><span class="s1">result = {}</span>
        <span class="s1">Object.entries({ ONE_OR_MORE, OPTIONAL, PARSER, REMAINDER, SUPPRESS, ZERO_OR_MORE }).forEach(([ n, v ]) =&gt; {</span>
            <span class="s1">Object.defineProperty(result, n, {</span>
                <span class="s1">get() {</span>
                    <span class="s1">deprecate(n, sub(</span><span class="s2">'use argparse.%s instead of argparse.Const.%s'</span><span class="s1">, n, n))</span>
                    <span class="s3">return </span><span class="s1">v</span>
                <span class="s1">}</span>
            <span class="s1">})</span>
        <span class="s1">})</span>
        <span class="s1">Object.entries({ _UNRECOGNIZED_ARGS_ATTR }).forEach(([ n, v ]) =&gt; {</span>
            <span class="s1">Object.defineProperty(result, n, {</span>
                <span class="s1">get() {</span>
                    <span class="s1">deprecate(n, sub(</span><span class="s2">'argparse.Const.%s is an internal symbol and will no longer be available'</span><span class="s1">, n))</span>
                    <span class="s3">return </span><span class="s1">v</span>
                <span class="s1">}</span>
            <span class="s1">})</span>
        <span class="s1">})</span>
        <span class="s3">return </span><span class="s1">result</span>
    <span class="s1">},</span>
    <span class="s1">enumerable: </span><span class="s3">false</span>
<span class="s1">})</span>
<span class="s0">// end</span>
</pre>
</body>
</html>