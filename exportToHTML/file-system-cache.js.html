<html>
<head>
<title>file-system-cache.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
file-system-cache.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;default&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">FileSystemCache;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_responsecache = require(</span><span class="s0">&quot;../../response-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;../../../shared/lib/isomorphic/path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_tagsmanifestexternal = require(</span><span class="s0">&quot;./tags-manifest.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_multifilewriter = require(</span><span class="s0">&quot;../../../lib/multi-file-writer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_memorycacheexternal = require(</span><span class="s0">&quot;./memory-cache.external&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">FileSystemCache {</span>
    <span class="s2">static </span><span class="s1">#_ = </span><span class="s2">this</span><span class="s1">.debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE;</span>
    <span class="s1">constructor(ctx){</span>
        <span class="s2">this</span><span class="s1">.fs = ctx.fs;</span>
        <span class="s2">this</span><span class="s1">.flushToDisk = ctx.flushToDisk;</span>
        <span class="s2">this</span><span class="s1">.serverDistDir = ctx.serverDistDir;</span>
        <span class="s2">this</span><span class="s1">.revalidatedTags = ctx.revalidatedTags;</span>
        <span class="s2">if </span><span class="s1">(ctx.maxMemoryCacheSize) {</span>
            <span class="s2">if </span><span class="s1">(!FileSystemCache.memoryCache) {</span>
                <span class="s2">if </span><span class="s1">(FileSystemCache.debug) {</span>
                    <span class="s1">console.log(</span><span class="s0">'using memory store for fetch cache'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">FileSystemCache.memoryCache = (</span><span class="s4">0</span><span class="s1">, _memorycacheexternal.getMemoryCache)(ctx.maxMemoryCacheSize);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(FileSystemCache.debug) {</span>
                <span class="s1">console.log(</span><span class="s0">'memory store already initialized'</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(FileSystemCache.debug) {</span>
            <span class="s1">console.log(</span><span class="s0">'not using memory store for fetch cache'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">resetRequestCache() {}</span>
    <span class="s1">async revalidateTag(...args) {</span>
        <span class="s2">let </span><span class="s1">[tags] = args;</span>
        <span class="s1">tags = </span><span class="s2">typeof </span><span class="s1">tags === </span><span class="s0">'string' </span><span class="s1">? [</span>
            <span class="s1">tags</span>
        <span class="s1">] : tags;</span>
        <span class="s2">if </span><span class="s1">(FileSystemCache.debug) {</span>
            <span class="s1">console.log(</span><span class="s0">'revalidateTag'</span><span class="s1">, tags);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(tags.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">tag of tags){</span>
            <span class="s2">if </span><span class="s1">(!_tagsmanifestexternal.tagsManifest.has(tag)) {</span>
                <span class="s1">_tagsmanifestexternal.tagsManifest.set(tag, Date.now());</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async get(...args) {</span>
        <span class="s2">var </span><span class="s1">_FileSystemCache_memoryCache, _data_value, _data_value1, _data_value2, _data_value3;</span>
        <span class="s2">const </span><span class="s1">[key, ctx] = args;</span>
        <span class="s2">const </span><span class="s1">{ kind } = ctx;</span>
        <span class="s2">let </span><span class="s1">data = (_FileSystemCache_memoryCache = FileSystemCache.memoryCache) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _FileSystemCache_memoryCache.get(key);</span>
        <span class="s2">if </span><span class="s1">(FileSystemCache.debug) {</span>
            <span class="s2">if </span><span class="s1">(kind === _responsecache.IncrementalCacheKind.FETCH) {</span>
                <span class="s1">console.log(</span><span class="s0">'get'</span><span class="s1">, key, ctx.tags, kind, !!data);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">console.log(</span><span class="s0">'get'</span><span class="s1">, key, kind, !!data);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// let's check the disk for seed data</span>
        <span class="s2">if </span><span class="s1">(!data &amp;&amp; process.env.NEXT_RUNTIME !== </span><span class="s0">'edge'</span><span class="s1">) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(kind === _responsecache.IncrementalCacheKind.APP_ROUTE) {</span>
                    <span class="s2">const </span><span class="s1">filePath = </span><span class="s2">this</span><span class="s1">.getFilePath(</span><span class="s0">`</span><span class="s1">${key}</span><span class="s0">.body`</span><span class="s1">, _responsecache.IncrementalCacheKind.APP_ROUTE);</span>
                    <span class="s2">const </span><span class="s1">fileData = </span><span class="s2">await this</span><span class="s1">.fs.readFile(filePath);</span>
                    <span class="s2">const </span><span class="s1">{ mtime } = </span><span class="s2">await this</span><span class="s1">.fs.stat(filePath);</span>
                    <span class="s2">const </span><span class="s1">meta = JSON.parse(</span><span class="s2">await this</span><span class="s1">.fs.readFile(filePath.replace(</span><span class="s5">/\.body$/</span><span class="s1">, _constants.NEXT_META_SUFFIX), </span><span class="s0">'utf8'</span><span class="s1">));</span>
                    <span class="s1">data = {</span>
                        <span class="s1">lastModified: mtime.getTime(),</span>
                        <span class="s1">value: {</span>
                            <span class="s1">kind: _responsecache.CachedRouteKind.APP_ROUTE,</span>
                            <span class="s1">body: fileData,</span>
                            <span class="s1">headers: meta.headers,</span>
                            <span class="s1">status: meta.status</span>
                        <span class="s1">}</span>
                    <span class="s1">};</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">const </span><span class="s1">filePath = </span><span class="s2">this</span><span class="s1">.getFilePath(kind === _responsecache.IncrementalCacheKind.FETCH ? key : </span><span class="s0">`</span><span class="s1">${key}</span><span class="s0">.html`</span><span class="s1">, kind);</span>
                    <span class="s2">const </span><span class="s1">fileData = </span><span class="s2">await this</span><span class="s1">.fs.readFile(filePath, </span><span class="s0">'utf8'</span><span class="s1">);</span>
                    <span class="s2">const </span><span class="s1">{ mtime } = </span><span class="s2">await this</span><span class="s1">.fs.stat(filePath);</span>
                    <span class="s2">if </span><span class="s1">(kind === _responsecache.IncrementalCacheKind.FETCH) {</span>
                        <span class="s2">var </span><span class="s1">_data_value4;</span>
                        <span class="s2">const </span><span class="s1">{ tags, fetchIdx, fetchUrl } = ctx;</span>
                        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.flushToDisk) </span><span class="s2">return null</span><span class="s1">;</span>
                        <span class="s2">const </span><span class="s1">lastModified = mtime.getTime();</span>
                        <span class="s2">const </span><span class="s1">parsedData = JSON.parse(fileData);</span>
                        <span class="s1">data = {</span>
                            <span class="s1">lastModified,</span>
                            <span class="s1">value: parsedData</span>
                        <span class="s1">};</span>
                        <span class="s2">if </span><span class="s1">(((_data_value4 = data.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _data_value4.kind) === _responsecache.CachedRouteKind.FETCH) {</span>
                            <span class="s2">var </span><span class="s1">_data_value5;</span>
                            <span class="s2">const </span><span class="s1">storedTags = (_data_value5 = data.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _data_value5.tags;</span>
                            <span class="s3">// update stored tags if a new one is being added</span>
                            <span class="s3">// TODO: remove this when we can send the tags</span>
                            <span class="s3">// via header on GET same as SET</span>
                            <span class="s2">if </span><span class="s1">(!(tags == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: tags.every((tag)=&gt;storedTags == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: storedTags.includes(tag)))) {</span>
                                <span class="s2">if </span><span class="s1">(FileSystemCache.debug) {</span>
                                    <span class="s1">console.log(</span><span class="s0">'tags vs storedTags mismatch'</span><span class="s1">, tags, storedTags);</span>
                                <span class="s1">}</span>
                                <span class="s2">await this</span><span class="s1">.set(key, data.value, {</span>
                                    <span class="s1">fetchCache: </span><span class="s2">true</span><span class="s1">,</span>
                                    <span class="s1">tags,</span>
                                    <span class="s1">fetchIdx,</span>
                                    <span class="s1">fetchUrl</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(kind === _responsecache.IncrementalCacheKind.APP_PAGE) {</span>
                        <span class="s3">// We try to load the metadata file, but if it fails, we don't</span>
                        <span class="s3">// error. We also don't load it if this is a fallback.</span>
                        <span class="s2">let </span><span class="s1">meta;</span>
                        <span class="s2">try </span><span class="s1">{</span>
                            <span class="s1">meta = JSON.parse(</span><span class="s2">await this</span><span class="s1">.fs.readFile(filePath.replace(</span><span class="s5">/\.html$/</span><span class="s1">, _constants.NEXT_META_SUFFIX), </span><span class="s0">'utf8'</span><span class="s1">));</span>
                        <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{}</span>
                        <span class="s2">let </span><span class="s1">maybeSegmentData;</span>
                        <span class="s2">if </span><span class="s1">(meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: meta.segmentPaths) {</span>
                            <span class="s3">// Collect all the segment data for this page.</span>
                            <span class="s3">// TODO: To optimize file system reads, we should consider creating</span>
                            <span class="s3">// separate cache entries for each segment, rather than storing them</span>
                            <span class="s3">// all on the page's entry. Though the behavior is</span>
                            <span class="s3">// identical regardless.</span>
                            <span class="s2">const </span><span class="s1">segmentData = </span><span class="s2">new </span><span class="s1">Map();</span>
                            <span class="s1">maybeSegmentData = segmentData;</span>
                            <span class="s2">const </span><span class="s1">segmentsDir = key + _constants.RSC_SEGMENTS_DIR_SUFFIX;</span>
                            <span class="s2">await </span><span class="s1">Promise.all(meta.segmentPaths.map(async (segmentPath)=&gt;{</span>
                                <span class="s2">const </span><span class="s1">segmentDataFilePath = </span><span class="s2">this</span><span class="s1">.getFilePath(segmentsDir + segmentPath + _constants.RSC_SEGMENT_SUFFIX, _responsecache.IncrementalCacheKind.APP_PAGE);</span>
                                <span class="s2">try </span><span class="s1">{</span>
                                    <span class="s1">segmentData.set(segmentPath, </span><span class="s2">await this</span><span class="s1">.fs.readFile(segmentDataFilePath));</span>
                                <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
                                <span class="s3">// This shouldn't happen, but if for some reason we fail to</span>
                                <span class="s3">// load a segment from the filesystem, treat it the same as if</span>
                                <span class="s3">// the segment is dynamic and does not have a prefetch.</span>
                                <span class="s1">}</span>
                            <span class="s1">}));</span>
                        <span class="s1">}</span>
                        <span class="s2">let </span><span class="s1">rscData;</span>
                        <span class="s2">if </span><span class="s1">(!ctx.isFallback) {</span>
                            <span class="s1">rscData = </span><span class="s2">await this</span><span class="s1">.fs.readFile(</span><span class="s2">this</span><span class="s1">.getFilePath(</span><span class="s0">`</span><span class="s1">${key}${ctx.isRoutePPREnabled ? _constants.RSC_PREFETCH_SUFFIX : _constants.RSC_SUFFIX}</span><span class="s0">`</span><span class="s1">, _responsecache.IncrementalCacheKind.APP_PAGE));</span>
                        <span class="s1">}</span>
                        <span class="s1">data = {</span>
                            <span class="s1">lastModified: mtime.getTime(),</span>
                            <span class="s1">value: {</span>
                                <span class="s1">kind: _responsecache.CachedRouteKind.APP_PAGE,</span>
                                <span class="s1">html: fileData,</span>
                                <span class="s1">rscData,</span>
                                <span class="s1">postponed: meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: meta.postponed,</span>
                                <span class="s1">headers: meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: meta.headers,</span>
                                <span class="s1">status: meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: meta.status,</span>
                                <span class="s1">segmentData: maybeSegmentData</span>
                            <span class="s1">}</span>
                        <span class="s1">};</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(kind === _responsecache.IncrementalCacheKind.PAGES) {</span>
                        <span class="s2">let </span><span class="s1">meta;</span>
                        <span class="s2">let </span><span class="s1">pageData = {};</span>
                        <span class="s2">if </span><span class="s1">(!ctx.isFallback) {</span>
                            <span class="s1">pageData = JSON.parse(</span><span class="s2">await this</span><span class="s1">.fs.readFile(</span><span class="s2">this</span><span class="s1">.getFilePath(</span><span class="s0">`</span><span class="s1">${key}${_constants.NEXT_DATA_SUFFIX}</span><span class="s0">`</span><span class="s1">, _responsecache.IncrementalCacheKind.PAGES), </span><span class="s0">'utf8'</span><span class="s1">));</span>
                        <span class="s1">}</span>
                        <span class="s1">data = {</span>
                            <span class="s1">lastModified: mtime.getTime(),</span>
                            <span class="s1">value: {</span>
                                <span class="s1">kind: _responsecache.CachedRouteKind.PAGES,</span>
                                <span class="s1">html: fileData,</span>
                                <span class="s1">pageData,</span>
                                <span class="s1">headers: meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: meta.headers,</span>
                                <span class="s1">status: meta == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: meta.status</span>
                            <span class="s1">}</span>
                        <span class="s1">};</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invariant: Unexpected route kind </span><span class="s1">${kind} </span><span class="s0">in file system cache.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E445&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(data) {</span>
                    <span class="s2">var </span><span class="s1">_FileSystemCache_memoryCache1;</span>
                    <span class="s1">(_FileSystemCache_memoryCache1 = FileSystemCache.memoryCache) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _FileSystemCache_memoryCache1.set(key, data);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_data_value = data.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _data_value.kind) === _responsecache.CachedRouteKind.APP_PAGE || (data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_data_value1 = data.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _data_value1.kind) === _responsecache.CachedRouteKind.APP_ROUTE || (data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_data_value2 = data.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _data_value2.kind) === _responsecache.CachedRouteKind.PAGES) {</span>
            <span class="s2">var </span><span class="s1">_data_value_headers;</span>
            <span class="s2">let </span><span class="s1">cacheTags;</span>
            <span class="s2">const </span><span class="s1">tagsHeader = (_data_value_headers = data.value.headers) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _data_value_headers[_constants.NEXT_CACHE_TAGS_HEADER];</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">tagsHeader === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">cacheTags = tagsHeader.split(</span><span class="s0">','</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(cacheTags == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: cacheTags.length) {</span>
                <span class="s3">// we trigger a blocking validation if an ISR page</span>
                <span class="s3">// had a tag revalidated, if we want to be a background</span>
                <span class="s3">// revalidation instead we return data.lastModified = -1</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _tagsmanifestexternal.isStale)(cacheTags, (data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: data.lastModified) || Date.now())) {</span>
                    <span class="s2">return null</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">((data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_data_value3 = data.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _data_value3.kind) === _responsecache.CachedRouteKind.FETCH) {</span>
            <span class="s2">const </span><span class="s1">combinedTags = ctx.kind === _responsecache.IncrementalCacheKind.FETCH ? [</span>
                <span class="s1">...ctx.tags || [],</span>
                <span class="s1">...ctx.softTags || []</span>
            <span class="s1">] : [];</span>
            <span class="s2">const </span><span class="s1">wasRevalidated = combinedTags.some((tag)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.revalidatedTags.includes(tag)) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _tagsmanifestexternal.isStale)([</span>
                    <span class="s1">tag</span>
                <span class="s1">], (data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: data.lastModified) || Date.now());</span>
            <span class="s1">});</span>
            <span class="s3">// When revalidate tag is called we don't return</span>
            <span class="s3">// stale data so it's updated right away</span>
            <span class="s2">if </span><span class="s1">(wasRevalidated) {</span>
                <span class="s1">data = undefined;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">data ?? </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async set(key, data, ctx) {</span>
        <span class="s2">var </span><span class="s1">_FileSystemCache_memoryCache;</span>
        <span class="s1">(_FileSystemCache_memoryCache = FileSystemCache.memoryCache) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _FileSystemCache_memoryCache.set(key, {</span>
            <span class="s1">value: data,</span>
            <span class="s1">lastModified: Date.now()</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(FileSystemCache.debug) {</span>
            <span class="s1">console.log(</span><span class="s0">'set'</span><span class="s1">, key);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.flushToDisk || !data) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s3">// Create a new writer that will prepare to write all the files to disk</span>
        <span class="s3">// after their containing directory is created.</span>
        <span class="s2">const </span><span class="s1">writer = </span><span class="s2">new </span><span class="s1">_multifilewriter.MultiFileWriter(</span><span class="s2">this</span><span class="s1">.fs);</span>
        <span class="s2">if </span><span class="s1">(data.kind === _responsecache.CachedRouteKind.APP_ROUTE) {</span>
            <span class="s2">const </span><span class="s1">filePath = </span><span class="s2">this</span><span class="s1">.getFilePath(</span><span class="s0">`</span><span class="s1">${key}</span><span class="s0">.body`</span><span class="s1">, _responsecache.IncrementalCacheKind.APP_ROUTE);</span>
            <span class="s1">writer.append(filePath, data.body);</span>
            <span class="s2">const </span><span class="s1">meta = {</span>
                <span class="s1">headers: data.headers,</span>
                <span class="s1">status: data.status,</span>
                <span class="s1">postponed: undefined,</span>
                <span class="s1">segmentPaths: undefined</span>
            <span class="s1">};</span>
            <span class="s1">writer.append(filePath.replace(</span><span class="s5">/\.body$/</span><span class="s1">, _constants.NEXT_META_SUFFIX), JSON.stringify(meta, </span><span class="s2">null</span><span class="s1">, </span><span class="s4">2</span><span class="s1">));</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(data.kind === _responsecache.CachedRouteKind.PAGES || data.kind === _responsecache.CachedRouteKind.APP_PAGE) {</span>
            <span class="s2">const </span><span class="s1">isAppPath = data.kind === _responsecache.CachedRouteKind.APP_PAGE;</span>
            <span class="s2">const </span><span class="s1">htmlPath = </span><span class="s2">this</span><span class="s1">.getFilePath(</span><span class="s0">`</span><span class="s1">${key}</span><span class="s0">.html`</span><span class="s1">, isAppPath ? _responsecache.IncrementalCacheKind.APP_PAGE : _responsecache.IncrementalCacheKind.PAGES);</span>
            <span class="s1">writer.append(htmlPath, data.html);</span>
            <span class="s3">// Fallbacks don't generate a data file.</span>
            <span class="s2">if </span><span class="s1">(!ctx.fetchCache &amp;&amp; !ctx.isFallback) {</span>
                <span class="s1">writer.append(</span><span class="s2">this</span><span class="s1">.getFilePath(</span><span class="s0">`</span><span class="s1">${key}${isAppPath ? ctx.isRoutePPREnabled ? _constants.RSC_PREFETCH_SUFFIX : _constants.RSC_SUFFIX : _constants.NEXT_DATA_SUFFIX}</span><span class="s0">`</span><span class="s1">, isAppPath ? _responsecache.IncrementalCacheKind.APP_PAGE : _responsecache.IncrementalCacheKind.PAGES), isAppPath ? data.rscData : JSON.stringify(data.pageData));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((data == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: data.kind) === _responsecache.CachedRouteKind.APP_PAGE) {</span>
                <span class="s2">let </span><span class="s1">segmentPaths;</span>
                <span class="s2">if </span><span class="s1">(data.segmentData) {</span>
                    <span class="s1">segmentPaths = [];</span>
                    <span class="s2">const </span><span class="s1">segmentsDir = htmlPath.replace(</span><span class="s5">/\.html$/</span><span class="s1">, _constants.RSC_SEGMENTS_DIR_SUFFIX);</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[segmentPath, buffer] of data.segmentData){</span>
                        <span class="s1">segmentPaths.push(segmentPath);</span>
                        <span class="s2">const </span><span class="s1">segmentDataFilePath = segmentsDir + segmentPath + _constants.RSC_SEGMENT_SUFFIX;</span>
                        <span class="s1">writer.append(segmentDataFilePath, buffer);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">meta = {</span>
                    <span class="s1">headers: data.headers,</span>
                    <span class="s1">status: data.status,</span>
                    <span class="s1">postponed: data.postponed,</span>
                    <span class="s1">segmentPaths</span>
                <span class="s1">};</span>
                <span class="s1">writer.append(htmlPath.replace(</span><span class="s5">/\.html$/</span><span class="s1">, _constants.NEXT_META_SUFFIX), JSON.stringify(meta));</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(data.kind === _responsecache.CachedRouteKind.FETCH) {</span>
            <span class="s2">const </span><span class="s1">filePath = </span><span class="s2">this</span><span class="s1">.getFilePath(key, _responsecache.IncrementalCacheKind.FETCH);</span>
            <span class="s1">writer.append(filePath, JSON.stringify({</span>
                <span class="s1">...data,</span>
                <span class="s1">tags: ctx.fetchCache ? ctx.tags : []</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
        <span class="s3">// Wait for all FS operations to complete.</span>
        <span class="s2">await </span><span class="s1">writer.wait();</span>
    <span class="s1">}</span>
    <span class="s1">getFilePath(pathname, kind) {</span>
        <span class="s2">switch</span><span class="s1">(kind){</span>
            <span class="s2">case </span><span class="s1">_responsecache.IncrementalCacheKind.FETCH:</span>
                <span class="s3">// we store in .next/cache/fetch-cache so it can be persisted</span>
                <span class="s3">// across deploys</span>
                <span class="s2">return </span><span class="s1">_path.default.join(</span><span class="s2">this</span><span class="s1">.serverDistDir, </span><span class="s0">'..'</span><span class="s1">, </span><span class="s0">'cache'</span><span class="s1">, </span><span class="s0">'fetch-cache'</span><span class="s1">, pathname);</span>
            <span class="s2">case </span><span class="s1">_responsecache.IncrementalCacheKind.PAGES:</span>
                <span class="s2">return </span><span class="s1">_path.default.join(</span><span class="s2">this</span><span class="s1">.serverDistDir, </span><span class="s0">'pages'</span><span class="s1">, pathname);</span>
            <span class="s2">case </span><span class="s1">_responsecache.IncrementalCacheKind.IMAGE:</span>
            <span class="s2">case </span><span class="s1">_responsecache.IncrementalCacheKind.APP_PAGE:</span>
            <span class="s2">case </span><span class="s1">_responsecache.IncrementalCacheKind.APP_ROUTE:</span>
                <span class="s2">return </span><span class="s1">_path.default.join(</span><span class="s2">this</span><span class="s1">.serverDistDir, </span><span class="s0">'app'</span><span class="s1">, pathname);</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Unexpected file path kind: </span><span class="s1">${kind}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E479&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=file-system-cache.js.map</span></pre>
</body>
</html>