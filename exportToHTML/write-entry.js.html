<html>
<head>
<title>write-entry.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #264eff;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
write-entry.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">__importDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importDefault) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">return </span><span class="s1">(mod &amp;&amp; mod.__esModule) ? mod : { </span><span class="s0">&quot;default&quot;</span><span class="s1">: mod };</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.WriteEntryTar = exports.WriteEntrySync = exports.WriteEntry = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">fs_1 = __importDefault(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">minipass_1 = require(</span><span class="s0">&quot;minipass&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">path_1 = __importDefault(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">header_js_1 = require(</span><span class="s0">&quot;./header.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">mode_fix_js_1 = require(</span><span class="s0">&quot;./mode-fix.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">normalize_windows_path_js_1 = require(</span><span class="s0">&quot;./normalize-windows-path.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">options_js_1 = require(</span><span class="s0">&quot;./options.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">pax_js_1 = require(</span><span class="s0">&quot;./pax.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">strip_absolute_path_js_1 = require(</span><span class="s0">&quot;./strip-absolute-path.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">strip_trailing_slashes_js_1 = require(</span><span class="s0">&quot;./strip-trailing-slashes.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">warn_method_js_1 = require(</span><span class="s0">&quot;./warn-method.js&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">winchars = __importStar(require(</span><span class="s0">&quot;./winchars.js&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">prefixPath = (path, prefix) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!prefix) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(path);</span>
    <span class="s1">}</span>
    <span class="s1">path = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(path).replace(</span><span class="s4">/^\.(\/|$)/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, strip_trailing_slashes_js_1.stripTrailingSlashes)(prefix) + </span><span class="s0">'/' </span><span class="s1">+ path;</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">maxReadSize = </span><span class="s3">16 </span><span class="s1">* </span><span class="s3">1024 </span><span class="s1">* </span><span class="s3">1024</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">PROCESS = Symbol(</span><span class="s0">'process'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">FILE = Symbol(</span><span class="s0">'file'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">DIRECTORY = Symbol(</span><span class="s0">'directory'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">SYMLINK = Symbol(</span><span class="s0">'symlink'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">HARDLINK = Symbol(</span><span class="s0">'hardlink'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">HEADER = Symbol(</span><span class="s0">'header'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">READ = Symbol(</span><span class="s0">'read'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">LSTAT = Symbol(</span><span class="s0">'lstat'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ONLSTAT = Symbol(</span><span class="s0">'onlstat'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ONREAD = Symbol(</span><span class="s0">'onread'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ONREADLINK = Symbol(</span><span class="s0">'onreadlink'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">OPENFILE = Symbol(</span><span class="s0">'openfile'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ONOPENFILE = Symbol(</span><span class="s0">'onopenfile'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">CLOSE = Symbol(</span><span class="s0">'close'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MODE = Symbol(</span><span class="s0">'mode'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">AWAITDRAIN = Symbol(</span><span class="s0">'awaitDrain'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ONDRAIN = Symbol(</span><span class="s0">'ondrain'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">PREFIX = Symbol(</span><span class="s0">'prefix'</span><span class="s1">);</span>
<span class="s2">class </span><span class="s1">WriteEntry </span><span class="s2">extends </span><span class="s1">minipass_1.Minipass {</span>
    <span class="s1">path;</span>
    <span class="s1">portable;</span>
    <span class="s1">myuid = (process.getuid &amp;&amp; process.getuid()) || </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s5">// until node has builtin pwnam functions, this'll have to do</span>
    <span class="s1">myuser = process.env.USER || </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">maxReadSize;</span>
    <span class="s1">linkCache;</span>
    <span class="s1">statCache;</span>
    <span class="s1">preservePaths;</span>
    <span class="s1">cwd;</span>
    <span class="s1">strict;</span>
    <span class="s1">mtime;</span>
    <span class="s1">noPax;</span>
    <span class="s1">noMtime;</span>
    <span class="s1">prefix;</span>
    <span class="s1">fd;</span>
    <span class="s1">blockLen = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">blockRemain = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">buf;</span>
    <span class="s1">pos = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">remain = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">offset = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">win32;</span>
    <span class="s1">absolute;</span>
    <span class="s1">header;</span>
    <span class="s1">type;</span>
    <span class="s1">linkpath;</span>
    <span class="s1">stat;</span>
    <span class="s1">onWriteEntry;</span>
    <span class="s1">#hadError = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">constructor(p, opt_ = {}) {</span>
        <span class="s2">const </span><span class="s1">opt = (</span><span class="s3">0</span><span class="s1">, options_js_1.dealias)(opt_);</span>
        <span class="s2">super</span><span class="s1">();</span>
        <span class="s2">this</span><span class="s1">.path = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(p);</span>
        <span class="s5">// suppress atime, ctime, uid, gid, uname, gname</span>
        <span class="s2">this</span><span class="s1">.portable = !!opt.portable;</span>
        <span class="s2">this</span><span class="s1">.maxReadSize = opt.maxReadSize || maxReadSize;</span>
        <span class="s2">this</span><span class="s1">.linkCache = opt.linkCache || </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s2">this</span><span class="s1">.statCache = opt.statCache || </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s2">this</span><span class="s1">.preservePaths = !!opt.preservePaths;</span>
        <span class="s2">this</span><span class="s1">.cwd = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(opt.cwd || process.cwd());</span>
        <span class="s2">this</span><span class="s1">.strict = !!opt.strict;</span>
        <span class="s2">this</span><span class="s1">.noPax = !!opt.noPax;</span>
        <span class="s2">this</span><span class="s1">.noMtime = !!opt.noMtime;</span>
        <span class="s2">this</span><span class="s1">.mtime = opt.mtime;</span>
        <span class="s2">this</span><span class="s1">.prefix =</span>
            <span class="s1">opt.prefix ? (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(opt.prefix) : undefined;</span>
        <span class="s2">this</span><span class="s1">.onWriteEntry = opt.onWriteEntry;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opt.onwarn === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.on(</span><span class="s0">'warn'</span><span class="s1">, opt.onwarn);</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">pathWarn = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.preservePaths) {</span>
            <span class="s2">const </span><span class="s1">[root, stripped] = (</span><span class="s3">0</span><span class="s1">, strip_absolute_path_js_1.stripAbsolutePath)(</span><span class="s2">this</span><span class="s1">.path);</span>
            <span class="s2">if </span><span class="s1">(root &amp;&amp; </span><span class="s2">typeof </span><span class="s1">stripped === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.path = stripped;</span>
                <span class="s1">pathWarn = root;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.win32 = !!opt.win32 || process.platform === </span><span class="s0">'win32'</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.win32) {</span>
            <span class="s5">// force the \ to / normalization, since we might not *actually*</span>
            <span class="s5">// be on windows, but want \ to be considered a path separator.</span>
            <span class="s2">this</span><span class="s1">.path = winchars.decode(</span><span class="s2">this</span><span class="s1">.path.replace(</span><span class="s4">/\\/g</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">));</span>
            <span class="s1">p = p.replace(</span><span class="s4">/\\/g</span><span class="s1">, </span><span class="s0">'/'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.absolute = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(opt.absolute || path_1.default.resolve(</span><span class="s2">this</span><span class="s1">.cwd, p));</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.path === </span><span class="s0">''</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.path = </span><span class="s0">'./'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(pathWarn) {</span>
            <span class="s2">this</span><span class="s1">.warn(</span><span class="s0">'TAR_ENTRY_INFO'</span><span class="s1">, </span><span class="s0">`stripping </span><span class="s1">${pathWarn} </span><span class="s0">from absolute path`</span><span class="s1">, {</span>
                <span class="s1">entry: </span><span class="s2">this</span><span class="s1">,</span>
                <span class="s1">path: pathWarn + </span><span class="s2">this</span><span class="s1">.path,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">cs = </span><span class="s2">this</span><span class="s1">.statCache.get(</span><span class="s2">this</span><span class="s1">.absolute);</span>
        <span class="s2">if </span><span class="s1">(cs) {</span>
            <span class="s2">this</span><span class="s1">[ONLSTAT](cs);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">[LSTAT]();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">warn(code, message, data = {}) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, warn_method_js_1.warnMethod)(</span><span class="s2">this</span><span class="s1">, code, message, data);</span>
    <span class="s1">}</span>
    <span class="s1">emit(ev, ...data) {</span>
        <span class="s2">if </span><span class="s1">(ev === </span><span class="s0">'error'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.#hadError = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return super</span><span class="s1">.emit(ev, ...data);</span>
    <span class="s1">}</span>
    <span class="s1">[LSTAT]() {</span>
        <span class="s1">fs_1.default.lstat(</span><span class="s2">this</span><span class="s1">.absolute, (er, stat) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(er) {</span>
                <span class="s2">return this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er);</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">[ONLSTAT](stat);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">[ONLSTAT](stat) {</span>
        <span class="s2">this</span><span class="s1">.statCache.set(</span><span class="s2">this</span><span class="s1">.absolute, stat);</span>
        <span class="s2">this</span><span class="s1">.stat = stat;</span>
        <span class="s2">if </span><span class="s1">(!stat.isFile()) {</span>
            <span class="s1">stat.size = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.type = getType(stat);</span>
        <span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'stat'</span><span class="s1">, stat);</span>
        <span class="s2">this</span><span class="s1">[PROCESS]();</span>
    <span class="s1">}</span>
    <span class="s1">[PROCESS]() {</span>
        <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type) {</span>
            <span class="s2">case </span><span class="s0">'File'</span><span class="s1">:</span>
                <span class="s2">return this</span><span class="s1">[FILE]();</span>
            <span class="s2">case </span><span class="s0">'Directory'</span><span class="s1">:</span>
                <span class="s2">return this</span><span class="s1">[DIRECTORY]();</span>
            <span class="s2">case </span><span class="s0">'SymbolicLink'</span><span class="s1">:</span>
                <span class="s2">return this</span><span class="s1">[SYMLINK]();</span>
            <span class="s5">// unsupported types are ignored.</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">return this</span><span class="s1">.end();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">[MODE](mode) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, mode_fix_js_1.modeFix)(mode, </span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Directory'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.portable);</span>
    <span class="s1">}</span>
    <span class="s1">[PREFIX](path) {</span>
        <span class="s2">return </span><span class="s1">prefixPath(path, </span><span class="s2">this</span><span class="s1">.prefix);</span>
    <span class="s1">}</span>
    <span class="s1">[HEADER]() {</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.stat) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'cannot write header before stat'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Directory' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.portable) {</span>
            <span class="s2">this</span><span class="s1">.noMtime = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.onWriteEntry?.(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.header = </span><span class="s2">new </span><span class="s1">header_js_1.Header({</span>
            <span class="s1">path: </span><span class="s2">this</span><span class="s1">[PREFIX](</span><span class="s2">this</span><span class="s1">.path),</span>
            <span class="s5">// only apply the prefix to hard links.</span>
            <span class="s1">linkpath: </span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Link' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.linkpath !== undefined ?</span>
                <span class="s2">this</span><span class="s1">[PREFIX](</span><span class="s2">this</span><span class="s1">.linkpath)</span>
                <span class="s1">: </span><span class="s2">this</span><span class="s1">.linkpath,</span>
            <span class="s5">// only the permissions and setuid/setgid/sticky bitflags</span>
            <span class="s5">// not the higher-order bits that specify file type</span>
            <span class="s1">mode: </span><span class="s2">this</span><span class="s1">[MODE](</span><span class="s2">this</span><span class="s1">.stat.mode),</span>
            <span class="s1">uid: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.stat.uid,</span>
            <span class="s1">gid: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.stat.gid,</span>
            <span class="s1">size: </span><span class="s2">this</span><span class="s1">.stat.size,</span>
            <span class="s1">mtime: </span><span class="s2">this</span><span class="s1">.noMtime ? undefined : </span><span class="s2">this</span><span class="s1">.mtime || </span><span class="s2">this</span><span class="s1">.stat.mtime,</span>
            <span class="s5">/* c8 ignore next */</span>
            <span class="s1">type: </span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Unsupported' </span><span class="s1">? undefined : </span><span class="s2">this</span><span class="s1">.type,</span>
            <span class="s1">uname: </span><span class="s2">this</span><span class="s1">.portable ? undefined</span>
                <span class="s1">: </span><span class="s2">this</span><span class="s1">.stat.uid === </span><span class="s2">this</span><span class="s1">.myuid ? </span><span class="s2">this</span><span class="s1">.myuser</span>
                    <span class="s1">: </span><span class="s0">''</span><span class="s1">,</span>
            <span class="s1">atime: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.stat.atime,</span>
            <span class="s1">ctime: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.stat.ctime,</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.header.encode() &amp;&amp; !</span><span class="s2">this</span><span class="s1">.noPax) {</span>
            <span class="s2">super</span><span class="s1">.write(</span><span class="s2">new </span><span class="s1">pax_js_1.Pax({</span>
                <span class="s1">atime: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.header.atime,</span>
                <span class="s1">ctime: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.header.ctime,</span>
                <span class="s1">gid: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.header.gid,</span>
                <span class="s1">mtime: </span><span class="s2">this</span><span class="s1">.noMtime ? undefined : (</span><span class="s2">this</span><span class="s1">.mtime || </span><span class="s2">this</span><span class="s1">.header.mtime),</span>
                <span class="s1">path: </span><span class="s2">this</span><span class="s1">[PREFIX](</span><span class="s2">this</span><span class="s1">.path),</span>
                <span class="s1">linkpath: </span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Link' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.linkpath !== undefined ?</span>
                    <span class="s2">this</span><span class="s1">[PREFIX](</span><span class="s2">this</span><span class="s1">.linkpath)</span>
                    <span class="s1">: </span><span class="s2">this</span><span class="s1">.linkpath,</span>
                <span class="s1">size: </span><span class="s2">this</span><span class="s1">.header.size,</span>
                <span class="s1">uid: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.header.uid,</span>
                <span class="s1">uname: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.header.uname,</span>
                <span class="s1">dev: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.stat.dev,</span>
                <span class="s1">ino: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.stat.ino,</span>
                <span class="s1">nlink: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.stat.nlink,</span>
            <span class="s1">}).encode());</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">block = </span><span class="s2">this</span><span class="s1">.header?.block;</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!block) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'failed to encode header'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">super</span><span class="s1">.write(block);</span>
    <span class="s1">}</span>
    <span class="s1">[DIRECTORY]() {</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.stat) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'cannot create directory entry without stat'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.path.slice(-</span><span class="s3">1</span><span class="s1">) !== </span><span class="s0">'/'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.path += </span><span class="s0">'/'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.stat.size = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">[HEADER]();</span>
        <span class="s2">this</span><span class="s1">.end();</span>
    <span class="s1">}</span>
    <span class="s1">[SYMLINK]() {</span>
        <span class="s1">fs_1.default.readlink(</span><span class="s2">this</span><span class="s1">.absolute, (er, linkpath) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(er) {</span>
                <span class="s2">return this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er);</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">[ONREADLINK](linkpath);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">[ONREADLINK](linkpath) {</span>
        <span class="s2">this</span><span class="s1">.linkpath = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(linkpath);</span>
        <span class="s2">this</span><span class="s1">[HEADER]();</span>
        <span class="s2">this</span><span class="s1">.end();</span>
    <span class="s1">}</span>
    <span class="s1">[HARDLINK](linkpath) {</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.stat) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'cannot create link entry without stat'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">this</span><span class="s1">.type = </span><span class="s0">'Link'</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.linkpath = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.relative(</span><span class="s2">this</span><span class="s1">.cwd, linkpath));</span>
        <span class="s2">this</span><span class="s1">.stat.size = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">[HEADER]();</span>
        <span class="s2">this</span><span class="s1">.end();</span>
    <span class="s1">}</span>
    <span class="s1">[FILE]() {</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.stat) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'cannot create file entry without stat'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.stat.nlink &gt; </span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">linkKey = </span><span class="s0">`</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.stat.dev}</span><span class="s0">:</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.stat.ino}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">linkpath = </span><span class="s2">this</span><span class="s1">.linkCache.get(linkKey);</span>
            <span class="s2">if </span><span class="s1">(linkpath?.indexOf(</span><span class="s2">this</span><span class="s1">.cwd) === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">return this</span><span class="s1">[HARDLINK](linkpath);</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.linkCache.set(linkKey, </span><span class="s2">this</span><span class="s1">.absolute);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">[HEADER]();</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.stat.size === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.end();</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">[OPENFILE]();</span>
    <span class="s1">}</span>
    <span class="s1">[OPENFILE]() {</span>
        <span class="s1">fs_1.default.open(</span><span class="s2">this</span><span class="s1">.absolute, </span><span class="s0">'r'</span><span class="s1">, (er, fd) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(er) {</span>
                <span class="s2">return this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er);</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">[ONOPENFILE](fd);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">[ONOPENFILE](fd) {</span>
        <span class="s2">this</span><span class="s1">.fd = fd;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.#hadError) {</span>
            <span class="s2">return this</span><span class="s1">[CLOSE]();</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.stat) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'should stat before calling onopenfile'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">this</span><span class="s1">.blockLen = </span><span class="s3">512 </span><span class="s1">* Math.ceil(</span><span class="s2">this</span><span class="s1">.stat.size / </span><span class="s3">512</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.blockRemain = </span><span class="s2">this</span><span class="s1">.blockLen;</span>
        <span class="s2">const </span><span class="s1">bufLen = Math.min(</span><span class="s2">this</span><span class="s1">.blockLen, </span><span class="s2">this</span><span class="s1">.maxReadSize);</span>
        <span class="s2">this</span><span class="s1">.buf = Buffer.allocUnsafe(bufLen);</span>
        <span class="s2">this</span><span class="s1">.offset = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.pos = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.remain = </span><span class="s2">this</span><span class="s1">.stat.size;</span>
        <span class="s2">this</span><span class="s1">.length = </span><span class="s2">this</span><span class="s1">.buf.length;</span>
        <span class="s2">this</span><span class="s1">[READ]();</span>
    <span class="s1">}</span>
    <span class="s1">[READ]() {</span>
        <span class="s2">const </span><span class="s1">{ fd, buf, offset, length, pos } = </span><span class="s2">this</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(fd === undefined || buf === undefined) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'cannot read file without first opening'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">fs_1.default.read(fd, buf, offset, length, pos, (er, bytesRead) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(er) {</span>
                <span class="s5">// ignoring the error from close(2) is a bad practice, but at</span>
                <span class="s5">// this point we already have an error, don't need another one</span>
                <span class="s2">return this</span><span class="s1">[CLOSE](() =&gt; </span><span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er));</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">[ONREAD](bytesRead);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s5">/* c8 ignore start */</span>
    <span class="s1">[CLOSE](cb = () =&gt; { }) {</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.fd !== undefined)</span>
            <span class="s1">fs_1.default.close(</span><span class="s2">this</span><span class="s1">.fd, cb);</span>
    <span class="s1">}</span>
    <span class="s1">[ONREAD](bytesRead) {</span>
        <span class="s2">if </span><span class="s1">(bytesRead &lt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.remain &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">er = Object.assign(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'encountered unexpected EOF'</span><span class="s1">), {</span>
                <span class="s1">path: </span><span class="s2">this</span><span class="s1">.absolute,</span>
                <span class="s1">syscall: </span><span class="s0">'read'</span><span class="s1">,</span>
                <span class="s1">code: </span><span class="s0">'EOF'</span><span class="s1">,</span>
            <span class="s1">});</span>
            <span class="s2">return this</span><span class="s1">[CLOSE](() =&gt; </span><span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(bytesRead &gt; </span><span class="s2">this</span><span class="s1">.remain) {</span>
            <span class="s2">const </span><span class="s1">er = Object.assign(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'did not encounter expected EOF'</span><span class="s1">), {</span>
                <span class="s1">path: </span><span class="s2">this</span><span class="s1">.absolute,</span>
                <span class="s1">syscall: </span><span class="s0">'read'</span><span class="s1">,</span>
                <span class="s1">code: </span><span class="s0">'EOF'</span><span class="s1">,</span>
            <span class="s1">});</span>
            <span class="s2">return this</span><span class="s1">[CLOSE](() =&gt; </span><span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er));</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.buf) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'should have created buffer prior to reading'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s5">// null out the rest of the buffer, if we could fit the block padding</span>
        <span class="s5">// at the end of this loop, we've incremented bytesRead and this.remain</span>
        <span class="s5">// to be incremented up to the blockRemain level, as if we had expected</span>
        <span class="s5">// to get a null-padded file, and read it until the end.  then we will</span>
        <span class="s5">// decrement both remain and blockRemain by bytesRead, and know that we</span>
        <span class="s5">// reached the expected EOF, without any null buffer to append.</span>
        <span class="s2">if </span><span class="s1">(bytesRead === </span><span class="s2">this</span><span class="s1">.remain) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = bytesRead; i &lt; </span><span class="s2">this</span><span class="s1">.length &amp;&amp; bytesRead &lt; </span><span class="s2">this</span><span class="s1">.blockRemain; i++) {</span>
                <span class="s2">this</span><span class="s1">.buf[i + </span><span class="s2">this</span><span class="s1">.offset] = </span><span class="s3">0</span><span class="s1">;</span>
                <span class="s1">bytesRead++;</span>
                <span class="s2">this</span><span class="s1">.remain++;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.offset === </span><span class="s3">0 </span><span class="s1">&amp;&amp; bytesRead === </span><span class="s2">this</span><span class="s1">.buf.length ?</span>
            <span class="s2">this</span><span class="s1">.buf</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.buf.subarray(</span><span class="s2">this</span><span class="s1">.offset, </span><span class="s2">this</span><span class="s1">.offset + bytesRead);</span>
        <span class="s2">const </span><span class="s1">flushed = </span><span class="s2">this</span><span class="s1">.write(chunk);</span>
        <span class="s2">if </span><span class="s1">(!flushed) {</span>
            <span class="s2">this</span><span class="s1">[AWAITDRAIN](() =&gt; </span><span class="s2">this</span><span class="s1">[ONDRAIN]());</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">[ONDRAIN]();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">[AWAITDRAIN](cb) {</span>
        <span class="s2">this</span><span class="s1">.once(</span><span class="s0">'drain'</span><span class="s1">, cb);</span>
    <span class="s1">}</span>
    <span class="s1">write(chunk, encoding, cb) {</span>
        <span class="s5">/* c8 ignore start - just junk to comply with NodeJS.WritableStream */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">encoding === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">cb = encoding;</span>
            <span class="s1">encoding = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">chunk === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">chunk = Buffer.from(chunk, </span><span class="s2">typeof </span><span class="s1">encoding === </span><span class="s0">'string' </span><span class="s1">? encoding : </span><span class="s0">'utf8'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.blockRemain &lt; chunk.length) {</span>
            <span class="s2">const </span><span class="s1">er = Object.assign(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'writing more data than expected'</span><span class="s1">), {</span>
                <span class="s1">path: </span><span class="s2">this</span><span class="s1">.absolute,</span>
            <span class="s1">});</span>
            <span class="s2">return this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.remain -= chunk.length;</span>
        <span class="s2">this</span><span class="s1">.blockRemain -= chunk.length;</span>
        <span class="s2">this</span><span class="s1">.pos += chunk.length;</span>
        <span class="s2">this</span><span class="s1">.offset += chunk.length;</span>
        <span class="s2">return super</span><span class="s1">.write(chunk, </span><span class="s2">null</span><span class="s1">, cb);</span>
    <span class="s1">}</span>
    <span class="s1">[ONDRAIN]() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.remain) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.blockRemain) {</span>
                <span class="s2">super</span><span class="s1">.write(Buffer.alloc(</span><span class="s2">this</span><span class="s1">.blockRemain));</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">[CLOSE](er =&gt; er ? </span><span class="s2">this</span><span class="s1">.emit(</span><span class="s0">'error'</span><span class="s1">, er) : </span><span class="s2">this</span><span class="s1">.end());</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.buf) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'buffer lost somehow in ONDRAIN'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.offset &gt;= </span><span class="s2">this</span><span class="s1">.length) {</span>
            <span class="s5">// if we only have a smaller bit left to read, alloc a smaller buffer</span>
            <span class="s5">// otherwise, keep it the same length it was before.</span>
            <span class="s2">this</span><span class="s1">.buf = Buffer.allocUnsafe(Math.min(</span><span class="s2">this</span><span class="s1">.blockRemain, </span><span class="s2">this</span><span class="s1">.buf.length));</span>
            <span class="s2">this</span><span class="s1">.offset = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.length = </span><span class="s2">this</span><span class="s1">.buf.length - </span><span class="s2">this</span><span class="s1">.offset;</span>
        <span class="s2">this</span><span class="s1">[READ]();</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.WriteEntry = WriteEntry;</span>
<span class="s2">class </span><span class="s1">WriteEntrySync </span><span class="s2">extends </span><span class="s1">WriteEntry {</span>
    <span class="s1">sync = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">[LSTAT]() {</span>
        <span class="s2">this</span><span class="s1">[ONLSTAT](fs_1.default.lstatSync(</span><span class="s2">this</span><span class="s1">.absolute));</span>
    <span class="s1">}</span>
    <span class="s1">[SYMLINK]() {</span>
        <span class="s2">this</span><span class="s1">[ONREADLINK](fs_1.default.readlinkSync(</span><span class="s2">this</span><span class="s1">.absolute));</span>
    <span class="s1">}</span>
    <span class="s1">[OPENFILE]() {</span>
        <span class="s2">this</span><span class="s1">[ONOPENFILE](fs_1.default.openSync(</span><span class="s2">this</span><span class="s1">.absolute, </span><span class="s0">'r'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s1">[READ]() {</span>
        <span class="s2">let </span><span class="s1">threw = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">{ fd, buf, offset, length, pos } = </span><span class="s2">this</span><span class="s1">;</span>
            <span class="s5">/* c8 ignore start */</span>
            <span class="s2">if </span><span class="s1">(fd === undefined || buf === undefined) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'fd and buf must be set in READ method'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s5">/* c8 ignore stop */</span>
            <span class="s2">const </span><span class="s1">bytesRead = fs_1.default.readSync(fd, buf, offset, length, pos);</span>
            <span class="s2">this</span><span class="s1">[ONREAD](bytesRead);</span>
            <span class="s1">threw = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">finally </span><span class="s1">{</span>
            <span class="s5">// ignoring the error from close(2) is a bad practice, but at</span>
            <span class="s5">// this point we already have an error, don't need another one</span>
            <span class="s2">if </span><span class="s1">(threw) {</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">this</span><span class="s1">[CLOSE](() =&gt; { });</span>
                <span class="s1">}</span>
                <span class="s2">catch </span><span class="s1">(er) { }</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">[AWAITDRAIN](cb) {</span>
        <span class="s1">cb();</span>
    <span class="s1">}</span>
    <span class="s5">/* c8 ignore start */</span>
    <span class="s1">[CLOSE](cb = () =&gt; { }) {</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.fd !== undefined)</span>
            <span class="s1">fs_1.default.closeSync(</span><span class="s2">this</span><span class="s1">.fd);</span>
        <span class="s1">cb();</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.WriteEntrySync = WriteEntrySync;</span>
<span class="s2">class </span><span class="s1">WriteEntryTar </span><span class="s2">extends </span><span class="s1">minipass_1.Minipass {</span>
    <span class="s1">blockLen = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">blockRemain = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">buf = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">pos = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">remain = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">preservePaths;</span>
    <span class="s1">portable;</span>
    <span class="s1">strict;</span>
    <span class="s1">noPax;</span>
    <span class="s1">noMtime;</span>
    <span class="s1">readEntry;</span>
    <span class="s1">type;</span>
    <span class="s1">prefix;</span>
    <span class="s1">path;</span>
    <span class="s1">mode;</span>
    <span class="s1">uid;</span>
    <span class="s1">gid;</span>
    <span class="s1">uname;</span>
    <span class="s1">gname;</span>
    <span class="s1">header;</span>
    <span class="s1">mtime;</span>
    <span class="s1">atime;</span>
    <span class="s1">ctime;</span>
    <span class="s1">linkpath;</span>
    <span class="s1">size;</span>
    <span class="s1">onWriteEntry;</span>
    <span class="s1">warn(code, message, data = {}) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, warn_method_js_1.warnMethod)(</span><span class="s2">this</span><span class="s1">, code, message, data);</span>
    <span class="s1">}</span>
    <span class="s1">constructor(readEntry, opt_ = {}) {</span>
        <span class="s2">const </span><span class="s1">opt = (</span><span class="s3">0</span><span class="s1">, options_js_1.dealias)(opt_);</span>
        <span class="s2">super</span><span class="s1">();</span>
        <span class="s2">this</span><span class="s1">.preservePaths = !!opt.preservePaths;</span>
        <span class="s2">this</span><span class="s1">.portable = !!opt.portable;</span>
        <span class="s2">this</span><span class="s1">.strict = !!opt.strict;</span>
        <span class="s2">this</span><span class="s1">.noPax = !!opt.noPax;</span>
        <span class="s2">this</span><span class="s1">.noMtime = !!opt.noMtime;</span>
        <span class="s2">this</span><span class="s1">.onWriteEntry = opt.onWriteEntry;</span>
        <span class="s2">this</span><span class="s1">.readEntry = readEntry;</span>
        <span class="s2">const </span><span class="s1">{ type } = readEntry;</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'Unsupported'</span><span class="s1">) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'writing entry that should be ignored'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">this</span><span class="s1">.type = type;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Directory' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.portable) {</span>
            <span class="s2">this</span><span class="s1">.noMtime = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.prefix = opt.prefix;</span>
        <span class="s2">this</span><span class="s1">.path = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(readEntry.path);</span>
        <span class="s2">this</span><span class="s1">.mode =</span>
            <span class="s1">readEntry.mode !== undefined ?</span>
                <span class="s2">this</span><span class="s1">[MODE](readEntry.mode)</span>
                <span class="s1">: undefined;</span>
        <span class="s2">this</span><span class="s1">.uid = </span><span class="s2">this</span><span class="s1">.portable ? undefined : readEntry.uid;</span>
        <span class="s2">this</span><span class="s1">.gid = </span><span class="s2">this</span><span class="s1">.portable ? undefined : readEntry.gid;</span>
        <span class="s2">this</span><span class="s1">.uname = </span><span class="s2">this</span><span class="s1">.portable ? undefined : readEntry.uname;</span>
        <span class="s2">this</span><span class="s1">.gname = </span><span class="s2">this</span><span class="s1">.portable ? undefined : readEntry.gname;</span>
        <span class="s2">this</span><span class="s1">.size = readEntry.size;</span>
        <span class="s2">this</span><span class="s1">.mtime =</span>
            <span class="s2">this</span><span class="s1">.noMtime ? undefined : opt.mtime || readEntry.mtime;</span>
        <span class="s2">this</span><span class="s1">.atime = </span><span class="s2">this</span><span class="s1">.portable ? undefined : readEntry.atime;</span>
        <span class="s2">this</span><span class="s1">.ctime = </span><span class="s2">this</span><span class="s1">.portable ? undefined : readEntry.ctime;</span>
        <span class="s2">this</span><span class="s1">.linkpath =</span>
            <span class="s1">readEntry.linkpath !== undefined ?</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(readEntry.linkpath)</span>
                <span class="s1">: undefined;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opt.onwarn === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.on(</span><span class="s0">'warn'</span><span class="s1">, opt.onwarn);</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">pathWarn = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.preservePaths) {</span>
            <span class="s2">const </span><span class="s1">[root, stripped] = (</span><span class="s3">0</span><span class="s1">, strip_absolute_path_js_1.stripAbsolutePath)(</span><span class="s2">this</span><span class="s1">.path);</span>
            <span class="s2">if </span><span class="s1">(root &amp;&amp; </span><span class="s2">typeof </span><span class="s1">stripped === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.path = stripped;</span>
                <span class="s1">pathWarn = root;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.remain = readEntry.size;</span>
        <span class="s2">this</span><span class="s1">.blockRemain = readEntry.startBlockSize;</span>
        <span class="s2">this</span><span class="s1">.onWriteEntry?.(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.header = </span><span class="s2">new </span><span class="s1">header_js_1.Header({</span>
            <span class="s1">path: </span><span class="s2">this</span><span class="s1">[PREFIX](</span><span class="s2">this</span><span class="s1">.path),</span>
            <span class="s1">linkpath: </span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Link' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.linkpath !== undefined ?</span>
                <span class="s2">this</span><span class="s1">[PREFIX](</span><span class="s2">this</span><span class="s1">.linkpath)</span>
                <span class="s1">: </span><span class="s2">this</span><span class="s1">.linkpath,</span>
            <span class="s5">// only the permissions and setuid/setgid/sticky bitflags</span>
            <span class="s5">// not the higher-order bits that specify file type</span>
            <span class="s1">mode: </span><span class="s2">this</span><span class="s1">.mode,</span>
            <span class="s1">uid: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.uid,</span>
            <span class="s1">gid: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.gid,</span>
            <span class="s1">size: </span><span class="s2">this</span><span class="s1">.size,</span>
            <span class="s1">mtime: </span><span class="s2">this</span><span class="s1">.noMtime ? undefined : </span><span class="s2">this</span><span class="s1">.mtime,</span>
            <span class="s1">type: </span><span class="s2">this</span><span class="s1">.type,</span>
            <span class="s1">uname: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.uname,</span>
            <span class="s1">atime: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.atime,</span>
            <span class="s1">ctime: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.ctime,</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(pathWarn) {</span>
            <span class="s2">this</span><span class="s1">.warn(</span><span class="s0">'TAR_ENTRY_INFO'</span><span class="s1">, </span><span class="s0">`stripping </span><span class="s1">${pathWarn} </span><span class="s0">from absolute path`</span><span class="s1">, {</span>
                <span class="s1">entry: </span><span class="s2">this</span><span class="s1">,</span>
                <span class="s1">path: pathWarn + </span><span class="s2">this</span><span class="s1">.path,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.header.encode() &amp;&amp; !</span><span class="s2">this</span><span class="s1">.noPax) {</span>
            <span class="s2">super</span><span class="s1">.write(</span><span class="s2">new </span><span class="s1">pax_js_1.Pax({</span>
                <span class="s1">atime: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.atime,</span>
                <span class="s1">ctime: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.ctime,</span>
                <span class="s1">gid: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.gid,</span>
                <span class="s1">mtime: </span><span class="s2">this</span><span class="s1">.noMtime ? undefined : </span><span class="s2">this</span><span class="s1">.mtime,</span>
                <span class="s1">path: </span><span class="s2">this</span><span class="s1">[PREFIX](</span><span class="s2">this</span><span class="s1">.path),</span>
                <span class="s1">linkpath: </span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Link' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.linkpath !== undefined ?</span>
                    <span class="s2">this</span><span class="s1">[PREFIX](</span><span class="s2">this</span><span class="s1">.linkpath)</span>
                    <span class="s1">: </span><span class="s2">this</span><span class="s1">.linkpath,</span>
                <span class="s1">size: </span><span class="s2">this</span><span class="s1">.size,</span>
                <span class="s1">uid: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.uid,</span>
                <span class="s1">uname: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.uname,</span>
                <span class="s1">dev: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.readEntry.dev,</span>
                <span class="s1">ino: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.readEntry.ino,</span>
                <span class="s1">nlink: </span><span class="s2">this</span><span class="s1">.portable ? undefined : </span><span class="s2">this</span><span class="s1">.readEntry.nlink,</span>
            <span class="s1">}).encode());</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">b = </span><span class="s2">this</span><span class="s1">.header?.block;</span>
        <span class="s5">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!b)</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'failed to encode header'</span><span class="s1">);</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">super</span><span class="s1">.write(b);</span>
        <span class="s1">readEntry.pipe(</span><span class="s2">this</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">[PREFIX](path) {</span>
        <span class="s2">return </span><span class="s1">prefixPath(path, </span><span class="s2">this</span><span class="s1">.prefix);</span>
    <span class="s1">}</span>
    <span class="s1">[MODE](mode) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, mode_fix_js_1.modeFix)(mode, </span><span class="s2">this</span><span class="s1">.type === </span><span class="s0">'Directory'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.portable);</span>
    <span class="s1">}</span>
    <span class="s1">write(chunk, encoding, cb) {</span>
        <span class="s5">/* c8 ignore start - just junk to comply with NodeJS.WritableStream */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">encoding === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">cb = encoding;</span>
            <span class="s1">encoding = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">chunk === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">chunk = Buffer.from(chunk, </span><span class="s2">typeof </span><span class="s1">encoding === </span><span class="s0">'string' </span><span class="s1">? encoding : </span><span class="s0">'utf8'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">const </span><span class="s1">writeLen = chunk.length;</span>
        <span class="s2">if </span><span class="s1">(writeLen &gt; </span><span class="s2">this</span><span class="s1">.blockRemain) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'writing more to entry than is appropriate'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.blockRemain -= writeLen;</span>
        <span class="s2">return super</span><span class="s1">.write(chunk, cb);</span>
    <span class="s1">}</span>
    <span class="s1">end(chunk, encoding, cb) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.blockRemain) {</span>
            <span class="s2">super</span><span class="s1">.write(Buffer.alloc(</span><span class="s2">this</span><span class="s1">.blockRemain));</span>
        <span class="s1">}</span>
        <span class="s5">/* c8 ignore start - just junk to comply with NodeJS.WritableStream */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">chunk === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">cb = chunk;</span>
            <span class="s1">encoding = undefined;</span>
            <span class="s1">chunk = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">encoding === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">cb = encoding;</span>
            <span class="s1">encoding = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">chunk === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">chunk = Buffer.from(chunk, encoding ?? </span><span class="s0">'utf8'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(cb)</span>
            <span class="s2">this</span><span class="s1">.once(</span><span class="s0">'finish'</span><span class="s1">, cb);</span>
        <span class="s1">chunk ? </span><span class="s2">super</span><span class="s1">.end(chunk, cb) : </span><span class="s2">super</span><span class="s1">.end(cb);</span>
        <span class="s5">/* c8 ignore stop */</span>
        <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.WriteEntryTar = WriteEntryTar;</span>
<span class="s2">const </span><span class="s1">getType = (stat) =&gt; stat.isFile() ? </span><span class="s0">'File'</span>
    <span class="s1">: stat.isDirectory() ? </span><span class="s0">'Directory'</span>
        <span class="s1">: stat.isSymbolicLink() ? </span><span class="s0">'SymbolicLink'</span>
            <span class="s1">: </span><span class="s0">'Unsupported'</span><span class="s1">;</span>
<span class="s5">//# sourceMappingURL=write-entry.js.map</span></pre>
</body>
</html>