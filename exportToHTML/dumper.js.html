<html>
<head>
<title>dumper.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dumper.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">/*eslint-disable no-use-before-define*/</span>

<span class="s3">var </span><span class="s1">common              = require(</span><span class="s0">'./common'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">YAMLException       = require(</span><span class="s0">'./exception'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">DEFAULT_SCHEMA      = require(</span><span class="s0">'./schema/default'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">_toString       = Object.prototype.toString;</span>
<span class="s3">var </span><span class="s1">_hasOwnProperty = Object.prototype.hasOwnProperty;</span>

<span class="s3">var </span><span class="s1">CHAR_BOM                  = </span><span class="s4">0xFEFF</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">CHAR_TAB                  = </span><span class="s4">0x09</span><span class="s1">; </span><span class="s2">/* Tab */</span>
<span class="s3">var </span><span class="s1">CHAR_LINE_FEED            = </span><span class="s4">0x0A</span><span class="s1">; </span><span class="s2">/* LF */</span>
<span class="s3">var </span><span class="s1">CHAR_CARRIAGE_RETURN      = </span><span class="s4">0x0D</span><span class="s1">; </span><span class="s2">/* CR */</span>
<span class="s3">var </span><span class="s1">CHAR_SPACE                = </span><span class="s4">0x20</span><span class="s1">; </span><span class="s2">/* Space */</span>
<span class="s3">var </span><span class="s1">CHAR_EXCLAMATION          = </span><span class="s4">0x21</span><span class="s1">; </span><span class="s2">/* ! */</span>
<span class="s3">var </span><span class="s1">CHAR_DOUBLE_QUOTE         = </span><span class="s4">0x22</span><span class="s1">; </span><span class="s2">/* &quot; */</span>
<span class="s3">var </span><span class="s1">CHAR_SHARP                = </span><span class="s4">0x23</span><span class="s1">; </span><span class="s2">/* # */</span>
<span class="s3">var </span><span class="s1">CHAR_PERCENT              = </span><span class="s4">0x25</span><span class="s1">; </span><span class="s2">/* % */</span>
<span class="s3">var </span><span class="s1">CHAR_AMPERSAND            = </span><span class="s4">0x26</span><span class="s1">; </span><span class="s2">/* &amp; */</span>
<span class="s3">var </span><span class="s1">CHAR_SINGLE_QUOTE         = </span><span class="s4">0x27</span><span class="s1">; </span><span class="s2">/* ' */</span>
<span class="s3">var </span><span class="s1">CHAR_ASTERISK             = </span><span class="s4">0x2A</span><span class="s1">; </span><span class="s2">/* * */</span>
<span class="s3">var </span><span class="s1">CHAR_COMMA                = </span><span class="s4">0x2C</span><span class="s1">; </span><span class="s2">/* , */</span>
<span class="s3">var </span><span class="s1">CHAR_MINUS                = </span><span class="s4">0x2D</span><span class="s1">; </span><span class="s2">/* - */</span>
<span class="s3">var </span><span class="s1">CHAR_COLON                = </span><span class="s4">0x3A</span><span class="s1">; </span><span class="s2">/* : */</span>
<span class="s3">var </span><span class="s1">CHAR_EQUALS               = </span><span class="s4">0x3D</span><span class="s1">; </span><span class="s2">/* = */</span>
<span class="s3">var </span><span class="s1">CHAR_GREATER_THAN         = </span><span class="s4">0x3E</span><span class="s1">; </span><span class="s2">/* &gt; */</span>
<span class="s3">var </span><span class="s1">CHAR_QUESTION             = </span><span class="s4">0x3F</span><span class="s1">; </span><span class="s2">/* ? */</span>
<span class="s3">var </span><span class="s1">CHAR_COMMERCIAL_AT        = </span><span class="s4">0x40</span><span class="s1">; </span><span class="s2">/* @ */</span>
<span class="s3">var </span><span class="s1">CHAR_LEFT_SQUARE_BRACKET  = </span><span class="s4">0x5B</span><span class="s1">; </span><span class="s2">/* [ */</span>
<span class="s3">var </span><span class="s1">CHAR_RIGHT_SQUARE_BRACKET = </span><span class="s4">0x5D</span><span class="s1">; </span><span class="s2">/* ] */</span>
<span class="s3">var </span><span class="s1">CHAR_GRAVE_ACCENT         = </span><span class="s4">0x60</span><span class="s1">; </span><span class="s2">/* ` */</span>
<span class="s3">var </span><span class="s1">CHAR_LEFT_CURLY_BRACKET   = </span><span class="s4">0x7B</span><span class="s1">; </span><span class="s2">/* { */</span>
<span class="s3">var </span><span class="s1">CHAR_VERTICAL_LINE        = </span><span class="s4">0x7C</span><span class="s1">; </span><span class="s2">/* | */</span>
<span class="s3">var </span><span class="s1">CHAR_RIGHT_CURLY_BRACKET  = </span><span class="s4">0x7D</span><span class="s1">; </span><span class="s2">/* } */</span>

<span class="s3">var </span><span class="s1">ESCAPE_SEQUENCES = {};</span>

<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x00</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">0'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x07</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">a'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x08</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">b'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x09</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">t'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x0A</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">n'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x0B</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">v'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x0C</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">f'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x0D</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">r'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x1B</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">e'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x22</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">&quot;'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x5C</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\\\</span><span class="s0">'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x85</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">N'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0xA0</span><span class="s1">]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">_'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x2028</span><span class="s1">] = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">L'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0x2029</span><span class="s1">] = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">P'</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">DEPRECATED_BOOLEANS_SYNTAX = [</span>
  <span class="s0">'y'</span><span class="s1">, </span><span class="s0">'Y'</span><span class="s1">, </span><span class="s0">'yes'</span><span class="s1">, </span><span class="s0">'Yes'</span><span class="s1">, </span><span class="s0">'YES'</span><span class="s1">, </span><span class="s0">'on'</span><span class="s1">, </span><span class="s0">'On'</span><span class="s1">, </span><span class="s0">'ON'</span><span class="s1">,</span>
  <span class="s0">'n'</span><span class="s1">, </span><span class="s0">'N'</span><span class="s1">, </span><span class="s0">'no'</span><span class="s1">, </span><span class="s0">'No'</span><span class="s1">, </span><span class="s0">'NO'</span><span class="s1">, </span><span class="s0">'off'</span><span class="s1">, </span><span class="s0">'Off'</span><span class="s1">, </span><span class="s0">'OFF'</span>
<span class="s1">];</span>

<span class="s3">var </span><span class="s1">DEPRECATED_BASE60_SYNTAX = </span><span class="s6">/^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">compileStyleMap(schema, map) {</span>
  <span class="s3">var </span><span class="s1">result, keys, index, length, tag, style, type;</span>

  <span class="s3">if </span><span class="s1">(map === </span><span class="s3">null</span><span class="s1">) </span><span class="s3">return </span><span class="s1">{};</span>

  <span class="s1">result = {};</span>
  <span class="s1">keys = Object.keys(map);</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = keys.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">tag = keys[index];</span>
    <span class="s1">style = String(map[tag]);</span>

    <span class="s3">if </span><span class="s1">(tag.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">) === </span><span class="s0">'!!'</span><span class="s1">) {</span>
      <span class="s1">tag = </span><span class="s0">'tag:yaml.org,2002:' </span><span class="s1">+ tag.slice(</span><span class="s4">2</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">type = schema.compiledTypeMap[</span><span class="s0">'fallback'</span><span class="s1">][tag];</span>

    <span class="s3">if </span><span class="s1">(type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {</span>
      <span class="s1">style = type.styleAliases[style];</span>
    <span class="s1">}</span>

    <span class="s1">result[tag] = style;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">encodeHex(character) {</span>
  <span class="s3">var </span><span class="s1">string, handle, length;</span>

  <span class="s1">string = character.toString(</span><span class="s4">16</span><span class="s1">).toUpperCase();</span>

  <span class="s3">if </span><span class="s1">(character &lt;= </span><span class="s4">0xFF</span><span class="s1">) {</span>
    <span class="s1">handle = </span><span class="s0">'x'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(character &lt;= </span><span class="s4">0xFFFF</span><span class="s1">) {</span>
    <span class="s1">handle = </span><span class="s0">'u'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(character &lt;= </span><span class="s4">0xFFFFFFFF</span><span class="s1">) {</span>
    <span class="s1">handle = </span><span class="s0">'U'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'code point within a string may not be greater than 0xFFFFFFFF'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">' </span><span class="s1">+ handle + common.repeat(</span><span class="s0">'0'</span><span class="s1">, length - string.length) + string;</span>
<span class="s1">}</span>


<span class="s3">var </span><span class="s1">QUOTING_TYPE_SINGLE = </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">QUOTING_TYPE_DOUBLE = </span><span class="s4">2</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">State(options) {</span>
  <span class="s3">this</span><span class="s1">.schema        = options[</span><span class="s0">'schema'</span><span class="s1">] || DEFAULT_SCHEMA;</span>
  <span class="s3">this</span><span class="s1">.indent        = Math.max(</span><span class="s4">1</span><span class="s1">, (options[</span><span class="s0">'indent'</span><span class="s1">] || </span><span class="s4">2</span><span class="s1">));</span>
  <span class="s3">this</span><span class="s1">.noArrayIndent = options[</span><span class="s0">'noArrayIndent'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.skipInvalid   = options[</span><span class="s0">'skipInvalid'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.flowLevel     = (common.isNothing(options[</span><span class="s0">'flowLevel'</span><span class="s1">]) ? -</span><span class="s4">1 </span><span class="s1">: options[</span><span class="s0">'flowLevel'</span><span class="s1">]);</span>
  <span class="s3">this</span><span class="s1">.styleMap      = compileStyleMap(</span><span class="s3">this</span><span class="s1">.schema, options[</span><span class="s0">'styles'</span><span class="s1">] || </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s3">this</span><span class="s1">.sortKeys      = options[</span><span class="s0">'sortKeys'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.lineWidth     = options[</span><span class="s0">'lineWidth'</span><span class="s1">] || </span><span class="s4">80</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.noRefs        = options[</span><span class="s0">'noRefs'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.noCompatMode  = options[</span><span class="s0">'noCompatMode'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.condenseFlow  = options[</span><span class="s0">'condenseFlow'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.quotingType   = options[</span><span class="s0">'quotingType'</span><span class="s1">] === </span><span class="s0">'&quot;' </span><span class="s1">? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;</span>
  <span class="s3">this</span><span class="s1">.forceQuotes   = options[</span><span class="s0">'forceQuotes'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.replacer      = </span><span class="s3">typeof </span><span class="s1">options[</span><span class="s0">'replacer'</span><span class="s1">] === </span><span class="s0">'function' </span><span class="s1">? options[</span><span class="s0">'replacer'</span><span class="s1">] : </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">this</span><span class="s1">.implicitTypes = </span><span class="s3">this</span><span class="s1">.schema.compiledImplicit;</span>
  <span class="s3">this</span><span class="s1">.explicitTypes = </span><span class="s3">this</span><span class="s1">.schema.compiledExplicit;</span>

  <span class="s3">this</span><span class="s1">.tag = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.result = </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s3">this</span><span class="s1">.duplicates = [];</span>
  <span class="s3">this</span><span class="s1">.usedDuplicates = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Indents every line in a string. Empty lines (\n only) are not indented.</span>
<span class="s3">function </span><span class="s1">indentString(string, spaces) {</span>
  <span class="s3">var </span><span class="s1">ind = common.repeat(</span><span class="s0">' '</span><span class="s1">, spaces),</span>
      <span class="s1">position = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">next = -</span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">result = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">line,</span>
      <span class="s1">length = string.length;</span>

  <span class="s3">while </span><span class="s1">(position &lt; length) {</span>
    <span class="s1">next = string.indexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">, position);</span>
    <span class="s3">if </span><span class="s1">(next === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">line = string.slice(position);</span>
      <span class="s1">position = length;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">line = string.slice(position, next + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">position = next + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(line.length &amp;&amp; line !== </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">) result += ind;</span>

    <span class="s1">result += line;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">generateNextLine(state, level) {</span>
  <span class="s3">return </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ common.repeat(</span><span class="s0">' '</span><span class="s1">, state.indent * level);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">testImplicitResolving(state, str) {</span>
  <span class="s3">var </span><span class="s1">index, length, type;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = state.implicitTypes.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">type = state.implicitTypes[index];</span>

    <span class="s3">if </span><span class="s1">(type.resolve(str)) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// [33] s-white ::= s-space | s-tab</span>
<span class="s3">function </span><span class="s1">isWhitespace(c) {</span>
  <span class="s3">return </span><span class="s1">c === CHAR_SPACE || c === CHAR_TAB;</span>
<span class="s1">}</span>

<span class="s2">// Returns true if the character can be printed without escaping.</span>
<span class="s2">// From YAML 1.2: &quot;any allowed characters known to be non-printable</span>
<span class="s2">// should also be escaped. [However,] This isn’t mandatory&quot;</span>
<span class="s2">// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.</span>
<span class="s3">function </span><span class="s1">isPrintable(c) {</span>
  <span class="s3">return  </span><span class="s1">(</span><span class="s4">0x00020 </span><span class="s1">&lt;= c &amp;&amp; c &lt;= </span><span class="s4">0x00007E</span><span class="s1">)</span>
      <span class="s1">|| ((</span><span class="s4">0x000A1 </span><span class="s1">&lt;= c &amp;&amp; c &lt;= </span><span class="s4">0x00D7FF</span><span class="s1">) &amp;&amp; c !== </span><span class="s4">0x2028 </span><span class="s1">&amp;&amp; c !== </span><span class="s4">0x2029</span><span class="s1">)</span>
      <span class="s1">|| ((</span><span class="s4">0x0E000 </span><span class="s1">&lt;= c &amp;&amp; c &lt;= </span><span class="s4">0x00FFFD</span><span class="s1">) &amp;&amp; c !== CHAR_BOM)</span>
      <span class="s1">||  (</span><span class="s4">0x10000 </span><span class="s1">&lt;= c &amp;&amp; c &lt;= </span><span class="s4">0x10FFFF</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">// [34] ns-char ::= nb-char - s-white</span>
<span class="s2">// [27] nb-char ::= c-printable - b-char - c-byte-order-mark</span>
<span class="s2">// [26] b-char  ::= b-line-feed | b-carriage-return</span>
<span class="s2">// Including s-white (for some reason, examples doesn't match specs in this aspect)</span>
<span class="s2">// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark</span>
<span class="s3">function </span><span class="s1">isNsCharOrWhitespace(c) {</span>
  <span class="s3">return </span><span class="s1">isPrintable(c)</span>
    <span class="s1">&amp;&amp; c !== CHAR_BOM</span>
    <span class="s2">// - b-char</span>
    <span class="s1">&amp;&amp; c !== CHAR_CARRIAGE_RETURN</span>
    <span class="s1">&amp;&amp; c !== CHAR_LINE_FEED;</span>
<span class="s1">}</span>

<span class="s2">// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out</span>
<span class="s2">//                             c = flow-in   ⇒ ns-plain-safe-in</span>
<span class="s2">//                             c = block-key ⇒ ns-plain-safe-out</span>
<span class="s2">//                             c = flow-key  ⇒ ns-plain-safe-in</span>
<span class="s2">// [128] ns-plain-safe-out ::= ns-char</span>
<span class="s2">// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator</span>
<span class="s2">// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )</span>
<span class="s2">//                            | ( /* An ns-char preceding */ “#” )</span>
<span class="s2">//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )</span>
<span class="s3">function </span><span class="s1">isPlainSafe(c, prev, inblock) {</span>
  <span class="s3">var </span><span class="s1">cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);</span>
  <span class="s3">var </span><span class="s1">cIsNsChar = cIsNsCharOrWhitespace &amp;&amp; !isWhitespace(c);</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s2">// ns-plain-safe</span>
    <span class="s1">inblock ? </span><span class="s2">// c = flow-in</span>
      <span class="s1">cIsNsCharOrWhitespace</span>
      <span class="s1">: cIsNsCharOrWhitespace</span>
        <span class="s2">// - c-flow-indicator</span>
        <span class="s1">&amp;&amp; c !== CHAR_COMMA</span>
        <span class="s1">&amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET</span>
        <span class="s1">&amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET</span>
        <span class="s1">&amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET</span>
        <span class="s1">&amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET</span>
  <span class="s1">)</span>
    <span class="s2">// ns-plain-char</span>
    <span class="s1">&amp;&amp; c !== CHAR_SHARP </span><span class="s2">// false on '#'</span>
    <span class="s1">&amp;&amp; !(prev === CHAR_COLON &amp;&amp; !cIsNsChar) </span><span class="s2">// false on ': '</span>
    <span class="s1">|| (isNsCharOrWhitespace(prev) &amp;&amp; !isWhitespace(prev) &amp;&amp; c === CHAR_SHARP) </span><span class="s2">// change to true on '[^ ]#'</span>
    <span class="s1">|| (prev === CHAR_COLON &amp;&amp; cIsNsChar); </span><span class="s2">// change to true on ':[^ ]'</span>
<span class="s1">}</span>

<span class="s2">// Simplified test for values allowed as the first character in plain style.</span>
<span class="s3">function </span><span class="s1">isPlainSafeFirst(c) {</span>
  <span class="s2">// Uses a subset of ns-char - c-indicator</span>
  <span class="s2">// where ns-char = nb-char - s-white.</span>
  <span class="s2">// No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part</span>
  <span class="s3">return </span><span class="s1">isPrintable(c) &amp;&amp; c !== CHAR_BOM</span>
    <span class="s1">&amp;&amp; !isWhitespace(c) </span><span class="s2">// - s-white</span>
    <span class="s2">// - (c-indicator ::=</span>
    <span class="s2">// “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”</span>
    <span class="s1">&amp;&amp; c !== CHAR_MINUS</span>
    <span class="s1">&amp;&amp; c !== CHAR_QUESTION</span>
    <span class="s1">&amp;&amp; c !== CHAR_COLON</span>
    <span class="s1">&amp;&amp; c !== CHAR_COMMA</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET</span>
    <span class="s2">// | “#” | “&amp;” | “*” | “!” | “|” | “=” | “&gt;” | “'” | “&quot;”</span>
    <span class="s1">&amp;&amp; c !== CHAR_SHARP</span>
    <span class="s1">&amp;&amp; c !== CHAR_AMPERSAND</span>
    <span class="s1">&amp;&amp; c !== CHAR_ASTERISK</span>
    <span class="s1">&amp;&amp; c !== CHAR_EXCLAMATION</span>
    <span class="s1">&amp;&amp; c !== CHAR_VERTICAL_LINE</span>
    <span class="s1">&amp;&amp; c !== CHAR_EQUALS</span>
    <span class="s1">&amp;&amp; c !== CHAR_GREATER_THAN</span>
    <span class="s1">&amp;&amp; c !== CHAR_SINGLE_QUOTE</span>
    <span class="s1">&amp;&amp; c !== CHAR_DOUBLE_QUOTE</span>
    <span class="s2">// | “%” | “@” | “`”)</span>
    <span class="s1">&amp;&amp; c !== CHAR_PERCENT</span>
    <span class="s1">&amp;&amp; c !== CHAR_COMMERCIAL_AT</span>
    <span class="s1">&amp;&amp; c !== CHAR_GRAVE_ACCENT;</span>
<span class="s1">}</span>

<span class="s2">// Simplified test for values allowed as the last character in plain style.</span>
<span class="s3">function </span><span class="s1">isPlainSafeLast(c) {</span>
  <span class="s2">// just not whitespace or colon, it will be checked to be plain character later</span>
  <span class="s3">return </span><span class="s1">!isWhitespace(c) &amp;&amp; c !== CHAR_COLON;</span>
<span class="s1">}</span>

<span class="s2">// Same as 'string'.codePointAt(pos), but works in older browsers.</span>
<span class="s3">function </span><span class="s1">codePointAt(string, pos) {</span>
  <span class="s3">var </span><span class="s1">first = string.charCodeAt(pos), second;</span>
  <span class="s3">if </span><span class="s1">(first &gt;= </span><span class="s4">0xD800 </span><span class="s1">&amp;&amp; first &lt;= </span><span class="s4">0xDBFF </span><span class="s1">&amp;&amp; pos + </span><span class="s4">1 </span><span class="s1">&lt; string.length) {</span>
    <span class="s1">second = string.charCodeAt(pos + </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(second &gt;= </span><span class="s4">0xDC00 </span><span class="s1">&amp;&amp; second &lt;= </span><span class="s4">0xDFFF</span><span class="s1">) {</span>
      <span class="s2">// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae</span>
      <span class="s3">return </span><span class="s1">(first - </span><span class="s4">0xD800</span><span class="s1">) * </span><span class="s4">0x400 </span><span class="s1">+ second - </span><span class="s4">0xDC00 </span><span class="s1">+ </span><span class="s4">0x10000</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">first;</span>
<span class="s1">}</span>

<span class="s2">// Determines whether block indentation indicator is required.</span>
<span class="s3">function </span><span class="s1">needIndentIndicator(string) {</span>
  <span class="s3">var </span><span class="s1">leadingSpaceRe = </span><span class="s6">/^\n* /</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">leadingSpaceRe.test(string);</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">STYLE_PLAIN   = </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">STYLE_SINGLE  = </span><span class="s4">2</span><span class="s1">,</span>
    <span class="s1">STYLE_LITERAL = </span><span class="s4">3</span><span class="s1">,</span>
    <span class="s1">STYLE_FOLDED  = </span><span class="s4">4</span><span class="s1">,</span>
    <span class="s1">STYLE_DOUBLE  = </span><span class="s4">5</span><span class="s1">;</span>

<span class="s2">// Determines which scalar styles are possible and returns the preferred style.</span>
<span class="s2">// lineWidth = -1 =&gt; no limit.</span>
<span class="s2">// Pre-conditions: str.length &gt; 0.</span>
<span class="s2">// Post-conditions:</span>
<span class="s2">//    STYLE_PLAIN or STYLE_SINGLE =&gt; no \n are in the string.</span>
<span class="s2">//    STYLE_LITERAL =&gt; no lines are suitable for folding (or lineWidth is -1).</span>
<span class="s2">//    STYLE_FOLDED =&gt; a line &gt; lineWidth and can be folded (and lineWidth != -1).</span>
<span class="s3">function </span><span class="s1">chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,</span>
  <span class="s1">testAmbiguousType, quotingType, forceQuotes, inblock) {</span>

  <span class="s3">var </span><span class="s1">i;</span>
  <span class="s3">var </span><span class="s1">char = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">prevChar = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">hasLineBreak = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">hasFoldableLine = </span><span class="s3">false</span><span class="s1">; </span><span class="s2">// only checked if shouldTrackWidth</span>
  <span class="s3">var </span><span class="s1">shouldTrackWidth = lineWidth !== -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">previousLineBreak = -</span><span class="s4">1</span><span class="s1">; </span><span class="s2">// count the first line correctly</span>
  <span class="s3">var </span><span class="s1">plain = isPlainSafeFirst(codePointAt(string, </span><span class="s4">0</span><span class="s1">))</span>
          <span class="s1">&amp;&amp; isPlainSafeLast(codePointAt(string, string.length - </span><span class="s4">1</span><span class="s1">));</span>

  <span class="s3">if </span><span class="s1">(singleLineOnly || forceQuotes) {</span>
    <span class="s2">// Case: no block styles.</span>
    <span class="s2">// Check for disallowed characters to rule out plain and single.</span>
    <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; char &gt;= </span><span class="s4">0x10000 </span><span class="s1">? i += </span><span class="s4">2 </span><span class="s1">: i++) {</span>
      <span class="s1">char = codePointAt(string, i);</span>
      <span class="s3">if </span><span class="s1">(!isPrintable(char)) {</span>
        <span class="s3">return </span><span class="s1">STYLE_DOUBLE;</span>
      <span class="s1">}</span>
      <span class="s1">plain = plain &amp;&amp; isPlainSafe(char, prevChar, inblock);</span>
      <span class="s1">prevChar = char;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">// Case: block styles permitted.</span>
    <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; char &gt;= </span><span class="s4">0x10000 </span><span class="s1">? i += </span><span class="s4">2 </span><span class="s1">: i++) {</span>
      <span class="s1">char = codePointAt(string, i);</span>
      <span class="s3">if </span><span class="s1">(char === CHAR_LINE_FEED) {</span>
        <span class="s1">hasLineBreak = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s2">// Check if any line can be folded.</span>
        <span class="s3">if </span><span class="s1">(shouldTrackWidth) {</span>
          <span class="s1">hasFoldableLine = hasFoldableLine ||</span>
            <span class="s2">// Foldable line = too long, and not more-indented.</span>
            <span class="s1">(i - previousLineBreak - </span><span class="s4">1 </span><span class="s1">&gt; lineWidth &amp;&amp;</span>
             <span class="s1">string[previousLineBreak + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">' '</span><span class="s1">);</span>
          <span class="s1">previousLineBreak = i;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!isPrintable(char)) {</span>
        <span class="s3">return </span><span class="s1">STYLE_DOUBLE;</span>
      <span class="s1">}</span>
      <span class="s1">plain = plain &amp;&amp; isPlainSafe(char, prevChar, inblock);</span>
      <span class="s1">prevChar = char;</span>
    <span class="s1">}</span>
    <span class="s2">// in case the end is missing a \n</span>
    <span class="s1">hasFoldableLine = hasFoldableLine || (shouldTrackWidth &amp;&amp;</span>
      <span class="s1">(i - previousLineBreak - </span><span class="s4">1 </span><span class="s1">&gt; lineWidth &amp;&amp;</span>
       <span class="s1">string[previousLineBreak + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">' '</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s2">// Although every style can represent \n without escaping, prefer block styles</span>
  <span class="s2">// for multiline, since they're more readable and they don't add empty lines.</span>
  <span class="s2">// Also prefer folding a super-long line.</span>
  <span class="s3">if </span><span class="s1">(!hasLineBreak &amp;&amp; !hasFoldableLine) {</span>
    <span class="s2">// Strings interpretable as another type have to be quoted;</span>
    <span class="s2">// e.g. the string 'true' vs. the boolean true.</span>
    <span class="s3">if </span><span class="s1">(plain &amp;&amp; !forceQuotes &amp;&amp; !testAmbiguousType(string)) {</span>
      <span class="s3">return </span><span class="s1">STYLE_PLAIN;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;</span>
  <span class="s1">}</span>
  <span class="s2">// Edge case: block indentation indicator can only have one digit.</span>
  <span class="s3">if </span><span class="s1">(indentPerLevel &gt; </span><span class="s4">9 </span><span class="s1">&amp;&amp; needIndentIndicator(string)) {</span>
    <span class="s3">return </span><span class="s1">STYLE_DOUBLE;</span>
  <span class="s1">}</span>
  <span class="s2">// At this point we know block styles are valid.</span>
  <span class="s2">// Prefer literal style unless we want to fold.</span>
  <span class="s3">if </span><span class="s1">(!forceQuotes) {</span>
    <span class="s3">return </span><span class="s1">hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;</span>
<span class="s1">}</span>

<span class="s2">// Note: line breaking/folding is implemented for only the folded style.</span>
<span class="s2">// NB. We drop the last trailing newline (if any) of a returned block scalar</span>
<span class="s2">//  since the dumper adds its own newline. This always works:</span>
<span class="s2">//    • No ending newline =&gt; unaffected; already using strip &quot;-&quot; chomping.</span>
<span class="s2">//    • Ending newline    =&gt; removed then restored.</span>
<span class="s2">//  Importantly, this keeps the &quot;+&quot; chomp indicator from gaining an extra line.</span>
<span class="s3">function </span><span class="s1">writeScalar(state, string, level, iskey, inblock) {</span>
  <span class="s1">state.dump = (</span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">if </span><span class="s1">(string.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">state.quotingType === QUOTING_TYPE_DOUBLE ? </span><span class="s0">'&quot;&quot;' </span><span class="s1">: </span><span class="s0">&quot;''&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!state.noCompatMode) {</span>
      <span class="s3">if </span><span class="s1">(DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -</span><span class="s4">1 </span><span class="s1">|| DEPRECATED_BASE60_SYNTAX.test(string)) {</span>
        <span class="s3">return </span><span class="s1">state.quotingType === QUOTING_TYPE_DOUBLE ? (</span><span class="s0">'&quot;' </span><span class="s1">+ string + </span><span class="s0">'&quot;'</span><span class="s1">) : (</span><span class="s0">&quot;'&quot; </span><span class="s1">+ string + </span><span class="s0">&quot;'&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">indent = state.indent * Math.max(</span><span class="s4">1</span><span class="s1">, level); </span><span class="s2">// no 0-indent scalars</span>
    <span class="s2">// As indentation gets deeper, let the width decrease monotonically</span>
    <span class="s2">// to the lower bound min(state.lineWidth, 40).</span>
    <span class="s2">// Note that this implies</span>
    <span class="s2">//  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.</span>
    <span class="s2">//  state.lineWidth &gt; 40 + state.indent: width decreases until the lower bound.</span>
    <span class="s2">// This behaves better than a constant minimum width which disallows narrower options,</span>
    <span class="s2">// or an indent threshold which causes the width to suddenly increase.</span>
    <span class="s3">var </span><span class="s1">lineWidth = state.lineWidth === -</span><span class="s4">1</span>
      <span class="s1">? -</span><span class="s4">1 </span><span class="s1">: Math.max(Math.min(state.lineWidth, </span><span class="s4">40</span><span class="s1">), state.lineWidth - indent);</span>

    <span class="s2">// Without knowing if keys are implicit/explicit, assume implicit for safety.</span>
    <span class="s3">var </span><span class="s1">singleLineOnly = iskey</span>
      <span class="s2">// No block styles in flow mode.</span>
      <span class="s1">|| (state.flowLevel &gt; -</span><span class="s4">1 </span><span class="s1">&amp;&amp; level &gt;= state.flowLevel);</span>
    <span class="s3">function </span><span class="s1">testAmbiguity(string) {</span>
      <span class="s3">return </span><span class="s1">testImplicitResolving(state, string);</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,</span>
      <span class="s1">testAmbiguity, state.quotingType, state.forceQuotes &amp;&amp; !iskey, inblock)) {</span>

      <span class="s3">case </span><span class="s1">STYLE_PLAIN:</span>
        <span class="s3">return </span><span class="s1">string;</span>
      <span class="s3">case </span><span class="s1">STYLE_SINGLE:</span>
        <span class="s3">return </span><span class="s0">&quot;'&quot; </span><span class="s1">+ string.replace(</span><span class="s6">/'/g</span><span class="s1">, </span><span class="s0">&quot;''&quot;</span><span class="s1">) + </span><span class="s0">&quot;'&quot;</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s1">STYLE_LITERAL:</span>
        <span class="s3">return </span><span class="s0">'|' </span><span class="s1">+ blockHeader(string, state.indent)</span>
          <span class="s1">+ dropEndingNewline(indentString(string, indent));</span>
      <span class="s3">case </span><span class="s1">STYLE_FOLDED:</span>
        <span class="s3">return </span><span class="s0">'&gt;' </span><span class="s1">+ blockHeader(string, state.indent)</span>
          <span class="s1">+ dropEndingNewline(indentString(foldString(string, lineWidth), indent));</span>
      <span class="s3">case </span><span class="s1">STYLE_DOUBLE:</span>
        <span class="s3">return </span><span class="s0">'&quot;' </span><span class="s1">+ escapeString(string, lineWidth) + </span><span class="s0">'&quot;'</span><span class="s1">;</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'impossible error: invalid scalar style'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}());</span>
<span class="s1">}</span>

<span class="s2">// Pre-conditions: string is valid for a block scalar, 1 &lt;= indentPerLevel &lt;= 9.</span>
<span class="s3">function </span><span class="s1">blockHeader(string, indentPerLevel) {</span>
  <span class="s3">var </span><span class="s1">indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s2">// note the special case: the string '\n' counts as a &quot;trailing&quot; empty line.</span>
  <span class="s3">var </span><span class="s1">clip =          string[string.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">keep = clip &amp;&amp; (string[string.length - </span><span class="s4">2</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">|| string === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">chomp = keep ? </span><span class="s0">'+' </span><span class="s1">: (clip ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'-'</span><span class="s1">);</span>

  <span class="s3">return </span><span class="s1">indentIndicator + chomp + </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// (See the note for writeScalar.)</span>
<span class="s3">function </span><span class="s1">dropEndingNewline(string) {</span>
  <span class="s3">return </span><span class="s1">string[string.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">? string.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">) : string;</span>
<span class="s1">}</span>

<span class="s2">// Note: a long line without a suitable break point will exceed the width limit.</span>
<span class="s2">// Pre-conditions: every char in str isPrintable, str.length &gt; 0, width &gt; 0.</span>
<span class="s3">function </span><span class="s1">foldString(string, width) {</span>
  <span class="s2">// In folded style, $k$ consecutive newlines output as $k+1$ newlines—</span>
  <span class="s2">// unless they're before or after a more-indented line, or at the very</span>
  <span class="s2">// beginning or end, in which case $k$ maps to $k$.</span>
  <span class="s2">// Therefore, parse each chunk as newline(s) followed by a content line.</span>
  <span class="s3">var </span><span class="s1">lineRe = </span><span class="s6">/(\n+)([^\n]*)/g</span><span class="s1">;</span>

  <span class="s2">// first line (possibly an empty line)</span>
  <span class="s3">var </span><span class="s1">result = (</span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">var </span><span class="s1">nextLF = string.indexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
    <span class="s1">nextLF = nextLF !== -</span><span class="s4">1 </span><span class="s1">? nextLF : string.length;</span>
    <span class="s1">lineRe.lastIndex = nextLF;</span>
    <span class="s3">return </span><span class="s1">foldLine(string.slice(</span><span class="s4">0</span><span class="s1">, nextLF), width);</span>
  <span class="s1">}());</span>
  <span class="s2">// If we haven't reached the first content line yet, don't add an extra \n.</span>
  <span class="s3">var </span><span class="s1">prevMoreIndented = string[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">|| string[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">moreIndented;</span>

  <span class="s2">// rest of the lines</span>
  <span class="s3">var </span><span class="s1">match;</span>
  <span class="s3">while </span><span class="s1">((match = lineRe.exec(string))) {</span>
    <span class="s3">var </span><span class="s1">prefix = match[</span><span class="s4">1</span><span class="s1">], line = match[</span><span class="s4">2</span><span class="s1">];</span>
    <span class="s1">moreIndented = (line[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">);</span>
    <span class="s1">result += prefix</span>
      <span class="s1">+ (!prevMoreIndented &amp;&amp; !moreIndented &amp;&amp; line !== </span><span class="s0">''</span>
        <span class="s1">? </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">)</span>
      <span class="s1">+ foldLine(line, width);</span>
    <span class="s1">prevMoreIndented = moreIndented;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">// Greedy line breaking.</span>
<span class="s2">// Picks the longest line under the limit each time,</span>
<span class="s2">// otherwise settles for the shortest line over the limit.</span>
<span class="s2">// NB. More-indented lines *cannot* be folded, as that would add an extra \n.</span>
<span class="s3">function </span><span class="s1">foldLine(line, width) {</span>
  <span class="s3">if </span><span class="s1">(line === </span><span class="s0">'' </span><span class="s1">|| line[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">) </span><span class="s3">return </span><span class="s1">line;</span>

  <span class="s2">// Since a more-indented line adds a \n, breaks can't be followed by a space.</span>
  <span class="s3">var </span><span class="s1">breakRe = </span><span class="s6">/ [^ ]/g</span><span class="s1">; </span><span class="s2">// note: the match index will always be &lt;= length-2.</span>
  <span class="s3">var </span><span class="s1">match;</span>
  <span class="s2">// start is an inclusive index. end, curr, and next are exclusive.</span>
  <span class="s3">var </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">, end, curr = </span><span class="s4">0</span><span class="s1">, next = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">result = </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s2">// Invariants: 0 &lt;= start &lt;= length-1.</span>
  <span class="s2">//   0 &lt;= curr &lt;= next &lt;= max(0, length-2). curr - start &lt;= width.</span>
  <span class="s2">// Inside the loop:</span>
  <span class="s2">//   A match implies length &gt;= 2, so curr and next are &lt;= length-2.</span>
  <span class="s3">while </span><span class="s1">((match = breakRe.exec(line))) {</span>
    <span class="s1">next = match.index;</span>
    <span class="s2">// maintain invariant: curr - start &lt;= width</span>
    <span class="s3">if </span><span class="s1">(next - start &gt; width) {</span>
      <span class="s1">end = (curr &gt; start) ? curr : next; </span><span class="s2">// derive end &lt;= length-2</span>
      <span class="s1">result += </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ line.slice(start, end);</span>
      <span class="s2">// skip the space that was output as \n</span>
      <span class="s1">start = end + </span><span class="s4">1</span><span class="s1">;                    </span><span class="s2">// derive start &lt;= length-1</span>
    <span class="s1">}</span>
    <span class="s1">curr = next;</span>
  <span class="s1">}</span>

  <span class="s2">// By the invariants, start &lt;= length-1, so there is something left over.</span>
  <span class="s2">// It is either the whole string or a part starting from non-whitespace.</span>
  <span class="s1">result += </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
  <span class="s2">// Insert a break if the remainder is too long and there is a break available.</span>
  <span class="s3">if </span><span class="s1">(line.length - start &gt; width &amp;&amp; curr &gt; start) {</span>
    <span class="s1">result += line.slice(start, curr) + </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ line.slice(curr + </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">result += line.slice(start);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result.slice(</span><span class="s4">1</span><span class="s1">); </span><span class="s2">// drop extra \n joiner</span>
<span class="s1">}</span>

<span class="s2">// Escapes a double-quoted string.</span>
<span class="s3">function </span><span class="s1">escapeString(string) {</span>
  <span class="s3">var </span><span class="s1">result = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">char = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">escapeSeq;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; char &gt;= </span><span class="s4">0x10000 </span><span class="s1">? i += </span><span class="s4">2 </span><span class="s1">: i++) {</span>
    <span class="s1">char = codePointAt(string, i);</span>
    <span class="s1">escapeSeq = ESCAPE_SEQUENCES[char];</span>

    <span class="s3">if </span><span class="s1">(!escapeSeq &amp;&amp; isPrintable(char)) {</span>
      <span class="s1">result += string[i];</span>
      <span class="s3">if </span><span class="s1">(char &gt;= </span><span class="s4">0x10000</span><span class="s1">) result += string[i + </span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">result += escapeSeq || encodeHex(char);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">writeFlowSequence(state, level, object) {</span>
  <span class="s3">var </span><span class="s1">_result = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">_tag    = state.tag,</span>
      <span class="s1">index,</span>
      <span class="s1">length,</span>
      <span class="s1">value;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">value = object[index];</span>

    <span class="s3">if </span><span class="s1">(state.replacer) {</span>
      <span class="s1">value = state.replacer.call(object, String(index), value);</span>
    <span class="s1">}</span>

    <span class="s2">// Write only valid elements, put null instead of invalid elements.</span>
    <span class="s3">if </span><span class="s1">(writeNode(state, level, value, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">) ||</span>
        <span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp;</span>
         <span class="s1">writeNode(state, level, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">))) {</span>

      <span class="s3">if </span><span class="s1">(_result !== </span><span class="s0">''</span><span class="s1">) _result += </span><span class="s0">',' </span><span class="s1">+ (!state.condenseFlow ? </span><span class="s0">' ' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">);</span>
      <span class="s1">_result += state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = </span><span class="s0">'[' </span><span class="s1">+ _result + </span><span class="s0">']'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">writeBlockSequence(state, level, object, compact) {</span>
  <span class="s3">var </span><span class="s1">_result = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">_tag    = state.tag,</span>
      <span class="s1">index,</span>
      <span class="s1">length,</span>
      <span class="s1">value;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">value = object[index];</span>

    <span class="s3">if </span><span class="s1">(state.replacer) {</span>
      <span class="s1">value = state.replacer.call(object, String(index), value);</span>
    <span class="s1">}</span>

    <span class="s2">// Write only valid elements, put null instead of invalid elements.</span>
    <span class="s3">if </span><span class="s1">(writeNode(state, level + </span><span class="s4">1</span><span class="s1">, value, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">true</span><span class="s1">) ||</span>
        <span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp;</span>
         <span class="s1">writeNode(state, level + </span><span class="s4">1</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">true</span><span class="s1">))) {</span>

      <span class="s3">if </span><span class="s1">(!compact || _result !== </span><span class="s0">''</span><span class="s1">) {</span>
        <span class="s1">_result += generateNextLine(state, level);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">_result += </span><span class="s0">'-'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">_result += </span><span class="s0">'- '</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">_result += state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = _result || </span><span class="s0">'[]'</span><span class="s1">; </span><span class="s2">// Empty sequence if no valid values.</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">writeFlowMapping(state, level, object) {</span>
  <span class="s3">var </span><span class="s1">_result       = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">_tag          = state.tag,</span>
      <span class="s1">objectKeyList = Object.keys(object),</span>
      <span class="s1">index,</span>
      <span class="s1">length,</span>
      <span class="s1">objectKey,</span>
      <span class="s1">objectValue,</span>
      <span class="s1">pairBuffer;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>

    <span class="s1">pairBuffer = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(_result !== </span><span class="s0">''</span><span class="s1">) pairBuffer += </span><span class="s0">', '</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(state.condenseFlow) pairBuffer += </span><span class="s0">'&quot;'</span><span class="s1">;</span>

    <span class="s1">objectKey = objectKeyList[index];</span>
    <span class="s1">objectValue = object[objectKey];</span>

    <span class="s3">if </span><span class="s1">(state.replacer) {</span>
      <span class="s1">objectValue = state.replacer.call(object, objectKey, objectValue);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!writeNode(state, level, objectKey, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">)) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s2">// Skip this pair because of invalid key;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(state.dump.length &gt; </span><span class="s4">1024</span><span class="s1">) pairBuffer += </span><span class="s0">'? '</span><span class="s1">;</span>

    <span class="s1">pairBuffer += state.dump + (state.condenseFlow ? </span><span class="s0">'&quot;' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">) + </span><span class="s0">':' </span><span class="s1">+ (state.condenseFlow ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">' '</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(!writeNode(state, level, objectValue, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">)) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s2">// Skip this pair because of invalid value.</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s2">// Both key and value are valid.</span>
    <span class="s1">_result += pairBuffer;</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = </span><span class="s0">'{' </span><span class="s1">+ _result + </span><span class="s0">'}'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">writeBlockMapping(state, level, object, compact) {</span>
  <span class="s3">var </span><span class="s1">_result       = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">_tag          = state.tag,</span>
      <span class="s1">objectKeyList = Object.keys(object),</span>
      <span class="s1">index,</span>
      <span class="s1">length,</span>
      <span class="s1">objectKey,</span>
      <span class="s1">objectValue,</span>
      <span class="s1">explicitPair,</span>
      <span class="s1">pairBuffer;</span>

  <span class="s2">// Allow sorting keys so that the output file is deterministic</span>
  <span class="s3">if </span><span class="s1">(state.sortKeys === </span><span class="s3">true</span><span class="s1">) {</span>
    <span class="s2">// Default sorting</span>
    <span class="s1">objectKeyList.sort();</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">state.sortKeys === </span><span class="s0">'function'</span><span class="s1">) {</span>
    <span class="s2">// Custom sort function</span>
    <span class="s1">objectKeyList.sort(state.sortKeys);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(state.sortKeys) {</span>
    <span class="s2">// Something is wrong</span>
    <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'sortKeys must be a boolean or a function'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">pairBuffer = </span><span class="s0">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!compact || _result !== </span><span class="s0">''</span><span class="s1">) {</span>
      <span class="s1">pairBuffer += generateNextLine(state, level);</span>
    <span class="s1">}</span>

    <span class="s1">objectKey = objectKeyList[index];</span>
    <span class="s1">objectValue = object[objectKey];</span>

    <span class="s3">if </span><span class="s1">(state.replacer) {</span>
      <span class="s1">objectValue = state.replacer.call(object, objectKey, objectValue);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!writeNode(state, level + </span><span class="s4">1</span><span class="s1">, objectKey, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">)) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s2">// Skip this pair because of invalid key.</span>
    <span class="s1">}</span>

    <span class="s1">explicitPair = (state.tag !== </span><span class="s3">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s0">'?'</span><span class="s1">) ||</span>
                   <span class="s1">(state.dump &amp;&amp; state.dump.length &gt; </span><span class="s4">1024</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(explicitPair) {</span>
      <span class="s3">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">pairBuffer += </span><span class="s0">'?'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">pairBuffer += </span><span class="s0">'? '</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s3">if </span><span class="s1">(explicitPair) {</span>
      <span class="s1">pairBuffer += generateNextLine(state, level);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!writeNode(state, level + </span><span class="s4">1</span><span class="s1">, objectValue, </span><span class="s3">true</span><span class="s1">, explicitPair)) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s2">// Skip this pair because of invalid value.</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s1">pairBuffer += </span><span class="s0">':'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">pairBuffer += </span><span class="s0">': '</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s2">// Both key and value are valid.</span>
    <span class="s1">_result += pairBuffer;</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = _result || </span><span class="s0">'{}'</span><span class="s1">; </span><span class="s2">// Empty mapping if no valid pairs.</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">detectType(state, object, explicit) {</span>
  <span class="s3">var </span><span class="s1">_result, typeList, index, length, type, style;</span>

  <span class="s1">typeList = explicit ? state.explicitTypes : state.implicitTypes;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = typeList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">type = typeList[index];</span>

    <span class="s3">if </span><span class="s1">((type.instanceOf  || type.predicate) &amp;&amp;</span>
        <span class="s1">(!type.instanceOf || ((</span><span class="s3">typeof </span><span class="s1">object === </span><span class="s0">'object'</span><span class="s1">) &amp;&amp; (object </span><span class="s3">instanceof </span><span class="s1">type.instanceOf))) &amp;&amp;</span>
        <span class="s1">(!type.predicate  || type.predicate(object))) {</span>

      <span class="s3">if </span><span class="s1">(explicit) {</span>
        <span class="s3">if </span><span class="s1">(type.multi &amp;&amp; type.representName) {</span>
          <span class="s1">state.tag = type.representName(object);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">state.tag = type.tag;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">state.tag = </span><span class="s0">'?'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(type.represent) {</span>
        <span class="s1">style = state.styleMap[type.tag] || type.defaultStyle;</span>

        <span class="s3">if </span><span class="s1">(_toString.call(type.represent) === </span><span class="s0">'[object Function]'</span><span class="s1">) {</span>
          <span class="s1">_result = type.represent(object, style);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(_hasOwnProperty.call(type.represent, style)) {</span>
          <span class="s1">_result = type.represent[style](object, style);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'!&lt;' </span><span class="s1">+ type.tag + </span><span class="s0">'&gt; tag resolver accepts not &quot;' </span><span class="s1">+ style + </span><span class="s0">'&quot; style'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">state.dump = _result;</span>
      <span class="s1">}</span>

      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Serializes `object` and writes it to global `result`.</span>
<span class="s2">// Returns true on success, or false on invalid object.</span>
<span class="s2">//</span>
<span class="s3">function </span><span class="s1">writeNode(state, level, object, block, compact, iskey, isblockseq) {</span>
  <span class="s1">state.tag = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">state.dump = object;</span>

  <span class="s3">if </span><span class="s1">(!detectType(state, object, </span><span class="s3">false</span><span class="s1">)) {</span>
    <span class="s1">detectType(state, object, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">type = _toString.call(state.dump);</span>
  <span class="s3">var </span><span class="s1">inblock = block;</span>
  <span class="s3">var </span><span class="s1">tagStr;</span>

  <span class="s3">if </span><span class="s1">(block) {</span>
    <span class="s1">block = (state.flowLevel &lt; </span><span class="s4">0 </span><span class="s1">|| state.flowLevel &gt; level);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">objectOrArray = type === </span><span class="s0">'[object Object]' </span><span class="s1">|| type === </span><span class="s0">'[object Array]'</span><span class="s1">,</span>
      <span class="s1">duplicateIndex,</span>
      <span class="s1">duplicate;</span>

  <span class="s3">if </span><span class="s1">(objectOrArray) {</span>
    <span class="s1">duplicateIndex = state.duplicates.indexOf(object);</span>
    <span class="s1">duplicate = duplicateIndex !== -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">((state.tag !== </span><span class="s3">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s0">'?'</span><span class="s1">) || duplicate || (state.indent !== </span><span class="s4">2 </span><span class="s1">&amp;&amp; level &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
    <span class="s1">compact = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {</span>
    <span class="s1">state.dump = </span><span class="s0">'*ref_' </span><span class="s1">+ duplicateIndex;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {</span>
      <span class="s1">state.usedDuplicates[duplicateIndex] = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(type === </span><span class="s0">'[object Object]'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(block &amp;&amp; (Object.keys(state.dump).length !== </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">writeBlockMapping(state, level, state.dump, compact);</span>
        <span class="s3">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s0">'&amp;ref_' </span><span class="s1">+ duplicateIndex + state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">writeFlowMapping(state, level, state.dump);</span>
        <span class="s3">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s0">'&amp;ref_' </span><span class="s1">+ duplicateIndex + </span><span class="s0">' ' </span><span class="s1">+ state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type === </span><span class="s0">'[object Array]'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(block &amp;&amp; (state.dump.length !== </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s3">if </span><span class="s1">(state.noArrayIndent &amp;&amp; !isblockseq &amp;&amp; level &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">writeBlockSequence(state, level - </span><span class="s4">1</span><span class="s1">, state.dump, compact);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">writeBlockSequence(state, level, state.dump, compact);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s0">'&amp;ref_' </span><span class="s1">+ duplicateIndex + state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">writeFlowSequence(state, level, state.dump);</span>
        <span class="s3">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s0">'&amp;ref_' </span><span class="s1">+ duplicateIndex + </span><span class="s0">' ' </span><span class="s1">+ state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type === </span><span class="s0">'[object String]'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(state.tag !== </span><span class="s0">'?'</span><span class="s1">) {</span>
        <span class="s1">writeScalar(state, state.dump, level, iskey, inblock);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type === </span><span class="s0">'[object Undefined]'</span><span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(state.skipInvalid) </span><span class="s3">return false</span><span class="s1">;</span>
      <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'unacceptable kind of an object to dump ' </span><span class="s1">+ type);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(state.tag !== </span><span class="s3">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s0">'?'</span><span class="s1">) {</span>
      <span class="s2">// Need to encode all characters except those allowed by the spec:</span>
      <span class="s2">//</span>
      <span class="s2">// [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */</span>
      <span class="s2">// [36] ns-hex-digit    ::=  ns-dec-digit</span>
      <span class="s2">//                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */</span>
      <span class="s2">// [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */</span>
      <span class="s2">// [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”</span>
      <span class="s2">// [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”</span>
      <span class="s2">//                         | “;” | “/” | “?” | “:” | “@” | “&amp;” | “=” | “+” | “$” | “,”</span>
      <span class="s2">//                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”</span>
      <span class="s2">//</span>
      <span class="s2">// Also need to encode '!' because it has special meaning (end of tag prefix).</span>
      <span class="s2">//</span>
      <span class="s1">tagStr = encodeURI(</span>
        <span class="s1">state.tag[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'!' </span><span class="s1">? state.tag.slice(</span><span class="s4">1</span><span class="s1">) : state.tag</span>
      <span class="s1">).replace(</span><span class="s6">/!/g</span><span class="s1">, </span><span class="s0">'%21'</span><span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(state.tag[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'!'</span><span class="s1">) {</span>
        <span class="s1">tagStr = </span><span class="s0">'!' </span><span class="s1">+ tagStr;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(tagStr.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">18</span><span class="s1">) === </span><span class="s0">'tag:yaml.org,2002:'</span><span class="s1">) {</span>
        <span class="s1">tagStr = </span><span class="s0">'!!' </span><span class="s1">+ tagStr.slice(</span><span class="s4">18</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">tagStr = </span><span class="s0">'!&lt;' </span><span class="s1">+ tagStr + </span><span class="s0">'&gt;'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">state.dump = tagStr + </span><span class="s0">' ' </span><span class="s1">+ state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getDuplicateReferences(object, state) {</span>
  <span class="s3">var </span><span class="s1">objects = [],</span>
      <span class="s1">duplicatesIndexes = [],</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s1">inspectNode(object, objects, duplicatesIndexes);</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = duplicatesIndexes.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">state.duplicates.push(objects[duplicatesIndexes[index]]);</span>
  <span class="s1">}</span>
  <span class="s1">state.usedDuplicates = </span><span class="s3">new </span><span class="s1">Array(length);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">inspectNode(object, objects, duplicatesIndexes) {</span>
  <span class="s3">var </span><span class="s1">objectKeyList,</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s3">if </span><span class="s1">(object !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">object === </span><span class="s0">'object'</span><span class="s1">) {</span>
    <span class="s1">index = objects.indexOf(object);</span>
    <span class="s3">if </span><span class="s1">(index !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(duplicatesIndexes.indexOf(index) === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">duplicatesIndexes.push(index);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">objects.push(object);</span>

      <span class="s3">if </span><span class="s1">(Array.isArray(object)) {</span>
        <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">inspectNode(object[index], objects, duplicatesIndexes);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">objectKeyList = Object.keys(object);</span>

        <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">dump(input, options) {</span>
  <span class="s1">options = options || {};</span>

  <span class="s3">var </span><span class="s1">state = </span><span class="s3">new </span><span class="s1">State(options);</span>

  <span class="s3">if </span><span class="s1">(!state.noRefs) getDuplicateReferences(input, state);</span>

  <span class="s3">var </span><span class="s1">value = input;</span>

  <span class="s3">if </span><span class="s1">(state.replacer) {</span>
    <span class="s1">value = state.replacer.call({ </span><span class="s0">''</span><span class="s1">: value }, </span><span class="s0">''</span><span class="s1">, value);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(writeNode(state, </span><span class="s4">0</span><span class="s1">, value, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">state.dump + </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>

  <span class="s3">return </span><span class="s0">''</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">module.exports.dump = dump;</span>
</pre>
</body>
</html>