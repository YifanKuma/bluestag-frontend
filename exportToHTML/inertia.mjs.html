<html>
<head>
<title>inertia.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
inertia.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ spring } from </span><span class="s2">'./spring/index.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ calcGeneratorVelocity } from </span><span class="s2">'./utils/velocity.mjs'</span><span class="s1">;</span>

<span class="s0">function </span><span class="s1">inertia({ keyframes, velocity = </span><span class="s3">0.0</span><span class="s1">, power = </span><span class="s3">0.8</span><span class="s1">, timeConstant = </span><span class="s3">325</span><span class="s1">, bounceDamping = </span><span class="s3">10</span><span class="s1">, bounceStiffness = </span><span class="s3">500</span><span class="s1">, modifyTarget, min, max, restDelta = </span><span class="s3">0.5</span><span class="s1">, restSpeed, }) {</span>
    <span class="s0">const </span><span class="s1">origin = keyframes[</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s0">const </span><span class="s1">state = {</span>
        <span class="s1">done: </span><span class="s0">false</span><span class="s1">,</span>
        <span class="s1">value: origin,</span>
    <span class="s1">};</span>
    <span class="s0">const </span><span class="s1">isOutOfBounds = (v) =&gt; (min !== undefined &amp;&amp; v &lt; min) || (max !== undefined &amp;&amp; v &gt; max);</span>
    <span class="s0">const </span><span class="s1">nearestBoundary = (v) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(min === undefined)</span>
            <span class="s0">return </span><span class="s1">max;</span>
        <span class="s0">if </span><span class="s1">(max === undefined)</span>
            <span class="s0">return </span><span class="s1">min;</span>
        <span class="s0">return </span><span class="s1">Math.abs(min - v) &lt; Math.abs(max - v) ? min : max;</span>
    <span class="s1">};</span>
    <span class="s0">let </span><span class="s1">amplitude = power * velocity;</span>
    <span class="s0">const </span><span class="s1">ideal = origin + amplitude;</span>
    <span class="s0">const </span><span class="s1">target = modifyTarget === undefined ? ideal : modifyTarget(ideal);</span>
    <span class="s4">/**</span>
     <span class="s4">* If the target has changed we need to re-calculate the amplitude, otherwise</span>
     <span class="s4">* the animation will start from the wrong position.</span>
     <span class="s4">*/</span>
    <span class="s0">if </span><span class="s1">(target !== ideal)</span>
        <span class="s1">amplitude = target - origin;</span>
    <span class="s0">const </span><span class="s1">calcDelta = (t) =&gt; -amplitude * Math.exp(-t / timeConstant);</span>
    <span class="s0">const </span><span class="s1">calcLatest = (t) =&gt; target + calcDelta(t);</span>
    <span class="s0">const </span><span class="s1">applyFriction = (t) =&gt; {</span>
        <span class="s0">const </span><span class="s1">delta = calcDelta(t);</span>
        <span class="s0">const </span><span class="s1">latest = calcLatest(t);</span>
        <span class="s1">state.done = Math.abs(delta) &lt;= restDelta;</span>
        <span class="s1">state.value = state.done ? target : latest;</span>
    <span class="s1">};</span>
    <span class="s4">/**</span>
     <span class="s4">* Ideally this would resolve for t in a stateless way, we could</span>
     <span class="s4">* do that by always precalculating the animation but as we know</span>
     <span class="s4">* this will be done anyway we can assume that spring will</span>
     <span class="s4">* be discovered during that.</span>
     <span class="s4">*/</span>
    <span class="s0">let </span><span class="s1">timeReachedBoundary;</span>
    <span class="s0">let </span><span class="s1">spring$1;</span>
    <span class="s0">const </span><span class="s1">checkCatchBoundary = (t) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(!isOutOfBounds(state.value))</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s1">timeReachedBoundary = t;</span>
        <span class="s1">spring$1 = spring({</span>
            <span class="s1">keyframes: [state.value, nearestBoundary(state.value)],</span>
            <span class="s1">velocity: calcGeneratorVelocity(calcLatest, t, state.value), </span><span class="s4">// TODO: This should be passing * 1000</span>
            <span class="s1">damping: bounceDamping,</span>
            <span class="s1">stiffness: bounceStiffness,</span>
            <span class="s1">restDelta,</span>
            <span class="s1">restSpeed,</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
    <span class="s1">checkCatchBoundary(</span><span class="s3">0</span><span class="s1">);</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">calculatedDuration: </span><span class="s0">null</span><span class="s1">,</span>
        <span class="s1">next: (t) =&gt; {</span>
            <span class="s4">/**</span>
             <span class="s4">* We need to resolve the friction to figure out if we need a</span>
             <span class="s4">* spring but we don't want to do this twice per frame. So here</span>
             <span class="s4">* we flag if we updated for this frame and later if we did</span>
             <span class="s4">* we can skip doing it again.</span>
             <span class="s4">*/</span>
            <span class="s0">let </span><span class="s1">hasUpdatedFrame = </span><span class="s0">false</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(!spring$1 &amp;&amp; timeReachedBoundary === undefined) {</span>
                <span class="s1">hasUpdatedFrame = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s1">applyFriction(t);</span>
                <span class="s1">checkCatchBoundary(t);</span>
            <span class="s1">}</span>
            <span class="s4">/**</span>
             <span class="s4">* If we have a spring and the provided t is beyond the moment the friction</span>
             <span class="s4">* animation crossed the min/max boundary, use the spring.</span>
             <span class="s4">*/</span>
            <span class="s0">if </span><span class="s1">(timeReachedBoundary !== undefined &amp;&amp; t &gt;= timeReachedBoundary) {</span>
                <span class="s0">return </span><span class="s1">spring$1.next(t - timeReachedBoundary);</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">!hasUpdatedFrame &amp;&amp; applyFriction(t);</span>
                <span class="s0">return </span><span class="s1">state;</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ inertia };</span>
</pre>
</body>
</html>