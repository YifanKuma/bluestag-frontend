<html>
<head>
<title>no-explicit-any.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-explicit-any.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s1">exports.default = (</span><span class="s3">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'no-explicit-any'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Disallow the `any` type'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s0">'recommended'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
        <span class="s1">hasSuggestions: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">suggestNever: </span><span class="s0">&quot;Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.&quot;</span><span class="s1">,</span>
            <span class="s1">suggestPropertyKey: </span><span class="s0">'Use `PropertyKey` instead, this is more explicit than `keyof any`.'</span><span class="s1">,</span>
            <span class="s1">suggestUnknown: </span><span class="s0">'Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.'</span><span class="s1">,</span>
            <span class="s1">unexpectedAny: </span><span class="s0">'Unexpected any. Specify a different type.'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">fixToUnknown: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to enable auto-fixing in which the `any` type is converted to the `unknown` type.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">ignoreRestArgs: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to ignore rest parameter arrays.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">fixToUnknown: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">ignoreRestArgs: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [{ fixToUnknown, ignoreRestArgs }]) {</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the node is an arrow function, function/constructor declaration or function expression</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the node is any kind of function declaration or expression</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isNodeValidFunction(node) {</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">utils_1.AST_NODE_TYPES.ArrowFunctionExpression, </span><span class="s4">// const x = (...args: any[]) =&gt; {};</span>
                <span class="s1">utils_1.AST_NODE_TYPES.FunctionDeclaration, </span><span class="s4">// function f(...args: any[]) {}</span>
                <span class="s1">utils_1.AST_NODE_TYPES.FunctionExpression, </span><span class="s4">// const x = function(...args: any[]) {};</span>
                <span class="s1">utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration, </span><span class="s4">// type T = {(...args: any[]): unknown};</span>
                <span class="s1">utils_1.AST_NODE_TYPES.TSConstructorType, </span><span class="s4">// type T = new (...args: any[]) =&gt; unknown</span>
                <span class="s1">utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration, </span><span class="s4">// type T = {new (...args: any[]): unknown};</span>
                <span class="s1">utils_1.AST_NODE_TYPES.TSDeclareFunction, </span><span class="s4">// declare function _8(...args: any[]): unknown;</span>
                <span class="s1">utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression, </span><span class="s4">// declare class A { f(...args: any[]): unknown; }</span>
                <span class="s1">utils_1.AST_NODE_TYPES.TSFunctionType, </span><span class="s4">// type T = (...args: any[]) =&gt; unknown;</span>
                <span class="s1">utils_1.AST_NODE_TYPES.TSMethodSignature, </span><span class="s4">// type T = {f(...args: any[]): unknown};</span>
            <span class="s1">].includes(node.type);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the node is a rest element child node of a function</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the node is a rest element child node of a function</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isNodeRestElementInFunction(node) {</span>
            <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.RestElement &amp;&amp;</span>
                <span class="s1">isNodeValidFunction(node.parent));</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the node is a TSTypeOperator node with a readonly operator</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the node is a TSTypeOperator node with a readonly operator</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isNodeReadonlyTSTypeOperator(node) {</span>
            <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.TSTypeOperator &amp;&amp;</span>
                <span class="s1">node.operator === </span><span class="s0">'readonly'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the node is a TSTypeReference node with an Array identifier</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the node is a TSTypeReference node with an Array identifier</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isNodeValidArrayTSTypeReference(node) {</span>
            <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.TSTypeReference &amp;&amp;</span>
                <span class="s1">node.typeName.type === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                <span class="s1">[</span><span class="s0">'Array'</span><span class="s1">, </span><span class="s0">'ReadonlyArray'</span><span class="s1">].includes(node.typeName.name));</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the node is a valid TSTypeOperator or TSTypeReference node</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the node is a valid TSTypeOperator or TSTypeReference node</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isNodeValidTSType(node) {</span>
            <span class="s2">return </span><span class="s1">(isNodeReadonlyTSTypeOperator(node) ||</span>
                <span class="s1">isNodeValidArrayTSTypeReference(node));</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the great grand-parent node is a RestElement node in a function</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the great grand-parent node is a RestElement node in a function</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isGreatGrandparentRestElement(node) {</span>
            <span class="s2">return </span><span class="s1">(node.parent?.parent?.parent != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                <span class="s1">isNodeRestElementInFunction(node.parent.parent.parent));</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the great great grand-parent node is a valid RestElement node in a function</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the great great grand-parent node is a valid RestElement node in a function</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isGreatGreatGrandparentRestElement(node) {</span>
            <span class="s2">return </span><span class="s1">(node.parent?.parent?.parent?.parent != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                <span class="s1">isNodeValidTSType(node.parent.parent) &amp;&amp;</span>
                <span class="s1">isNodeRestElementInFunction(node.parent.parent.parent.parent));</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the great grand-parent or the great great grand-parent node is a RestElement node</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the great grand-parent or the great great grand-parent node is a RestElement node</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isNodeDescendantOfRestElementInFunction(node) {</span>
            <span class="s2">return </span><span class="s1">(isGreatGrandparentRestElement(node) ||</span>
                <span class="s1">isGreatGreatGrandparentRestElement(node));</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if the node is within a keyof any expression</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be validated.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">true if the node is within a keyof any expression, false otherwise</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">isNodeWithinKeyofAny(node) {</span>
            <span class="s2">return </span><span class="s1">(node.parent.type === utils_1.AST_NODE_TYPES.TSTypeOperator &amp;&amp;</span>
                <span class="s1">node.parent.operator === </span><span class="s0">'keyof'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Creates a fixer that replaces a keyof any with PropertyKey</span>
         <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the node to be fixed.</span>
         <span class="s4">* </span><span class="s5">@returns </span><span class="s4">a function that will fix the node.</span>
         <span class="s4">* </span><span class="s5">@private</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">createPropertyKeyFixer(node) {</span>
            <span class="s2">return </span><span class="s1">(fixer) =&gt; {</span>
                <span class="s2">return </span><span class="s1">fixer.replaceText(node.parent, </span><span class="s0">'PropertyKey'</span><span class="s1">);</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">TSAnyKeyword(node) {</span>
                <span class="s2">const </span><span class="s1">isKeyofAny = isNodeWithinKeyofAny(node);</span>
                <span class="s2">if </span><span class="s1">(ignoreRestArgs &amp;&amp; isNodeDescendantOfRestElementInFunction(node)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">fixOrSuggest = {</span>
                    <span class="s1">fix: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">suggest: isKeyofAny</span>
                        <span class="s1">? [</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'suggestPropertyKey'</span><span class="s1">,</span>
                                <span class="s1">fix: createPropertyKeyFixer(node),</span>
                            <span class="s1">},</span>
                        <span class="s1">]</span>
                        <span class="s1">: [</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'suggestUnknown'</span><span class="s1">,</span>
                                <span class="s1">fix: fixer =&gt; fixer.replaceText(node, </span><span class="s0">'unknown'</span><span class="s1">),</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'suggestNever'</span><span class="s1">,</span>
                                <span class="s1">fix: fixer =&gt; fixer.replaceText(node, </span><span class="s0">'never'</span><span class="s1">),</span>
                            <span class="s1">},</span>
                        <span class="s1">],</span>
                <span class="s1">};</span>
                <span class="s2">if </span><span class="s1">(fixToUnknown) {</span>
                    <span class="s1">fixOrSuggest.fix = isKeyofAny</span>
                        <span class="s1">? createPropertyKeyFixer(node)</span>
                        <span class="s1">: fixer =&gt; fixer.replaceText(node, </span><span class="s0">'unknown'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: </span><span class="s0">'unexpectedAny'</span><span class="s1">,</span>
                    <span class="s1">...fixOrSuggest,</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
    <span class="s1">},</span>
<span class="s1">});</span>
</pre>
</body>
</html>