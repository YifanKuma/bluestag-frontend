<html>
<head>
<title>next-ssg-transform.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-ssg-transform.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">EXPORT_NAME_GET_SERVER_PROPS: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">EXPORT_NAME_GET_STATIC_PATHS: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">EXPORT_NAME_GET_STATIC_PROPS: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">EXPORT_NAME_GET_SERVER_PROPS: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">EXPORT_NAME_GET_SERVER_PROPS;</span>
    <span class="s1">},</span>
    <span class="s1">EXPORT_NAME_GET_STATIC_PATHS: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">EXPORT_NAME_GET_STATIC_PATHS;</span>
    <span class="s1">},</span>
    <span class="s1">EXPORT_NAME_GET_STATIC_PROPS: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">EXPORT_NAME_GET_STATIC_PROPS;</span>
    <span class="s1">},</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">nextTransformSsg;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">EXPORT_NAME_GET_STATIC_PROPS = </span><span class="s0">'getStaticProps'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">EXPORT_NAME_GET_STATIC_PATHS = </span><span class="s0">'getStaticPaths'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">EXPORT_NAME_GET_SERVER_PROPS = </span><span class="s0">'getServerSideProps'</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">ssgExports = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s1">EXPORT_NAME_GET_STATIC_PROPS,</span>
    <span class="s1">EXPORT_NAME_GET_STATIC_PATHS,</span>
    <span class="s1">EXPORT_NAME_GET_SERVER_PROPS,</span>
    <span class="s4">// legacy methods added so build doesn't fail from importing</span>
    <span class="s4">// server-side only methods</span>
    <span class="s0">`unstable_getStaticProps`</span><span class="s1">,</span>
    <span class="s0">`unstable_getStaticPaths`</span><span class="s1">,</span>
    <span class="s0">`unstable_getServerProps`</span><span class="s1">,</span>
    <span class="s0">`unstable_getServerSideProps`</span>
<span class="s1">]);</span>
<span class="s2">function </span><span class="s1">decorateSsgExport(t, path, state) {</span>
    <span class="s2">const </span><span class="s1">gsspName = state.isPrerender ? _constants1.STATIC_PROPS_ID : _constants1.SERVER_PROPS_ID;</span>
    <span class="s2">const </span><span class="s1">gsspId = t.identifier(gsspName);</span>
    <span class="s2">const </span><span class="s1">addGsspExport = (exportPath)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(state.done) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">state.done = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">[pageCompPath] = exportPath.replaceWithMultiple([</span>
            <span class="s1">t.exportNamedDeclaration(t.variableDeclaration(</span><span class="s4">// We use 'var' instead of 'let' or 'const' for ES5 support. Since</span>
            <span class="s4">// this runs in `Program#exit`, no ES2015 transforms (preset env)</span>
            <span class="s4">// will be ran against this code.</span>
            <span class="s0">'var'</span><span class="s1">, [</span>
                <span class="s1">t.variableDeclarator(gsspId, t.booleanLiteral(</span><span class="s2">true</span><span class="s1">))</span>
            <span class="s1">]), [</span>
                <span class="s1">t.exportSpecifier(gsspId, gsspId)</span>
            <span class="s1">]),</span>
            <span class="s1">exportPath.node</span>
        <span class="s1">]);</span>
        <span class="s1">exportPath.scope.registerDeclaration(pageCompPath);</span>
    <span class="s1">};</span>
    <span class="s1">path.traverse({</span>
        <span class="s1">ExportDefaultDeclaration (exportDefaultPath) {</span>
            <span class="s1">addGsspExport(exportDefaultPath);</span>
        <span class="s1">},</span>
        <span class="s1">ExportNamedDeclaration (exportNamedPath) {</span>
            <span class="s1">addGsspExport(exportNamedPath);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">isDataIdentifier = (name, state)=&gt;{</span>
    <span class="s2">if </span><span class="s1">(ssgExports.has(name)) {</span>
        <span class="s2">if </span><span class="s1">(name === EXPORT_NAME_GET_SERVER_PROPS) {</span>
            <span class="s2">if </span><span class="s1">(state.isPrerender) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(_constants.SERVER_PROPS_SSG_CONFLICT), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">state.isServerProps = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(state.isServerProps) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(_constants.SERVER_PROPS_SSG_CONFLICT), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">state.isPrerender = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">nextTransformSsg({ types: t }) {</span>
    <span class="s2">function </span><span class="s1">getIdentifier(path) {</span>
        <span class="s2">const </span><span class="s1">parentPath = path.parentPath;</span>
        <span class="s2">if </span><span class="s1">(parentPath.type === </span><span class="s0">'VariableDeclarator'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">pp = parentPath;</span>
            <span class="s2">const </span><span class="s1">name = pp.get(</span><span class="s0">'id'</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">name.node.type === </span><span class="s0">'Identifier' </span><span class="s1">? name : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(parentPath.type === </span><span class="s0">'AssignmentExpression'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">pp = parentPath;</span>
            <span class="s2">const </span><span class="s1">name = pp.get(</span><span class="s0">'left'</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">name.node.type === </span><span class="s0">'Identifier' </span><span class="s1">? name : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(path.node.type === </span><span class="s0">'ArrowFunctionExpression'</span><span class="s1">) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">path.node.id &amp;&amp; path.node.id.type === </span><span class="s0">'Identifier' </span><span class="s1">? path.get(</span><span class="s0">'id'</span><span class="s1">) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">isIdentifierReferenced(ident) {</span>
        <span class="s2">const </span><span class="s1">b = ident.scope.getBinding(ident.node.name);</span>
        <span class="s2">if </span><span class="s1">(b == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: b.referenced) {</span>
            <span class="s4">// Functions can reference themselves, so we need to check if there's a</span>
            <span class="s4">// binding outside the function scope or not.</span>
            <span class="s2">if </span><span class="s1">(b.path.type === </span><span class="s0">'FunctionDeclaration'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">!b.constantViolations.concat(b.referencePaths)</span><span class="s4">// Check that every reference is contained within the function:</span>
                <span class="s1">.every((ref)=&gt;ref.findParent((p)=&gt;p === b.path));</span>
            <span class="s1">}</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">markFunction(path, state) {</span>
        <span class="s2">const </span><span class="s1">ident = getIdentifier(path);</span>
        <span class="s2">if </span><span class="s1">((ident == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: ident.node) &amp;&amp; isIdentifierReferenced(ident)) {</span>
            <span class="s1">state.refs.add(ident);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">markImport(path, state) {</span>
        <span class="s2">const </span><span class="s1">local = path.get(</span><span class="s0">'local'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(isIdentifierReferenced(local)) {</span>
            <span class="s1">state.refs.add(local);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">visitor: {</span>
            <span class="s1">Program: {</span>
                <span class="s1">enter (path, state) {</span>
                    <span class="s1">state.refs = </span><span class="s2">new </span><span class="s1">Set();</span>
                    <span class="s1">state.isPrerender = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s1">state.isServerProps = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s1">state.done = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s1">path.traverse({</span>
                        <span class="s1">VariableDeclarator (variablePath, variableState) {</span>
                            <span class="s2">if </span><span class="s1">(variablePath.node.id.type === </span><span class="s0">'Identifier'</span><span class="s1">) {</span>
                                <span class="s2">const </span><span class="s1">local = variablePath.get(</span><span class="s0">'id'</span><span class="s1">);</span>
                                <span class="s2">if </span><span class="s1">(isIdentifierReferenced(local)) {</span>
                                    <span class="s1">variableState.refs.add(local);</span>
                                <span class="s1">}</span>
                            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(variablePath.node.id.type === </span><span class="s0">'ObjectPattern'</span><span class="s1">) {</span>
                                <span class="s2">const </span><span class="s1">pattern = variablePath.get(</span><span class="s0">'id'</span><span class="s1">);</span>
                                <span class="s2">const </span><span class="s1">properties = pattern.get(</span><span class="s0">'properties'</span><span class="s1">);</span>
                                <span class="s1">properties.forEach((p)=&gt;{</span>
                                    <span class="s2">const </span><span class="s1">local = p.get(p.node.type === </span><span class="s0">'ObjectProperty' </span><span class="s1">? </span><span class="s0">'value' </span><span class="s1">: p.node.type === </span><span class="s0">'RestElement' </span><span class="s1">? </span><span class="s0">'argument' </span><span class="s1">: </span><span class="s2">function</span><span class="s1">() {</span>
                                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                            <span class="s1">value: </span><span class="s0">&quot;E400&quot;</span><span class="s1">,</span>
                                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                            <span class="s1">configurable: </span><span class="s2">true</span>
                                        <span class="s1">});</span>
                                    <span class="s1">}());</span>
                                    <span class="s2">if </span><span class="s1">(isIdentifierReferenced(local)) {</span>
                                        <span class="s1">variableState.refs.add(local);</span>
                                    <span class="s1">}</span>
                                <span class="s1">});</span>
                            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(variablePath.node.id.type === </span><span class="s0">'ArrayPattern'</span><span class="s1">) {</span>
                                <span class="s2">const </span><span class="s1">pattern = variablePath.get(</span><span class="s0">'id'</span><span class="s1">);</span>
                                <span class="s2">const </span><span class="s1">elements = pattern.get(</span><span class="s0">'elements'</span><span class="s1">);</span>
                                <span class="s1">elements.forEach((e)=&gt;{</span>
                                    <span class="s2">var </span><span class="s1">_e_node, _e_node1;</span>
                                    <span class="s2">let </span><span class="s1">local;</span>
                                    <span class="s2">if </span><span class="s1">(((_e_node = e.node) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _e_node.type) === </span><span class="s0">'Identifier'</span><span class="s1">) {</span>
                                        <span class="s1">local = e;</span>
                                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(((_e_node1 = e.node) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _e_node1.type) === </span><span class="s0">'RestElement'</span><span class="s1">) {</span>
                                        <span class="s1">local = e.get(</span><span class="s0">'argument'</span><span class="s1">);</span>
                                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                        <span class="s2">return</span><span class="s1">;</span>
                                    <span class="s1">}</span>
                                    <span class="s2">if </span><span class="s1">(isIdentifierReferenced(local)) {</span>
                                        <span class="s1">variableState.refs.add(local);</span>
                                    <span class="s1">}</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                        <span class="s1">},</span>
                        <span class="s1">FunctionDeclaration: markFunction,</span>
                        <span class="s1">FunctionExpression: markFunction,</span>
                        <span class="s1">ArrowFunctionExpression: markFunction,</span>
                        <span class="s1">ImportSpecifier: markImport,</span>
                        <span class="s1">ImportDefaultSpecifier: markImport,</span>
                        <span class="s1">ImportNamespaceSpecifier: markImport,</span>
                        <span class="s1">ExportNamedDeclaration (exportNamedPath, exportNamedState) {</span>
                            <span class="s2">const </span><span class="s1">specifiers = exportNamedPath.get(</span><span class="s0">'specifiers'</span><span class="s1">);</span>
                            <span class="s2">if </span><span class="s1">(specifiers.length) {</span>
                                <span class="s1">specifiers.forEach((s)=&gt;{</span>
                                    <span class="s2">if </span><span class="s1">(isDataIdentifier(t.isIdentifier(s.node.exported) ? s.node.exported.name : s.node.exported.value, exportNamedState)) {</span>
                                        <span class="s1">s.remove();</span>
                                    <span class="s1">}</span>
                                <span class="s1">});</span>
                                <span class="s2">if </span><span class="s1">(exportNamedPath.node.specifiers.length &lt; </span><span class="s3">1</span><span class="s1">) {</span>
                                    <span class="s1">exportNamedPath.remove();</span>
                                <span class="s1">}</span>
                                <span class="s2">return</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s2">const </span><span class="s1">decl = exportNamedPath.get(</span><span class="s0">'declaration'</span><span class="s1">);</span>
                            <span class="s2">if </span><span class="s1">(decl == </span><span class="s2">null </span><span class="s1">|| decl.node == </span><span class="s2">null</span><span class="s1">) {</span>
                                <span class="s2">return</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s2">switch</span><span class="s1">(decl.node.type){</span>
                                <span class="s2">case </span><span class="s0">'FunctionDeclaration'</span><span class="s1">:</span>
                                    <span class="s1">{</span>
                                        <span class="s2">const </span><span class="s1">name = decl.node.id.name;</span>
                                        <span class="s2">if </span><span class="s1">(isDataIdentifier(name, exportNamedState)) {</span>
                                            <span class="s1">exportNamedPath.remove();</span>
                                        <span class="s1">}</span>
                                        <span class="s2">break</span><span class="s1">;</span>
                                    <span class="s1">}</span>
                                <span class="s2">case </span><span class="s0">'VariableDeclaration'</span><span class="s1">:</span>
                                    <span class="s1">{</span>
                                        <span class="s2">const </span><span class="s1">inner = decl.get(</span><span class="s0">'declarations'</span><span class="s1">);</span>
                                        <span class="s1">inner.forEach((d)=&gt;{</span>
                                            <span class="s2">if </span><span class="s1">(d.node.id.type !== </span><span class="s0">'Identifier'</span><span class="s1">) {</span>
                                                <span class="s2">return</span><span class="s1">;</span>
                                            <span class="s1">}</span>
                                            <span class="s2">const </span><span class="s1">name = d.node.id.name;</span>
                                            <span class="s2">if </span><span class="s1">(isDataIdentifier(name, exportNamedState)) {</span>
                                                <span class="s1">d.remove();</span>
                                            <span class="s1">}</span>
                                        <span class="s1">});</span>
                                        <span class="s2">break</span><span class="s1">;</span>
                                    <span class="s1">}</span>
                                <span class="s2">default</span><span class="s1">:</span>
                                    <span class="s1">{</span>
                                        <span class="s2">break</span><span class="s1">;</span>
                                    <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}, state);</span>
                    <span class="s2">if </span><span class="s1">(!state.isPrerender &amp;&amp; !state.isServerProps) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">refs = state.refs;</span>
                    <span class="s2">let </span><span class="s1">count;</span>
                    <span class="s2">function </span><span class="s1">sweepFunction(sweepPath) {</span>
                        <span class="s2">const </span><span class="s1">ident = getIdentifier(sweepPath);</span>
                        <span class="s2">if </span><span class="s1">((ident == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: ident.node) &amp;&amp; refs.has(ident) &amp;&amp; !isIdentifierReferenced(ident)) {</span>
                            <span class="s1">++count;</span>
                            <span class="s2">if </span><span class="s1">(t.isAssignmentExpression(sweepPath.parentPath.node) || t.isVariableDeclarator(sweepPath.parentPath.node)) {</span>
                                <span class="s1">sweepPath.parentPath.remove();</span>
                            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                <span class="s1">sweepPath.remove();</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">function </span><span class="s1">sweepImport(sweepPath) {</span>
                        <span class="s2">const </span><span class="s1">local = sweepPath.get(</span><span class="s0">'local'</span><span class="s1">);</span>
                        <span class="s2">if </span><span class="s1">(refs.has(local) &amp;&amp; !isIdentifierReferenced(local)) {</span>
                            <span class="s1">++count;</span>
                            <span class="s1">sweepPath.remove();</span>
                            <span class="s2">if </span><span class="s1">(sweepPath.parent.specifiers.length === </span><span class="s3">0</span><span class="s1">) {</span>
                                <span class="s1">sweepPath.parentPath.remove();</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">do </span><span class="s1">{</span>
                        <span class="s1">;</span>
                        <span class="s1">path.scope.crawl();</span>
                        <span class="s1">count = </span><span class="s3">0</span><span class="s1">;</span>
                        <span class="s1">path.traverse({</span>
                            <span class="s4">// eslint-disable-next-line no-loop-func</span>
                            <span class="s1">VariableDeclarator (variablePath) {</span>
                                <span class="s2">if </span><span class="s1">(variablePath.node.id.type === </span><span class="s0">'Identifier'</span><span class="s1">) {</span>
                                    <span class="s2">const </span><span class="s1">local = variablePath.get(</span><span class="s0">'id'</span><span class="s1">);</span>
                                    <span class="s2">if </span><span class="s1">(refs.has(local) &amp;&amp; !isIdentifierReferenced(local)) {</span>
                                        <span class="s1">++count;</span>
                                        <span class="s1">variablePath.remove();</span>
                                    <span class="s1">}</span>
                                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(variablePath.node.id.type === </span><span class="s0">'ObjectPattern'</span><span class="s1">) {</span>
                                    <span class="s2">const </span><span class="s1">pattern = variablePath.get(</span><span class="s0">'id'</span><span class="s1">);</span>
                                    <span class="s2">const </span><span class="s1">beforeCount = count;</span>
                                    <span class="s2">const </span><span class="s1">properties = pattern.get(</span><span class="s0">'properties'</span><span class="s1">);</span>
                                    <span class="s1">properties.forEach((p)=&gt;{</span>
                                        <span class="s2">const </span><span class="s1">local = p.get(p.node.type === </span><span class="s0">'ObjectProperty' </span><span class="s1">? </span><span class="s0">'value' </span><span class="s1">: p.node.type === </span><span class="s0">'RestElement' </span><span class="s1">? </span><span class="s0">'argument' </span><span class="s1">: </span><span class="s2">function</span><span class="s1">() {</span>
                                            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                                                <span class="s1">value: </span><span class="s0">&quot;E400&quot;</span><span class="s1">,</span>
                                                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                                                <span class="s1">configurable: </span><span class="s2">true</span>
                                            <span class="s1">});</span>
                                        <span class="s1">}());</span>
                                        <span class="s2">if </span><span class="s1">(refs.has(local) &amp;&amp; !isIdentifierReferenced(local)) {</span>
                                            <span class="s1">++count;</span>
                                            <span class="s1">p.remove();</span>
                                        <span class="s1">}</span>
                                    <span class="s1">});</span>
                                    <span class="s2">if </span><span class="s1">(beforeCount !== count &amp;&amp; pattern.get(</span><span class="s0">'properties'</span><span class="s1">).length &lt; </span><span class="s3">1</span><span class="s1">) {</span>
                                        <span class="s1">variablePath.remove();</span>
                                    <span class="s1">}</span>
                                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(variablePath.node.id.type === </span><span class="s0">'ArrayPattern'</span><span class="s1">) {</span>
                                    <span class="s2">const </span><span class="s1">pattern = variablePath.get(</span><span class="s0">'id'</span><span class="s1">);</span>
                                    <span class="s2">const </span><span class="s1">beforeCount = count;</span>
                                    <span class="s2">const </span><span class="s1">elements = pattern.get(</span><span class="s0">'elements'</span><span class="s1">);</span>
                                    <span class="s1">elements.forEach((e)=&gt;{</span>
                                        <span class="s2">var </span><span class="s1">_e_node, _e_node1;</span>
                                        <span class="s2">let </span><span class="s1">local;</span>
                                        <span class="s2">if </span><span class="s1">(((_e_node = e.node) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _e_node.type) === </span><span class="s0">'Identifier'</span><span class="s1">) {</span>
                                            <span class="s1">local = e;</span>
                                        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(((_e_node1 = e.node) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _e_node1.type) === </span><span class="s0">'RestElement'</span><span class="s1">) {</span>
                                            <span class="s1">local = e.get(</span><span class="s0">'argument'</span><span class="s1">);</span>
                                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                                            <span class="s2">return</span><span class="s1">;</span>
                                        <span class="s1">}</span>
                                        <span class="s2">if </span><span class="s1">(refs.has(local) &amp;&amp; !isIdentifierReferenced(local)) {</span>
                                            <span class="s1">++count;</span>
                                            <span class="s1">e.remove();</span>
                                        <span class="s1">}</span>
                                    <span class="s1">});</span>
                                    <span class="s2">if </span><span class="s1">(beforeCount !== count &amp;&amp; pattern.get(</span><span class="s0">'elements'</span><span class="s1">).length &lt; </span><span class="s3">1</span><span class="s1">) {</span>
                                        <span class="s1">variablePath.remove();</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">},</span>
                            <span class="s1">FunctionDeclaration: sweepFunction,</span>
                            <span class="s1">FunctionExpression: sweepFunction,</span>
                            <span class="s1">ArrowFunctionExpression: sweepFunction,</span>
                            <span class="s1">ImportSpecifier: sweepImport,</span>
                            <span class="s1">ImportDefaultSpecifier: sweepImport,</span>
                            <span class="s1">ImportNamespaceSpecifier: sweepImport</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span><span class="s2">while </span><span class="s1">(count);</span>
                    <span class="s1">decorateSsgExport(t, path, state);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=next-ssg-transform.js.map</span></pre>
</body>
</html>