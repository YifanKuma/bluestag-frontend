<html>
<head>
<title>locale-route-matcher.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
locale-route-matcher.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/route-matchers/locale-route-matcher.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { LocaleAnalysisResult } from '../lib/i18n-provider'</span><span class="s3">\n</span><span class="s1">import type { LocaleRouteDefinition } from '../route-definitions/locale-route-definition'</span><span class="s3">\n</span><span class="s1">import type { LocaleRouteMatch } from '../route-matches/locale-route-match'</span><span class="s3">\n</span><span class="s1">import { RouteMatcher } from './route-matcher'</span><span class="s3">\n\n</span><span class="s1">export type LocaleMatcherMatchOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If defined, this indicates to the matcher that the request should be</span><span class="s3">\n   </span><span class="s1">* treated as locale-aware. If this is undefined, it means that this</span><span class="s3">\n   </span><span class="s1">* application was not configured for additional locales.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">i18n?: LocaleAnalysisResult</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class LocaleRouteMatcher&lt;</span><span class="s3">\n  </span><span class="s1">D extends LocaleRouteDefinition = LocaleRouteDefinition,</span><span class="s3">\n</span><span class="s1">&gt; extends RouteMatcher&lt;D&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Identity returns the identity part of the matcher. This is used to compare</span><span class="s3">\n   </span><span class="s1">* a unique matcher to another. This is also used when sorting dynamic routes,</span><span class="s3">\n   </span><span class="s1">* so it must contain the pathname part as well.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get identity(): string {</span><span class="s3">\n    </span><span class="s1">return `${this.definition.pathname}?__nextLocale=${this.definition.i18n?.locale}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Match will attempt to match the given pathname against this route while</span><span class="s3">\n   </span><span class="s1">* also taking into account the locale information.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname The pathname to match against.</span><span class="s3">\n   </span><span class="s1">* @param options The options to use when matching.</span><span class="s3">\n   </span><span class="s1">* @returns The match result, or `null` if there was no match.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public match(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options?: LocaleMatcherMatchOptions</span><span class="s3">\n  </span><span class="s1">): LocaleRouteMatch&lt;D&gt; | null {</span><span class="s3">\n    </span><span class="s1">// This is like the parent `match` method but instead this injects the</span><span class="s3">\n    </span><span class="s1">// additional `options` into the</span><span class="s3">\n    </span><span class="s1">const result = this.test(pathname, options)</span><span class="s3">\n    </span><span class="s1">if (!result) return null</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">definition: this.definition,</span><span class="s3">\n      </span><span class="s1">params: result.params,</span><span class="s3">\n      </span><span class="s1">detectedLocale:</span><span class="s3">\n        </span><span class="s1">// If the options have a detected locale, then use that, otherwise use</span><span class="s3">\n        </span><span class="s1">// the route's locale.</span><span class="s3">\n        </span><span class="s1">options?.i18n?.detectedLocale ?? this.definition.i18n?.locale,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Test will attempt to match the given pathname against this route while</span><span class="s3">\n   </span><span class="s1">* also taking into account the locale information.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname The pathname to match against.</span><span class="s3">\n   </span><span class="s1">* @param options The options to use when matching.</span><span class="s3">\n   </span><span class="s1">* @returns The match result, or `null` if there was no match.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public test(pathname: string, options?: LocaleMatcherMatchOptions) {</span><span class="s3">\n    </span><span class="s1">// If this route has locale information and we have detected a locale, then</span><span class="s3">\n    </span><span class="s1">// we need to compare the detected locale to the route's locale.</span><span class="s3">\n    </span><span class="s1">if (this.definition.i18n &amp;&amp; options?.i18n) {</span><span class="s3">\n      </span><span class="s1">// If we have detected a locale and it does not match this route's locale,</span><span class="s3">\n      </span><span class="s1">// then this isn't a match!</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.definition.i18n.locale &amp;&amp;</span><span class="s3">\n        </span><span class="s1">options.i18n.detectedLocale &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.definition.i18n.locale !== options.i18n.detectedLocale</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Perform regular matching against the locale stripped pathname now, the</span><span class="s3">\n      </span><span class="s1">// locale information matches!</span><span class="s3">\n      </span><span class="s1">return super.test(options.i18n.pathname)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we don't have locale information, then we can just perform regular</span><span class="s3">\n    </span><span class="s1">// matching.</span><span class="s3">\n    </span><span class="s1">return super.test(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;LocaleRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;identity&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;locale&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAcaA;;;eAAAA;;;8BAXgB;AAWtB,MAAMA,2BAEHC,0BAAY;IACpB;;;;GAIC,GACD,IAAWC,WAAmB;YACuB;QAAnD,OAAO,GAAG,IAAI,CAACC,UAAU,CAACC,QAAQ,CAAC,cAAc,GAAE,wBAAA,IAAI,CAACD,UAAU,CAACE,IAAI,qBAApB,sBAAsBC,MAAM,EAAE;IACnF;IAEA;;;;;;;GAOC,GACD,AAAOC,MACLH,QAAgB,EAChBI,OAAmC,EACP;YAUxB,sEAAsE;QACtE,sBAAsB;QACtBA,eAAiC;QAXrC,sEAAsE;QACtE,gCAAgC;QAChC,MAAMC,SAAS,IAAI,CAACC,IAAI,CAACN,UAAUI;QACnC,IAAI,CAACC,QAAQ,OAAO;QAEpB,OAAO;YACLN,YAAY,IAAI,CAACA,UAAU;YAC3BQ,QAAQF,OAAOE,MAAM;YACrBC,gBAGEJ,CAAAA,4BAAAA,gBAAAA,QAASH,IAAI,qBAAbG,cAAeI,cAAc,OAAI,wBAAA,IAAI,CAACT,UAAU,CAACE,IAAI,qBAApB,sBAAsBC,MAAM;QACjE;IACF;IAEA;;;;;;;GAOC,GACD,AAAOI,KAAKN,QAAgB,EAAEI,OAAmC,EAAE;QACjE,2EAA2E;QAC3E,gEAAgE;QAChE,IAAI,IAAI,CAACL,UAAU,CAACE,IAAI,KAAIG,2BAAAA,QAASH,IAAI,GAAE;YACzC,0EAA0E;YAC1E,2BAA2B;YAC3B,IACE,IAAI,CAACF,UAAU,CAACE,IAAI,CAACC,MAAM,IAC3BE,QAAQH,IAAI,CAACO,cAAc,IAC3B,IAAI,CAACT,UAAU,CAACE,IAAI,CAACC,MAAM,KAAKE,QAAQH,IAAI,CAACO,cAAc,EAC3D;gBACA,OAAO;YACT;YAEA,yEAAyE;YACzE,8BAA8B;YAC9B,OAAO,KAAK,CAACF,KAAKF,QAAQH,IAAI,CAACD,QAAQ;QACzC;QAEA,wEAAwE;QACxE,YAAY;QACZ,OAAO,KAAK,CAACM,KAAKN;IACpB;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>