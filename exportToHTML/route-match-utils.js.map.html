<html>
<head>
<title>route-match-utils.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
route-match-utils.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../../src/shared/lib/router/utils/route-match-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Client-safe utilities for route matching that don't import server-side</span><span class="s3">\n </span><span class="s1">* utilities to avoid bundling issues with Turbopack</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Key,</span><span class="s3">\n  </span><span class="s1">TokensToRegexpOptions,</span><span class="s3">\n  </span><span class="s1">ParseOptions,</span><span class="s3">\n  </span><span class="s1">TokensToFunctionOptions,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">pathToRegexp,</span><span class="s3">\n  </span><span class="s1">compile,</span><span class="s3">\n  </span><span class="s1">regexpToFunction,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">hasAdjacentParameterIssues,</span><span class="s3">\n  </span><span class="s1">normalizeAdjacentParameters,</span><span class="s3">\n  </span><span class="s1">stripParameterSeparators,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/route-pattern-normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around pathToRegexp that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* This includes both </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">Must have text between parameters</span><span class="s3">\&quot; </span><span class="s1">errors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safePathToRegexp(</span><span class="s3">\n  </span><span class="s1">route: string | RegExp | Array&lt;string | RegExp&gt;,</span><span class="s3">\n  </span><span class="s1">keys?: Key[],</span><span class="s3">\n  </span><span class="s1">options?: TokensToRegexpOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">): RegExp {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(route, keys, options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(routeToUse, keys, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return pathToRegexp(normalizedRoute, keys, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around compile that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* No server-side error reporting to avoid bundling issues.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeCompile(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">options?: TokensToFunctionOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return compile(routeToUse, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return compile(normalizedRoute, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around regexpToFunction that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRegexpToFunction&lt;</span><span class="s3">\n  </span><span class="s1">T extends Record&lt;string, any&gt; = Record&lt;string, any&gt;,</span><span class="s3">\n</span><span class="s1">&gt;(regexp: RegExp, keys?: Key[]): (pathname: string) =&gt; { params: T } | false {</span><span class="s3">\n  </span><span class="s1">const originalMatcher = regexpToFunction&lt;T&gt;(regexp, keys || [])</span><span class="s3">\n\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = originalMatcher(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">...result,</span><span class="s3">\n      </span><span class="s1">params: stripParameterSeparators(result.params as any) as T,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Safe wrapper for route matcher functions that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">* This is client-safe and doesn't import path-to-regexp.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRouteMatcher&lt;T extends Record&lt;string, any&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">matcherFn: (pathname: string) =&gt; false | T</span><span class="s3">\n</span><span class="s1">): (pathname: string) =&gt; false | T {</span><span class="s3">\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = matcherFn(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return stripParameterSeparators(result) as T</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;safeCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;safePathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;safeRegexpToFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;safeRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;needsNormalization&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAdjacentParameterIssues&quot;</span><span class="s0">,</span><span class="s1">&quot;routeToUse&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAdjacentParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;retryError&quot;</span><span class="s0">,</span><span class="s1">&quot;compile&quot;</span><span class="s0">,</span><span class="s1">&quot;regexp&quot;</span><span class="s0">,</span><span class="s1">&quot;originalMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpToFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;stripParameterSeparators&quot;</span><span class="s0">,</span><span class="s1">&quot;matcherFn&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;CAGC;;;;;;;;;;;;;;;;;IA2DeA,WAAW;eAAXA;;IApCAC,gBAAgB;eAAhBA;;IAkEAC,oBAAoB;eAApBA;;IAqBAC,gBAAgB;eAAhBA;;;8BAlGT;wCAKA;AAMA,SAASF,iBACdG,KAA+C,EAC/CC,IAAY,EACZC,OAA8C;IAE9C,IAAI,OAAOF,UAAU,UAAU;QAC7B,OAAOG,IAAAA,0BAAY,EAACH,OAAOC,MAAMC;IACnC;IAEA,wDAAwD;IACxD,MAAME,qBAAqBC,IAAAA,kDAA0B,EAACL;IACtD,MAAMM,aAAaF,qBACfG,IAAAA,mDAA2B,EAACP,SAC5BA;IAEJ,IAAI;QACF,OAAOG,IAAAA,0BAAY,EAACG,YAAYL,MAAMC;IACxC,EAAE,OAAOM,OAAO;QACd,0DAA0D;QAC1D,IAAI,CAACJ,oBAAoB;YACvB,IAAI;gBACF,MAAMK,kBAAkBF,IAAAA,mDAA2B,EAACP;gBACpD,OAAOG,IAAAA,0BAAY,EAACM,iBAAiBR,MAAMC;YAC7C,EAAE,OAAOQ,YAAY;gBACnB,oDAAoD;gBACpD,MAAMF;YACR;QACF;QACA,MAAMA;IACR;AACF;AAMO,SAASZ,YACdI,KAAa,EACbE,OAAgD;IAEhD,wDAAwD;IACxD,MAAME,qBAAqBC,IAAAA,kDAA0B,EAACL;IACtD,MAAMM,aAAaF,qBACfG,IAAAA,mDAA2B,EAACP,SAC5BA;IAEJ,IAAI;QACF,OAAOW,IAAAA,qBAAO,EAACL,YAAYJ;IAC7B,EAAE,OAAOM,OAAO;QACd,0DAA0D;QAC1D,IAAI,CAACJ,oBAAoB;YACvB,IAAI;gBACF,MAAMK,kBAAkBF,IAAAA,mDAA2B,EAACP;gBACpD,OAAOW,IAAAA,qBAAO,EAACF,iBAAiBP;YAClC,EAAE,OAAOQ,YAAY;gBACnB,oDAAoD;gBACpD,MAAMF;YACR;QACF;QACA,MAAMA;IACR;AACF;AAKO,SAASV,qBAEdc,MAAc,EAAEX,IAAY;IAC5B,MAAMY,kBAAkBC,IAAAA,8BAAgB,EAAIF,QAAQX,QAAQ,EAAE;IAE9D,OAAO,CAACc;QACN,MAAMC,SAASH,gBAAgBE;QAC/B,IAAI,CAACC,QAAQ,OAAO;QAEpB,oCAAoC;QACpC,OAAO;YACL,GAAGA,MAAM;YACTC,QAAQC,IAAAA,gDAAwB,EAACF,OAAOC,MAAM;QAChD;IACF;AACF;AAMO,SAASlB,iBACdoB,SAA0C;IAE1C,OAAO,CAACJ;QACN,MAAMC,SAASG,UAAUJ;QACzB,IAAI,CAACC,QAAQ,OAAO;QAEpB,oCAAoC;QACpC,OAAOE,IAAAA,gDAAwB,EAACF;IAClC;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>