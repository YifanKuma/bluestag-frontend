<html>
<head>
<title>dynamic-rendering.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dynamic-rendering.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The functions provided by this module are used to communicate certain properties</span>
 <span class="s0">* about the currently running code so that Next.js can make decisions on how to handle</span>
 <span class="s0">* the current execution in different rendering modes such as pre-rendering, resuming, and SSR.</span>
 <span class="s0">*</span>
 <span class="s0">* Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.</span>
 <span class="s0">* Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts</span>
 <span class="s0">* of a React tree as dynamic while still keeping other parts static. There are really two different kinds of</span>
 <span class="s0">* Dynamic indications.</span>
 <span class="s0">*</span>
 <span class="s0">* The first is simply an intention to be dynamic. unstable_noStore is an example of this where</span>
 <span class="s0">* the currently executing code simply declares that the current scope is dynamic but if you use it</span>
 <span class="s0">* inside unstable_cache it can still be cached. This type of indication can be removed if we ever</span>
 <span class="s0">* make the default dynamic to begin with because the only way you would ever be static is inside</span>
 <span class="s0">* a cache scope which this indication does not affect.</span>
 <span class="s0">*</span>
 <span class="s0">* The second is an indication that a dynamic data source was read. This is a stronger form of dynamic</span>
 <span class="s0">* because it means that it is inappropriate to cache this at all. using a dynamic data source inside</span>
 <span class="s0">* unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should</span>
 <span class="s0">* read that data outside the cache and pass it in as an argument to the cached function.</span>
 <span class="s0">*/ </span><span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s4">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">Postpone: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">PreludeState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">abortAndThrowOnSynchronousRequestDataAccess: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">abortOnSynchronousPlatformIOAccess: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">accessedDynamicData: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">annotateDynamicAccess: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">consumeDynamicAccess: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">createDynamicTrackingState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">createDynamicValidationState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">createHangingInputAbortSignal: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">createRenderInBrowserAbortSignal: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">delayUntilRuntimeStage: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">formatDynamicAPIAccesses: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">getFirstDynamicReason: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">isDynamicPostpone: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">isPrerenderInterruptedError: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">logDisallowedDynamicError: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">markCurrentScopeAsDynamic: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">postponeWithTracking: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">throwIfDisallowedDynamic: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">throwToInterruptStaticGeneration: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">trackAllowedDynamicAccess: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">trackDynamicDataInDynamicRender: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">trackSynchronousPlatformIOAccessInDev: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">trackSynchronousRequestDataAccessInDev: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">useDynamicRouteParams: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">warnOnSyncDynamicError: </span><span class="s3">null</span>
<span class="s1">});</span>
<span class="s3">function </span><span class="s1">_export(target, all) {</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">name </span><span class="s3">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">Postpone: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">Postpone;</span>
    <span class="s1">},</span>
    <span class="s1">PreludeState: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">PreludeState;</span>
    <span class="s1">},</span>
    <span class="s1">abortAndThrowOnSynchronousRequestDataAccess: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">abortAndThrowOnSynchronousRequestDataAccess;</span>
    <span class="s1">},</span>
    <span class="s1">abortOnSynchronousPlatformIOAccess: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">abortOnSynchronousPlatformIOAccess;</span>
    <span class="s1">},</span>
    <span class="s1">accessedDynamicData: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">accessedDynamicData;</span>
    <span class="s1">},</span>
    <span class="s1">annotateDynamicAccess: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">annotateDynamicAccess;</span>
    <span class="s1">},</span>
    <span class="s1">consumeDynamicAccess: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">consumeDynamicAccess;</span>
    <span class="s1">},</span>
    <span class="s1">createDynamicTrackingState: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">createDynamicTrackingState;</span>
    <span class="s1">},</span>
    <span class="s1">createDynamicValidationState: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">createDynamicValidationState;</span>
    <span class="s1">},</span>
    <span class="s1">createHangingInputAbortSignal: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">createHangingInputAbortSignal;</span>
    <span class="s1">},</span>
    <span class="s1">createRenderInBrowserAbortSignal: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">createRenderInBrowserAbortSignal;</span>
    <span class="s1">},</span>
    <span class="s1">delayUntilRuntimeStage: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">delayUntilRuntimeStage;</span>
    <span class="s1">},</span>
    <span class="s1">formatDynamicAPIAccesses: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">formatDynamicAPIAccesses;</span>
    <span class="s1">},</span>
    <span class="s1">getFirstDynamicReason: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">getFirstDynamicReason;</span>
    <span class="s1">},</span>
    <span class="s1">isDynamicPostpone: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">isDynamicPostpone;</span>
    <span class="s1">},</span>
    <span class="s1">isPrerenderInterruptedError: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">isPrerenderInterruptedError;</span>
    <span class="s1">},</span>
    <span class="s1">logDisallowedDynamicError: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">logDisallowedDynamicError;</span>
    <span class="s1">},</span>
    <span class="s1">markCurrentScopeAsDynamic: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">markCurrentScopeAsDynamic;</span>
    <span class="s1">},</span>
    <span class="s1">postponeWithTracking: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">postponeWithTracking;</span>
    <span class="s1">},</span>
    <span class="s1">throwIfDisallowedDynamic: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">throwIfDisallowedDynamic;</span>
    <span class="s1">},</span>
    <span class="s1">throwToInterruptStaticGeneration: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">throwToInterruptStaticGeneration;</span>
    <span class="s1">},</span>
    <span class="s1">trackAllowedDynamicAccess: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">trackAllowedDynamicAccess;</span>
    <span class="s1">},</span>
    <span class="s1">trackDynamicDataInDynamicRender: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">trackDynamicDataInDynamicRender;</span>
    <span class="s1">},</span>
    <span class="s1">trackSynchronousPlatformIOAccessInDev: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">trackSynchronousPlatformIOAccessInDev;</span>
    <span class="s1">},</span>
    <span class="s1">trackSynchronousRequestDataAccessInDev: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">trackSynchronousRequestDataAccessInDev;</span>
    <span class="s1">},</span>
    <span class="s1">useDynamicRouteParams: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">useDynamicRouteParams;</span>
    <span class="s1">},</span>
    <span class="s1">warnOnSyncDynamicError: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">warnOnSyncDynamicError;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_react = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;react&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_hooksservercontext = require(</span><span class="s2">&quot;../../client/components/hooks-server-context&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_staticgenerationbailout = require(</span><span class="s2">&quot;../../client/components/static-generation-bailout&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s2">&quot;./work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_workasyncstorageexternal = require(</span><span class="s2">&quot;../app-render/work-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_dynamicrenderingutils = require(</span><span class="s2">&quot;../dynamic-rendering-utils&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_boundaryconstants = require(</span><span class="s2">&quot;../../lib/framework/boundary-constants&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_scheduler = require(</span><span class="s2">&quot;../../lib/scheduler&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_bailouttocsr = require(</span><span class="s2">&quot;../../shared/lib/lazy-dynamic/bailout-to-csr&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_invarianterror = require(</span><span class="s2">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s3">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s3">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">hasPostpone = </span><span class="s3">typeof </span><span class="s1">_react.default.unstable_postpone === </span><span class="s2">'function'</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">createDynamicTrackingState(isDebugDynamicAccesses) {</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">isDebugDynamicAccesses,</span>
        <span class="s1">dynamicAccesses: [],</span>
        <span class="s1">syncDynamicErrorWithStack: </span><span class="s3">null</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createDynamicValidationState() {</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">hasSuspenseAboveBody: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">hasDynamicMetadata: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">hasDynamicViewport: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">hasAllowedDynamic: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">dynamicErrors: []</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getFirstDynamicReason(trackingState) {</span>
    <span class="s3">var </span><span class="s1">_trackingState_dynamicAccesses_;</span>
    <span class="s3">return </span><span class="s1">(_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[</span><span class="s4">0</span><span class="s1">]) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _trackingState_dynamicAccesses_.expression;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markCurrentScopeAsDynamic(store, workUnitStore, expression) {</span>
    <span class="s3">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s3">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s3">case </span><span class="s2">'cache'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'unstable-cache'</span><span class="s1">:</span>
                <span class="s0">// Inside cache scopes, marking a scope as dynamic has no effect,</span>
                <span class="s0">// because the outer cache scope creates a cache boundary. This is</span>
                <span class="s0">// subtly different from reading a dynamic data source, which is</span>
                <span class="s0">// forbidden inside a cache scope.</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s3">case </span><span class="s2">'private-cache'</span><span class="s1">:</span>
                <span class="s0">// A private cache scope is already dynamic by definition.</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s3">case </span><span class="s2">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'request'</span><span class="s1">:</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// If we're forcing dynamic rendering or we're forcing static rendering, we</span>
    <span class="s0">// don't need to do anything here because the entire page is already dynamic</span>
    <span class="s0">// or it's static and it should not throw or postpone here.</span>
    <span class="s3">if </span><span class="s1">(store.forceDynamic || store.forceStatic) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(store.dynamicShouldError) {</span>
        <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError(</span><span class="s2">`Route </span><span class="s1">${store.route} </span><span class="s2">with </span><span class="s5">\`</span><span class="s2">dynamic = &quot;error&quot;</span><span class="s5">\` </span><span class="s2">couldn't be rendered statically because it used </span><span class="s5">\`</span><span class="s1">${expression}</span><span class="s5">\`</span><span class="s2">. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s2">&quot;E553&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s3">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s3">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s3">case </span><span class="s2">'prerender-ppr'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);</span>
            <span class="s3">case </span><span class="s2">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s1">workUnitStore.revalidate = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s0">// We aren't prerendering, but we are generating a static page. We need</span>
                <span class="s0">// to bail out of static generation.</span>
                <span class="s3">const </span><span class="s1">err = Object.defineProperty(</span><span class="s3">new </span><span class="s1">_hooksservercontext.DynamicServerError(</span><span class="s2">`Route </span><span class="s1">${store.route} </span><span class="s2">couldn't be rendered statically because it used </span><span class="s1">${expression}</span><span class="s2">. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s2">&quot;E550&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s3">true</span>
                <span class="s1">});</span>
                <span class="s1">store.dynamicUsageDescription = expression;</span>
                <span class="s1">store.dynamicUsageStack = err.stack;</span>
                <span class="s3">throw </span><span class="s1">err;</span>
            <span class="s3">case </span><span class="s2">'request'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) {</span>
                    <span class="s1">workUnitStore.usedDynamic = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">throwToInterruptStaticGeneration(expression, store, prerenderStore) {</span>
    <span class="s0">// We aren't prerendering but we are generating a static page. We need to bail out of static generation</span>
    <span class="s3">const </span><span class="s1">err = Object.defineProperty(</span><span class="s3">new </span><span class="s1">_hooksservercontext.DynamicServerError(</span><span class="s2">`Route </span><span class="s1">${store.route} </span><span class="s2">couldn't be rendered statically because it used </span><span class="s5">\`</span><span class="s1">${expression}</span><span class="s5">\`</span><span class="s2">. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s2">&quot;E558&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">});</span>
    <span class="s1">prerenderStore.revalidate = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">store.dynamicUsageDescription = expression;</span>
    <span class="s1">store.dynamicUsageStack = err.stack;</span>
    <span class="s3">throw </span><span class="s1">err;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">trackDynamicDataInDynamicRender(workUnitStore) {</span>
    <span class="s3">switch</span><span class="s1">(workUnitStore.type){</span>
        <span class="s3">case </span><span class="s2">'cache'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'unstable-cache'</span><span class="s1">:</span>
            <span class="s0">// Inside cache scopes, marking a scope as dynamic has no effect,</span>
            <span class="s0">// because the outer cache scope creates a cache boundary. This is</span>
            <span class="s0">// subtly different from reading a dynamic data source, which is</span>
            <span class="s0">// forbidden inside a cache scope.</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">'private-cache'</span><span class="s1">:</span>
            <span class="s0">// A private cache scope is already dynamic by definition.</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">'prerender'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'prerender-runtime'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'prerender-legacy'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'prerender-ppr'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'prerender-client'</span><span class="s1">:</span>
            <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">'request'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) {</span>
                <span class="s1">workUnitStore.usedDynamic = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s1">workUnitStore;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {</span>
    <span class="s3">const </span><span class="s1">reason = </span><span class="s2">`Route </span><span class="s1">${route} </span><span class="s2">needs to bail out of prerendering at this point because it used </span><span class="s1">${expression}</span><span class="s2">.`</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">error = createPrerenderInterruptedError(reason);</span>
    <span class="s1">prerenderStore.controller.abort(error);</span>
    <span class="s3">const </span><span class="s1">dynamicTracking = prerenderStore.dynamicTracking;</span>
    <span class="s3">if </span><span class="s1">(dynamicTracking) {</span>
        <span class="s1">dynamicTracking.dynamicAccesses.push({</span>
            <span class="s0">// When we aren't debugging, we don't need to create another error for the</span>
            <span class="s0">// stack trace.</span>
            <span class="s1">stack: dynamicTracking.isDebugDynamicAccesses ? </span><span class="s3">new </span><span class="s1">Error().stack : undefined,</span>
            <span class="s1">expression</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {</span>
    <span class="s3">const </span><span class="s1">dynamicTracking = prerenderStore.dynamicTracking;</span>
    <span class="s1">abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);</span>
    <span class="s0">// It is important that we set this tracking value after aborting. Aborts are executed</span>
    <span class="s0">// synchronously except for the case where you abort during render itself. By setting this</span>
    <span class="s0">// value late we can use it to determine if any of the aborted tasks are the task that</span>
    <span class="s0">// called the sync IO expression in the first place.</span>
    <span class="s3">if </span><span class="s1">(dynamicTracking) {</span>
        <span class="s3">if </span><span class="s1">(dynamicTracking.syncDynamicErrorWithStack === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">dynamicTracking.syncDynamicErrorWithStack = errorWithStack;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">trackSynchronousPlatformIOAccessInDev(requestStore) {</span>
    <span class="s0">// We don't actually have a controller to abort but we do the semantic equivalent by</span>
    <span class="s0">// advancing the request store out of prerender mode</span>
    <span class="s1">requestStore.prerenderPhase = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {</span>
    <span class="s3">const </span><span class="s1">prerenderSignal = prerenderStore.controller.signal;</span>
    <span class="s3">if </span><span class="s1">(prerenderSignal.aborted === </span><span class="s3">false</span><span class="s1">) {</span>
        <span class="s0">// TODO it would be better to move this aborted check into the callsite so we can avoid making</span>
        <span class="s0">// the error object when it isn't relevant to the aborting of the prerender however</span>
        <span class="s0">// since we need the throw semantics regardless of whether we abort it is easier to land</span>
        <span class="s0">// this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer</span>
        <span class="s0">// to ideal implementation</span>
        <span class="s1">abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);</span>
        <span class="s0">// It is important that we set this tracking value after aborting. Aborts are executed</span>
        <span class="s0">// synchronously except for the case where you abort during render itself. By setting this</span>
        <span class="s0">// value late we can use it to determine if any of the aborted tasks are the task that</span>
        <span class="s0">// called the sync IO expression in the first place.</span>
        <span class="s3">const </span><span class="s1">dynamicTracking = prerenderStore.dynamicTracking;</span>
        <span class="s3">if </span><span class="s1">(dynamicTracking) {</span>
            <span class="s3">if </span><span class="s1">(dynamicTracking.syncDynamicErrorWithStack === </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">dynamicTracking.syncDynamicErrorWithStack = errorWithStack;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">throw </span><span class="s1">createPrerenderInterruptedError(</span><span class="s2">`Route </span><span class="s1">${route} </span><span class="s2">needs to bail out of prerendering at this point because it used </span><span class="s1">${expression}</span><span class="s2">.`</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">warnOnSyncDynamicError(dynamicTracking) {</span>
    <span class="s3">if </span><span class="s1">(dynamicTracking.syncDynamicErrorWithStack) {</span>
        <span class="s0">// the server did something sync dynamic, likely</span>
        <span class="s0">// leading to an early termination of the prerender.</span>
        <span class="s1">console.error(dynamicTracking.syncDynamicErrorWithStack);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;</span>
<span class="s3">function </span><span class="s1">Postpone({ reason, route }) {</span>
    <span class="s3">const </span><span class="s1">prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s3">const </span><span class="s1">dynamicTracking = prerenderStore &amp;&amp; prerenderStore.type === </span><span class="s2">'prerender-ppr' </span><span class="s1">? prerenderStore.dynamicTracking : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">postponeWithTracking(route, reason, dynamicTracking);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">postponeWithTracking(route, expression, dynamicTracking) {</span>
    <span class="s1">assertPostpone();</span>
    <span class="s3">if </span><span class="s1">(dynamicTracking) {</span>
        <span class="s1">dynamicTracking.dynamicAccesses.push({</span>
            <span class="s0">// When we aren't debugging, we don't need to create another error for the</span>
            <span class="s0">// stack trace.</span>
            <span class="s1">stack: dynamicTracking.isDebugDynamicAccesses ? </span><span class="s3">new </span><span class="s1">Error().stack : undefined,</span>
            <span class="s1">expression</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">_react.default.unstable_postpone(createPostponeReason(route, expression));</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createPostponeReason(route, expression) {</span>
    <span class="s3">return </span><span class="s2">`Route </span><span class="s1">${route} </span><span class="s2">needs to bail out of prerendering at this point because it used </span><span class="s1">${expression}</span><span class="s2">. ` </span><span class="s1">+ </span><span class="s2">`React throws this special object to indicate where. It should not be caught by ` </span><span class="s1">+ </span><span class="s2">`your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isDynamicPostpone(err) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">err === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; err !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">err.message === </span><span class="s2">'string'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">isDynamicPostponeReason(err.message);</span>
    <span class="s1">}</span>
    <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isDynamicPostponeReason(reason) {</span>
    <span class="s3">return </span><span class="s1">reason.includes(</span><span class="s2">'needs to bail out of prerendering at this point because it used'</span><span class="s1">) &amp;&amp; reason.includes(</span><span class="s2">'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">if </span><span class="s1">(isDynamicPostponeReason(createPostponeReason(</span><span class="s2">'%%%'</span><span class="s1">, </span><span class="s2">'^^^'</span><span class="s1">)) === </span><span class="s3">false</span><span class="s1">) {</span>
    <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s2">&quot;E296&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">NEXT_PRERENDER_INTERRUPTED = </span><span class="s2">'NEXT_PRERENDER_INTERRUPTED'</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">createPrerenderInterruptedError(message) {</span>
    <span class="s3">const </span><span class="s1">error = Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(message), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s2">&quot;E394&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">});</span>
    <span class="s1">error.digest = NEXT_PRERENDER_INTERRUPTED;</span>
    <span class="s3">return </span><span class="s1">error;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isPrerenderInterruptedError(error) {</span>
    <span class="s3">return typeof </span><span class="s1">error === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; error !== </span><span class="s3">null </span><span class="s1">&amp;&amp; error.digest === NEXT_PRERENDER_INTERRUPTED &amp;&amp; </span><span class="s2">'name' </span><span class="s3">in </span><span class="s1">error &amp;&amp; </span><span class="s2">'message' </span><span class="s3">in </span><span class="s1">error &amp;&amp; error </span><span class="s3">instanceof </span><span class="s1">Error;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">accessedDynamicData(dynamicAccesses) {</span>
    <span class="s3">return </span><span class="s1">dynamicAccesses.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">consumeDynamicAccess(serverDynamic, clientDynamic) {</span>
    <span class="s0">// We mutate because we only call this once we are no longer writing</span>
    <span class="s0">// to the dynamicTrackingState and it's more efficient than creating a new</span>
    <span class="s0">// array.</span>
    <span class="s1">serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);</span>
    <span class="s3">return </span><span class="s1">serverDynamic.dynamicAccesses;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">formatDynamicAPIAccesses(dynamicAccesses) {</span>
    <span class="s3">return </span><span class="s1">dynamicAccesses.filter((access)=&gt;</span><span class="s3">typeof </span><span class="s1">access.stack === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; access.stack.length &gt; </span><span class="s4">0</span><span class="s1">).map(({ expression, stack })=&gt;{</span>
        <span class="s1">stack = stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">)</span><span class="s0">// Remove the &quot;Error: &quot; prefix from the first line of the stack trace as</span>
        <span class="s0">// well as the first 4 lines of the stack trace which is the distance</span>
        <span class="s0">// from the user code and the `new Error().stack` call.</span>
        <span class="s1">.slice(</span><span class="s4">4</span><span class="s1">).filter((line)=&gt;{</span>
            <span class="s0">// Exclude Next.js internals from the stack trace.</span>
            <span class="s3">if </span><span class="s1">(line.includes(</span><span class="s2">'node_modules/next/'</span><span class="s1">)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// Exclude anonymous functions from the stack trace.</span>
            <span class="s3">if </span><span class="s1">(line.includes(</span><span class="s2">' (&lt;anonymous&gt;)'</span><span class="s1">)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// Exclude Node.js internals from the stack trace.</span>
            <span class="s3">if </span><span class="s1">(line.includes(</span><span class="s2">' (node:'</span><span class="s1">)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}).join(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s2">`Dynamic API Usage Debug - </span><span class="s1">${expression}</span><span class="s2">:</span><span class="s5">\n</span><span class="s1">${stack}</span><span class="s2">`</span><span class="s1">;</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">assertPostpone() {</span>
    <span class="s3">if </span><span class="s1">(!hasPostpone) {</span>
        <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s2">&quot;E224&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s3">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createRenderInBrowserAbortSignal() {</span>
    <span class="s3">const </span><span class="s1">controller = </span><span class="s3">new </span><span class="s1">AbortController();</span>
    <span class="s1">controller.abort(Object.defineProperty(</span><span class="s3">new </span><span class="s1">_bailouttocsr.BailoutToCSRError(</span><span class="s2">'Render in Browser'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s2">&quot;E721&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">}));</span>
    <span class="s3">return </span><span class="s1">controller.signal;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createHangingInputAbortSignal(workUnitStore) {</span>
    <span class="s3">switch</span><span class="s1">(workUnitStore.type){</span>
        <span class="s3">case </span><span class="s2">'prerender'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'prerender-runtime'</span><span class="s1">:</span>
            <span class="s3">const </span><span class="s1">controller = </span><span class="s3">new </span><span class="s1">AbortController();</span>
            <span class="s3">if </span><span class="s1">(workUnitStore.cacheSignal) {</span>
                <span class="s0">// If we have a cacheSignal it means we're in a prospective render. If</span>
                <span class="s0">// the input we're waiting on is coming from another cache, we do want</span>
                <span class="s0">// to wait for it so that we can resolve this cache entry too.</span>
                <span class="s1">workUnitStore.cacheSignal.inputReady().then(()=&gt;{</span>
                    <span class="s1">controller.abort();</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s0">// Otherwise we're in the final render and we should already have all</span>
                <span class="s0">// our caches filled.</span>
                <span class="s0">// If the prerender uses stages, we have wait until the runtime stage,</span>
                <span class="s0">// at which point all runtime inputs will be resolved.</span>
                <span class="s0">// (otherwise, a runtime prerender might consider `cookies()` hanging</span>
                <span class="s0">//  even though they'd resolve in the next task.)</span>
                <span class="s0">//</span>
                <span class="s0">// We might still be waiting on some microtasks so we</span>
                <span class="s0">// wait one tick before giving up. When we give up, we still want to</span>
                <span class="s0">// render the content of this cache as deeply as we can so that we can</span>
                <span class="s0">// suspend as deeply as possible in the tree or not at all if we don't</span>
                <span class="s0">// end up waiting for the input.</span>
                <span class="s3">const </span><span class="s1">runtimeStagePromise = (</span><span class="s4">0</span><span class="s1">, _workunitasyncstorageexternal.getRuntimeStagePromise)(workUnitStore);</span>
                <span class="s3">if </span><span class="s1">(runtimeStagePromise) {</span>
                    <span class="s1">runtimeStagePromise.then(()=&gt;(</span><span class="s4">0</span><span class="s1">, _scheduler.scheduleOnNextTick)(()=&gt;controller.abort()));</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _scheduler.scheduleOnNextTick)(()=&gt;controller.abort());</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">controller.signal;</span>
        <span class="s3">case </span><span class="s2">'prerender-client'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'prerender-ppr'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'prerender-legacy'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'request'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'cache'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'private-cache'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'unstable-cache'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">undefined;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s1">workUnitStore;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">annotateDynamicAccess(expression, prerenderStore) {</span>
    <span class="s3">const </span><span class="s1">dynamicTracking = prerenderStore.dynamicTracking;</span>
    <span class="s3">if </span><span class="s1">(dynamicTracking) {</span>
        <span class="s1">dynamicTracking.dynamicAccesses.push({</span>
            <span class="s1">stack: dynamicTracking.isDebugDynamicAccesses ? </span><span class="s3">new </span><span class="s1">Error().stack : undefined,</span>
            <span class="s1">expression</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">useDynamicRouteParams(expression) {</span>
    <span class="s3">const </span><span class="s1">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
    <span class="s3">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s3">if </span><span class="s1">(workStore &amp;&amp; workUnitStore) {</span>
        <span class="s3">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s3">case </span><span class="s2">'prerender-client'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'prerender'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s3">const </span><span class="s1">fallbackParams = workUnitStore.fallbackRouteParams;</span>
                    <span class="s3">if </span><span class="s1">(fallbackParams &amp;&amp; fallbackParams.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s0">// We are in a prerender with cacheComponents semantics. We are going to</span>
                        <span class="s0">// hang here and never resolve. This will cause the currently</span>
                        <span class="s0">// rendering component to effectively be a dynamic hole.</span>
                        <span class="s1">_react.default.use((</span><span class="s4">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, expression));</span>
                    <span class="s1">}</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s3">case </span><span class="s2">'prerender-ppr'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s3">const </span><span class="s1">fallbackParams = workUnitStore.fallbackRouteParams;</span>
                    <span class="s3">if </span><span class="s1">(fallbackParams &amp;&amp; fallbackParams.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s3">return </span><span class="s1">postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);</span>
                    <span class="s1">}</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s3">case </span><span class="s2">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s2">`</span><span class="s5">\`</span><span class="s1">${expression}</span><span class="s5">\` </span><span class="s2">was called during a runtime prerender. Next.js should be preventing </span><span class="s1">${expression} </span><span class="s2">from being included in server components statically, but did not in this case.`</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s2">&quot;E771&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s3">true</span>
                <span class="s1">});</span>
            <span class="s3">case </span><span class="s2">'cache'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'private-cache'</span><span class="s1">:</span>
                <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s2">`</span><span class="s5">\`</span><span class="s1">${expression}</span><span class="s5">\` </span><span class="s2">was called inside a cache scope. Next.js should be preventing </span><span class="s1">${expression} </span><span class="s2">from being included in server components statically, but did not in this case.`</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s2">&quot;E745&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s3">true</span>
                <span class="s1">});</span>
            <span class="s3">case </span><span class="s2">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'request'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'unstable-cache'</span><span class="s1">:</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">hasSuspenseRegex = </span><span class="s6">/\n\s+at Suspense \(&lt;anonymous&gt;\)/</span><span class="s1">;</span>
<span class="s0">// Common implicit body tags that React will treat as body when placed directly in html</span>
<span class="s3">const </span><span class="s1">bodyAndImplicitTags = </span><span class="s2">'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'</span><span class="s1">;</span>
<span class="s0">// Detects when RootLayoutBoundary (our framework marker component) appears</span>
<span class="s0">// after Suspense in the component stack, indicating the root layout is wrapped</span>
<span class="s0">// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.</span>
<span class="s0">//</span>
<span class="s0">// Example matches:</span>
<span class="s0">//   at Suspense (&lt;anonymous&gt;)</span>
<span class="s0">//   at __next_root_layout_boundary__ (&lt;anonymous&gt;)</span>
<span class="s0">//</span>
<span class="s0">// Or with other components in between (but not body/html/implicit-body):</span>
<span class="s0">//   at Suspense (&lt;anonymous&gt;)</span>
<span class="s0">//   at SomeComponent (&lt;anonymous&gt;)</span>
<span class="s0">//   at __next_root_layout_boundary__ (&lt;anonymous&gt;)</span>
<span class="s3">const </span><span class="s1">hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">`</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s+at Suspense </span><span class="s5">\\</span><span class="s2">(&lt;anonymous&gt;</span><span class="s5">\\</span><span class="s2">)(?:(?!</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s+at (?:</span><span class="s1">${bodyAndImplicitTags}</span><span class="s2">) </span><span class="s5">\\</span><span class="s2">(&lt;anonymous&gt;</span><span class="s5">\\</span><span class="s2">))[</span><span class="s5">\\</span><span class="s2">s</span><span class="s5">\\</span><span class="s2">S])*?</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s+at </span><span class="s1">${_boundaryconstants.ROOT_LAYOUT_BOUNDARY_NAME} </span><span class="s5">\\</span><span class="s2">([^</span><span class="s5">\\</span><span class="s2">n]*</span><span class="s5">\\</span><span class="s2">)`</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">hasMetadataRegex = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">`</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s+at </span><span class="s1">${_boundaryconstants.METADATA_BOUNDARY_NAME}</span><span class="s2">[</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s]`</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">hasViewportRegex = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">`</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s+at </span><span class="s1">${_boundaryconstants.VIEWPORT_BOUNDARY_NAME}</span><span class="s2">[</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s]`</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">hasOutletRegex = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">`</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s+at </span><span class="s1">${_boundaryconstants.OUTLET_BOUNDARY_NAME}</span><span class="s2">[</span><span class="s5">\\</span><span class="s2">n</span><span class="s5">\\</span><span class="s2">s]`</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {</span>
    <span class="s3">if </span><span class="s1">(hasOutletRegex.test(componentStack)) {</span>
        <span class="s0">// We don't need to track that this is dynamic. It is only so when something else is also dynamic.</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(hasMetadataRegex.test(componentStack)) {</span>
        <span class="s1">dynamicValidation.hasDynamicMetadata = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(hasViewportRegex.test(componentStack)) {</span>
        <span class="s1">dynamicValidation.hasDynamicViewport = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {</span>
        <span class="s0">// For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.</span>
        <span class="s0">// But if you have Suspense above body, the prelude is empty but we allow that because having Suspense</span>
        <span class="s0">// is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.</span>
        <span class="s1">dynamicValidation.hasAllowedDynamic = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">dynamicValidation.hasSuspenseAboveBody = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(hasSuspenseRegex.test(componentStack)) {</span>
        <span class="s0">// this error had a Suspense boundary above it so we don't need to report it as a source</span>
        <span class="s0">// of disallowed</span>
        <span class="s1">dynamicValidation.hasAllowedDynamic = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(clientDynamic.syncDynamicErrorWithStack) {</span>
        <span class="s0">// This task was the task that called the sync error.</span>
        <span class="s1">dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">const </span><span class="s1">message = </span><span class="s2">`Route &quot;</span><span class="s1">${workStore.route}</span><span class="s2">&quot;: A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a &quot;use cache&quot; above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s1">error = createErrorWithComponentOrOwnerStack(message, componentStack);</span>
        <span class="s1">dynamicValidation.dynamicErrors.push(error);</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* In dev mode, we prefer using the owner stack, otherwise the provided</span>
 <span class="s0">* component stack is used.</span>
 <span class="s0">*/ </span><span class="s3">function </span><span class="s1">createErrorWithComponentOrOwnerStack(message, componentStack) {</span>
    <span class="s3">const </span><span class="s1">ownerStack = process.env.NODE_ENV !== </span><span class="s2">'production' </span><span class="s1">&amp;&amp; _react.default.captureOwnerStack ? _react.default.captureOwnerStack() : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">error = Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(message), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s2">&quot;E394&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">});</span>
    <span class="s1">error.stack = error.name + </span><span class="s2">': ' </span><span class="s1">+ message + (ownerStack ?? componentStack);</span>
    <span class="s3">return </span><span class="s1">error;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">PreludeState = </span><span class="s0">/*#__PURE__*/ </span><span class="s3">function</span><span class="s1">(PreludeState) {</span>
    <span class="s1">PreludeState[PreludeState[</span><span class="s2">&quot;Full&quot;</span><span class="s1">] = </span><span class="s4">0</span><span class="s1">] = </span><span class="s2">&quot;Full&quot;</span><span class="s1">;</span>
    <span class="s1">PreludeState[PreludeState[</span><span class="s2">&quot;Empty&quot;</span><span class="s1">] = </span><span class="s4">1</span><span class="s1">] = </span><span class="s2">&quot;Empty&quot;</span><span class="s1">;</span>
    <span class="s1">PreludeState[PreludeState[</span><span class="s2">&quot;Errored&quot;</span><span class="s1">] = </span><span class="s4">2</span><span class="s1">] = </span><span class="s2">&quot;Errored&quot;</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">PreludeState;</span>
<span class="s1">}({});</span>
<span class="s3">function </span><span class="s1">logDisallowedDynamicError(workStore, error) {</span>
    <span class="s1">console.error(error);</span>
    <span class="s3">if </span><span class="s1">(!workStore.dev) {</span>
        <span class="s3">if </span><span class="s1">(workStore.hasReadableErrorStacks) {</span>
            <span class="s1">console.error(</span><span class="s2">`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running </span><span class="s5">\`</span><span class="s2">next dev</span><span class="s5">\`</span><span class="s2">, then open &quot;</span><span class="s1">${workStore.route}</span><span class="s2">&quot; in your browser to investigate the error.`</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">console.error(</span><span class="s2">`To get a more detailed stack trace and pinpoint the issue, try one of the following: 
  - Start the app in development mode by running </span><span class="s5">\`</span><span class="s2">next dev</span><span class="s5">\`</span><span class="s2">, then open &quot;</span><span class="s1">${workStore.route}</span><span class="s2">&quot; in your browser to investigate the error. 
  - Rerun the production build with </span><span class="s5">\`</span><span class="s2">next build --debug-prerender</span><span class="s5">\` </span><span class="s2">to generate better stack traces.`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {</span>
    <span class="s3">if </span><span class="s1">(prelude !== </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(dynamicValidation.hasSuspenseAboveBody) {</span>
            <span class="s0">// This route has opted into allowing fully dynamic rendering</span>
            <span class="s0">// by including a Suspense boundary above the body. In this case</span>
            <span class="s0">// a lack of a shell is not considered disallowed so we simply return</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(serverDynamic.syncDynamicErrorWithStack) {</span>
            <span class="s0">// There is no shell and the server did something sync dynamic likely</span>
            <span class="s0">// leading to an early termination of the prerender before the shell</span>
            <span class="s0">// could be completed. We terminate the build/validating render.</span>
            <span class="s1">logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);</span>
            <span class="s3">throw new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError();</span>
        <span class="s1">}</span>
        <span class="s0">// We didn't have any sync bailouts but there may be user code which</span>
        <span class="s0">// blocked the root. We would have captured these during the prerender</span>
        <span class="s0">// and can log them here and then terminate the build/validating render</span>
        <span class="s3">const </span><span class="s1">dynamicErrors = dynamicValidation.dynamicErrors;</span>
        <span class="s3">if </span><span class="s1">(dynamicErrors.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; dynamicErrors.length; i++){</span>
                <span class="s1">logDisallowedDynamicError(workStore, dynamicErrors[i]);</span>
            <span class="s1">}</span>
            <span class="s3">throw new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError();</span>
        <span class="s1">}</span>
        <span class="s0">// If we got this far then the only other thing that could be blocking</span>
        <span class="s0">// the root is dynamic Viewport. If this is dynamic then</span>
        <span class="s0">// you need to opt into that by adding a Suspense boundary above the body</span>
        <span class="s0">// to indicate your are ok with fully dynamic rendering.</span>
        <span class="s3">if </span><span class="s1">(dynamicValidation.hasDynamicViewport) {</span>
            <span class="s1">console.error(</span><span class="s2">`Route &quot;</span><span class="s1">${workStore.route}</span><span class="s2">&quot; has a </span><span class="s5">\`</span><span class="s2">generateViewport</span><span class="s5">\` </span><span class="s2">that depends on Request data (</span><span class="s5">\`</span><span class="s2">cookies()</span><span class="s5">\`</span><span class="s2">, etc...) or uncached external data (</span><span class="s5">\`</span><span class="s2">fetch(...)</span><span class="s5">\`</span><span class="s2">, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`</span><span class="s1">);</span>
            <span class="s3">throw new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(prelude === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s0">// If we ever get this far then we messed up the tracking of invalid dynamic.</span>
            <span class="s0">// We still adhere to the constraint that you must produce a shell but invite the</span>
            <span class="s0">// user to report this as a bug in Next.js.</span>
            <span class="s1">console.error(</span><span class="s2">`Route &quot;</span><span class="s1">${workStore.route}</span><span class="s2">&quot; did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`</span><span class="s1">);</span>
            <span class="s3">throw new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError();</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(dynamicValidation.hasAllowedDynamic === </span><span class="s3">false </span><span class="s1">&amp;&amp; dynamicValidation.hasDynamicMetadata) {</span>
            <span class="s1">console.error(</span><span class="s2">`Route &quot;</span><span class="s1">${workStore.route}</span><span class="s2">&quot; has a </span><span class="s5">\`</span><span class="s2">generateMetadata</span><span class="s5">\` </span><span class="s2">that depends on Request data (</span><span class="s5">\`</span><span class="s2">cookies()</span><span class="s5">\`</span><span class="s2">, etc...) or uncached external data (</span><span class="s5">\`</span><span class="s2">fetch(...)</span><span class="s5">\`</span><span class="s2">, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`</span><span class="s1">);</span>
            <span class="s3">throw new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">delayUntilRuntimeStage(prerenderStore, result) {</span>
    <span class="s3">if </span><span class="s1">(prerenderStore.runtimeStagePromise) {</span>
        <span class="s3">return </span><span class="s1">prerenderStore.runtimeStagePromise.then(()=&gt;result);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=dynamic-rendering.js.map</span></pre>
</body>
</html>