<html>
<head>
<title>unstable-cache.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
unstable-cache.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/web/spec-extension/unstable-cache.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { IncrementalCache } from '../../lib/incremental-cache'</span><span class="s3">\n\n</span><span class="s1">import { CACHE_ONE_YEAR } from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { validateRevalidate, validateTags } from '../../lib/patch-fetch'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type WorkStore,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getCacheSignal,</span><span class="s3">\n  </span><span class="s1">getDraftModeProviderForCacheScope,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedFetchData,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">UnstableCacheStore,</span><span class="s3">\n  </span><span class="s1">WorkUnitStore,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n\n</span><span class="s1">type Callback = (...args: any[]) =&gt; Promise&lt;any&gt;</span><span class="s3">\n\n</span><span class="s1">let noStoreFetchIdx = 0</span><span class="s3">\n\n</span><span class="s1">async function cacheNewResult&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">result: T,</span><span class="s3">\n  </span><span class="s1">incrementalCache: IncrementalCache,</span><span class="s3">\n  </span><span class="s1">cacheKey: string,</span><span class="s3">\n  </span><span class="s1">tags: string[],</span><span class="s3">\n  </span><span class="s1">revalidate: number | false | undefined,</span><span class="s3">\n  </span><span class="s1">fetchIdx: number,</span><span class="s3">\n  </span><span class="s1">fetchUrl: string</span><span class="s3">\n</span><span class="s1">): Promise&lt;unknown&gt; {</span><span class="s3">\n  </span><span class="s1">await incrementalCache.set(</span><span class="s3">\n    </span><span class="s1">cacheKey,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">kind: CachedRouteKind.FETCH,</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">headers: {},</span><span class="s3">\n        </span><span class="s1">// TODO: handle non-JSON values?</span><span class="s3">\n        </span><span class="s1">body: JSON.stringify(result),</span><span class="s3">\n        </span><span class="s1">status: 200,</span><span class="s3">\n        </span><span class="s1">url: '',</span><span class="s3">\n      </span><span class="s1">} satisfies CachedFetchData,</span><span class="s3">\n      </span><span class="s1">revalidate: typeof revalidate !== 'number' ? CACHE_ONE_YEAR : revalidate,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ fetchCache: true, tags, fetchIdx, fetchUrl }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">return</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `unstable_cache`](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function unstable_cache&lt;T extends Callback&gt;(</span><span class="s3">\n  </span><span class="s1">cb: T,</span><span class="s3">\n  </span><span class="s1">keyParts?: string[],</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The revalidation interval in seconds.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">revalidate?: number | false</span><span class="s3">\n    </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">if (options.revalidate === 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invariant revalidate: 0 can not be passed to unstable_cache(), must be </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">&gt; 0</span><span class="s3">\&quot; </span><span class="s1">${cb.toString()}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Validate the tags provided are valid</span><span class="s3">\n  </span><span class="s1">const tags = options.tags</span><span class="s3">\n    </span><span class="s1">? validateTags(options.tags, `unstable_cache ${cb.toString()}`)</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n\n  </span><span class="s1">// Validate the revalidate options</span><span class="s3">\n  </span><span class="s1">validateRevalidate(</span><span class="s3">\n    </span><span class="s1">options.revalidate,</span><span class="s3">\n    </span><span class="s1">`unstable_cache ${cb.name || cb.toString()}`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Stash the fixed part of the key at construction time. The invocation key will combine</span><span class="s3">\n  </span><span class="s1">// the fixed key with the arguments when actually called</span><span class="s3">\n  </span><span class="s1">// @TODO if cb.toString() is long we should hash it</span><span class="s3">\n  </span><span class="s1">// @TODO come up with a collision-free way to combine keyParts</span><span class="s3">\n  </span><span class="s1">// @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees</span><span class="s3">\n  </span><span class="s1">// and the error produced by accidentally using something that cannot be safely coerced is likely</span><span class="s3">\n  </span><span class="s1">// hard to debug</span><span class="s3">\n  </span><span class="s1">const fixedKey = `${cb.toString()}-${</span><span class="s3">\n    </span><span class="s1">Array.isArray(keyParts) &amp;&amp; keyParts.join(',')</span><span class="s3">\n  </span><span class="s1">}`</span><span class="s3">\n\n  </span><span class="s1">const cachedCb = async (...args: any[]) =&gt; {</span><span class="s3">\n    </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n    </span><span class="s1">// We must be able to find the incremental cache otherwise we throw</span><span class="s3">\n    </span><span class="s1">const maybeIncrementalCache:</span><span class="s3">\n      </span><span class="s1">| import('../../lib/incremental-cache').IncrementalCache</span><span class="s3">\n      </span><span class="s1">| undefined =</span><span class="s3">\n      </span><span class="s1">workStore?.incrementalCache || (globalThis as any).__incrementalCache</span><span class="s3">\n\n    </span><span class="s1">if (!maybeIncrementalCache) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const incrementalCache = maybeIncrementalCache</span><span class="s3">\n\n    </span><span class="s1">const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null</span><span class="s3">\n    </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n      </span><span class="s1">cacheSignal.beginRead()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// If there's no request store, we aren't in a request (or we're not in</span><span class="s3">\n      </span><span class="s1">// app router) and if there's no static generation store, we aren't in app</span><span class="s3">\n      </span><span class="s1">// router. Default to an empty pathname and search params when there's no</span><span class="s3">\n      </span><span class="s1">// request store or static generation store available.</span><span class="s3">\n      </span><span class="s1">const fetchUrlPrefix =</span><span class="s3">\n        </span><span class="s1">workStore &amp;&amp; workUnitStore</span><span class="s3">\n          </span><span class="s1">? getFetchUrlPrefix(workStore, workUnitStore)</span><span class="s3">\n          </span><span class="s1">: ''</span><span class="s3">\n\n      </span><span class="s1">// Construct the complete cache key for this function invocation</span><span class="s3">\n      </span><span class="s1">// @TODO stringify is likely not safe here. We will coerce undefined to null which will make</span><span class="s3">\n      </span><span class="s1">// the keyspace smaller than the execution space</span><span class="s3">\n      </span><span class="s1">const invocationKey = `${fixedKey}-${JSON.stringify(args)}`</span><span class="s3">\n      </span><span class="s1">const cacheKey = await incrementalCache.generateCacheKey(invocationKey)</span><span class="s3">\n      </span><span class="s1">// $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse</span><span class="s3">\n      </span><span class="s1">const fetchUrl = `unstable_cache ${fetchUrlPrefix} ${cb.name ? ` ${cb.name}` : cacheKey}`</span><span class="s3">\n      </span><span class="s1">const fetchIdx =</span><span class="s3">\n        </span><span class="s1">(workStore ? workStore.nextFetchId : noStoreFetchIdx) ?? 1</span><span class="s3">\n\n      </span><span class="s1">const implicitTags = workUnitStore?.implicitTags</span><span class="s3">\n\n      </span><span class="s1">const innerCacheStore: UnstableCacheStore = {</span><span class="s3">\n        </span><span class="s1">type: 'unstable-cache',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">draftMode:</span><span class="s3">\n          </span><span class="s1">workUnitStore &amp;&amp;</span><span class="s3">\n          </span><span class="s1">workStore &amp;&amp;</span><span class="s3">\n          </span><span class="s1">getDraftModeProviderForCacheScope(workStore, workUnitStore),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (workStore) {</span><span class="s3">\n        </span><span class="s1">workStore.nextFetchId = fetchIdx + 1</span><span class="s3">\n\n        </span><span class="s1">// We are in an App Router context. We try to return the cached entry if it exists and is valid</span><span class="s3">\n        </span><span class="s1">// If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in</span><span class="s3">\n        </span><span class="s1">// the background. If the entry is missing or invalid we generate a new entry and return it.</span><span class="s3">\n\n        </span><span class="s1">let isNestedUnstableCache = false</span><span class="s3">\n\n        </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n          </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n            </span><span class="s1">case 'cache':</span><span class="s3">\n            </span><span class="s1">case 'private-cache':</span><span class="s3">\n            </span><span class="s1">case 'prerender':</span><span class="s3">\n            </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n            </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n            </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n              </span><span class="s1">// We update the store's revalidate property if the option.revalidate is a higher precedence</span><span class="s3">\n              </span><span class="s1">// options.revalidate === undefined doesn't affect timing.</span><span class="s3">\n              </span><span class="s1">// options.revalidate === false doesn't shrink timing. it stays at the maximum.</span><span class="s3">\n              </span><span class="s1">if (typeof options.revalidate === 'number') {</span><span class="s3">\n                </span><span class="s1">if (workUnitStore.revalidate &lt; options.revalidate) {</span><span class="s3">\n                  </span><span class="s1">// The store is already revalidating on a shorter time interval, leave it alone</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                  </span><span class="s1">workUnitStore.revalidate = options.revalidate</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">// We need to accumulate the tags for this invocation within the store</span><span class="s3">\n              </span><span class="s1">const collectedTags = workUnitStore.tags</span><span class="s3">\n              </span><span class="s1">if (collectedTags === null) {</span><span class="s3">\n                </span><span class="s1">workUnitStore.tags = tags.slice()</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">for (const tag of tags) {</span><span class="s3">\n                  </span><span class="s1">// @TODO refactor tags to be a set to avoid this O(n) lookup</span><span class="s3">\n                  </span><span class="s1">if (!collectedTags.includes(tag)) {</span><span class="s3">\n                    </span><span class="s1">collectedTags.push(tag)</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n              </span><span class="s1">isNestedUnstableCache = true</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case 'prerender-client':</span><span class="s3">\n            </span><span class="s1">case 'request':</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">// when we are nested inside of other unstable_cache's</span><span class="s3">\n          </span><span class="s1">// we should bypass cache similar to fetches</span><span class="s3">\n          </span><span class="s1">!isNestedUnstableCache &amp;&amp;</span><span class="s3">\n          </span><span class="s1">workStore.fetchCache !== 'force-no-store' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!workStore.isOnDemandRevalidate &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!incrementalCache.isOnDemandRevalidate &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!workStore.isDraftMode</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// We attempt to get the current cache entry from the incremental cache.</span><span class="s3">\n          </span><span class="s1">const cacheEntry = await incrementalCache.get(cacheKey, {</span><span class="s3">\n            </span><span class="s1">kind: IncrementalCacheKind.FETCH,</span><span class="s3">\n            </span><span class="s1">revalidate: options.revalidate,</span><span class="s3">\n            </span><span class="s1">tags,</span><span class="s3">\n            </span><span class="s1">softTags: implicitTags?.tags,</span><span class="s3">\n            </span><span class="s1">fetchIdx,</span><span class="s3">\n            </span><span class="s1">fetchUrl,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">if (cacheEntry &amp;&amp; cacheEntry.value) {</span><span class="s3">\n            </span><span class="s1">// The entry exists and has a value</span><span class="s3">\n            </span><span class="s1">if (cacheEntry.value.kind !== CachedRouteKind.FETCH) {</span><span class="s3">\n              </span><span class="s1">// The entry is invalid and we need a special warning</span><span class="s3">\n              </span><span class="s1">// @TODO why do we warn this way? Should this just be an error? How are these errors surfaced</span><span class="s3">\n              </span><span class="s1">// so bugs can be reported</span><span class="s3">\n              </span><span class="s1">// @TODO the invocation key can have sensitive data in it. we should not log this entire object</span><span class="s3">\n              </span><span class="s1">console.error(</span><span class="s3">\n                </span><span class="s1">`Invariant invalid cacheEntry returned for ${invocationKey}`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">// will fall through to generating a new cache entry below</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// We have a valid cache entry so we will be returning it. We also check to see if we need</span><span class="s3">\n              </span><span class="s1">// to background revalidate it by checking if it is stale.</span><span class="s3">\n              </span><span class="s1">const cachedResponse =</span><span class="s3">\n                </span><span class="s1">cacheEntry.value.data.body !== undefined</span><span class="s3">\n                  </span><span class="s1">? JSON.parse(cacheEntry.value.data.body)</span><span class="s3">\n                  </span><span class="s1">: undefined</span><span class="s3">\n              </span><span class="s1">if (cacheEntry.isStale) {</span><span class="s3">\n                </span><span class="s1">// In App Router we return the stale result and revalidate in the background</span><span class="s3">\n                </span><span class="s1">if (!workStore.pendingRevalidates) {</span><span class="s3">\n                  </span><span class="s1">workStore.pendingRevalidates = {}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">// We run the cache function asynchronously and save the result when it completes</span><span class="s3">\n                </span><span class="s1">workStore.pendingRevalidates[invocationKey] =</span><span class="s3">\n                  </span><span class="s1">workUnitAsyncStorage</span><span class="s3">\n                    </span><span class="s1">.run(innerCacheStore, cb, ...args)</span><span class="s3">\n                    </span><span class="s1">.then((result) =&gt; {</span><span class="s3">\n                      </span><span class="s1">return cacheNewResult(</span><span class="s3">\n                        </span><span class="s1">result,</span><span class="s3">\n                        </span><span class="s1">incrementalCache,</span><span class="s3">\n                        </span><span class="s1">cacheKey,</span><span class="s3">\n                        </span><span class="s1">tags,</span><span class="s3">\n                        </span><span class="s1">options.revalidate,</span><span class="s3">\n                        </span><span class="s1">fetchIdx,</span><span class="s3">\n                        </span><span class="s1">fetchUrl</span><span class="s3">\n                      </span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">})</span><span class="s3">\n                    </span><span class="s1">// @TODO This error handling seems wrong. We swallow the error?</span><span class="s3">\n                    </span><span class="s1">.catch((err) =&gt;</span><span class="s3">\n                      </span><span class="s1">console.error(</span><span class="s3">\n                        </span><span class="s1">`revalidating cache with key: ${invocationKey}`,</span><span class="s3">\n                        </span><span class="s1">err</span><span class="s3">\n                      </span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">// We had a valid cache entry so we return it here</span><span class="s3">\n              </span><span class="s1">return cachedResponse</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If we got this far then we had an invalid cache entry and need to generate a new one</span><span class="s3">\n        </span><span class="s1">const result = await workUnitAsyncStorage.run(</span><span class="s3">\n          </span><span class="s1">innerCacheStore,</span><span class="s3">\n          </span><span class="s1">cb,</span><span class="s3">\n          </span><span class="s1">...args</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (!workStore.isDraftMode) {</span><span class="s3">\n          </span><span class="s1">if (!workStore.pendingRevalidates) {</span><span class="s3">\n            </span><span class="s1">workStore.pendingRevalidates = {}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// We need to push the cache result promise to pending</span><span class="s3">\n          </span><span class="s1">// revalidates otherwise it won't be awaited and is just</span><span class="s3">\n          </span><span class="s1">// dangling</span><span class="s3">\n          </span><span class="s1">workStore.pendingRevalidates[invocationKey] = cacheNewResult(</span><span class="s3">\n            </span><span class="s1">result,</span><span class="s3">\n            </span><span class="s1">incrementalCache,</span><span class="s3">\n            </span><span class="s1">cacheKey,</span><span class="s3">\n            </span><span class="s1">tags,</span><span class="s3">\n            </span><span class="s1">options.revalidate,</span><span class="s3">\n            </span><span class="s1">fetchIdx,</span><span class="s3">\n            </span><span class="s1">fetchUrl</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return result</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">noStoreFetchIdx += 1</span><span class="s3">\n        </span><span class="s1">// We are in Pages Router or were called outside of a render. We don't have a store</span><span class="s3">\n        </span><span class="s1">// so we just call the callback directly when it needs to run.</span><span class="s3">\n        </span><span class="s1">// If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in</span><span class="s3">\n        </span><span class="s1">// the background. If the entry is missing or invalid we generate a new entry and return it.</span><span class="s3">\n\n        </span><span class="s1">if (!incrementalCache.isOnDemandRevalidate) {</span><span class="s3">\n          </span><span class="s1">// We aren't doing an on demand revalidation so we check use the cache if valid</span><span class="s3">\n          </span><span class="s1">const cacheEntry = await incrementalCache.get(cacheKey, {</span><span class="s3">\n            </span><span class="s1">kind: IncrementalCacheKind.FETCH,</span><span class="s3">\n            </span><span class="s1">revalidate: options.revalidate,</span><span class="s3">\n            </span><span class="s1">tags,</span><span class="s3">\n            </span><span class="s1">fetchIdx,</span><span class="s3">\n            </span><span class="s1">fetchUrl,</span><span class="s3">\n            </span><span class="s1">softTags: implicitTags?.tags,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n\n          </span><span class="s1">if (cacheEntry &amp;&amp; cacheEntry.value) {</span><span class="s3">\n            </span><span class="s1">// The entry exists and has a value</span><span class="s3">\n            </span><span class="s1">if (cacheEntry.value.kind !== CachedRouteKind.FETCH) {</span><span class="s3">\n              </span><span class="s1">// The entry is invalid and we need a special warning</span><span class="s3">\n              </span><span class="s1">// @TODO why do we warn this way? Should this just be an error? How are these errors surfaced</span><span class="s3">\n              </span><span class="s1">// so bugs can be reported</span><span class="s3">\n              </span><span class="s1">console.error(</span><span class="s3">\n                </span><span class="s1">`Invariant invalid cacheEntry returned for ${invocationKey}`</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">// will fall through to generating a new cache entry below</span><span class="s3">\n            </span><span class="s1">} else if (!cacheEntry.isStale) {</span><span class="s3">\n              </span><span class="s1">// We have a valid cache entry and it is fresh so we return it</span><span class="s3">\n              </span><span class="s1">return cacheEntry.value.data.body !== undefined</span><span class="s3">\n                </span><span class="s1">? JSON.parse(cacheEntry.value.data.body)</span><span class="s3">\n                </span><span class="s1">: undefined</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If we got this far then we had an invalid cache entry and need to generate a new one</span><span class="s3">\n        </span><span class="s1">const result = await workUnitAsyncStorage.run(</span><span class="s3">\n          </span><span class="s1">innerCacheStore,</span><span class="s3">\n          </span><span class="s1">cb,</span><span class="s3">\n          </span><span class="s1">...args</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// we need to wait setting the new cache result here as</span><span class="s3">\n        </span><span class="s1">// we don't have pending revalidates on workStore to</span><span class="s3">\n        </span><span class="s1">// push to and we can't have a dangling promise</span><span class="s3">\n        </span><span class="s1">await cacheNewResult(</span><span class="s3">\n          </span><span class="s1">result,</span><span class="s3">\n          </span><span class="s1">incrementalCache,</span><span class="s3">\n          </span><span class="s1">cacheKey,</span><span class="s3">\n          </span><span class="s1">tags,</span><span class="s3">\n          </span><span class="s1">options.revalidate,</span><span class="s3">\n          </span><span class="s1">fetchIdx,</span><span class="s3">\n          </span><span class="s1">fetchUrl</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return result</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">if (cacheSignal) {</span><span class="s3">\n        </span><span class="s1">cacheSignal.endRead()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary</span><span class="s3">\n  </span><span class="s1">return cachedCb as unknown as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getFetchUrlPrefix(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">workUnitStore: WorkUnitStore</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n    </span><span class="s1">case 'request':</span><span class="s3">\n      </span><span class="s1">const pathname = workUnitStore.url.pathname</span><span class="s3">\n      </span><span class="s1">const searchParams = new URLSearchParams(workUnitStore.url.search)</span><span class="s3">\n\n      </span><span class="s1">const sortedSearch = [...searchParams.keys()]</span><span class="s3">\n        </span><span class="s1">.sort((a, b) =&gt; a.localeCompare(b))</span><span class="s3">\n        </span><span class="s1">.map((key) =&gt; `${key}=${searchParams.get(key)}`)</span><span class="s3">\n        </span><span class="s1">.join('&amp;')</span><span class="s3">\n\n      </span><span class="s1">return `${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch}`</span><span class="s3">\n    </span><span class="s1">case 'prerender':</span><span class="s3">\n    </span><span class="s1">case 'prerender-client':</span><span class="s3">\n    </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n    </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n    </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n    </span><span class="s1">case 'cache':</span><span class="s3">\n    </span><span class="s1">case 'private-cache':</span><span class="s3">\n    </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n      </span><span class="s1">return workStore.route</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return workUnitStore satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;unstable_cache&quot;</span><span class="s0">,</span><span class="s1">&quot;noStoreFetchIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNewResult&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedRouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;FETCH&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;CACHE_ONE_YEAR&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;keyParts&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;validateTags&quot;</span><span class="s0">,</span><span class="s1">&quot;validateRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;fixedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedCb&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeIncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;__incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;beginRead&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrlPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getFetchUrlPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;invocationKey&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFetchId&quot;</span><span class="s0">,</span><span class="s1">&quot;implicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;innerCacheStore&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;draftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;getDraftModeProviderForCacheScope&quot;</span><span class="s0">,</span><span class="s1">&quot;isNestedUnstableCache&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;isDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;softTags&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;isStale&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;endRead&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;sortedSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;localeCompare&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>