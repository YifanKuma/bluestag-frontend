<html>
<head>
<title>middleware-turbopack.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
middleware-turbopack.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">getOriginalStackFrames: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getOverlayMiddleware: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getSourceMapMiddleware: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">getOriginalStackFrames: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getOriginalStackFrames;</span>
    <span class="s1">},</span>
    <span class="s1">getOverlayMiddleware: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getOverlayMiddleware;</span>
    <span class="s1">},</span>
    <span class="s1">getSourceMapMiddleware: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getSourceMapMiddleware;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_shared = require(</span><span class="s0">&quot;../../next-devtools/server/shared&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_middlewareresponse = require(</span><span class="s0">&quot;../../next-devtools/server/middleware-response&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_path = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_launcheditor = require(</span><span class="s0">&quot;../../next-devtools/server/launch-editor&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_sourcemap08 = require(</span><span class="s0">&quot;next/dist/compiled/source-map08&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_sourcemaps = require(</span><span class="s0">&quot;../lib/source-maps&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nodemodule = require(</span><span class="s0">&quot;node:module&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nodeurl = require(</span><span class="s0">&quot;node:url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nodeutil = require(</span><span class="s0">&quot;node:util&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldIgnorePath(modulePath) {</span>
    <span class="s2">return </span><span class="s1">modulePath.includes(</span><span class="s0">'node_modules'</span><span class="s1">) || </span><span class="s4">// Only relevant for when Next.js is symlinked e.g. in the Next.js monorepo</span>
    <span class="s1">modulePath.includes(</span><span class="s0">'next/dist'</span><span class="s1">) || modulePath.startsWith(</span><span class="s0">'node:'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">currentSourcesByFile = </span><span class="s2">new </span><span class="s1">Map();</span>
<span class="s4">/**</span>
 <span class="s4">* </span><span class="s5">@returns </span><span class="s4">1-based lines and 1-based columns</span>
 <span class="s4">*/ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">batchedTraceSource(project, frame) {</span>
    <span class="s2">const </span><span class="s1">file = frame.file ? decodeURIComponent(frame.file) : undefined;</span>
    <span class="s2">if </span><span class="s1">(!file) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s4">// For node internals they cannot traced the actual source code with project.traceSource,</span>
    <span class="s4">// we need an early return to indicate it's ignored to avoid the unknown scheme error from `project.traceSource`.</span>
    <span class="s2">if </span><span class="s1">(file.startsWith(</span><span class="s0">'node:'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">frame: {</span>
                <span class="s1">file,</span>
                <span class="s1">line1: frame.line ?? </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">column1: frame.column ?? </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">methodName: frame.methodName ?? </span><span class="s0">'&lt;unknown&gt;'</span><span class="s1">,</span>
                <span class="s1">ignored: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">arguments: []</span>
            <span class="s1">},</span>
            <span class="s1">source: </span><span class="s2">null</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">currentDirectoryFileUrl = (</span><span class="s3">0</span><span class="s1">, _nodeurl.pathToFileURL)(process.cwd()).href;</span>
    <span class="s2">const </span><span class="s1">sourceFrame = </span><span class="s2">await </span><span class="s1">project.traceSource(frame, currentDirectoryFileUrl);</span>
    <span class="s2">if </span><span class="s1">(!sourceFrame) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">frame: {</span>
                <span class="s1">file,</span>
                <span class="s1">line1: frame.line ?? </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">column1: frame.column ?? </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">methodName: frame.methodName ?? </span><span class="s0">'&lt;unknown&gt;'</span><span class="s1">,</span>
                <span class="s1">ignored: shouldIgnorePath(file),</span>
                <span class="s1">arguments: []</span>
            <span class="s1">},</span>
            <span class="s1">source: </span><span class="s2">null</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">source = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">originalFile = sourceFrame.originalFile;</span>
    <span class="s4">// Don't look up source for node_modules or internals. These can often be large bundled files.</span>
    <span class="s2">const </span><span class="s1">ignored = shouldIgnorePath(originalFile ?? sourceFrame.file) || </span><span class="s4">// isInternal means resource starts with turbopack:///[turbopack]</span>
    <span class="s1">!!sourceFrame.isInternal;</span>
    <span class="s2">if </span><span class="s1">(originalFile &amp;&amp; !ignored) {</span>
        <span class="s2">let </span><span class="s1">sourcePromise = currentSourcesByFile.get(originalFile);</span>
        <span class="s2">if </span><span class="s1">(!sourcePromise) {</span>
            <span class="s1">sourcePromise = project.getSourceForAsset(originalFile);</span>
            <span class="s1">currentSourcesByFile.set(originalFile, sourcePromise);</span>
            <span class="s1">setTimeout(()=&gt;{</span>
                <span class="s4">// Cache file reads for 100ms, as frames will often reference the same</span>
                <span class="s4">// files and can be large.</span>
                <span class="s1">currentSourcesByFile.delete(originalFile);</span>
            <span class="s1">}, </span><span class="s3">100</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">source = </span><span class="s2">await </span><span class="s1">sourcePromise;</span>
    <span class="s1">}</span>
    <span class="s4">// TODO: get ignoredList from turbopack source map</span>
    <span class="s2">const </span><span class="s1">ignorableFrame = {</span>
        <span class="s1">file: sourceFrame.file,</span>
        <span class="s1">line1: sourceFrame.line ?? </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">column1: sourceFrame.column ?? </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">methodName: </span><span class="s4">// We ignore the sourcemapped name since it won't be the correct name.</span>
        <span class="s4">// The callsite will point to the column of the variable name instead of the</span>
        <span class="s4">// name of the enclosing function.</span>
        <span class="s4">// TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.</span>
        <span class="s1">frame.methodName ?? </span><span class="s0">'&lt;unknown&gt;'</span><span class="s1">,</span>
        <span class="s1">ignored,</span>
        <span class="s1">arguments: []</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">frame: ignorableFrame,</span>
        <span class="s1">source</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseFile(fileParam) {</span>
    <span class="s2">if </span><span class="s1">(!fileParam) {</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _sourcemaps.devirtualizeReactServerURL)(fileParam);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createStackFrames(body) {</span>
    <span class="s2">const </span><span class="s1">{ frames, isServer } = body;</span>
    <span class="s2">return </span><span class="s1">frames.map((frame)=&gt;{</span>
        <span class="s2">const </span><span class="s1">file = parseFile(frame.file);</span>
        <span class="s2">if </span><span class="s1">(!file) {</span>
            <span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">file,</span>
            <span class="s1">methodName: frame.methodName ?? </span><span class="s0">'&lt;unknown&gt;'</span><span class="s1">,</span>
            <span class="s1">line: frame.line1 ?? undefined,</span>
            <span class="s1">column: frame.column1 ?? undefined,</span>
            <span class="s1">isServer</span>
        <span class="s1">};</span>
    <span class="s1">}).filter((f)=&gt;f !== undefined);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createStackFrame(searchParams) {</span>
    <span class="s2">const </span><span class="s1">file = parseFile(searchParams.get(</span><span class="s0">'file'</span><span class="s1">));</span>
    <span class="s2">if </span><span class="s1">(!file) {</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">file,</span>
        <span class="s1">methodName: searchParams.get(</span><span class="s0">'methodName'</span><span class="s1">) ?? </span><span class="s0">'&lt;unknown&gt;'</span><span class="s1">,</span>
        <span class="s1">line: parseInt(searchParams.get(</span><span class="s0">'line1'</span><span class="s1">) ?? </span><span class="s0">'0'</span><span class="s1">, </span><span class="s3">10</span><span class="s1">) || undefined,</span>
        <span class="s1">column: parseInt(searchParams.get(</span><span class="s0">'column1'</span><span class="s1">) ?? </span><span class="s0">'0'</span><span class="s1">, </span><span class="s3">10</span><span class="s1">) || undefined,</span>
        <span class="s1">isServer: searchParams.get(</span><span class="s0">'isServer'</span><span class="s1">) === </span><span class="s0">'true'</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* </span><span class="s5">@returns </span><span class="s4">1-based lines and 1-based columns</span>
 <span class="s4">*/ </span><span class="s1">async </span><span class="s2">function </span><span class="s1">nativeTraceSource(frame) {</span>
    <span class="s2">const </span><span class="s1">sourceURL = frame.file;</span>
    <span class="s2">let </span><span class="s1">sourceMapPayload;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_findSourceMap;</span>
        <span class="s1">sourceMapPayload = (_findSourceMap = (</span><span class="s3">0</span><span class="s1">, _nodemodule.findSourceMap)(sourceURL)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _findSourceMap.payload;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(cause) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${sourceURL}</span><span class="s0">: Invalid source map. Only conformant source maps can be used to find the original code.`</span><span class="s1">, {</span>
            <span class="s1">cause</span>
        <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E635&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(sourceMapPayload !== undefined) {</span>
        <span class="s2">let </span><span class="s1">consumer;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">consumer = </span><span class="s2">await new </span><span class="s1">_sourcemap08.SourceMapConsumer(sourceMapPayload);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(cause) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${sourceURL}</span><span class="s0">: Invalid source map. Only conformant source maps can be used to find the original code.`</span><span class="s1">, {</span>
                <span class="s1">cause</span>
            <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E635&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">traced;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">originalPosition = consumer.originalPositionFor({</span>
                <span class="s1">line: frame.line ?? </span><span class="s3">1</span><span class="s1">,</span>
                <span class="s4">// 0-based columns out requires 0-based columns in.</span>
                <span class="s1">column: (frame.column ?? </span><span class="s3">1</span><span class="s1">) - </span><span class="s3">1</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(originalPosition.source === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">traced = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">sourceContent = consumer.sourceContentFor(originalPosition.source, </span><span class="s4">/* returnNullOnMissing */ </span><span class="s2">true</span><span class="s1">) ?? </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">traced = {</span>
                    <span class="s1">originalPosition,</span>
                    <span class="s1">sourceContent</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
            <span class="s1">consumer.destroy();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(traced !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s4">// We ignore the sourcemapped name since it won't be the correct name.</span>
            <span class="s4">// The callsite will point to the column of the variable name instead of the</span>
            <span class="s4">// name of the enclosing function.</span>
            <span class="s4">// TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.</span>
            <span class="s1">_frame_methodName_replace, _frame_methodName;</span>
            <span class="s2">const </span><span class="s1">{ originalPosition, sourceContent } = traced;</span>
            <span class="s2">const </span><span class="s1">applicableSourceMap = (</span><span class="s3">0</span><span class="s1">, _sourcemaps.findApplicableSourceMapPayload)((frame.line ?? </span><span class="s3">1</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">, (frame.column ?? </span><span class="s3">1</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">, sourceMapPayload);</span>
            <span class="s4">// TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.</span>
            <span class="s2">let </span><span class="s1">ignored = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(applicableSourceMap === undefined) {</span>
                <span class="s1">console.error(</span><span class="s0">'No applicable source map found in sections for frame'</span><span class="s1">, frame);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">var </span><span class="s1">_applicableSourceMap_ignoreList;</span>
                <span class="s4">// TODO: O(n^2). Consider moving `ignoreList` into a Set</span>
                <span class="s2">const </span><span class="s1">sourceIndex = applicableSourceMap.sources.indexOf(originalPosition.source);</span>
                <span class="s1">ignored = ((_applicableSourceMap_ignoreList = applicableSourceMap.ignoreList) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _applicableSourceMap_ignoreList.includes(sourceIndex)) ?? </span><span class="s4">// When sourcemap is not available, fallback to checking `frame.file`.</span>
                <span class="s4">// e.g. In pages router, nextjs server code is not bundled into the page.</span>
                <span class="s1">shouldIgnorePath(frame.file);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">originalStackFrame = {</span>
                <span class="s1">methodName: ((_frame_methodName = frame.methodName) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_frame_methodName_replace = _frame_methodName.replace(</span><span class="s0">'__WEBPACK_DEFAULT_EXPORT__'</span><span class="s1">, </span><span class="s0">'default'</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _frame_methodName_replace.replace(</span><span class="s0">'__webpack_exports__.'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">)) || </span><span class="s0">'&lt;unknown&gt;'</span><span class="s1">,</span>
                <span class="s1">file: originalPosition.source,</span>
                <span class="s1">line1: originalPosition.line,</span>
                <span class="s1">column1: originalPosition.column === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: originalPosition.column + </span><span class="s3">1</span><span class="s1">,</span>
                <span class="s4">// TODO: c&amp;p from async createOriginalStackFrame but why not frame.arguments?</span>
                <span class="s1">arguments: [],</span>
                <span class="s1">ignored</span>
            <span class="s1">};</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">frame: originalStackFrame,</span>
                <span class="s1">source: sourceContent</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createOriginalStackFrame(project, projectPath, frame) {</span>
    <span class="s2">const </span><span class="s1">traced = </span><span class="s2">await </span><span class="s1">nativeTraceSource(frame) ?? </span><span class="s4">// TODO(veil): When would the bundler know more than native?</span>
    <span class="s4">// If it's faster, try the bundler first and fall back to native later.</span>
    <span class="s2">await </span><span class="s1">batchedTraceSource(project, frame);</span>
    <span class="s2">if </span><span class="s1">(!traced) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">normalizedStackFrameLocation = traced.frame.file;</span>
    <span class="s2">if </span><span class="s1">(normalizedStackFrameLocation !== </span><span class="s2">null </span><span class="s1">&amp;&amp; normalizedStackFrameLocation.startsWith(</span><span class="s0">'file://'</span><span class="s1">)) {</span>
        <span class="s1">normalizedStackFrameLocation = _path.default.relative(projectPath, (</span><span class="s3">0</span><span class="s1">, _nodeurl.fileURLToPath)(normalizedStackFrameLocation));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">originalStackFrame: {</span>
            <span class="s1">arguments: traced.frame.arguments,</span>
            <span class="s1">file: normalizedStackFrameLocation,</span>
            <span class="s1">line1: traced.frame.line1,</span>
            <span class="s1">column1: traced.frame.column1,</span>
            <span class="s1">ignored: traced.frame.ignored,</span>
            <span class="s1">methodName: traced.frame.methodName</span>
        <span class="s1">},</span>
        <span class="s1">originalCodeFrame: (</span><span class="s3">0</span><span class="s1">, _shared.getOriginalCodeFrame)(traced.frame, traced.source)</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getOverlayMiddleware({ project, projectPath, isSrcDir }) {</span>
    <span class="s2">return </span><span class="s1">async </span><span class="s2">function</span><span class="s1">(req, res, next) {</span>
        <span class="s2">const </span><span class="s1">{ pathname, searchParams } = </span><span class="s2">new </span><span class="s1">URL(req.url, </span><span class="s0">'http://n'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(pathname === </span><span class="s0">'/__nextjs_original-stack-frames'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(req.method !== </span><span class="s0">'POST'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.badRequest(res);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">body = </span><span class="s2">await new </span><span class="s1">Promise((resolve, reject)=&gt;{</span>
                <span class="s2">let </span><span class="s1">data = </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s1">req.on(</span><span class="s0">'data'</span><span class="s1">, (chunk)=&gt;{</span>
                    <span class="s1">data += chunk;</span>
                <span class="s1">});</span>
                <span class="s1">req.on(</span><span class="s0">'end'</span><span class="s1">, ()=&gt;resolve(data));</span>
                <span class="s1">req.on(</span><span class="s0">'error'</span><span class="s1">, reject);</span>
            <span class="s1">});</span>
            <span class="s2">const </span><span class="s1">request = JSON.parse(body);</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">getOriginalStackFrames({</span>
                <span class="s1">project,</span>
                <span class="s1">projectPath,</span>
                <span class="s1">frames: request.frames,</span>
                <span class="s1">isServer: request.isServer,</span>
                <span class="s1">isEdgeServer: request.isEdgeServer,</span>
                <span class="s1">isAppDirectory: request.isAppDirectory</span>
            <span class="s1">});</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _shared.ignoreListAnonymousStackFramesIfSandwiched)(result);</span>
            <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.json(res, result);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(pathname === </span><span class="s0">'/__nextjs_launch-editor'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">isAppRelativePath = searchParams.get(</span><span class="s0">'isAppRelativePath'</span><span class="s1">) === </span><span class="s0">'1'</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">openEditorResult;</span>
            <span class="s2">if </span><span class="s1">(isAppRelativePath) {</span>
                <span class="s2">const </span><span class="s1">relativeFilePath = searchParams.get(</span><span class="s0">'file'</span><span class="s1">) || </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">appPath = _path.default.join(</span><span class="s0">'app'</span><span class="s1">, isSrcDir ? </span><span class="s0">'src' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">, relativeFilePath);</span>
                <span class="s1">openEditorResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _launcheditor.openFileInEditor)(appPath, </span><span class="s3">1</span><span class="s1">, </span><span class="s3">1</span><span class="s1">, projectPath);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">frame = createStackFrame(searchParams);</span>
                <span class="s2">if </span><span class="s1">(!frame) </span><span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.badRequest(res);</span>
                <span class="s1">openEditorResult = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _launcheditor.openFileInEditor)(frame.file, frame.line ?? </span><span class="s3">1</span><span class="s1">, frame.column ?? </span><span class="s3">1</span><span class="s1">, projectPath);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(openEditorResult.error) {</span>
                <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.internalServerError(res, openEditorResult.error);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!openEditorResult.found) {</span>
                <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.notFound(res);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.noContent(res);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">next();</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSourceMapMiddleware(project) {</span>
    <span class="s2">return </span><span class="s1">async </span><span class="s2">function</span><span class="s1">(req, res, next) {</span>
        <span class="s2">const </span><span class="s1">{ pathname, searchParams } = </span><span class="s2">new </span><span class="s1">URL(req.url, </span><span class="s0">'http://n'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(pathname !== </span><span class="s0">'/__nextjs_source-map'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">next();</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">filename = searchParams.get(</span><span class="s0">'filename'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!filename) {</span>
            <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.badRequest(res);</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">nativeSourceMap;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">nativeSourceMap = (</span><span class="s3">0</span><span class="s1">, _nodemodule.findSourceMap)(filename);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(cause) {</span>
            <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.internalServerError(res, Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${filename}</span><span class="s0">: Invalid source map. Only conformant source maps can be used to find the original code.`</span><span class="s1">, {</span>
                <span class="s1">cause</span>
            <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E635&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(nativeSourceMap !== undefined) {</span>
            <span class="s2">const </span><span class="s1">sourceMapPayload = nativeSourceMap.payload;</span>
            <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.json(res, sourceMapPayload);</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s4">// Turbopack chunk filenames might be URL-encoded.</span>
            <span class="s1">filename = decodeURI(filename);</span>
        <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.badRequest(res);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(_path.default.isAbsolute(filename)) {</span>
            <span class="s1">filename = (</span><span class="s3">0</span><span class="s1">, _nodeurl.pathToFileURL)(filename).href;</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">sourceMapString = </span><span class="s2">await </span><span class="s1">project.getSourceMap(filename);</span>
            <span class="s2">if </span><span class="s1">(sourceMapString) {</span>
                <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.jsonString(res, sourceMapString);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(cause) {</span>
            <span class="s2">return </span><span class="s1">_middlewareresponse.middlewareResponse.internalServerError(res, Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Failed to get source map for '</span><span class="s1">${filename}</span><span class="s0">'. This is a bug in Next.js`</span><span class="s1">, {</span>
                <span class="s1">cause</span>
            <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E719&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
        <span class="s1">_middlewareresponse.middlewareResponse.noContent(res);</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getOriginalStackFrames({ project, projectPath, frames, isServer, isEdgeServer, isAppDirectory }) {</span>
    <span class="s2">const </span><span class="s1">stackFrames = createStackFrames({</span>
        <span class="s1">frames,</span>
        <span class="s1">isServer,</span>
        <span class="s1">isEdgeServer,</span>
        <span class="s1">isAppDirectory</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">Promise.all(stackFrames.map(async (frame)=&gt;{</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">stackFrame = </span><span class="s2">await </span><span class="s1">createOriginalStackFrame(project, projectPath, frame);</span>
            <span class="s2">if </span><span class="s1">(stackFrame === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">status: </span><span class="s0">'rejected'</span><span class="s1">,</span>
                    <span class="s1">reason: </span><span class="s0">'Failed to create original stack frame'</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">status: </span><span class="s0">'fulfilled'</span><span class="s1">,</span>
                <span class="s1">value: stackFrame</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">status: </span><span class="s0">'rejected'</span><span class="s1">,</span>
                <span class="s1">reason: (</span><span class="s3">0</span><span class="s1">, _nodeutil.inspect)(error, {</span>
                    <span class="s1">colors: </span><span class="s2">false</span>
                <span class="s1">})</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">}));</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=middleware-turbopack.js.map</span></pre>
</body>
</html>