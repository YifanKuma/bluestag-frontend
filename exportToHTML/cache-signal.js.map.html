<html>
<head>
<title>cache-signal.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cache-signal.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/cache-signal.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This class is used to detect when all cache reads for a given render are settled.</span><span class="s3">\n </span><span class="s1">* We do this to allow for cache warming the prerender without having to continue rendering</span><span class="s3">\n </span><span class="s1">* the remainder of the page. This feature is really only useful when the cacheComponents flag is on</span><span class="s3">\n </span><span class="s1">* and should only be used in codepaths gated with this feature.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">export class CacheSignal {</span><span class="s3">\n  </span><span class="s1">private count = 0</span><span class="s3">\n  </span><span class="s1">private earlyListeners: Array&lt;() =&gt; void&gt; = []</span><span class="s3">\n  </span><span class="s1">private listeners: Array&lt;() =&gt; void&gt; = []</span><span class="s3">\n  </span><span class="s1">private tickPending = false</span><span class="s3">\n  </span><span class="s1">private taskPending = false</span><span class="s3">\n\n  </span><span class="s1">private subscribedSignals: Set&lt;CacheSignal&gt; | null = null</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">// we rely on `process.nextTick`, which is not supported in edge</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">'CacheSignal cannot be used in the edge runtime, because `cacheComponents` does not support it.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private noMorePendingCaches() {</span><span class="s3">\n    </span><span class="s1">if (!this.tickPending) {</span><span class="s3">\n      </span><span class="s1">this.tickPending = true</span><span class="s3">\n      </span><span class="s1">process.nextTick(() =&gt; {</span><span class="s3">\n        </span><span class="s1">this.tickPending = false</span><span class="s3">\n        </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n          </span><span class="s1">for (let i = 0; i &lt; this.earlyListeners.length; i++) {</span><span class="s3">\n            </span><span class="s1">this.earlyListeners[i]()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.earlyListeners.length = 0</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!this.taskPending) {</span><span class="s3">\n      </span><span class="s1">this.taskPending = true</span><span class="s3">\n      </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">this.taskPending = false</span><span class="s3">\n        </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n          </span><span class="s1">for (let i = 0; i &lt; this.listeners.length; i++) {</span><span class="s3">\n            </span><span class="s1">this.listeners[i]()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.listeners.length = 0</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, 0)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This promise waits until there are no more in progress cache reads but no later.</span><span class="s3">\n   </span><span class="s1">* This allows for adding more cache reads after to delay cacheReady.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">inputReady() {</span><span class="s3">\n    </span><span class="s1">return new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.earlyListeners.push(resolve)</span><span class="s3">\n      </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n        </span><span class="s1">this.noMorePendingCaches()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If there are inflight cache reads this Promise can resolve in a microtask however</span><span class="s3">\n   </span><span class="s1">* if there are no inflight cache reads then we wait at least one task to allow initial</span><span class="s3">\n   </span><span class="s1">* cache reads to be initiated.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cacheReady() {</span><span class="s3">\n    </span><span class="s1">return new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.listeners.push(resolve)</span><span class="s3">\n      </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n        </span><span class="s1">this.noMorePendingCaches()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">beginRead() {</span><span class="s3">\n    </span><span class="s1">this.count++</span><span class="s3">\n\n    </span><span class="s1">if (this.subscribedSignals !== null) {</span><span class="s3">\n      </span><span class="s1">for (const subscriber of this.subscribedSignals) {</span><span class="s3">\n        </span><span class="s1">subscriber.beginRead()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">endRead() {</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">'CacheSignal got more endRead() calls than beginRead() calls'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If this is the last read we need to wait a task before we can claim the cache is settled.</span><span class="s3">\n    </span><span class="s1">// The cache read will likely ping a Server Component which can read from the cache again and this</span><span class="s3">\n    </span><span class="s1">// will play out in a microtask so we need to only resolve pending listeners if we're still at 0</span><span class="s3">\n    </span><span class="s1">// after at least one task.</span><span class="s3">\n    </span><span class="s1">// We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.</span><span class="s3">\n    </span><span class="s1">// If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency</span><span class="s3">\n    </span><span class="s1">this.count--</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">this.noMorePendingCaches()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.subscribedSignals !== null) {</span><span class="s3">\n      </span><span class="s1">for (const subscriber of this.subscribedSignals) {</span><span class="s3">\n        </span><span class="s1">subscriber.endRead()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">trackRead&lt;T&gt;(promise: Promise&lt;T&gt;) {</span><span class="s3">\n    </span><span class="s1">this.beginRead()</span><span class="s3">\n    </span><span class="s1">// `promise.finally()` still rejects, so don't use it here to avoid unhandled rejections</span><span class="s3">\n    </span><span class="s1">const onFinally = this.endRead.bind(this)</span><span class="s3">\n    </span><span class="s1">promise.then(onFinally, onFinally)</span><span class="s3">\n    </span><span class="s1">return promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">subscribeToReads(subscriber: CacheSignal): () =&gt; void {</span><span class="s3">\n    </span><span class="s1">if (subscriber === this) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError('A CacheSignal cannot subscribe to itself')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.subscribedSignals === null) {</span><span class="s3">\n      </span><span class="s1">this.subscribedSignals = new Set()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.subscribedSignals.add(subscriber)</span><span class="s3">\n\n    </span><span class="s1">// we'll notify the subscriber of each endRead() on this signal,</span><span class="s3">\n    </span><span class="s1">// so we need to give it a corresponding beginRead() for each read we have in flight now.</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; this.count; i++) {</span><span class="s3">\n      </span><span class="s1">subscriber.beginRead()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.unsubscribeFromReads.bind(this, subscriber)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">unsubscribeFromReads(subscriber: CacheSignal) {</span><span class="s3">\n    </span><span class="s1">if (!this.subscribedSignals) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.subscribedSignals.delete(subscriber)</span><span class="s3">\n\n    </span><span class="s1">// we don't need to set the set back to `null` if it's empty --</span><span class="s3">\n    </span><span class="s1">// if other signals are subscribing to this one, it'll likely get more subscriptions later,</span><span class="s3">\n    </span><span class="s1">// so we'd have to allocate a fresh set again when that happens.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;CacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;earlyListeners&quot;</span><span class="s0">,</span><span class="s1">&quot;listeners&quot;</span><span class="s0">,</span><span class="s1">&quot;tickPending&quot;</span><span class="s0">,</span><span class="s1">&quot;taskPending&quot;</span><span class="s0">,</span><span class="s1">&quot;subscribedSignals&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;noMorePendingCaches&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;inputReady&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheReady&quot;</span><span class="s0">,</span><span class="s1">&quot;beginRead&quot;</span><span class="s0">,</span><span class="s1">&quot;subscriber&quot;</span><span class="s0">,</span><span class="s1">&quot;endRead&quot;</span><span class="s0">,</span><span class="s1">&quot;trackRead&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;onFinally&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;subscribeToReads&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;unsubscribeFromReads&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>