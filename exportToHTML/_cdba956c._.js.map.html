<html>
<head>
<title>_cdba956c._.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_cdba956c._.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span>
  <span class="s1">&quot;version&quot;</span><span class="s0">: </span><span class="s2">3</span><span class="s0">,</span>
  <span class="s1">&quot;sources&quot;</span><span class="s0">: [],</span>
  <span class="s1">&quot;sections&quot;</span><span class="s0">: [</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">13</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/shared/runtime-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This file contains runtime types and functions that are shared between all</span><span class="s3">\n </span><span class="s1">* TurboPack ECMAScript runtimes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It will be prepended to the runtime code of each runtime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">./runtime-types.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">type EsmNamespaceObject = Record&lt;string, any&gt;</span><span class="s3">\n\n</span><span class="s1">// @ts-ignore Defined in `dev-base.ts`</span><span class="s3">\n</span><span class="s1">declare function getOrInstantiateModuleFromParent&lt;M&gt;(</span><span class="s3">\n  </span><span class="s1">id: ModuleId,</span><span class="s3">\n  </span><span class="s1">sourceModule: M</span><span class="s3">\n</span><span class="s1">): M</span><span class="s3">\n\n</span><span class="s1">const REEXPORTED_OBJECTS = new WeakMap&lt;Module, ReexportedObjects&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Constructs the `__turbopack_context__` object for a module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Context(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">module: Module,</span><span class="s3">\n  </span><span class="s1">exports: Exports</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.m = module</span><span class="s3">\n  </span><span class="s1">// We need to store this here instead of accessing it from the module object to:</span><span class="s3">\n  </span><span class="s1">// 1. Make it available to factories directly, since we rewrite `this` to</span><span class="s3">\n  </span><span class="s1">//    `__turbopack_context__.e` in CJS modules.</span><span class="s3">\n  </span><span class="s1">// 2. Support async modules which rewrite `module.exports` to a promise, so we</span><span class="s3">\n  </span><span class="s1">//    can still access the original exports object from functions like</span><span class="s3">\n  </span><span class="s1">//    `esmExport`</span><span class="s3">\n  </span><span class="s1">// Ideally we could find a new approach for async modules and drop this property altogether.</span><span class="s3">\n  </span><span class="s1">this.e = exports</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const contextPrototype = Context.prototype as TurbopackBaseContext&lt;Module&gt;</span><span class="s3">\n\n</span><span class="s1">type ModuleContextMap = Record&lt;ModuleId, ModuleContextEntry&gt;</span><span class="s3">\n\n</span><span class="s1">interface ModuleContextEntry {</span><span class="s3">\n  </span><span class="s1">id: () =&gt; ModuleId</span><span class="s3">\n  </span><span class="s1">module: () =&gt; any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ModuleContext {</span><span class="s3">\n  </span><span class="s1">// require call</span><span class="s3">\n  </span><span class="s1">(moduleId: ModuleId): Exports | EsmNamespaceObject</span><span class="s3">\n\n  </span><span class="s1">// async import call</span><span class="s3">\n  </span><span class="s1">import(moduleId: ModuleId): Promise&lt;Exports | EsmNamespaceObject&gt;</span><span class="s3">\n\n  </span><span class="s1">keys(): ModuleId[]</span><span class="s3">\n\n  </span><span class="s1">resolve(moduleId: ModuleId): ModuleId</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetOrInstantiateModuleFromParent&lt;M extends Module&gt; = (</span><span class="s3">\n  </span><span class="s1">moduleId: M['id'],</span><span class="s3">\n  </span><span class="s1">parentModule: M</span><span class="s3">\n</span><span class="s1">) =&gt; M</span><span class="s3">\n\n</span><span class="s1">declare function getOrInstantiateRuntimeModule(</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n</span><span class="s1">): Module</span><span class="s3">\n\n</span><span class="s1">const hasOwnProperty = Object.prototype.hasOwnProperty</span><span class="s3">\n</span><span class="s1">const toStringTag = typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag</span><span class="s3">\n\n</span><span class="s1">function defineProp(</span><span class="s3">\n  </span><span class="s1">obj: any,</span><span class="s3">\n  </span><span class="s1">name: PropertyKey,</span><span class="s3">\n  </span><span class="s1">options: PropertyDescriptor &amp; ThisType&lt;any&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getOverwrittenModule(</span><span class="s3">\n  </span><span class="s1">moduleCache: ModuleCache&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">let module = moduleCache[id]</span><span class="s3">\n  </span><span class="s1">if (!module) {</span><span class="s3">\n    </span><span class="s1">// This is invoked when a module is merged into another module, thus it wasn't invoked via</span><span class="s3">\n    </span><span class="s1">// instantiateModule and the cache entry wasn't created yet.</span><span class="s3">\n    </span><span class="s1">module = createModuleObject(id)</span><span class="s3">\n    </span><span class="s1">moduleCache[id] = module</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return module</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates the module object. Only done here to ensure all module objects have the same shape.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createModuleObject(id: ModuleId): Module {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">exports: {},</span><span class="s3">\n    </span><span class="s1">error: undefined,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">namespaceObject: undefined,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds the getters to the exports object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function esm(</span><span class="s3">\n  </span><span class="s1">exports: Exports,</span><span class="s3">\n  </span><span class="s1">getters: Array&lt;string | (() =&gt; unknown) | ((v: unknown) =&gt; void)&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">defineProp(exports, '__esModule', { value: true })</span><span class="s3">\n  </span><span class="s1">if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n  </span><span class="s1">while (i &lt; getters.length) {</span><span class="s3">\n    </span><span class="s1">const propName = getters[i++] as string</span><span class="s3">\n    </span><span class="s1">// TODO(luke.sandberg): we could support raw values here, but would need a discriminator beyond 'not a function'</span><span class="s3">\n    </span><span class="s1">const getter = getters[i++] as () =&gt; unknown</span><span class="s3">\n    </span><span class="s1">if (typeof getters[i] === 'function') {</span><span class="s3">\n      </span><span class="s1">// a setter</span><span class="s3">\n      </span><span class="s1">defineProp(exports, propName, {</span><span class="s3">\n        </span><span class="s1">get: getter,</span><span class="s3">\n        </span><span class="s1">set: getters[i++] as (v: unknown) =&gt; void,</span><span class="s3">\n        </span><span class="s1">enumerable: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">defineProp(exports, propName, { get: getter, enumerable: true })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">Object.seal(exports)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Makes the module an ESM with exports</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function esmExport(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">getters: Array&lt;string | (() =&gt; unknown) | ((v: unknown) =&gt; void)&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let module: Module</span><span class="s3">\n  </span><span class="s1">let exports: Module['exports']</span><span class="s3">\n  </span><span class="s1">if (id != null) {</span><span class="s3">\n    </span><span class="s1">module = getOverwrittenModule(this.c, id)</span><span class="s3">\n    </span><span class="s1">exports = module.exports</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">module = this.m</span><span class="s3">\n    </span><span class="s1">exports = this.e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">module.namespaceObject = exports</span><span class="s3">\n  </span><span class="s1">esm(exports, getters)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.s = esmExport</span><span class="s3">\n\n</span><span class="s1">type ReexportedObjects = Record&lt;PropertyKey, unknown&gt;[]</span><span class="s3">\n</span><span class="s1">function ensureDynamicExports(</span><span class="s3">\n  </span><span class="s1">module: Module,</span><span class="s3">\n  </span><span class="s1">exports: Exports</span><span class="s3">\n</span><span class="s1">): ReexportedObjects {</span><span class="s3">\n  </span><span class="s1">let reexportedObjects: ReexportedObjects | undefined =</span><span class="s3">\n    </span><span class="s1">REEXPORTED_OBJECTS.get(module)</span><span class="s3">\n\n  </span><span class="s1">if (!reexportedObjects) {</span><span class="s3">\n    </span><span class="s1">REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))</span><span class="s3">\n    </span><span class="s1">module.exports = module.namespaceObject = new Proxy(exports, {</span><span class="s3">\n      </span><span class="s1">get(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">hasOwnProperty.call(target, prop) ||</span><span class="s3">\n          </span><span class="s1">prop === 'default' ||</span><span class="s3">\n          </span><span class="s1">prop === '__esModule'</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">return Reflect.get(target, prop)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const obj of reexportedObjects!) {</span><span class="s3">\n          </span><span class="s1">const value = Reflect.get(obj, prop)</span><span class="s3">\n          </span><span class="s1">if (value !== undefined) return value</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">ownKeys(target) {</span><span class="s3">\n        </span><span class="s1">const keys = Reflect.ownKeys(target)</span><span class="s3">\n        </span><span class="s1">for (const obj of reexportedObjects!) {</span><span class="s3">\n          </span><span class="s1">for (const key of Reflect.ownKeys(obj)) {</span><span class="s3">\n            </span><span class="s1">if (key !== 'default' &amp;&amp; !keys.includes(key)) keys.push(key)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return keys</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return reexportedObjects</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Dynamically exports properties from an object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function dynamicExport(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">object: Record&lt;string, any&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let module: Module</span><span class="s3">\n  </span><span class="s1">let exports: Module['exports']</span><span class="s3">\n  </span><span class="s1">if (id != null) {</span><span class="s3">\n    </span><span class="s1">module = getOverwrittenModule(this.c, id)</span><span class="s3">\n    </span><span class="s1">exports = module.exports</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">module = this.m</span><span class="s3">\n    </span><span class="s1">exports = this.e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const reexportedObjects = ensureDynamicExports(module, exports)</span><span class="s3">\n\n  </span><span class="s1">if (typeof object === 'object' &amp;&amp; object !== null) {</span><span class="s3">\n    </span><span class="s1">reexportedObjects.push(object)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.j = dynamicExport</span><span class="s3">\n\n</span><span class="s1">function exportValue(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">value: any,</span><span class="s3">\n  </span><span class="s1">id: ModuleId | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let module: Module</span><span class="s3">\n  </span><span class="s1">if (id != null) {</span><span class="s3">\n    </span><span class="s1">module = getOverwrittenModule(this.c, id)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">module = this.m</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">module.exports = value</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.v = exportValue</span><span class="s3">\n\n</span><span class="s1">function exportNamespace(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">namespace: any,</span><span class="s3">\n  </span><span class="s1">id: ModuleId | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let module: Module</span><span class="s3">\n  </span><span class="s1">if (id != null) {</span><span class="s3">\n    </span><span class="s1">module = getOverwrittenModule(this.c, id)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">module = this.m</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">module.exports = module.namespaceObject = namespace</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.n = exportNamespace</span><span class="s3">\n\n</span><span class="s1">function createGetter(obj: Record&lt;string | symbol, any&gt;, key: string | symbol) {</span><span class="s3">\n  </span><span class="s1">return () =&gt; obj[key]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @returns prototype of the object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getProto: (obj: any) =&gt; any = Object.getPrototypeOf</span><span class="s3">\n  </span><span class="s1">? (obj) =&gt; Object.getPrototypeOf(obj)</span><span class="s3">\n  </span><span class="s1">: (obj) =&gt; obj.__proto__</span><span class="s3">\n\n</span><span class="s1">/** Prototypes that are not expanded for exports */</span><span class="s3">\n</span><span class="s1">const LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param raw</span><span class="s3">\n </span><span class="s1">* @param ns</span><span class="s3">\n </span><span class="s1">* @param allowExportDefault</span><span class="s3">\n </span><span class="s1">*   * `false`: will have the raw module as default export</span><span class="s3">\n </span><span class="s1">*   * `true`: will have the default property as default export</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function interopEsm(</span><span class="s3">\n  </span><span class="s1">raw: Exports,</span><span class="s3">\n  </span><span class="s1">ns: EsmNamespaceObject,</span><span class="s3">\n  </span><span class="s1">allowExportDefault?: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const getters: Array&lt;string | (() =&gt; unknown) | ((v: unknown) =&gt; void)&gt; = []</span><span class="s3">\n  </span><span class="s1">// The index of the `default` export if any</span><span class="s3">\n  </span><span class="s1">let defaultLocation = -1</span><span class="s3">\n  </span><span class="s1">for (</span><span class="s3">\n    </span><span class="s1">let current = raw;</span><span class="s3">\n    </span><span class="s1">(typeof current === 'object' || typeof current === 'function') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!LEAF_PROTOTYPES.includes(current);</span><span class="s3">\n    </span><span class="s1">current = getProto(current)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.getOwnPropertyNames(current)) {</span><span class="s3">\n      </span><span class="s1">getters.push(key, createGetter(raw, key))</span><span class="s3">\n      </span><span class="s1">if (defaultLocation === -1 &amp;&amp; key === 'default') {</span><span class="s3">\n        </span><span class="s1">defaultLocation = getters.length - 1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// this is not really correct</span><span class="s3">\n  </span><span class="s1">// we should set the `default` getter if the imported module is a `.cjs file`</span><span class="s3">\n  </span><span class="s1">if (!(allowExportDefault &amp;&amp; defaultLocation &gt;= 0)) {</span><span class="s3">\n    </span><span class="s1">// Replace the binding with one for the namespace itself in order to preserve iteration order.</span><span class="s3">\n    </span><span class="s1">if (defaultLocation &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">getters[defaultLocation] = () =&gt; raw</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">getters.push('default', () =&gt; raw)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">esm(ns, getters)</span><span class="s3">\n  </span><span class="s1">return ns</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createNS(raw: Module['exports']): EsmNamespaceObject {</span><span class="s3">\n  </span><span class="s1">if (typeof raw === 'function') {</span><span class="s3">\n    </span><span class="s1">return function (this: any, ...args: any[]) {</span><span class="s3">\n      </span><span class="s1">return raw.apply(this, args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return Object.create(null)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function esmImport(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId</span><span class="s3">\n</span><span class="s1">): Exclude&lt;Module['namespaceObject'], undefined&gt; {</span><span class="s3">\n  </span><span class="s1">const module = getOrInstantiateModuleFromParent(id, this.m)</span><span class="s3">\n\n  </span><span class="s1">// any ES module has to have `module.namespaceObject` defined.</span><span class="s3">\n  </span><span class="s1">if (module.namespaceObject) return module.namespaceObject</span><span class="s3">\n\n  </span><span class="s1">// only ESM can be an async module, so we don't need to worry about exports being a promise here.</span><span class="s3">\n  </span><span class="s1">const raw = module.exports</span><span class="s3">\n  </span><span class="s1">return (module.namespaceObject = interopEsm(</span><span class="s3">\n    </span><span class="s1">raw,</span><span class="s3">\n    </span><span class="s1">createNS(raw),</span><span class="s3">\n    </span><span class="s1">raw &amp;&amp; (raw as any).__esModule</span><span class="s3">\n  </span><span class="s1">))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.i = esmImport</span><span class="s3">\n\n</span><span class="s1">function asyncLoader(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n</span><span class="s1">): Promise&lt;Exports&gt; {</span><span class="s3">\n  </span><span class="s1">const loader = this.r(moduleId) as (</span><span class="s3">\n    </span><span class="s1">importFunction: EsmImport</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;Exports&gt;</span><span class="s3">\n  </span><span class="s1">return loader(this.i.bind(this))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.A = asyncLoader</span><span class="s3">\n\n</span><span class="s1">// Add a simple runtime require so that environments without one can still pass</span><span class="s3">\n</span><span class="s1">// `typeof require` CommonJS checks so that exports are correctly registered.</span><span class="s3">\n</span><span class="s1">const runtimeRequire =</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">typeof require === 'function'</span><span class="s3">\n    </span><span class="s1">? // @ts-ignore</span><span class="s3">\n      </span><span class="s1">require</span><span class="s3">\n    </span><span class="s1">: function require() {</span><span class="s3">\n        </span><span class="s1">throw new Error('Unexpected use of runtime require')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.t = runtimeRequire</span><span class="s3">\n\n</span><span class="s1">function commonJsRequire(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">id: ModuleId</span><span class="s3">\n</span><span class="s1">): Exports {</span><span class="s3">\n  </span><span class="s1">return getOrInstantiateModuleFromParent(id, this.m).exports</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.r = commonJsRequire</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* `require.context` and require/import expression runtime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function moduleContext(map: ModuleContextMap): ModuleContext {</span><span class="s3">\n  </span><span class="s1">function moduleContext(id: ModuleId): Exports {</span><span class="s3">\n    </span><span class="s1">if (hasOwnProperty.call(map, id)) {</span><span class="s3">\n      </span><span class="s1">return map[id].module()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const e = new Error(`Cannot find module '${id}'`)</span><span class="s3">\n    </span><span class="s1">;(e as any).code = 'MODULE_NOT_FOUND'</span><span class="s3">\n    </span><span class="s1">throw e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">moduleContext.keys = (): ModuleId[] =&gt; {</span><span class="s3">\n    </span><span class="s1">return Object.keys(map)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">moduleContext.resolve = (id: ModuleId): ModuleId =&gt; {</span><span class="s3">\n    </span><span class="s1">if (hasOwnProperty.call(map, id)) {</span><span class="s3">\n      </span><span class="s1">return map[id].id()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const e = new Error(`Cannot find module '${id}'`)</span><span class="s3">\n    </span><span class="s1">;(e as any).code = 'MODULE_NOT_FOUND'</span><span class="s3">\n    </span><span class="s1">throw e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">moduleContext.import = async (id: ModuleId) =&gt; {</span><span class="s3">\n    </span><span class="s1">return await (moduleContext(id) as Promise&lt;Exports&gt;)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return moduleContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.f = moduleContext</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the path of a chunk defined by its data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getChunkPath(chunkData: ChunkData): ChunkPath {</span><span class="s3">\n  </span><span class="s1">return typeof chunkData === 'string' ? chunkData : chunkData.path</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isPromise&lt;T = any&gt;(maybePromise: any): maybePromise is Promise&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">maybePromise != null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof maybePromise === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">'then' in maybePromise &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof maybePromise.then === 'function'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isAsyncModuleExt&lt;T extends {}&gt;(obj: T): obj is AsyncModuleExt &amp; T {</span><span class="s3">\n  </span><span class="s1">return turbopackQueues in obj</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPromise&lt;T&gt;() {</span><span class="s3">\n  </span><span class="s1">let resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">let reject: (reason?: any) =&gt; void</span><span class="s3">\n\n  </span><span class="s1">const promise = new Promise&lt;T&gt;((res, rej) =&gt; {</span><span class="s3">\n    </span><span class="s1">reject = rej</span><span class="s3">\n    </span><span class="s1">resolve = res</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">promise,</span><span class="s3">\n    </span><span class="s1">resolve: resolve!,</span><span class="s3">\n    </span><span class="s1">reject: reject!,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.</span><span class="s3">\n</span><span class="s1">// The CompressedModuleFactories format is</span><span class="s3">\n</span><span class="s1">// - 1 or more module ids</span><span class="s3">\n</span><span class="s1">// - a module factory function</span><span class="s3">\n</span><span class="s1">// So walking this is a little complex but the flat structure is also fast to</span><span class="s3">\n</span><span class="s1">// traverse, we can use `typeof` operators to distinguish the two cases.</span><span class="s3">\n</span><span class="s1">function installCompressedModuleFactories(</span><span class="s3">\n  </span><span class="s1">chunkModules: CompressedModuleFactories,</span><span class="s3">\n  </span><span class="s1">offset: number,</span><span class="s3">\n  </span><span class="s1">moduleFactories: ModuleFactories,</span><span class="s3">\n  </span><span class="s1">newModuleId?: (id: ModuleId) =&gt; void</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let i = offset</span><span class="s3">\n  </span><span class="s1">while (i &lt; chunkModules.length) {</span><span class="s3">\n    </span><span class="s1">let moduleId = chunkModules[i] as ModuleId</span><span class="s3">\n    </span><span class="s1">let end = i + 1</span><span class="s3">\n    </span><span class="s1">// Find our factory function</span><span class="s3">\n    </span><span class="s1">while (</span><span class="s3">\n      </span><span class="s1">end &lt; chunkModules.length &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof chunkModules[end] !== 'function'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">end++</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end === chunkModules.length) {</span><span class="s3">\n      </span><span class="s1">throw new Error('malformed chunk format, expected a factory function')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Each chunk item has a 'primary id' and optional additional ids. If the primary id is already</span><span class="s3">\n    </span><span class="s1">// present we know all the additional ids are also present, so we don't need to check.</span><span class="s3">\n    </span><span class="s1">if (!moduleFactories.has(moduleId)) {</span><span class="s3">\n      </span><span class="s1">const moduleFactoryFn = chunkModules[end] as Function</span><span class="s3">\n      </span><span class="s1">applyModuleFactoryName(moduleFactoryFn)</span><span class="s3">\n      </span><span class="s1">newModuleId?.(moduleId)</span><span class="s3">\n      </span><span class="s1">for (; i &lt; end; i++) {</span><span class="s3">\n        </span><span class="s1">moduleId = chunkModules[i] as ModuleId</span><span class="s3">\n        </span><span class="s1">moduleFactories.set(moduleId, moduleFactoryFn)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// everything below is adapted from webpack</span><span class="s3">\n</span><span class="s1">// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13</span><span class="s3">\n\n</span><span class="s1">const turbopackQueues = Symbol('turbopack queues')</span><span class="s3">\n</span><span class="s1">const turbopackExports = Symbol('turbopack exports')</span><span class="s3">\n</span><span class="s1">const turbopackError = Symbol('turbopack error')</span><span class="s3">\n\n</span><span class="s1">const enum QueueStatus {</span><span class="s3">\n  </span><span class="s1">Unknown = -1,</span><span class="s3">\n  </span><span class="s1">Unresolved = 0,</span><span class="s3">\n  </span><span class="s1">Resolved = 1,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AsyncQueueFn = (() =&gt; void) &amp; { queueCount: number }</span><span class="s3">\n</span><span class="s1">type AsyncQueue = AsyncQueueFn[] &amp; {</span><span class="s3">\n  </span><span class="s1">status: QueueStatus</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveQueue(queue?: AsyncQueue) {</span><span class="s3">\n  </span><span class="s1">if (queue &amp;&amp; queue.status !== QueueStatus.Resolved) {</span><span class="s3">\n    </span><span class="s1">queue.status = QueueStatus.Resolved</span><span class="s3">\n    </span><span class="s1">queue.forEach((fn) =&gt; fn.queueCount--)</span><span class="s3">\n    </span><span class="s1">queue.forEach((fn) =&gt; (fn.queueCount-- ? fn.queueCount++ : fn()))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type Dep = Exports | AsyncModulePromise | Promise&lt;Exports&gt;</span><span class="s3">\n\n</span><span class="s1">type AsyncModuleExt = {</span><span class="s3">\n  </span><span class="s1">[turbopackQueues]: (fn: (queue: AsyncQueue) =&gt; void) =&gt; void</span><span class="s3">\n  </span><span class="s1">[turbopackExports]: Exports</span><span class="s3">\n  </span><span class="s1">[turbopackError]?: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type AsyncModulePromise&lt;T = Exports&gt; = Promise&lt;T&gt; &amp; AsyncModuleExt</span><span class="s3">\n\n</span><span class="s1">function wrapDeps(deps: Dep[]): AsyncModuleExt[] {</span><span class="s3">\n  </span><span class="s1">return deps.map((dep): AsyncModuleExt =&gt; {</span><span class="s3">\n    </span><span class="s1">if (dep !== null &amp;&amp; typeof dep === 'object') {</span><span class="s3">\n      </span><span class="s1">if (isAsyncModuleExt(dep)) return dep</span><span class="s3">\n      </span><span class="s1">if (isPromise(dep)) {</span><span class="s3">\n        </span><span class="s1">const queue: AsyncQueue = Object.assign([], {</span><span class="s3">\n          </span><span class="s1">status: QueueStatus.Unresolved,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">const obj: AsyncModuleExt = {</span><span class="s3">\n          </span><span class="s1">[turbopackExports]: {},</span><span class="s3">\n          </span><span class="s1">[turbopackQueues]: (fn: (queue: AsyncQueue) =&gt; void) =&gt; fn(queue),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">dep.then(</span><span class="s3">\n          </span><span class="s1">(res) =&gt; {</span><span class="s3">\n            </span><span class="s1">obj[turbopackExports] = res</span><span class="s3">\n            </span><span class="s1">resolveQueue(queue)</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">(err) =&gt; {</span><span class="s3">\n            </span><span class="s1">obj[turbopackError] = err</span><span class="s3">\n            </span><span class="s1">resolveQueue(queue)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">return obj</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">[turbopackExports]: dep,</span><span class="s3">\n      </span><span class="s1">[turbopackQueues]: () =&gt; {},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function asyncModule(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">body: (</span><span class="s3">\n    </span><span class="s1">handleAsyncDependencies: (</span><span class="s3">\n      </span><span class="s1">deps: Dep[]</span><span class="s3">\n    </span><span class="s1">) =&gt; Exports[] | Promise&lt;() =&gt; Exports[]&gt;,</span><span class="s3">\n    </span><span class="s1">asyncResult: (err?: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">) =&gt; void,</span><span class="s3">\n  </span><span class="s1">hasAwait: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const module = this.m</span><span class="s3">\n  </span><span class="s1">const queue: AsyncQueue | undefined = hasAwait</span><span class="s3">\n    </span><span class="s1">? Object.assign([], { status: QueueStatus.Unknown })</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">const depQueues: Set&lt;AsyncQueue&gt; = new Set()</span><span class="s3">\n\n  </span><span class="s1">const { resolve, reject, promise: rawPromise } = createPromise&lt;Exports&gt;()</span><span class="s3">\n\n  </span><span class="s1">const promise: AsyncModulePromise = Object.assign(rawPromise, {</span><span class="s3">\n    </span><span class="s1">[turbopackExports]: module.exports,</span><span class="s3">\n    </span><span class="s1">[turbopackQueues]: (fn) =&gt; {</span><span class="s3">\n      </span><span class="s1">queue &amp;&amp; fn(queue)</span><span class="s3">\n      </span><span class="s1">depQueues.forEach(fn)</span><span class="s3">\n      </span><span class="s1">promise['catch'](() =&gt; {})</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">} satisfies AsyncModuleExt)</span><span class="s3">\n\n  </span><span class="s1">const attributes: PropertyDescriptor = {</span><span class="s3">\n    </span><span class="s1">get(): any {</span><span class="s3">\n      </span><span class="s1">return promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set(v: any) {</span><span class="s3">\n      </span><span class="s1">// Calling `esmExport` leads to this.</span><span class="s3">\n      </span><span class="s1">if (v !== promise) {</span><span class="s3">\n        </span><span class="s1">promise[turbopackExports] = v</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(module, 'exports', attributes)</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(module, 'namespaceObject', attributes)</span><span class="s3">\n\n  </span><span class="s1">function handleAsyncDependencies(deps: Dep[]) {</span><span class="s3">\n    </span><span class="s1">const currentDeps = wrapDeps(deps)</span><span class="s3">\n\n    </span><span class="s1">const getResult = () =&gt;</span><span class="s3">\n      </span><span class="s1">currentDeps.map((d) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (d[turbopackError]) throw d[turbopackError]</span><span class="s3">\n        </span><span class="s1">return d[turbopackExports]</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const { promise, resolve } = createPromise&lt;() =&gt; Exports[]&gt;()</span><span class="s3">\n\n    </span><span class="s1">const fn: AsyncQueueFn = Object.assign(() =&gt; resolve(getResult), {</span><span class="s3">\n      </span><span class="s1">queueCount: 0,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">function fnQueue(q: AsyncQueue) {</span><span class="s3">\n      </span><span class="s1">if (q !== queue &amp;&amp; !depQueues.has(q)) {</span><span class="s3">\n        </span><span class="s1">depQueues.add(q)</span><span class="s3">\n        </span><span class="s1">if (q &amp;&amp; q.status === QueueStatus.Unresolved) {</span><span class="s3">\n          </span><span class="s1">fn.queueCount++</span><span class="s3">\n          </span><span class="s1">q.push(fn)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">currentDeps.map((dep) =&gt; dep[turbopackQueues](fnQueue))</span><span class="s3">\n\n    </span><span class="s1">return fn.queueCount ? promise : getResult()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function asyncResult(err?: any) {</span><span class="s3">\n    </span><span class="s1">if (err) {</span><span class="s3">\n      </span><span class="s1">reject((promise[turbopackError] = err))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">resolve(promise[turbopackExports])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">resolveQueue(queue)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">body(handleAsyncDependencies, asyncResult)</span><span class="s3">\n\n  </span><span class="s1">if (queue &amp;&amp; queue.status === QueueStatus.Unknown) {</span><span class="s3">\n    </span><span class="s1">queue.status = QueueStatus.Unresolved</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.a = asyncModule</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A pseudo </span><span class="s3">\&quot;</span><span class="s1">fake</span><span class="s3">\&quot; </span><span class="s1">URL object to resolve to its relative path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this</span><span class="s3">\n </span><span class="s1">* runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid</span><span class="s3">\n </span><span class="s1">* hydration mismatch.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is based on webpack's existing implementation:</span><span class="s3">\n </span><span class="s1">* https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const relativeURL = function relativeURL(this: any, inputUrl: string) {</span><span class="s3">\n  </span><span class="s1">const realUrl = new URL(inputUrl, 'x:/')</span><span class="s3">\n  </span><span class="s1">const values: Record&lt;string, any&gt; = {}</span><span class="s3">\n  </span><span class="s1">for (const key in realUrl) values[key] = (realUrl as any)[key]</span><span class="s3">\n  </span><span class="s1">values.href = inputUrl</span><span class="s3">\n  </span><span class="s1">values.pathname = inputUrl.replace(/[?#].*/, '')</span><span class="s3">\n  </span><span class="s1">values.origin = values.protocol = ''</span><span class="s3">\n  </span><span class="s1">values.toString = values.toJSON = (..._args: Array&lt;any&gt;) =&gt; inputUrl</span><span class="s3">\n  </span><span class="s1">for (const key in values)</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(this, key, {</span><span class="s3">\n      </span><span class="s1">enumerable: true,</span><span class="s3">\n      </span><span class="s1">configurable: true,</span><span class="s3">\n      </span><span class="s1">value: values[key],</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">relativeURL.prototype = URL.prototype</span><span class="s3">\n</span><span class="s1">contextPrototype.U = relativeURL</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility function to ensure all variants of an enum are handled.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function invariant(never: never, computeMessage: (arg: any) =&gt; string): never {</span><span class="s3">\n  </span><span class="s1">throw new Error(`Invariant: ${computeMessage(never)}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A stub function to make `require` available but non-functional in ESM.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function requireStub(_moduleId: ModuleId): never {</span><span class="s3">\n  </span><span class="s1">throw new Error('dynamic usage of require is not supported')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.z = requireStub</span><span class="s3">\n\n</span><span class="s1">// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.</span><span class="s3">\n</span><span class="s1">contextPrototype.g = globalThis</span><span class="s3">\n\n</span><span class="s1">type ContextConstructor&lt;M&gt; = {</span><span class="s3">\n  </span><span class="s1">new (module: Module, exports: Exports): TurbopackBaseContext&lt;M&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyModuleFactoryName(factory: Function) {</span><span class="s3">\n  </span><span class="s1">// Give the module factory a nice name to improve stack traces.</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(factory, 'name', {</span><span class="s3">\n    </span><span class="s1">value: '__TURBOPACK__module__evaluation__',</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,6CAA6C;AAU7C,MAAM,qBAAqB,IAAI;AAE/B;;CAEC,GACD,SAAS,QAEP,MAAc,EACd,OAAgB;IAEhB,IAAI,CAAC,CAAC,GAAG;IACT,gFAAgF;IAChF,yEAAyE;IACzE,+CAA+C;IAC/C,8EAA8E;IAC9E,sEAAsE;IACtE,iBAAiB;IACjB,4FAA4F;IAC5F,IAAI,CAAC,CAAC,GAAG;AACX;AACA,MAAM,mBAAmB,QAAQ,SAAS;AA+B1C,MAAM,iBAAiB,OAAO,SAAS,CAAC,cAAc;AACtD,MAAM,cAAc,OAAO,WAAW,eAAe,OAAO,WAAW;AAEvE,SAAS,WACP,GAAQ,EACR,IAAiB,EACjB,OAA2C;IAE3C,IAAI,CAAC,eAAe,IAAI,CAAC,KAAK,OAAO,OAAO,cAAc,CAAC,KAAK,MAAM;AACxE;AAEA,SAAS,qBACP,WAAgC,EAChC,EAAY;IAEZ,IAAI,SAAS,WAAW,CAAC,GAAG;IAC5B,IAAI,CAAC,QAAQ;QACX,0FAA0F;QAC1F,4DAA4D;QAC5D,SAAS,mBAAmB;QAC5B,WAAW,CAAC,GAAG,GAAG;IACpB;IACA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,mBAAmB,EAAY;IACtC,OAAO;QACL,SAAS,CAAC;QACV,OAAO;QACP;QACA,iBAAiB;IACnB;AACF;AAEA;;CAEC,GACD,SAAS,IACP,OAAgB,EAChB,OAAiE;IAEjE,WAAW,SAAS,cAAc;QAAE,OAAO;IAAK;IAChD,IAAI,aAAa,WAAW,SAAS,aAAa;QAAE,OAAO;IAAS;IACpE,IAAI,IAAI;IACR,MAAO,IAAI,QAAQ,MAAM,CAAE;QACzB,MAAM,WAAW,OAAO,CAAC,IAAI;QAC7B,gHAAgH;QAChH,MAAM,SAAS,OAAO,CAAC,IAAI;QAC3B,IAAI,OAAO,OAAO,CAAC,EAAE,KAAK,YAAY;YACpC,WAAW;YACX,WAAW,SAAS,UAAU;gBAC5B,KAAK;gBACL,KAAK,OAAO,CAAC,IAAI;gBACjB,YAAY;YACd;QACF,OAAO;YACL,WAAW,SAAS,UAAU;gBAAE,KAAK;gBAAQ,YAAY;YAAK;QAChE;IACF;IACA,OAAO,IAAI,CAAC;AACd;AAEA;;CAEC,GACD,SAAS,UAEP,OAAiE,EACjE,EAAwB;IAExB,IAAI;IACJ,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;QACtC,UAAU,OAAO,OAAO;IAC1B,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;QACf,UAAU,IAAI,CAAC,CAAC;IAClB;IACA,OAAO,eAAe,GAAG;IACzB,IAAI,SAAS;AACf;AACA,iBAAiB,CAAC,GAAG;AAGrB,SAAS,qBACP,MAAc,EACd,OAAgB;IAEhB,IAAI,oBACF,mBAAmB,GAAG,CAAC;IAEzB,IAAI,CAAC,mBAAmB;QACtB,mBAAmB,GAAG,CAAC,QAAS,oBAAoB,EAAE;QACtD,OAAO,OAAO,GAAG,OAAO,eAAe,GAAG,IAAI,MAAM,SAAS;YAC3D,KAAI,MAAM,EAAE,IAAI;gBACd,IACE,eAAe,IAAI,CAAC,QAAQ,SAC5B,SAAS,aACT,SAAS,cACT;oBACA,OAAO,QAAQ,GAAG,CAAC,QAAQ;gBAC7B;gBACA,KAAK,MAAM,OAAO,kBAAoB;oBACpC,MAAM,QAAQ,QAAQ,GAAG,CAAC,KAAK;oBAC/B,IAAI,UAAU,WAAW,OAAO;gBAClC;gBACA,OAAO;YACT;YACA,SAAQ,MAAM;gBACZ,MAAM,OAAO,QAAQ,OAAO,CAAC;gBAC7B,KAAK,MAAM,OAAO,kBAAoB;oBACpC,KAAK,MAAM,OAAO,QAAQ,OAAO,CAAC,KAAM;wBACtC,IAAI,QAAQ,aAAa,CAAC,KAAK,QAAQ,CAAC,MAAM,KAAK,IAAI,CAAC;oBAC1D;gBACF;gBACA,OAAO;YACT;QACF;IACF;IACA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,cAEP,MAA2B,EAC3B,EAAwB;IAExB,IAAI;IACJ,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;QACtC,UAAU,OAAO,OAAO;IAC1B,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;QACf,UAAU,IAAI,CAAC,CAAC;IAClB;IACA,MAAM,oBAAoB,qBAAqB,QAAQ;IAEvD,IAAI,OAAO,WAAW,YAAY,WAAW,MAAM;QACjD,kBAAkB,IAAI,CAAC;IACzB;AACF;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,YAEP,KAAU,EACV,EAAwB;IAExB,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;IACxC,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;IACjB;IACA,OAAO,OAAO,GAAG;AACnB;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBAEP,SAAc,EACd,EAAwB;IAExB,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;IACxC,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;IACjB;IACA,OAAO,OAAO,GAAG,OAAO,eAAe,GAAG;AAC5C;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,aAAa,GAAiC,EAAE,GAAoB;IAC3E,OAAO,IAAM,GAAG,CAAC,IAAI;AACvB;AAEA;;CAEC,GACD,MAAM,WAA8B,OAAO,cAAc,GACrD,CAAC,MAAQ,OAAO,cAAc,CAAC,OAC/B,CAAC,MAAQ,IAAI,SAAS;AAE1B,iDAAiD,GACjD,MAAM,kBAAkB;IAAC;IAAM,SAAS,CAAC;IAAI,SAAS,EAAE;IAAG,SAAS;CAAU;AAE9E;;;;;;CAMC,GACD,SAAS,WACP,GAAY,EACZ,EAAsB,EACtB,kBAA4B;IAE5B,MAAM,UAAoE,EAAE;IAC5E,2CAA2C;IAC3C,IAAI,kBAAkB,CAAC;IACvB,IACE,IAAI,UAAU,KACd,CAAC,OAAO,YAAY,YAAY,OAAO,YAAY,UAAU,KAC7D,CAAC,gBAAgB,QAAQ,CAAC,UAC1B,UAAU,SAAS,SACnB;QACA,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,SAAU;YACrD,QAAQ,IAAI,CAAC,KAAK,aAAa,KAAK;YACpC,IAAI,oBAAoB,CAAC,KAAK,QAAQ,WAAW;gBAC/C,kBAAkB,QAAQ,MAAM,GAAG;YACrC;QACF;IACF;IAEA,6BAA6B;IAC7B,6EAA6E;IAC7E,IAAI,CAAC,CAAC,sBAAsB,mBAAmB,CAAC,GAAG;QACjD,8FAA8F;QAC9F,IAAI,mBAAmB,GAAG;YACxB,OAAO,CAAC,gBAAgB,GAAG,IAAM;QACnC,OAAO;YACL,QAAQ,IAAI,CAAC,WAAW,IAAM;QAChC;IACF;IAEA,IAAI,IAAI;IACR,OAAO;AACT;AAEA,SAAS,SAAS,GAAsB;IACtC,IAAI,OAAO,QAAQ,YAAY;QAC7B,OAAO,SAAqB,GAAG,IAAW;YACxC,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE;QACzB;IACF,OAAO;QACL,OAAO,OAAO,MAAM,CAAC;IACvB;AACF;AAEA,SAAS,UAEP,EAAY;IAEZ,MAAM,SAAS,iCAAiC,IAAI,IAAI,CAAC,CAAC;IAE1D,8DAA8D;IAC9D,IAAI,OAAO,eAAe,EAAE,OAAO,OAAO,eAAe;IAEzD,iGAAiG;IACjG,MAAM,MAAM,OAAO,OAAO;IAC1B,OAAQ,OAAO,eAAe,GAAG,WAC/B,KACA,SAAS,MACT,OAAO,AAAC,IAAY,UAAU;AAElC;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,YAEP,QAAkB;IAElB,MAAM,SAAS,IAAI,CAAC,CAAC,CAAC;IAGtB,OAAO,OAAO,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI;AAChC;AACA,iBAAiB,CAAC,GAAG;AAErB,+EAA+E;AAC/E,6EAA6E;AAC7E,MAAM,iBACJ,aAAa;AACb,OAAO,YAAY,aAEf,UACA,SAAS;IACP,MAAM,IAAI,MAAM;AAClB;AACN,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBAEP,EAAY;IAEZ,OAAO,iCAAiC,IAAI,IAAI,CAAC,CAAC,EAAE,OAAO;AAC7D;AACA,iBAAiB,CAAC,GAAG;AAErB;;CAEC,GACD,SAAS,cAAc,GAAqB;IAC1C,SAAS,cAAc,EAAY;QACjC,IAAI,eAAe,IAAI,CAAC,KAAK,KAAK;YAChC,OAAO,GAAG,CAAC,GAAG,CAAC,MAAM;QACvB;QAEA,MAAM,IAAI,IAAI,MAAM,CAAC,oBAAoB,EAAE,GAAG,CAAC,CAAC;QAC9C,EAAU,IAAI,GAAG;QACnB,MAAM;IACR;IAEA,cAAc,IAAI,GAAG;QACnB,OAAO,OAAO,IAAI,CAAC;IACrB;IAEA,cAAc,OAAO,GAAG,CAAC;QACvB,IAAI,eAAe,IAAI,CAAC,KAAK,KAAK;YAChC,OAAO,GAAG,CAAC,GAAG,CAAC,EAAE;QACnB;QAEA,MAAM,IAAI,IAAI,MAAM,CAAC,oBAAoB,EAAE,GAAG,CAAC,CAAC;QAC9C,EAAU,IAAI,GAAG;QACnB,MAAM;IACR;IAEA,cAAc,MAAM,GAAG,OAAO;QAC5B,OAAO,MAAO,cAAc;IAC9B;IAEA,OAAO;AACT;AACA,iBAAiB,CAAC,GAAG;AAErB;;CAEC,GACD,SAAS,aAAa,SAAoB;IACxC,OAAO,OAAO,cAAc,WAAW,YAAY,UAAU,IAAI;AACnE;AAEA,SAAS,UAAmB,YAAiB;IAC3C,OACE,gBAAgB,QAChB,OAAO,iBAAiB,YACxB,UAAU,gBACV,OAAO,aAAa,IAAI,KAAK;AAEjC;AAEA,SAAS,iBAA+B,GAAM;IAC5C,OAAO,mBAAmB;AAC5B;AAEA,SAAS;IACP,IAAI;IACJ,IAAI;IAEJ,MAAM,UAAU,IAAI,QAAW,CAAC,KAAK;QACnC,SAAS;QACT,UAAU;IACZ;IAEA,OAAO;QACL;QACA,SAAS;QACT,QAAQ;IACV;AACF;AAEA,gFAAgF;AAChF,0CAA0C;AAC1C,yBAAyB;AACzB,8BAA8B;AAC9B,6EAA6E;AAC7E,wEAAwE;AACxE,SAAS,iCACP,YAAuC,EACvC,MAAc,EACd,eAAgC,EAChC,WAAoC;IAEpC,IAAI,IAAI;IACR,MAAO,IAAI,aAAa,MAAM,CAAE;QAC9B,IAAI,WAAW,YAAY,CAAC,EAAE;QAC9B,IAAI,MAAM,IAAI;QACd,4BAA4B;QAC5B,MACE,MAAM,aAAa,MAAM,IACzB,OAAO,YAAY,CAAC,IAAI,KAAK,WAC7B;YACA;QACF;QACA,IAAI,QAAQ,aAAa,MAAM,EAAE;YAC/B,MAAM,IAAI,MAAM;QAClB;QACA,+FAA+F;QAC/F,sFAAsF;QACtF,IAAI,CAAC,gBAAgB,GAAG,CAAC,WAAW;YAClC,MAAM,kBAAkB,YAAY,CAAC,IAAI;YACzC,uBAAuB;YACvB,cAAc;YACd,MAAO,IAAI,KAAK,IAAK;gBACnB,WAAW,YAAY,CAAC,EAAE;gBAC1B,gBAAgB,GAAG,CAAC,UAAU;YAChC;QACF;QACA,IAAI,MAAM,GAAE,sFAAsF;IACpG;AACF;AAEA,2CAA2C;AAC3C,+HAA+H;AAE/H,MAAM,kBAAkB,OAAO;AAC/B,MAAM,mBAAmB,OAAO;AAChC,MAAM,iBAAiB,OAAO;AAa9B,SAAS,aAAa,KAAkB;IACtC,IAAI,SAAS,MAAM,MAAM,QAA2B;QAClD,MAAM,MAAM;QACZ,MAAM,OAAO,CAAC,CAAC,KAAO,GAAG,UAAU;QACnC,MAAM,OAAO,CAAC,CAAC,KAAQ,GAAG,UAAU,KAAK,GAAG,UAAU,KAAK;IAC7D;AACF;AAYA,SAAS,SAAS,IAAW;IAC3B,OAAO,KAAK,GAAG,CAAC,CAAC;QACf,IAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;YAC3C,IAAI,iBAAiB,MAAM,OAAO;YAClC,IAAI,UAAU,MAAM;gBAClB,MAAM,QAAoB,OAAO,MAAM,CAAC,EAAE,EAAE;oBAC1C,MAAM;gBACR;gBAEA,MAAM,MAAsB;oBAC1B,CAAC,iBAAiB,EAAE,CAAC;oBACrB,CAAC,gBAAgB,EAAE,CAAC,KAAoC,GAAG;gBAC7D;gBAEA,IAAI,IAAI,CACN,CAAC;oBACC,GAAG,CAAC,iBAAiB,GAAG;oBACxB,aAAa;gBACf,GACA,CAAC;oBACC,GAAG,CAAC,eAAe,GAAG;oBACtB,aAAa;gBACf;gBAGF,OAAO;YACT;QACF;QAEA,OAAO;YACL,CAAC,iBAAiB,EAAE;YACpB,CAAC,gBAAgB,EAAE,KAAO;QAC5B;IACF;AACF;AAEA,SAAS,YAEP,IAKS,EACT,QAAiB;IAEjB,MAAM,SAAS,IAAI,CAAC,CAAC;IACrB,MAAM,QAAgC,WAClC,OAAO,MAAM,CAAC,EAAE,EAAE;QAAE,MAAM;IAAsB,KAChD;IAEJ,MAAM,YAA6B,IAAI;IAEvC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,UAAU,EAAE,GAAG;IAEjD,MAAM,UAA8B,OAAO,MAAM,CAAC,YAAY;QAC5D,CAAC,iBAAiB,EAAE,OAAO,OAAO;QAClC,CAAC,gBAAgB,EAAE,CAAC;YAClB,SAAS,GAAG;YACZ,UAAU,OAAO,CAAC;YAClB,OAAO,CAAC,QAAQ,CAAC,KAAO;QAC1B;IACF;IAEA,MAAM,aAAiC;QACrC;YACE,OAAO;QACT;QACA,KAAI,CAAM;YACR,qCAAqC;YACrC,IAAI,MAAM,SAAS;gBACjB,OAAO,CAAC,iBAAiB,GAAG;YAC9B;QACF;IACF;IAEA,OAAO,cAAc,CAAC,QAAQ,WAAW;IACzC,OAAO,cAAc,CAAC,QAAQ,mBAAmB;IAEjD,SAAS,wBAAwB,IAAW;QAC1C,MAAM,cAAc,SAAS;QAE7B,MAAM,YAAY,IAChB,YAAY,GAAG,CAAC,CAAC;gBACf,IAAI,CAAC,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC,eAAe;gBAC9C,OAAO,CAAC,CAAC,iBAAiB;YAC5B;QAEF,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG;QAE7B,MAAM,KAAmB,OAAO,MAAM,CAAC,IAAM,QAAQ,YAAY;YAC/D,YAAY;QACd;QAEA,SAAS,QAAQ,CAAa;YAC5B,IAAI,MAAM,SAAS,CAAC,UAAU,GAAG,CAAC,IAAI;gBACpC,UAAU,GAAG,CAAC;gBACd,IAAI,KAAK,EAAE,MAAM,QAA6B;oBAC5C,GAAG,UAAU;oBACb,EAAE,IAAI,CAAC;gBACT;YACF;QACF;QAEA,YAAY,GAAG,CAAC,CAAC,MAAQ,GAAG,CAAC,gBAAgB,CAAC;QAE9C,OAAO,GAAG,UAAU,GAAG,UAAU;IACnC;IAEA,SAAS,YAAY,GAAS;QAC5B,IAAI,KAAK;YACP,OAAQ,OAAO,CAAC,eAAe,GAAG;QACpC,OAAO;YACL,QAAQ,OAAO,CAAC,iBAAiB;QACnC;QAEA,aAAa;IACf;IAEA,KAAK,yBAAyB;IAE9B,IAAI,SAAS,MAAM,MAAM,SAA0B;QACjD,MAAM,MAAM;IACd;AACF;AACA,iBAAiB,CAAC,GAAG;AAErB;;;;;;;;;CASC,GACD,MAAM,cAAc,SAAS,YAAuB,QAAgB;IAClE,MAAM,UAAU,IAAI,IAAI,UAAU;IAClC,MAAM,SAA8B,CAAC;IACrC,IAAK,MAAM,OAAO,QAAS,MAAM,CAAC,IAAI,GAAG,AAAC,OAAe,CAAC,IAAI;IAC9D,OAAO,IAAI,GAAG;IACd,OAAO,QAAQ,GAAG,SAAS,OAAO,CAAC,UAAU;IAC7C,OAAO,MAAM,GAAG,OAAO,QAAQ,GAAG;IAClC,OAAO,QAAQ,GAAG,OAAO,MAAM,GAAG,CAAC,GAAG,QAAsB;IAC5D,IAAK,MAAM,OAAO,OAChB,OAAO,cAAc,CAAC,IAAI,EAAE,KAAK;QAC/B,YAAY;QACZ,cAAc;QACd,OAAO,MAAM,CAAC,IAAI;IACpB;AACJ;AACA,YAAY,SAAS,GAAG,IAAI,SAAS;AACrC,iBAAiB,CAAC,GAAG;AAErB;;CAEC,GACD,SAAS,UAAU,KAAY,EAAE,cAAoC;IACnE,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,eAAe,QAAQ;AACvD;AAEA;;CAEC,GACD,SAAS,YAAY,SAAmB;IACtC,MAAM,IAAI,MAAM;AAClB;AACA,iBAAiB,CAAC,GAAG;AAErB,kGAAkG;AAClG,iBAAiB,CAAC,GAAG;AAMrB,SAAS,uBAAuB,OAAiB;IAC/C,+DAA+D;IAC/D,OAAO,cAAc,CAAC,SAAS,QAAQ;QACrC,OAAO;IACT;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">480</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This file contains runtime types and functions that are shared between all</span><span class="s3">\n </span><span class="s1">* Turbopack *development* ECMAScript runtimes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It will be appended to the runtime code of each runtime right after the</span><span class="s3">\n </span><span class="s1">* shared runtime utils.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../base/globals.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../../shared/runtime-utils.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">// Used in WebWorkers to tell the runtime about the chunk base path</span><span class="s3">\n</span><span class="s1">declare var TURBOPACK_WORKER_LOCATION: string</span><span class="s3">\n</span><span class="s1">// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript</span><span class="s3">\n</span><span class="s1">// Note it's stored in reversed order to use push and pop</span><span class="s3">\n</span><span class="s1">declare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined</span><span class="s3">\n\n</span><span class="s1">// Injected by rust code</span><span class="s3">\n</span><span class="s1">declare var CHUNK_BASE_PATH: string</span><span class="s3">\n</span><span class="s1">declare var CHUNK_SUFFIX_PATH: string</span><span class="s3">\n\n</span><span class="s1">interface TurbopackBrowserBaseContext&lt;M&gt; extends TurbopackBaseContext&lt;M&gt; {</span><span class="s3">\n  </span><span class="s1">R: ResolvePathFromModule</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const browserContextPrototype =</span><span class="s3">\n  </span><span class="s1">Context.prototype as TurbopackBrowserBaseContext&lt;unknown&gt;</span><span class="s3">\n\n</span><span class="s1">// Provided by build or dev base</span><span class="s3">\n</span><span class="s1">declare function instantiateModule(</span><span class="s3">\n  </span><span class="s1">id: ModuleId,</span><span class="s3">\n  </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n  </span><span class="s1">sourceData: SourceData</span><span class="s3">\n</span><span class="s1">): Module</span><span class="s3">\n\n</span><span class="s1">type RuntimeParams = {</span><span class="s3">\n  </span><span class="s1">otherChunks: ChunkData[]</span><span class="s3">\n  </span><span class="s1">runtimeModuleIds: ModuleId[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ChunkRegistration = [</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkScript,</span><span class="s3">\n  </span><span class="s1">...([RuntimeParams] | CompressedModuleFactories),</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">type ChunkList = {</span><span class="s3">\n  </span><span class="s1">script: ChunkListScript</span><span class="s3">\n  </span><span class="s1">chunks: ChunkData[]</span><span class="s3">\n  </span><span class="s1">source: 'entry' | 'dynamic'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum SourceType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The module was instantiated because it was included in an evaluated chunk's</span><span class="s3">\n   </span><span class="s1">* runtime.</span><span class="s3">\n   </span><span class="s1">* SourceData is a ChunkPath.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Runtime = 0,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The module was instantiated because a parent module imported it.</span><span class="s3">\n   </span><span class="s1">* SourceData is a ModuleId.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Parent = 1,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The module was instantiated because it was included in a chunk's hot module</span><span class="s3">\n   </span><span class="s1">* update.</span><span class="s3">\n   </span><span class="s1">* SourceData is an array of ModuleIds or undefined.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">Update = 2,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SourceData = ChunkPath | ModuleId | ModuleId[] | undefined</span><span class="s3">\n</span><span class="s1">interface RuntimeBackend {</span><span class="s3">\n  </span><span class="s1">registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) =&gt; void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the same Promise for the same chunk URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">loadChunkCached: (sourceType: SourceType, chunkUrl: ChunkUrl) =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">loadWebAssembly: (</span><span class="s3">\n    </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n    </span><span class="s1">sourceData: SourceData,</span><span class="s3">\n    </span><span class="s1">wasmChunkPath: ChunkPath,</span><span class="s3">\n    </span><span class="s1">edgeModule: () =&gt; WebAssembly.Module,</span><span class="s3">\n    </span><span class="s1">importsObj: WebAssembly.Imports</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;Exports&gt;</span><span class="s3">\n  </span><span class="s1">loadWebAssemblyModule: (</span><span class="s3">\n    </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n    </span><span class="s1">sourceData: SourceData,</span><span class="s3">\n    </span><span class="s1">wasmChunkPath: ChunkPath,</span><span class="s3">\n    </span><span class="s1">edgeModule: () =&gt; WebAssembly.Module</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;WebAssembly.Module&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface DevRuntimeBackend {</span><span class="s3">\n  </span><span class="s1">reloadChunk?: (chunkUrl: ChunkUrl) =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">unloadChunk?: (chunkUrl: ChunkUrl) =&gt; void</span><span class="s3">\n  </span><span class="s1">restart: () =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const moduleFactories: ModuleFactories = new Map()</span><span class="s3">\n</span><span class="s1">contextPrototype.M = moduleFactories</span><span class="s3">\n\n</span><span class="s1">const availableModules: Map&lt;ModuleId, Promise&lt;any&gt; | true&gt; = new Map()</span><span class="s3">\n\n</span><span class="s1">const availableModuleChunks: Map&lt;ChunkPath, Promise&lt;any&gt; | true&gt; = new Map()</span><span class="s3">\n\n</span><span class="s1">function factoryNotAvailable(</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId,</span><span class="s3">\n  </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n  </span><span class="s1">sourceData: SourceData</span><span class="s3">\n</span><span class="s1">): never {</span><span class="s3">\n  </span><span class="s1">let instantiationReason</span><span class="s3">\n  </span><span class="s1">switch (sourceType) {</span><span class="s3">\n    </span><span class="s1">case SourceType.Runtime:</span><span class="s3">\n      </span><span class="s1">instantiationReason = `as a runtime entry of chunk ${sourceData}`</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case SourceType.Parent:</span><span class="s3">\n      </span><span class="s1">instantiationReason = `because it was required from module ${sourceData}`</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case SourceType.Update:</span><span class="s3">\n      </span><span class="s1">instantiationReason = 'because of an HMR update'</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">invariant(</span><span class="s3">\n        </span><span class="s1">sourceType,</span><span class="s3">\n        </span><span class="s1">(sourceType) =&gt; `Unknown source type: ${sourceType}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\n    </span><span class="s1">`Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function loadChunk(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBrowserBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">chunkData: ChunkData</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">return loadChunkInternal(SourceType.Parent, this.m.id, chunkData)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">browserContextPrototype.l = loadChunk</span><span class="s3">\n\n</span><span class="s1">function loadInitialChunk(chunkPath: ChunkPath, chunkData: ChunkData) {</span><span class="s3">\n  </span><span class="s1">return loadChunkInternal(SourceType.Runtime, chunkPath, chunkData)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function loadChunkInternal(</span><span class="s3">\n  </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n  </span><span class="s1">sourceData: SourceData,</span><span class="s3">\n  </span><span class="s1">chunkData: ChunkData</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof chunkData === 'string') {</span><span class="s3">\n    </span><span class="s1">return loadChunkPath(sourceType, sourceData, chunkData)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const includedList = chunkData.included || []</span><span class="s3">\n  </span><span class="s1">const modulesPromises = includedList.map((included) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (moduleFactories.has(included)) return true</span><span class="s3">\n    </span><span class="s1">return availableModules.get(included)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">if (modulesPromises.length &gt; 0 &amp;&amp; modulesPromises.every((p) =&gt; p)) {</span><span class="s3">\n    </span><span class="s1">// When all included items are already loaded or loading, we can skip loading ourselves</span><span class="s3">\n    </span><span class="s1">await Promise.all(modulesPromises)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const includedModuleChunksList = chunkData.moduleChunks || []</span><span class="s3">\n  </span><span class="s1">const moduleChunksPromises = includedModuleChunksList</span><span class="s3">\n    </span><span class="s1">.map((included) =&gt; {</span><span class="s3">\n      </span><span class="s1">// TODO(alexkirsz) Do we need this check?</span><span class="s3">\n      </span><span class="s1">// if (moduleFactories[included]) return true;</span><span class="s3">\n      </span><span class="s1">return availableModuleChunks.get(included)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.filter((p) =&gt; p)</span><span class="s3">\n\n  </span><span class="s1">let promise: Promise&lt;unknown&gt;</span><span class="s3">\n  </span><span class="s1">if (moduleChunksPromises.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// Some module chunks are already loaded or loading.</span><span class="s3">\n\n    </span><span class="s1">if (moduleChunksPromises.length === includedModuleChunksList.length) {</span><span class="s3">\n      </span><span class="s1">// When all included module chunks are already loaded or loading, we can skip loading ourselves</span><span class="s3">\n      </span><span class="s1">await Promise.all(moduleChunksPromises)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const moduleChunksToLoad: Set&lt;ChunkPath&gt; = new Set()</span><span class="s3">\n    </span><span class="s1">for (const moduleChunk of includedModuleChunksList) {</span><span class="s3">\n      </span><span class="s1">if (!availableModuleChunks.has(moduleChunk)) {</span><span class="s3">\n        </span><span class="s1">moduleChunksToLoad.add(moduleChunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const moduleChunkToLoad of moduleChunksToLoad) {</span><span class="s3">\n      </span><span class="s1">const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)</span><span class="s3">\n\n      </span><span class="s1">availableModuleChunks.set(moduleChunkToLoad, promise)</span><span class="s3">\n\n      </span><span class="s1">moduleChunksPromises.push(promise)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">promise = Promise.all(moduleChunksPromises)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">promise = loadChunkPath(sourceType, sourceData, chunkData.path)</span><span class="s3">\n\n    </span><span class="s1">// Mark all included module chunks as loading if they are not already loaded or loading.</span><span class="s3">\n    </span><span class="s1">for (const includedModuleChunk of includedModuleChunksList) {</span><span class="s3">\n      </span><span class="s1">if (!availableModuleChunks.has(includedModuleChunk)) {</span><span class="s3">\n        </span><span class="s1">availableModuleChunks.set(includedModuleChunk, promise)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const included of includedList) {</span><span class="s3">\n    </span><span class="s1">if (!availableModules.has(included)) {</span><span class="s3">\n      </span><span class="s1">// It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.</span><span class="s3">\n      </span><span class="s1">// In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.</span><span class="s3">\n      </span><span class="s1">availableModules.set(included, promise)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">await promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const loadedChunk = Promise.resolve(undefined)</span><span class="s3">\n</span><span class="s1">const instrumentedBackendLoadChunks = new WeakMap&lt;</span><span class="s3">\n  </span><span class="s1">Promise&lt;any&gt;,</span><span class="s3">\n  </span><span class="s1">Promise&lt;any&gt; | typeof loadedChunk</span><span class="s3">\n</span><span class="s1">&gt;()</span><span class="s3">\n</span><span class="s1">// Do not make this async. React relies on referential equality of the returned Promise.</span><span class="s3">\n</span><span class="s1">function loadChunkByUrl(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBrowserBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">chunkUrl: ChunkUrl</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">browserContextPrototype.L = loadChunkByUrl</span><span class="s3">\n\n</span><span class="s1">// Do not make this async. React relies on referential equality of the returned Promise.</span><span class="s3">\n</span><span class="s1">function loadChunkByUrlInternal(</span><span class="s3">\n  </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n  </span><span class="s1">sourceData: SourceData,</span><span class="s3">\n  </span><span class="s1">chunkUrl: ChunkUrl</span><span class="s3">\n</span><span class="s1">): Promise&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl)</span><span class="s3">\n  </span><span class="s1">let entry = instrumentedBackendLoadChunks.get(thenable)</span><span class="s3">\n  </span><span class="s1">if (entry === undefined) {</span><span class="s3">\n    </span><span class="s1">const resolve = instrumentedBackendLoadChunks.set.bind(</span><span class="s3">\n      </span><span class="s1">instrumentedBackendLoadChunks,</span><span class="s3">\n      </span><span class="s1">thenable,</span><span class="s3">\n      </span><span class="s1">loadedChunk</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">entry = thenable.then(resolve).catch((error) =&gt; {</span><span class="s3">\n      </span><span class="s1">let loadReason: string</span><span class="s3">\n      </span><span class="s1">switch (sourceType) {</span><span class="s3">\n        </span><span class="s1">case SourceType.Runtime:</span><span class="s3">\n          </span><span class="s1">loadReason = `as a runtime dependency of chunk ${sourceData}`</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">case SourceType.Parent:</span><span class="s3">\n          </span><span class="s1">loadReason = `from module ${sourceData}`</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">case SourceType.Update:</span><span class="s3">\n          </span><span class="s1">loadReason = 'from an HMR update'</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">invariant(</span><span class="s3">\n            </span><span class="s1">sourceType,</span><span class="s3">\n            </span><span class="s1">(sourceType) =&gt; `Unknown source type: ${sourceType}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Failed to load chunk ${chunkUrl} ${loadReason}${</span><span class="s3">\n          </span><span class="s1">error ? `: ${error}` : ''</span><span class="s3">\n        </span><span class="s1">}`,</span><span class="s3">\n        </span><span class="s1">error</span><span class="s3">\n          </span><span class="s1">? {</span><span class="s3">\n              </span><span class="s1">cause: error,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">instrumentedBackendLoadChunks.set(thenable, entry)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return entry</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Do not make this async. React relies on referential equality of the returned Promise.</span><span class="s3">\n</span><span class="s1">function loadChunkPath(</span><span class="s3">\n  </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n  </span><span class="s1">sourceData: SourceData,</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">const url = getChunkRelativeUrl(chunkPath)</span><span class="s3">\n  </span><span class="s1">return loadChunkByUrlInternal(sourceType, sourceData, url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns an absolute url to an asset.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolvePathFromModule(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">moduleId: string</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const exported = this.r(moduleId)</span><span class="s3">\n  </span><span class="s1">return exported?.default ?? exported</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">browserContextPrototype.R = resolvePathFromModule</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* no-op for browser</span><span class="s3">\n </span><span class="s1">* @param modulePath</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolveAbsolutePath(modulePath?: string): string {</span><span class="s3">\n  </span><span class="s1">return `/ROOT/${modulePath ?? ''}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">browserContextPrototype.P = resolveAbsolutePath</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a blob URL for the worker.</span><span class="s3">\n </span><span class="s1">* @param chunks list of chunks to load</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getWorkerBlobURL(chunks: ChunkPath[]): string {</span><span class="s3">\n  </span><span class="s1">// It is important to reverse the array so when bootstrapping we can infer what chunk is being</span><span class="s3">\n  </span><span class="s1">// evaluated by poping urls off of this array.  See `getPathFromScript`</span><span class="s3">\n  </span><span class="s1">let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};</span><span class="s3">\n</span><span class="s1">self.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};</span><span class="s3">\n</span><span class="s1">importScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c =&gt; self.TURBOPACK_WORKER_LOCATION + c).reverse());`</span><span class="s3">\n  </span><span class="s1">let blob = new Blob([bootstrap], { type: 'text/javascript' })</span><span class="s3">\n  </span><span class="s1">return URL.createObjectURL(blob)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">browserContextPrototype.b = getWorkerBlobURL</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Instantiates a runtime module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function instantiateRuntimeModule(</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId,</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">return instantiateModule(moduleId, SourceType.Runtime, chunkPath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the URL relative to the origin where a chunk can be fetched from.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {</span><span class="s3">\n  </span><span class="s1">return `${CHUNK_BASE_PATH}${chunkPath</span><span class="s3">\n    </span><span class="s1">.split('/')</span><span class="s3">\n    </span><span class="s1">.map((p) =&gt; encodeURIComponent(p))</span><span class="s3">\n    </span><span class="s1">.join('/')}${CHUNK_SUFFIX_PATH}` as ChunkUrl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return the ChunkPath from a ChunkScript.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath</span><span class="s3">\n</span><span class="s1">function getPathFromScript(</span><span class="s3">\n  </span><span class="s1">chunkScript: ChunkListPath | ChunkListScript</span><span class="s3">\n</span><span class="s1">): ChunkListPath</span><span class="s3">\n</span><span class="s1">function getPathFromScript(</span><span class="s3">\n  </span><span class="s1">chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript</span><span class="s3">\n</span><span class="s1">): ChunkPath | ChunkListPath {</span><span class="s3">\n  </span><span class="s1">if (typeof chunkScript === 'string') {</span><span class="s3">\n    </span><span class="s1">return chunkScript as ChunkPath | ChunkListPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const chunkUrl =</span><span class="s3">\n    </span><span class="s1">typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined'</span><span class="s3">\n      </span><span class="s1">? TURBOPACK_NEXT_CHUNK_URLS.pop()!</span><span class="s3">\n      </span><span class="s1">: chunkScript.getAttribute('src')!</span><span class="s3">\n  </span><span class="s1">const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''))</span><span class="s3">\n  </span><span class="s1">const path = src.startsWith(CHUNK_BASE_PATH)</span><span class="s3">\n    </span><span class="s1">? src.slice(CHUNK_BASE_PATH.length)</span><span class="s3">\n    </span><span class="s1">: src</span><span class="s3">\n  </span><span class="s1">return path as ChunkPath | ChunkListPath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const regexJsUrl = /</span><span class="s3">\\</span><span class="s1">.js(?:</span><span class="s3">\\</span><span class="s1">?[^#]*)?(?:#.*)?$/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {</span><span class="s3">\n  </span><span class="s1">return regexJsUrl.test(chunkUrlOrPath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const regexCssUrl = /</span><span class="s3">\\</span><span class="s1">.css(?:</span><span class="s3">\\</span><span class="s1">?[^#]*)?(?:#.*)?$/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isCss(chunkUrl: ChunkUrl): boolean {</span><span class="s3">\n  </span><span class="s1">return regexCssUrl.test(chunkUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function loadWebAssembly(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">edgeModule: () =&gt; WebAssembly.Module,</span><span class="s3">\n  </span><span class="s1">importsObj: WebAssembly.Imports</span><span class="s3">\n</span><span class="s1">): Promise&lt;Exports&gt; {</span><span class="s3">\n  </span><span class="s1">return BACKEND.loadWebAssembly(</span><span class="s3">\n    </span><span class="s1">SourceType.Parent,</span><span class="s3">\n    </span><span class="s1">this.m.id,</span><span class="s3">\n    </span><span class="s1">chunkPath,</span><span class="s3">\n    </span><span class="s1">edgeModule,</span><span class="s3">\n    </span><span class="s1">importsObj</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.w = loadWebAssembly</span><span class="s3">\n\n</span><span class="s1">function loadWebAssemblyModule(</span><span class="s3">\n  </span><span class="s1">this: TurbopackBaseContext&lt;Module&gt;,</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">edgeModule: () =&gt; WebAssembly.Module</span><span class="s3">\n</span><span class="s1">): Promise&lt;WebAssembly.Module&gt; {</span><span class="s3">\n  </span><span class="s1">return BACKEND.loadWebAssemblyModule(</span><span class="s3">\n    </span><span class="s1">SourceType.Parent,</span><span class="s3">\n    </span><span class="s1">this.m.id,</span><span class="s3">\n    </span><span class="s1">chunkPath,</span><span class="s3">\n    </span><span class="s1">edgeModule</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">contextPrototype.u = loadWebAssemblyModule</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">704</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/browser/runtime/base/dev-base.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">./dev-globals.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">./dev-protocol.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">./dev-extensions.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">interface TurbopackDevContext extends TurbopackBrowserBaseContext&lt;HotModule&gt; {</span><span class="s3">\n  </span><span class="s1">k: RefreshContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const devContextPrototype = Context.prototype as TurbopackDevContext</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This file contains runtime types and functions that are shared between all</span><span class="s3">\n </span><span class="s1">* Turbopack *development* ECMAScript runtimes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It will be appended to the runtime code of each runtime right after the</span><span class="s3">\n </span><span class="s1">* shared runtime utils.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">const devModuleCache: ModuleCache&lt;HotModule&gt; = Object.create(null)</span><span class="s3">\n</span><span class="s1">devContextPrototype.c = devModuleCache</span><span class="s3">\n\n</span><span class="s1">// This file must not use `import` and `export` statements. Otherwise, it</span><span class="s3">\n</span><span class="s1">// becomes impossible to augment interfaces declared in `&lt;reference&gt;`d files</span><span class="s3">\n</span><span class="s1">// (e.g. `Module`). Hence, the need for `import()` here.</span><span class="s3">\n</span><span class="s1">type RefreshRuntimeGlobals =</span><span class="s3">\n  </span><span class="s1">import('@next/react-refresh-utils/dist/runtime').RefreshRuntimeGlobals</span><span class="s3">\n\n</span><span class="s1">declare var $RefreshHelpers$: RefreshRuntimeGlobals['$RefreshHelpers$']</span><span class="s3">\n</span><span class="s1">declare var $RefreshReg$: RefreshRuntimeGlobals['$RefreshReg$']</span><span class="s3">\n</span><span class="s1">declare var $RefreshSig$: RefreshRuntimeGlobals['$RefreshSig$']</span><span class="s3">\n</span><span class="s1">declare var $RefreshInterceptModuleExecution$: RefreshRuntimeGlobals['$RefreshInterceptModuleExecution$']</span><span class="s3">\n\n</span><span class="s1">type RefreshContext = {</span><span class="s3">\n  </span><span class="s1">register: RefreshRuntimeGlobals['$RefreshReg$']</span><span class="s3">\n  </span><span class="s1">signature: RefreshRuntimeGlobals['$RefreshSig$']</span><span class="s3">\n  </span><span class="s1">registerExports: typeof registerExportsAndSetupBoundaryForReactRefresh</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RefreshHelpers = RefreshRuntimeGlobals['$RefreshHelpers$']</span><span class="s3">\n\n</span><span class="s1">type ModuleFactory = (</span><span class="s3">\n  </span><span class="s1">this: Module['exports'],</span><span class="s3">\n  </span><span class="s1">context: TurbopackDevContext</span><span class="s3">\n</span><span class="s1">) =&gt; unknown</span><span class="s3">\n\n</span><span class="s1">interface DevRuntimeBackend {</span><span class="s3">\n  </span><span class="s1">reloadChunk?: (chunkUrl: ChunkUrl) =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">unloadChunk?: (chunkUrl: ChunkUrl) =&gt; void</span><span class="s3">\n  </span><span class="s1">restart: () =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class UpdateApplyError extends Error {</span><span class="s3">\n  </span><span class="s1">name = 'UpdateApplyError'</span><span class="s3">\n\n  </span><span class="s1">dependencyChain: ModuleId[]</span><span class="s3">\n\n  </span><span class="s1">constructor(message: string, dependencyChain: ModuleId[]) {</span><span class="s3">\n    </span><span class="s1">super(message)</span><span class="s3">\n    </span><span class="s1">this.dependencyChain = dependencyChain</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Module IDs that are instantiated as part of the runtime of a chunk.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const runtimeModules: Set&lt;ModuleId&gt; = new Set()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Map from module ID to the chunks that contain this module.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In HMR, we need to keep track of which modules are contained in which so</span><span class="s3">\n </span><span class="s1">* chunks. This is so we don't eagerly dispose of a module when it is removed</span><span class="s3">\n </span><span class="s1">* from chunk A, but still exists in chunk B.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const moduleChunksMap: Map&lt;ModuleId, Set&lt;ChunkPath&gt;&gt; = new Map()</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Map from a chunk path to all modules it contains.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const chunkModulesMap: Map&lt;ChunkPath, Set&lt;ModuleId&gt;&gt; = new Map()</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Chunk lists that contain a runtime. When these chunk lists receive an update</span><span class="s3">\n </span><span class="s1">* that can't be reconciled with the current state of the page, we need to</span><span class="s3">\n </span><span class="s1">* reload the runtime entirely.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const runtimeChunkLists: Set&lt;ChunkListPath&gt; = new Set()</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Map from a chunk list to the chunk paths it contains.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const chunkListChunksMap: Map&lt;ChunkListPath, Set&lt;ChunkPath&gt;&gt; = new Map()</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Map from a chunk path to the chunk lists it belongs to.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const chunkChunkListsMap: Map&lt;ChunkPath, Set&lt;ChunkListPath&gt;&gt; = new Map()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maps module IDs to persisted data between executions of their hot module</span><span class="s3">\n </span><span class="s1">* implementation (`hot.data`).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const moduleHotData: Map&lt;ModuleId, HotData&gt; = new Map()</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maps module instances to their hot module state.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const moduleHotState: Map&lt;Module, HotState&gt; = new Map()</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Modules that call `module.hot.invalidate()` (while being updated).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const queuedInvalidatedModules: Set&lt;ModuleId&gt; = new Set()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets or instantiates a runtime module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// @ts-ignore</span><span class="s3">\n</span><span class="s1">function getOrInstantiateRuntimeModule(</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath,</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">const module = devModuleCache[moduleId]</span><span class="s3">\n  </span><span class="s1">if (module) {</span><span class="s3">\n    </span><span class="s1">if (module.error) {</span><span class="s3">\n      </span><span class="s1">throw module.error</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return module</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">return instantiateModule(moduleId, SourceType.Runtime, chunkPath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Retrieves a module from the cache, or instantiate it if it is not cached.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// @ts-ignore Defined in `runtime-utils.ts`</span><span class="s3">\n</span><span class="s1">const getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent&lt;</span><span class="s3">\n  </span><span class="s1">HotModule</span><span class="s3">\n</span><span class="s1">&gt; = (id, sourceModule) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!sourceModule.hot.active) {</span><span class="s3">\n    </span><span class="s1">console.warn(</span><span class="s3">\n      </span><span class="s1">`Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const module = devModuleCache[id]</span><span class="s3">\n\n  </span><span class="s1">if (sourceModule.children.indexOf(id) === -1) {</span><span class="s3">\n    </span><span class="s1">sourceModule.children.push(id)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (module) {</span><span class="s3">\n    </span><span class="s1">if (module.error) {</span><span class="s3">\n      </span><span class="s1">throw module.error</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (module.parents.indexOf(sourceModule.id) === -1) {</span><span class="s3">\n      </span><span class="s1">module.parents.push(sourceModule.id)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return module</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return instantiateModule(id, SourceType.Parent, sourceModule.id)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function DevContext(</span><span class="s3">\n  </span><span class="s1">this: TurbopackDevContext,</span><span class="s3">\n  </span><span class="s1">module: HotModule,</span><span class="s3">\n  </span><span class="s1">exports: Exports,</span><span class="s3">\n  </span><span class="s1">refresh: RefreshContext</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">Context.call(this, module, exports)</span><span class="s3">\n  </span><span class="s1">this.k = refresh</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">DevContext.prototype = Context.prototype</span><span class="s3">\n\n</span><span class="s1">type DevContextConstructor = {</span><span class="s3">\n  </span><span class="s1">new (</span><span class="s3">\n    </span><span class="s1">module: HotModule,</span><span class="s3">\n    </span><span class="s1">exports: Exports,</span><span class="s3">\n    </span><span class="s1">refresh: RefreshContext</span><span class="s3">\n  </span><span class="s1">): TurbopackDevContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function instantiateModule(</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId,</span><span class="s3">\n  </span><span class="s1">sourceType: SourceType,</span><span class="s3">\n  </span><span class="s1">sourceData: SourceData</span><span class="s3">\n</span><span class="s1">): Module {</span><span class="s3">\n  </span><span class="s1">// We are in development, this is always a string.</span><span class="s3">\n  </span><span class="s1">let id = moduleId as string</span><span class="s3">\n\n  </span><span class="s1">const moduleFactory = moduleFactories.get(id)</span><span class="s3">\n  </span><span class="s1">if (typeof moduleFactory !== 'function') {</span><span class="s3">\n    </span><span class="s1">// This can happen if modules incorrectly handle HMR disposes/updates,</span><span class="s3">\n    </span><span class="s1">// e.g. when they keep a `setTimeout` around which still executes old code</span><span class="s3">\n    </span><span class="s1">// and contains e.g. a `require(</span><span class="s3">\&quot;</span><span class="s1">something</span><span class="s3">\&quot;</span><span class="s1">)` call.</span><span class="s3">\n    </span><span class="s1">factoryNotAvailable(id, sourceType, sourceData)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const hotData = moduleHotData.get(id)!</span><span class="s3">\n  </span><span class="s1">const { hot, hotState } = createModuleHot(id, hotData)</span><span class="s3">\n\n  </span><span class="s1">let parents: ModuleId[]</span><span class="s3">\n  </span><span class="s1">switch (sourceType) {</span><span class="s3">\n    </span><span class="s1">case SourceType.Runtime:</span><span class="s3">\n      </span><span class="s1">runtimeModules.add(id)</span><span class="s3">\n      </span><span class="s1">parents = []</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case SourceType.Parent:</span><span class="s3">\n      </span><span class="s1">// No need to add this module as a child of the parent module here, this</span><span class="s3">\n      </span><span class="s1">// has already been taken care of in `getOrInstantiateModuleFromParent`.</span><span class="s3">\n      </span><span class="s1">parents = [sourceData as ModuleId]</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case SourceType.Update:</span><span class="s3">\n      </span><span class="s1">parents = (sourceData as ModuleId[]) || []</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">invariant(</span><span class="s3">\n        </span><span class="s1">sourceType,</span><span class="s3">\n        </span><span class="s1">(sourceType) =&gt; `Unknown source type: ${sourceType}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const module: HotModule = createModuleObject(id) as HotModule</span><span class="s3">\n  </span><span class="s1">const exports = module.exports</span><span class="s3">\n  </span><span class="s1">module.parents = parents</span><span class="s3">\n  </span><span class="s1">module.children = []</span><span class="s3">\n  </span><span class="s1">module.hot = hot</span><span class="s3">\n\n  </span><span class="s1">devModuleCache[id] = module</span><span class="s3">\n  </span><span class="s1">moduleHotState.set(module, hotState)</span><span class="s3">\n\n  </span><span class="s1">// NOTE(alexkirsz) This can fail when the module encounters a runtime error.</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">runModuleExecutionHooks(module, (refresh) =&gt; {</span><span class="s3">\n      </span><span class="s1">const context = new (DevContext as any as DevContextConstructor)(</span><span class="s3">\n        </span><span class="s1">module,</span><span class="s3">\n        </span><span class="s1">exports,</span><span class="s3">\n        </span><span class="s1">refresh</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">moduleFactory(context, module, exports)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">module.error = error as any</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (module.namespaceObject &amp;&amp; module.exports !== module.namespaceObject) {</span><span class="s3">\n    </span><span class="s1">// in case of a circular dependency: cjs1 -&gt; esm2 -&gt; cjs1</span><span class="s3">\n    </span><span class="s1">interopEsm(module.exports, module.namespaceObject)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return module</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const DUMMY_REFRESH_CONTEXT = {</span><span class="s3">\n  </span><span class="s1">register: (_type: unknown, _id: unknown) =&gt; {},</span><span class="s3">\n  </span><span class="s1">signature: () =&gt; (_type: unknown) =&gt; {},</span><span class="s3">\n  </span><span class="s1">registerExports: (_module: unknown, _helpers: unknown) =&gt; {},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* NOTE(alexkirsz) Webpack has a </span><span class="s3">\&quot;</span><span class="s1">module execution</span><span class="s3">\&quot; </span><span class="s1">interception hook that</span><span class="s3">\n </span><span class="s1">* Next.js' React Refresh runtime hooks into to add module context to the</span><span class="s3">\n </span><span class="s1">* refresh registry.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function runModuleExecutionHooks(</span><span class="s3">\n  </span><span class="s1">module: HotModule,</span><span class="s3">\n  </span><span class="s1">executeModule: (ctx: RefreshContext) =&gt; void</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (typeof globalThis.$RefreshInterceptModuleExecution$ === 'function') {</span><span class="s3">\n    </span><span class="s1">const cleanupReactRefreshIntercept =</span><span class="s3">\n      </span><span class="s1">globalThis.$RefreshInterceptModuleExecution$(module.id)</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">executeModule({</span><span class="s3">\n        </span><span class="s1">register: globalThis.$RefreshReg$,</span><span class="s3">\n        </span><span class="s1">signature: globalThis.$RefreshSig$,</span><span class="s3">\n        </span><span class="s1">registerExports: registerExportsAndSetupBoundaryForReactRefresh,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">// Always cleanup the intercept, even if module execution failed.</span><span class="s3">\n      </span><span class="s1">cleanupReactRefreshIntercept()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// If the react refresh hooks are not installed we need to bind dummy functions.</span><span class="s3">\n    </span><span class="s1">// This is expected when running in a Web Worker.  It is also common in some of</span><span class="s3">\n    </span><span class="s1">// our test environments.</span><span class="s3">\n    </span><span class="s1">executeModule(DUMMY_REFRESH_CONTEXT)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function registerExportsAndSetupBoundaryForReactRefresh(</span><span class="s3">\n  </span><span class="s1">module: HotModule,</span><span class="s3">\n  </span><span class="s1">helpers: RefreshHelpers</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const currentExports = module.exports</span><span class="s3">\n  </span><span class="s1">const prevExports = module.hot.data.prevExports ?? null</span><span class="s3">\n\n  </span><span class="s1">helpers.registerExportsForReactRefresh(currentExports, module.id)</span><span class="s3">\n\n  </span><span class="s1">// A module can be accepted automatically based on its exports, e.g. when</span><span class="s3">\n  </span><span class="s1">// it is a Refresh Boundary.</span><span class="s3">\n  </span><span class="s1">if (helpers.isReactRefreshBoundary(currentExports)) {</span><span class="s3">\n    </span><span class="s1">// Save the previous exports on update, so we can compare the boundary</span><span class="s3">\n    </span><span class="s1">// signatures.</span><span class="s3">\n    </span><span class="s1">module.hot.dispose((data) =&gt; {</span><span class="s3">\n      </span><span class="s1">data.prevExports = currentExports</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">// Unconditionally accept an update to this module, we'll check if it's</span><span class="s3">\n    </span><span class="s1">// still a Refresh Boundary later.</span><span class="s3">\n    </span><span class="s1">module.hot.accept()</span><span class="s3">\n\n    </span><span class="s1">// This field is set when the previous version of this module was a</span><span class="s3">\n    </span><span class="s1">// Refresh Boundary, letting us know we need to check for invalidation or</span><span class="s3">\n    </span><span class="s1">// enqueue an update.</span><span class="s3">\n    </span><span class="s1">if (prevExports !== null) {</span><span class="s3">\n      </span><span class="s1">// A boundary can become ineligible if its exports are incompatible</span><span class="s3">\n      </span><span class="s1">// with the previous exports.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// For example, if you add/remove/change exports, we'll want to</span><span class="s3">\n      </span><span class="s1">// re-execute the importing modules, and force those components to</span><span class="s3">\n      </span><span class="s1">// re-render. Similarly, if you convert a class component to a</span><span class="s3">\n      </span><span class="s1">// function, we want to invalidate the boundary.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">helpers.shouldInvalidateReactRefreshBoundary(</span><span class="s3">\n          </span><span class="s1">helpers.getRefreshBoundarySignature(prevExports),</span><span class="s3">\n          </span><span class="s1">helpers.getRefreshBoundarySignature(currentExports)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">module.hot.invalidate()</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">helpers.scheduleUpdate()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Since we just executed the code for the module, it's possible that the</span><span class="s3">\n    </span><span class="s1">// new exports made it ineligible for being a boundary.</span><span class="s3">\n    </span><span class="s1">// We only care about the case when we were _previously_ a boundary,</span><span class="s3">\n    </span><span class="s1">// because we already accepted this update (accidental side effect).</span><span class="s3">\n    </span><span class="s1">const isNoLongerABoundary = prevExports !== null</span><span class="s3">\n    </span><span class="s1">if (isNoLongerABoundary) {</span><span class="s3">\n      </span><span class="s1">module.hot.invalidate()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function formatDependencyChain(dependencyChain: ModuleId[]): string {</span><span class="s3">\n  </span><span class="s1">return `Dependency chain: ${dependencyChain.join(' -&gt; ')}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeOutdatedModules(</span><span class="s3">\n  </span><span class="s1">added: Map&lt;ModuleId, EcmascriptModuleEntry | undefined&gt;,</span><span class="s3">\n  </span><span class="s1">modified: Map&lt;ModuleId, EcmascriptModuleEntry&gt;</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">outdatedModules: Set&lt;ModuleId&gt;</span><span class="s3">\n  </span><span class="s1">newModuleFactories: Map&lt;ModuleId, ModuleFactory&gt;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const newModuleFactories = new Map&lt;ModuleId, ModuleFactory&gt;()</span><span class="s3">\n\n  </span><span class="s1">for (const [moduleId, entry] of added) {</span><span class="s3">\n    </span><span class="s1">if (entry != null) {</span><span class="s3">\n      </span><span class="s1">newModuleFactories.set(moduleId, _eval(entry))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const outdatedModules = computedInvalidatedModules(modified.keys())</span><span class="s3">\n\n  </span><span class="s1">for (const [moduleId, entry] of modified) {</span><span class="s3">\n    </span><span class="s1">newModuleFactories.set(moduleId, _eval(entry))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { outdatedModules, newModuleFactories }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computedInvalidatedModules(</span><span class="s3">\n  </span><span class="s1">invalidated: Iterable&lt;ModuleId&gt;</span><span class="s3">\n</span><span class="s1">): Set&lt;ModuleId&gt; {</span><span class="s3">\n  </span><span class="s1">const outdatedModules = new Set&lt;ModuleId&gt;()</span><span class="s3">\n\n  </span><span class="s1">for (const moduleId of invalidated) {</span><span class="s3">\n    </span><span class="s1">const effect = getAffectedModuleEffects(moduleId)</span><span class="s3">\n\n    </span><span class="s1">switch (effect.type) {</span><span class="s3">\n      </span><span class="s1">case 'unaccepted':</span><span class="s3">\n        </span><span class="s1">throw new UpdateApplyError(</span><span class="s3">\n          </span><span class="s1">`cannot apply update: unaccepted module. ${formatDependencyChain(</span><span class="s3">\n            </span><span class="s1">effect.dependencyChain</span><span class="s3">\n          </span><span class="s1">)}.`,</span><span class="s3">\n          </span><span class="s1">effect.dependencyChain</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'self-declined':</span><span class="s3">\n        </span><span class="s1">throw new UpdateApplyError(</span><span class="s3">\n          </span><span class="s1">`cannot apply update: self-declined module. ${formatDependencyChain(</span><span class="s3">\n            </span><span class="s1">effect.dependencyChain</span><span class="s3">\n          </span><span class="s1">)}.`,</span><span class="s3">\n          </span><span class="s1">effect.dependencyChain</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case 'accepted':</span><span class="s3">\n        </span><span class="s1">for (const outdatedModuleId of effect.outdatedModules) {</span><span class="s3">\n          </span><span class="s1">outdatedModules.add(outdatedModuleId)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">// TODO(alexkirsz) Dependencies: handle dependencies effects.</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">invariant(effect, (effect) =&gt; `Unknown effect type: ${effect?.type}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return outdatedModules</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeOutdatedSelfAcceptedModules(</span><span class="s3">\n  </span><span class="s1">outdatedModules: Iterable&lt;ModuleId&gt;</span><span class="s3">\n</span><span class="s1">): { moduleId: ModuleId; errorHandler: true | Function }[] {</span><span class="s3">\n  </span><span class="s1">const outdatedSelfAcceptedModules: {</span><span class="s3">\n    </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n    </span><span class="s1">errorHandler: true | Function</span><span class="s3">\n  </span><span class="s1">}[] = []</span><span class="s3">\n  </span><span class="s1">for (const moduleId of outdatedModules) {</span><span class="s3">\n    </span><span class="s1">const module = devModuleCache[moduleId]</span><span class="s3">\n    </span><span class="s1">const hotState = moduleHotState.get(module)!</span><span class="s3">\n    </span><span class="s1">if (module &amp;&amp; hotState.selfAccepted &amp;&amp; !hotState.selfInvalidated) {</span><span class="s3">\n      </span><span class="s1">outdatedSelfAcceptedModules.push({</span><span class="s3">\n        </span><span class="s1">moduleId,</span><span class="s3">\n        </span><span class="s1">errorHandler: hotState.selfAccepted,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return outdatedSelfAcceptedModules</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds, deletes, and moves modules between chunks. This must happen before the</span><span class="s3">\n </span><span class="s1">* dispose phase as it needs to know which modules were removed from all chunks,</span><span class="s3">\n </span><span class="s1">* which we can only compute *after* taking care of added and moved modules.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function updateChunksPhase(</span><span class="s3">\n  </span><span class="s1">chunksAddedModules: Map&lt;ChunkPath, Set&lt;ModuleId&gt;&gt;,</span><span class="s3">\n  </span><span class="s1">chunksDeletedModules: Map&lt;ChunkPath, Set&lt;ModuleId&gt;&gt;</span><span class="s3">\n</span><span class="s1">): { disposedModules: Set&lt;ModuleId&gt; } {</span><span class="s3">\n  </span><span class="s1">for (const [chunkPath, addedModuleIds] of chunksAddedModules) {</span><span class="s3">\n    </span><span class="s1">for (const moduleId of addedModuleIds) {</span><span class="s3">\n      </span><span class="s1">addModuleToChunk(moduleId, chunkPath)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const disposedModules: Set&lt;ModuleId&gt; = new Set()</span><span class="s3">\n  </span><span class="s1">for (const [chunkPath, addedModuleIds] of chunksDeletedModules) {</span><span class="s3">\n    </span><span class="s1">for (const moduleId of addedModuleIds) {</span><span class="s3">\n      </span><span class="s1">if (removeModuleFromChunk(moduleId, chunkPath)) {</span><span class="s3">\n        </span><span class="s1">disposedModules.add(moduleId)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { disposedModules }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function disposePhase(</span><span class="s3">\n  </span><span class="s1">outdatedModules: Iterable&lt;ModuleId&gt;,</span><span class="s3">\n  </span><span class="s1">disposedModules: Iterable&lt;ModuleId&gt;</span><span class="s3">\n</span><span class="s1">): { outdatedModuleParents: Map&lt;ModuleId, Array&lt;ModuleId&gt;&gt; } {</span><span class="s3">\n  </span><span class="s1">for (const moduleId of outdatedModules) {</span><span class="s3">\n    </span><span class="s1">disposeModule(moduleId, 'replace')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const moduleId of disposedModules) {</span><span class="s3">\n    </span><span class="s1">disposeModule(moduleId, 'clear')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Removing modules from the module cache is a separate step.</span><span class="s3">\n  </span><span class="s1">// We also want to keep track of previous parents of the outdated modules.</span><span class="s3">\n  </span><span class="s1">const outdatedModuleParents = new Map()</span><span class="s3">\n  </span><span class="s1">for (const moduleId of outdatedModules) {</span><span class="s3">\n    </span><span class="s1">const oldModule = devModuleCache[moduleId]</span><span class="s3">\n    </span><span class="s1">outdatedModuleParents.set(moduleId, oldModule?.parents)</span><span class="s3">\n    </span><span class="s1">delete devModuleCache[moduleId]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO(alexkirsz) Dependencies: remove outdated dependency from module</span><span class="s3">\n  </span><span class="s1">// children.</span><span class="s3">\n\n  </span><span class="s1">return { outdatedModuleParents }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Disposes of an instance of a module.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Returns the persistent hot data that should be kept for the next module</span><span class="s3">\n </span><span class="s1">* instance.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* NOTE: mode = </span><span class="s3">\&quot;</span><span class="s1">replace</span><span class="s3">\&quot; </span><span class="s1">will not remove modules from the devModuleCache</span><span class="s3">\n </span><span class="s1">* This must be done in a separate step afterwards.</span><span class="s3">\n </span><span class="s1">* This is important because all modules need to be disposed to update the</span><span class="s3">\n </span><span class="s1">* parent/child relationships before they are actually removed from the devModuleCache.</span><span class="s3">\n </span><span class="s1">* If this was done in this method, the following disposeModule calls won't find</span><span class="s3">\n </span><span class="s1">* the module from the module id in the cache.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function disposeModule(moduleId: ModuleId, mode: 'clear' | 'replace') {</span><span class="s3">\n  </span><span class="s1">const module = devModuleCache[moduleId]</span><span class="s3">\n  </span><span class="s1">if (!module) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const hotState = moduleHotState.get(module)!</span><span class="s3">\n  </span><span class="s1">const data = {}</span><span class="s3">\n\n  </span><span class="s1">// Run the `hot.dispose` handler, if any, passing in the persistent</span><span class="s3">\n  </span><span class="s1">// `hot.data` object.</span><span class="s3">\n  </span><span class="s1">for (const disposeHandler of hotState.disposeHandlers) {</span><span class="s3">\n    </span><span class="s1">disposeHandler(data)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// This used to warn in `getOrInstantiateModuleFromParent` when a disposed</span><span class="s3">\n  </span><span class="s1">// module is still importing other modules.</span><span class="s3">\n  </span><span class="s1">module.hot.active = false</span><span class="s3">\n\n  </span><span class="s1">moduleHotState.delete(module)</span><span class="s3">\n\n  </span><span class="s1">// TODO(alexkirsz) Dependencies: delete the module from outdated deps.</span><span class="s3">\n\n  </span><span class="s1">// Remove the disposed module from its children's parent list.</span><span class="s3">\n  </span><span class="s1">// It will be added back once the module re-instantiates and imports its</span><span class="s3">\n  </span><span class="s1">// children again.</span><span class="s3">\n  </span><span class="s1">for (const childId of module.children) {</span><span class="s3">\n    </span><span class="s1">const child = devModuleCache[childId]</span><span class="s3">\n    </span><span class="s1">if (!child) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const idx = child.parents.indexOf(module.id)</span><span class="s3">\n    </span><span class="s1">if (idx &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">child.parents.splice(idx, 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">switch (mode) {</span><span class="s3">\n    </span><span class="s1">case 'clear':</span><span class="s3">\n      </span><span class="s1">delete devModuleCache[module.id]</span><span class="s3">\n      </span><span class="s1">moduleHotData.delete(module.id)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'replace':</span><span class="s3">\n      </span><span class="s1">moduleHotData.set(module.id, data)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">invariant(mode, (mode) =&gt; `invalid mode: ${mode}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyPhase(</span><span class="s3">\n  </span><span class="s1">outdatedSelfAcceptedModules: {</span><span class="s3">\n    </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n    </span><span class="s1">errorHandler: true | Function</span><span class="s3">\n  </span><span class="s1">}[],</span><span class="s3">\n  </span><span class="s1">newModuleFactories: Map&lt;ModuleId, ModuleFactory&gt;,</span><span class="s3">\n  </span><span class="s1">outdatedModuleParents: Map&lt;ModuleId, Array&lt;ModuleId&gt;&gt;,</span><span class="s3">\n  </span><span class="s1">reportError: (err: any) =&gt; void</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Update module factories.</span><span class="s3">\n  </span><span class="s1">for (const [moduleId, factory] of newModuleFactories.entries()) {</span><span class="s3">\n    </span><span class="s1">applyModuleFactoryName(factory)</span><span class="s3">\n    </span><span class="s1">moduleFactories.set(moduleId, factory)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO(alexkirsz) Run new runtime entries here.</span><span class="s3">\n\n  </span><span class="s1">// TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.</span><span class="s3">\n\n  </span><span class="s1">// Re-instantiate all outdated self-accepted modules.</span><span class="s3">\n  </span><span class="s1">for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">instantiateModule(</span><span class="s3">\n        </span><span class="s1">moduleId,</span><span class="s3">\n        </span><span class="s1">SourceType.Update,</span><span class="s3">\n        </span><span class="s1">outdatedModuleParents.get(moduleId)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">if (typeof errorHandler === 'function') {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">errorHandler(err, { moduleId, module: devModuleCache[moduleId] })</span><span class="s3">\n        </span><span class="s1">} catch (err2) {</span><span class="s3">\n          </span><span class="s1">reportError(err2)</span><span class="s3">\n          </span><span class="s1">reportError(err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">reportError(err)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyUpdate(update: PartialUpdate) {</span><span class="s3">\n  </span><span class="s1">switch (update.type) {</span><span class="s3">\n    </span><span class="s1">case 'ChunkListUpdate':</span><span class="s3">\n      </span><span class="s1">applyChunkListUpdate(update)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">invariant(update, (update) =&gt; `Unknown update type: ${update.type}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyChunkListUpdate(update: ChunkListUpdate) {</span><span class="s3">\n  </span><span class="s1">if (update.merged != null) {</span><span class="s3">\n    </span><span class="s1">for (const merged of update.merged) {</span><span class="s3">\n      </span><span class="s1">switch (merged.type) {</span><span class="s3">\n        </span><span class="s1">case 'EcmascriptMergedUpdate':</span><span class="s3">\n          </span><span class="s1">applyEcmascriptMergedUpdate(merged)</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">invariant(merged, (merged) =&gt; `Unknown merged type: ${merged.type}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (update.chunks != null) {</span><span class="s3">\n    </span><span class="s1">for (const [chunkPath, chunkUpdate] of Object.entries(</span><span class="s3">\n      </span><span class="s1">update.chunks</span><span class="s3">\n    </span><span class="s1">) as Array&lt;[ChunkPath, ChunkUpdate]&gt;) {</span><span class="s3">\n      </span><span class="s1">const chunkUrl = getChunkRelativeUrl(chunkPath)</span><span class="s3">\n\n      </span><span class="s1">switch (chunkUpdate.type) {</span><span class="s3">\n        </span><span class="s1">case 'added':</span><span class="s3">\n          </span><span class="s1">BACKEND.loadChunkCached(SourceType.Update, chunkUrl)</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">case 'total':</span><span class="s3">\n          </span><span class="s1">DEV_BACKEND.reloadChunk?.(chunkUrl)</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">case 'deleted':</span><span class="s3">\n          </span><span class="s1">DEV_BACKEND.unloadChunk?.(chunkUrl)</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">case 'partial':</span><span class="s3">\n          </span><span class="s1">invariant(</span><span class="s3">\n            </span><span class="s1">chunkUpdate.instruction,</span><span class="s3">\n            </span><span class="s1">(instruction) =&gt;</span><span class="s3">\n              </span><span class="s1">`Unknown partial instruction: ${JSON.stringify(instruction)}.`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">invariant(</span><span class="s3">\n            </span><span class="s1">chunkUpdate,</span><span class="s3">\n            </span><span class="s1">(chunkUpdate) =&gt; `Unknown chunk update type: ${chunkUpdate.type}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyEcmascriptMergedUpdate(update: EcmascriptMergedUpdate) {</span><span class="s3">\n  </span><span class="s1">const { entries = {}, chunks = {} } = update</span><span class="s3">\n  </span><span class="s1">const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(</span><span class="s3">\n    </span><span class="s1">entries,</span><span class="s3">\n    </span><span class="s1">chunks</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const { outdatedModules, newModuleFactories } = computeOutdatedModules(</span><span class="s3">\n    </span><span class="s1">added,</span><span class="s3">\n    </span><span class="s1">modified</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted)</span><span class="s3">\n\n  </span><span class="s1">applyInternal(outdatedModules, disposedModules, newModuleFactories)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyInvalidatedModules(outdatedModules: Set&lt;ModuleId&gt;) {</span><span class="s3">\n  </span><span class="s1">if (queuedInvalidatedModules.size &gt; 0) {</span><span class="s3">\n    </span><span class="s1">computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId) =&gt; {</span><span class="s3">\n      </span><span class="s1">outdatedModules.add(moduleId)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">queuedInvalidatedModules.clear()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return outdatedModules</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyInternal(</span><span class="s3">\n  </span><span class="s1">outdatedModules: Set&lt;ModuleId&gt;,</span><span class="s3">\n  </span><span class="s1">disposedModules: Iterable&lt;ModuleId&gt;,</span><span class="s3">\n  </span><span class="s1">newModuleFactories: Map&lt;ModuleId, ModuleFactory&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">outdatedModules = applyInvalidatedModules(outdatedModules)</span><span class="s3">\n\n  </span><span class="s1">const outdatedSelfAcceptedModules =</span><span class="s3">\n    </span><span class="s1">computeOutdatedSelfAcceptedModules(outdatedModules)</span><span class="s3">\n\n  </span><span class="s1">const { outdatedModuleParents } = disposePhase(</span><span class="s3">\n    </span><span class="s1">outdatedModules,</span><span class="s3">\n    </span><span class="s1">disposedModules</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// we want to continue on error and only throw the error after we tried applying all updates</span><span class="s3">\n  </span><span class="s1">let error: any</span><span class="s3">\n\n  </span><span class="s1">function reportError(err: any) {</span><span class="s3">\n    </span><span class="s1">if (!error) error = err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">applyPhase(</span><span class="s3">\n    </span><span class="s1">outdatedSelfAcceptedModules,</span><span class="s3">\n    </span><span class="s1">newModuleFactories,</span><span class="s3">\n    </span><span class="s1">outdatedModuleParents,</span><span class="s3">\n    </span><span class="s1">reportError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (error) {</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (queuedInvalidatedModules.size &gt; 0) {</span><span class="s3">\n    </span><span class="s1">applyInternal(new Set(), [], new Map())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeChangedModules(</span><span class="s3">\n  </span><span class="s1">entries: Record&lt;ModuleId, EcmascriptModuleEntry&gt;,</span><span class="s3">\n  </span><span class="s1">updates: Record&lt;ChunkPath, EcmascriptMergedChunkUpdate&gt;</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">added: Map&lt;ModuleId, EcmascriptModuleEntry | undefined&gt;</span><span class="s3">\n  </span><span class="s1">modified: Map&lt;ModuleId, EcmascriptModuleEntry&gt;</span><span class="s3">\n  </span><span class="s1">deleted: Set&lt;ModuleId&gt;</span><span class="s3">\n  </span><span class="s1">chunksAdded: Map&lt;ChunkPath, Set&lt;ModuleId&gt;&gt;</span><span class="s3">\n  </span><span class="s1">chunksDeleted: Map&lt;ChunkPath, Set&lt;ModuleId&gt;&gt;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const chunksAdded = new Map()</span><span class="s3">\n  </span><span class="s1">const chunksDeleted = new Map()</span><span class="s3">\n  </span><span class="s1">const added: Map&lt;ModuleId, EcmascriptModuleEntry&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">const modified = new Map()</span><span class="s3">\n  </span><span class="s1">const deleted: Set&lt;ModuleId&gt; = new Set()</span><span class="s3">\n\n  </span><span class="s1">for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates) as Array&lt;</span><span class="s3">\n    </span><span class="s1">[ChunkPath, EcmascriptMergedChunkUpdate]</span><span class="s3">\n  </span><span class="s1">&gt;) {</span><span class="s3">\n    </span><span class="s1">switch (mergedChunkUpdate.type) {</span><span class="s3">\n      </span><span class="s1">case 'added': {</span><span class="s3">\n        </span><span class="s1">const updateAdded = new Set(mergedChunkUpdate.modules)</span><span class="s3">\n        </span><span class="s1">for (const moduleId of updateAdded) {</span><span class="s3">\n          </span><span class="s1">added.set(moduleId, entries[moduleId])</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">chunksAdded.set(chunkPath, updateAdded)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'deleted': {</span><span class="s3">\n        </span><span class="s1">// We could also use `mergedChunkUpdate.modules` here.</span><span class="s3">\n        </span><span class="s1">const updateDeleted = new Set(chunkModulesMap.get(chunkPath))</span><span class="s3">\n        </span><span class="s1">for (const moduleId of updateDeleted) {</span><span class="s3">\n          </span><span class="s1">deleted.add(moduleId)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">chunksDeleted.set(chunkPath, updateDeleted)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'partial': {</span><span class="s3">\n        </span><span class="s1">const updateAdded = new Set(mergedChunkUpdate.added)</span><span class="s3">\n        </span><span class="s1">const updateDeleted = new Set(mergedChunkUpdate.deleted)</span><span class="s3">\n        </span><span class="s1">for (const moduleId of updateAdded) {</span><span class="s3">\n          </span><span class="s1">added.set(moduleId, entries[moduleId])</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const moduleId of updateDeleted) {</span><span class="s3">\n          </span><span class="s1">deleted.add(moduleId)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">chunksAdded.set(chunkPath, updateAdded)</span><span class="s3">\n        </span><span class="s1">chunksDeleted.set(chunkPath, updateDeleted)</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">invariant(</span><span class="s3">\n          </span><span class="s1">mergedChunkUpdate,</span><span class="s3">\n          </span><span class="s1">(mergedChunkUpdate) =&gt;</span><span class="s3">\n            </span><span class="s1">`Unknown merged chunk update type: ${mergedChunkUpdate.type}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If a module was added from one chunk and deleted from another in the same update,</span><span class="s3">\n  </span><span class="s1">// consider it to be modified, as it means the module was moved from one chunk to another</span><span class="s3">\n  </span><span class="s1">// AND has new code in a single update.</span><span class="s3">\n  </span><span class="s1">for (const moduleId of added.keys()) {</span><span class="s3">\n    </span><span class="s1">if (deleted.has(moduleId)) {</span><span class="s3">\n      </span><span class="s1">added.delete(moduleId)</span><span class="s3">\n      </span><span class="s1">deleted.delete(moduleId)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [moduleId, entry] of Object.entries(entries)) {</span><span class="s3">\n    </span><span class="s1">// Modules that haven't been added to any chunk but have new code are considered</span><span class="s3">\n    </span><span class="s1">// to be modified.</span><span class="s3">\n    </span><span class="s1">// This needs to be under the previous loop, as we need it to get rid of modules</span><span class="s3">\n    </span><span class="s1">// that were added and deleted in the same update.</span><span class="s3">\n    </span><span class="s1">if (!added.has(moduleId)) {</span><span class="s3">\n      </span><span class="s1">modified.set(moduleId, entry)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { added, deleted, modified, chunksAdded, chunksDeleted }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ModuleEffect =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'unaccepted'</span><span class="s3">\n      </span><span class="s1">dependencyChain: ModuleId[]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'self-declined'</span><span class="s3">\n      </span><span class="s1">dependencyChain: ModuleId[]</span><span class="s3">\n      </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'accepted'</span><span class="s3">\n      </span><span class="s1">moduleId: ModuleId</span><span class="s3">\n      </span><span class="s1">outdatedModules: Set&lt;ModuleId&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getAffectedModuleEffects(moduleId: ModuleId): ModuleEffect {</span><span class="s3">\n  </span><span class="s1">const outdatedModules: Set&lt;ModuleId&gt; = new Set()</span><span class="s3">\n\n  </span><span class="s1">type QueueItem = { moduleId?: ModuleId; dependencyChain: ModuleId[] }</span><span class="s3">\n\n  </span><span class="s1">const queue: QueueItem[] = [</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">moduleId,</span><span class="s3">\n      </span><span class="s1">dependencyChain: [],</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">let nextItem</span><span class="s3">\n  </span><span class="s1">while ((nextItem = queue.shift())) {</span><span class="s3">\n    </span><span class="s1">const { moduleId, dependencyChain } = nextItem</span><span class="s3">\n\n    </span><span class="s1">if (moduleId != null) {</span><span class="s3">\n      </span><span class="s1">if (outdatedModules.has(moduleId)) {</span><span class="s3">\n        </span><span class="s1">// Avoid infinite loops caused by cycles between modules in the dependency chain.</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">outdatedModules.add(moduleId)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We've arrived at the runtime of the chunk, which means that nothing</span><span class="s3">\n    </span><span class="s1">// else above can accept this update.</span><span class="s3">\n    </span><span class="s1">if (moduleId === undefined) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">type: 'unaccepted',</span><span class="s3">\n        </span><span class="s1">dependencyChain,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const module = devModuleCache[moduleId]</span><span class="s3">\n    </span><span class="s1">const hotState = moduleHotState.get(module)!</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// The module is not in the cache. Since this is a </span><span class="s3">\&quot;</span><span class="s1">modified</span><span class="s3">\&quot; </span><span class="s1">update,</span><span class="s3">\n      </span><span class="s1">// it means that the module was never instantiated before.</span><span class="s3">\n      </span><span class="s1">!module || // The module accepted itself without invalidating globalThis.</span><span class="s3">\n      </span><span class="s1">// TODO is that right?</span><span class="s3">\n      </span><span class="s1">(hotState.selfAccepted &amp;&amp; !hotState.selfInvalidated)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (hotState.selfDeclined) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">type: 'self-declined',</span><span class="s3">\n        </span><span class="s1">dependencyChain,</span><span class="s3">\n        </span><span class="s1">moduleId,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (runtimeModules.has(moduleId)) {</span><span class="s3">\n      </span><span class="s1">queue.push({</span><span class="s3">\n        </span><span class="s1">moduleId: undefined,</span><span class="s3">\n        </span><span class="s1">dependencyChain: [...dependencyChain, moduleId],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const parentId of module.parents) {</span><span class="s3">\n      </span><span class="s1">const parent = devModuleCache[parentId]</span><span class="s3">\n\n      </span><span class="s1">if (!parent) {</span><span class="s3">\n        </span><span class="s1">// TODO(alexkirsz) Is this even possible?</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// TODO(alexkirsz) Dependencies: check accepted and declined</span><span class="s3">\n      </span><span class="s1">// dependencies here.</span><span class="s3">\n\n      </span><span class="s1">queue.push({</span><span class="s3">\n        </span><span class="s1">moduleId: parentId,</span><span class="s3">\n        </span><span class="s1">dependencyChain: [...dependencyChain, moduleId],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: 'accepted',</span><span class="s3">\n    </span><span class="s1">moduleId,</span><span class="s3">\n    </span><span class="s1">outdatedModules,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleApply(chunkListPath: ChunkListPath, update: ServerMessage) {</span><span class="s3">\n  </span><span class="s1">switch (update.type) {</span><span class="s3">\n    </span><span class="s1">case 'partial': {</span><span class="s3">\n      </span><span class="s1">// This indicates that the update is can be applied to the current state of the application.</span><span class="s3">\n      </span><span class="s1">applyUpdate(update.instruction)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case 'restart': {</span><span class="s3">\n      </span><span class="s1">// This indicates that there is no way to apply the update to the</span><span class="s3">\n      </span><span class="s1">// current state of the application, and that the application must be</span><span class="s3">\n      </span><span class="s1">// restarted.</span><span class="s3">\n      </span><span class="s1">DEV_BACKEND.restart()</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case 'notFound': {</span><span class="s3">\n      </span><span class="s1">// This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,</span><span class="s3">\n      </span><span class="s1">// or the page itself was deleted.</span><span class="s3">\n      </span><span class="s1">// If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.</span><span class="s3">\n      </span><span class="s1">// If it is a runtime chunk list, we restart the application.</span><span class="s3">\n      </span><span class="s1">if (runtimeChunkLists.has(chunkListPath)) {</span><span class="s3">\n        </span><span class="s1">DEV_BACKEND.restart()</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">disposeChunkList(chunkListPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error(`Unknown update type: ${update.type}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createModuleHot(</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId,</span><span class="s3">\n  </span><span class="s1">hotData: HotData</span><span class="s3">\n</span><span class="s1">): { hot: Hot; hotState: HotState } {</span><span class="s3">\n  </span><span class="s1">const hotState: HotState = {</span><span class="s3">\n    </span><span class="s1">selfAccepted: false,</span><span class="s3">\n    </span><span class="s1">selfDeclined: false,</span><span class="s3">\n    </span><span class="s1">selfInvalidated: false,</span><span class="s3">\n    </span><span class="s1">disposeHandlers: [],</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const hot: Hot = {</span><span class="s3">\n    </span><span class="s1">// TODO(alexkirsz) This is not defined in the HMR API. It was used to</span><span class="s3">\n    </span><span class="s1">// decide whether to warn whenever an HMR-disposed module required other</span><span class="s3">\n    </span><span class="s1">// modules. We might want to remove it.</span><span class="s3">\n    </span><span class="s1">active: true,</span><span class="s3">\n\n    </span><span class="s1">data: hotData ?? {},</span><span class="s3">\n\n    </span><span class="s1">// TODO(alexkirsz) Support full (dep, callback, errorHandler) form.</span><span class="s3">\n    </span><span class="s1">accept: (</span><span class="s3">\n      </span><span class="s1">modules?: string | string[] | AcceptErrorHandler,</span><span class="s3">\n      </span><span class="s1">_callback?: AcceptCallback,</span><span class="s3">\n      </span><span class="s1">_errorHandler?: AcceptErrorHandler</span><span class="s3">\n    </span><span class="s1">) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (modules === undefined) {</span><span class="s3">\n        </span><span class="s1">hotState.selfAccepted = true</span><span class="s3">\n      </span><span class="s1">} else if (typeof modules === 'function') {</span><span class="s3">\n        </span><span class="s1">hotState.selfAccepted = modules</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error('unsupported `accept` signature')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">decline: (dep) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (dep === undefined) {</span><span class="s3">\n        </span><span class="s1">hotState.selfDeclined = true</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error('unsupported `decline` signature')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">dispose: (callback) =&gt; {</span><span class="s3">\n      </span><span class="s1">hotState.disposeHandlers.push(callback)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">addDisposeHandler: (callback) =&gt; {</span><span class="s3">\n      </span><span class="s1">hotState.disposeHandlers.push(callback)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">removeDisposeHandler: (callback) =&gt; {</span><span class="s3">\n      </span><span class="s1">const idx = hotState.disposeHandlers.indexOf(callback)</span><span class="s3">\n      </span><span class="s1">if (idx &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">hotState.disposeHandlers.splice(idx, 1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">invalidate: () =&gt; {</span><span class="s3">\n      </span><span class="s1">hotState.selfInvalidated = true</span><span class="s3">\n      </span><span class="s1">queuedInvalidatedModules.add(moduleId)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">// NOTE(alexkirsz) This is part of the management API, which we don't</span><span class="s3">\n    </span><span class="s1">// implement, but the Next.js React Refresh runtime uses this to decide</span><span class="s3">\n    </span><span class="s1">// whether to schedule an update.</span><span class="s3">\n    </span><span class="s1">status: () =&gt; 'idle',</span><span class="s3">\n\n    </span><span class="s1">// NOTE(alexkirsz) Since we always return </span><span class="s3">\&quot;</span><span class="s1">idle</span><span class="s3">\&quot; </span><span class="s1">for now, these are no-ops.</span><span class="s3">\n    </span><span class="s1">addStatusHandler: (_handler) =&gt; {},</span><span class="s3">\n    </span><span class="s1">removeStatusHandler: (_handler) =&gt; {},</span><span class="s3">\n\n    </span><span class="s1">// NOTE(jridgewell) Check returns the list of updated modules, but we don't</span><span class="s3">\n    </span><span class="s1">// want the webpack code paths to ever update (the turbopack paths handle</span><span class="s3">\n    </span><span class="s1">// this already).</span><span class="s3">\n    </span><span class="s1">check: () =&gt; Promise.resolve(null),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { hot, hotState }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes a module from a chunk.</span><span class="s3">\n </span><span class="s1">* Returns `true` if there are no remaining chunks including this module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function removeModuleFromChunk(</span><span class="s3">\n  </span><span class="s1">moduleId: ModuleId,</span><span class="s3">\n  </span><span class="s1">chunkPath: ChunkPath</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const moduleChunks = moduleChunksMap.get(moduleId)!</span><span class="s3">\n  </span><span class="s1">moduleChunks.delete(chunkPath)</span><span class="s3">\n\n  </span><span class="s1">const chunkModules = chunkModulesMap.get(chunkPath)!</span><span class="s3">\n  </span><span class="s1">chunkModules.delete(moduleId)</span><span class="s3">\n\n  </span><span class="s1">const noRemainingModules = chunkModules.size === 0</span><span class="s3">\n  </span><span class="s1">if (noRemainingModules) {</span><span class="s3">\n    </span><span class="s1">chunkModulesMap.delete(chunkPath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const noRemainingChunks = moduleChunks.size === 0</span><span class="s3">\n  </span><span class="s1">if (noRemainingChunks) {</span><span class="s3">\n    </span><span class="s1">moduleChunksMap.delete(moduleId)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return noRemainingChunks</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Disposes of a chunk list and its corresponding exclusive chunks.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function disposeChunkList(chunkListPath: ChunkListPath): boolean {</span><span class="s3">\n  </span><span class="s1">const chunkPaths = chunkListChunksMap.get(chunkListPath)</span><span class="s3">\n  </span><span class="s1">if (chunkPaths == null) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">chunkListChunksMap.delete(chunkListPath)</span><span class="s3">\n\n  </span><span class="s1">for (const chunkPath of chunkPaths) {</span><span class="s3">\n    </span><span class="s1">const chunkChunkLists = chunkChunkListsMap.get(chunkPath)!</span><span class="s3">\n    </span><span class="s1">chunkChunkLists.delete(chunkListPath)</span><span class="s3">\n\n    </span><span class="s1">if (chunkChunkLists.size === 0) {</span><span class="s3">\n      </span><span class="s1">chunkChunkListsMap.delete(chunkPath)</span><span class="s3">\n      </span><span class="s1">disposeChunk(chunkPath)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We must also dispose of the chunk list's chunk itself to ensure it may</span><span class="s3">\n  </span><span class="s1">// be reloaded properly in the future.</span><span class="s3">\n  </span><span class="s1">const chunkListUrl = getChunkRelativeUrl(chunkListPath)</span><span class="s3">\n\n  </span><span class="s1">DEV_BACKEND.unloadChunk?.(chunkListUrl)</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Disposes of a chunk and its corresponding exclusive modules.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @returns Whether the chunk was disposed of.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function disposeChunk(chunkPath: ChunkPath): boolean {</span><span class="s3">\n  </span><span class="s1">const chunkUrl = getChunkRelativeUrl(chunkPath)</span><span class="s3">\n  </span><span class="s1">// This should happen whether the chunk has any modules in it or not.</span><span class="s3">\n  </span><span class="s1">// For instance, CSS chunks have no modules in them, but they still need to be unloaded.</span><span class="s3">\n  </span><span class="s1">DEV_BACKEND.unloadChunk?.(chunkUrl)</span><span class="s3">\n\n  </span><span class="s1">const chunkModules = chunkModulesMap.get(chunkPath)</span><span class="s3">\n  </span><span class="s1">if (chunkModules == null) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">chunkModules.delete(chunkPath)</span><span class="s3">\n\n  </span><span class="s1">for (const moduleId of chunkModules) {</span><span class="s3">\n    </span><span class="s1">const moduleChunks = moduleChunksMap.get(moduleId)!</span><span class="s3">\n    </span><span class="s1">moduleChunks.delete(chunkPath)</span><span class="s3">\n\n    </span><span class="s1">const noRemainingChunks = moduleChunks.size === 0</span><span class="s3">\n    </span><span class="s1">if (noRemainingChunks) {</span><span class="s3">\n      </span><span class="s1">moduleChunksMap.delete(moduleId)</span><span class="s3">\n      </span><span class="s1">disposeModule(moduleId, 'clear')</span><span class="s3">\n      </span><span class="s1">availableModules.delete(moduleId)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds a module to a chunk.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function addModuleToChunk(moduleId: ModuleId, chunkPath: ChunkPath) {</span><span class="s3">\n  </span><span class="s1">let moduleChunks = moduleChunksMap.get(moduleId)</span><span class="s3">\n  </span><span class="s1">if (!moduleChunks) {</span><span class="s3">\n    </span><span class="s1">moduleChunks = new Set([chunkPath])</span><span class="s3">\n    </span><span class="s1">moduleChunksMap.set(moduleId, moduleChunks)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">moduleChunks.add(chunkPath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let chunkModules = chunkModulesMap.get(chunkPath)</span><span class="s3">\n  </span><span class="s1">if (!chunkModules) {</span><span class="s3">\n    </span><span class="s1">chunkModules = new Set([moduleId])</span><span class="s3">\n    </span><span class="s1">chunkModulesMap.set(chunkPath, chunkModules)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">chunkModules.add(moduleId)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Marks a chunk list as a runtime chunk list. There can be more than one</span><span class="s3">\n </span><span class="s1">* runtime chunk list. For instance, integration tests can have multiple chunk</span><span class="s3">\n </span><span class="s1">* groups loaded at runtime, each with its own chunk list.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function markChunkListAsRuntime(chunkListPath: ChunkListPath) {</span><span class="s3">\n  </span><span class="s1">runtimeChunkLists.add(chunkListPath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function registerChunk(registration: ChunkRegistration) {</span><span class="s3">\n  </span><span class="s1">const chunkPath = getPathFromScript(registration[0])</span><span class="s3">\n  </span><span class="s1">let runtimeParams: RuntimeParams | undefined</span><span class="s3">\n  </span><span class="s1">// When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length</span><span class="s3">\n  </span><span class="s1">if (registration.length === 2) {</span><span class="s3">\n    </span><span class="s1">runtimeParams = registration[1] as RuntimeParams</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">runtimeParams = undefined</span><span class="s3">\n    </span><span class="s1">installCompressedModuleFactories(</span><span class="s3">\n      </span><span class="s1">registration as CompressedModuleFactories,</span><span class="s3">\n      </span><span class="s1">/* offset= */ 1,</span><span class="s3">\n      </span><span class="s1">moduleFactories,</span><span class="s3">\n      </span><span class="s1">(id: ModuleId) =&gt; addModuleToChunk(id, chunkPath)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return BACKEND.registerChunk(chunkPath, runtimeParams)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Subscribes to chunk list updates from the update server and applies them.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function registerChunkList(chunkList: ChunkList) {</span><span class="s3">\n  </span><span class="s1">const chunkListScript = chunkList.script</span><span class="s3">\n  </span><span class="s1">const chunkListPath = getPathFromScript(chunkListScript)</span><span class="s3">\n  </span><span class="s1">// The </span><span class="s3">\&quot;</span><span class="s1">chunk</span><span class="s3">\&quot; </span><span class="s1">is also registered to finish the loading in the backend</span><span class="s3">\n  </span><span class="s1">BACKEND.registerChunk(chunkListPath as string as ChunkPath)</span><span class="s3">\n  </span><span class="s1">globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS!.push([</span><span class="s3">\n    </span><span class="s1">chunkListPath,</span><span class="s3">\n    </span><span class="s1">handleApply.bind(null, chunkListPath),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n\n  </span><span class="s1">// Adding chunks to chunk lists and vice versa.</span><span class="s3">\n  </span><span class="s1">const chunkPaths = new Set(chunkList.chunks.map(getChunkPath))</span><span class="s3">\n  </span><span class="s1">chunkListChunksMap.set(chunkListPath, chunkPaths)</span><span class="s3">\n  </span><span class="s1">for (const chunkPath of chunkPaths) {</span><span class="s3">\n    </span><span class="s1">let chunkChunkLists = chunkChunkListsMap.get(chunkPath)</span><span class="s3">\n    </span><span class="s1">if (!chunkChunkLists) {</span><span class="s3">\n      </span><span class="s1">chunkChunkLists = new Set([chunkListPath])</span><span class="s3">\n      </span><span class="s1">chunkChunkListsMap.set(chunkPath, chunkChunkLists)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">chunkChunkLists.add(chunkListPath)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (chunkList.source === 'entry') {</span><span class="s3">\n    </span><span class="s1">markChunkListAsRuntime(chunkListPath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= []</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1558</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/browser/runtime/dom/runtime-backend-dom.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This file contains the runtime code specific to the Turbopack development</span><span class="s3">\n </span><span class="s1">* ECMAScript DOM runtime.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It will be appended to the base development runtime code.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../../browser/runtime/base/runtime-base.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../../shared/runtime-types.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">type ChunkResolver = {</span><span class="s3">\n  </span><span class="s1">resolved: boolean</span><span class="s3">\n  </span><span class="s1">loadingStarted: boolean</span><span class="s3">\n  </span><span class="s1">resolve: () =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (error?: Error) =&gt; void</span><span class="s3">\n  </span><span class="s1">promise: Promise&lt;any&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let BACKEND: RuntimeBackend</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Maps chunk paths to the corresponding resolver.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const chunkResolvers: Map&lt;ChunkUrl, ChunkResolver&gt; = new Map()</span><span class="s3">\n\n</span><span class="s1">;(() =&gt; {</span><span class="s3">\n  </span><span class="s1">BACKEND = {</span><span class="s3">\n    </span><span class="s1">async registerChunk(chunkPath, params) {</span><span class="s3">\n      </span><span class="s1">const chunkUrl = getChunkRelativeUrl(chunkPath)</span><span class="s3">\n\n      </span><span class="s1">const resolver = getOrCreateResolver(chunkUrl)</span><span class="s3">\n      </span><span class="s1">resolver.resolve()</span><span class="s3">\n\n      </span><span class="s1">if (params == null) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">for (const otherChunkData of params.otherChunks) {</span><span class="s3">\n        </span><span class="s1">const otherChunkPath = getChunkPath(otherChunkData)</span><span class="s3">\n        </span><span class="s1">const otherChunkUrl = getChunkRelativeUrl(otherChunkPath)</span><span class="s3">\n\n        </span><span class="s1">// Chunk might have started loading, so we want to avoid triggering another load.</span><span class="s3">\n        </span><span class="s1">getOrCreateResolver(otherChunkUrl)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// This waits for chunks to be loaded, but also marks included items as available.</span><span class="s3">\n      </span><span class="s1">await Promise.all(</span><span class="s3">\n        </span><span class="s1">params.otherChunks.map((otherChunkData) =&gt;</span><span class="s3">\n          </span><span class="s1">loadInitialChunk(chunkPath, otherChunkData)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (params.runtimeModuleIds.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">for (const moduleId of params.runtimeModuleIds) {</span><span class="s3">\n          </span><span class="s1">getOrInstantiateRuntimeModule(chunkPath, moduleId)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Loads the given chunk, and returns a promise that resolves once the chunk</span><span class="s3">\n     </span><span class="s1">* has been loaded.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">loadChunkCached(sourceType: SourceType, chunkUrl: ChunkUrl) {</span><span class="s3">\n      </span><span class="s1">return doLoadChunk(sourceType, chunkUrl)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">async loadWebAssembly(</span><span class="s3">\n      </span><span class="s1">_sourceType: SourceType,</span><span class="s3">\n      </span><span class="s1">_sourceData: SourceData,</span><span class="s3">\n      </span><span class="s1">wasmChunkPath: ChunkPath,</span><span class="s3">\n      </span><span class="s1">_edgeModule: () =&gt; WebAssembly.Module,</span><span class="s3">\n      </span><span class="s1">importsObj: WebAssembly.Imports</span><span class="s3">\n    </span><span class="s1">): Promise&lt;Exports&gt; {</span><span class="s3">\n      </span><span class="s1">const req = fetchWebAssembly(wasmChunkPath)</span><span class="s3">\n\n      </span><span class="s1">const { instance } = await WebAssembly.instantiateStreaming(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">importsObj</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">return instance.exports</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">async loadWebAssemblyModule(</span><span class="s3">\n      </span><span class="s1">_sourceType: SourceType,</span><span class="s3">\n      </span><span class="s1">_sourceData: SourceData,</span><span class="s3">\n      </span><span class="s1">wasmChunkPath: ChunkPath,</span><span class="s3">\n      </span><span class="s1">_edgeModule: () =&gt; WebAssembly.Module</span><span class="s3">\n    </span><span class="s1">): Promise&lt;WebAssembly.Module&gt; {</span><span class="s3">\n      </span><span class="s1">const req = fetchWebAssembly(wasmChunkPath)</span><span class="s3">\n\n      </span><span class="s1">return await WebAssembly.compileStreaming(req)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {</span><span class="s3">\n    </span><span class="s1">let resolver = chunkResolvers.get(chunkUrl)</span><span class="s3">\n    </span><span class="s1">if (!resolver) {</span><span class="s3">\n      </span><span class="s1">let resolve: () =&gt; void</span><span class="s3">\n      </span><span class="s1">let reject: (error?: Error) =&gt; void</span><span class="s3">\n      </span><span class="s1">const promise = new Promise&lt;void&gt;((innerResolve, innerReject) =&gt; {</span><span class="s3">\n        </span><span class="s1">resolve = innerResolve</span><span class="s3">\n        </span><span class="s1">reject = innerReject</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">resolver = {</span><span class="s3">\n        </span><span class="s1">resolved: false,</span><span class="s3">\n        </span><span class="s1">loadingStarted: false,</span><span class="s3">\n        </span><span class="s1">promise,</span><span class="s3">\n        </span><span class="s1">resolve: () =&gt; {</span><span class="s3">\n          </span><span class="s1">resolver!.resolved = true</span><span class="s3">\n          </span><span class="s1">resolve()</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">reject: reject!,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">chunkResolvers.set(chunkUrl, resolver)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return resolver</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Loads the given chunk, and returns a promise that resolves once the chunk</span><span class="s3">\n   </span><span class="s1">* has been loaded.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function doLoadChunk(sourceType: SourceType, chunkUrl: ChunkUrl) {</span><span class="s3">\n    </span><span class="s1">const resolver = getOrCreateResolver(chunkUrl)</span><span class="s3">\n    </span><span class="s1">if (resolver.loadingStarted) {</span><span class="s3">\n      </span><span class="s1">return resolver.promise</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (sourceType === SourceType.Runtime) {</span><span class="s3">\n      </span><span class="s1">// We don't need to load chunks references from runtime code, as they're already</span><span class="s3">\n      </span><span class="s1">// present in the DOM.</span><span class="s3">\n      </span><span class="s1">resolver.loadingStarted = true</span><span class="s3">\n\n      </span><span class="s1">if (isCss(chunkUrl)) {</span><span class="s3">\n        </span><span class="s1">// CSS chunks do not register themselves, and as such must be marked as</span><span class="s3">\n        </span><span class="s1">// loaded instantly.</span><span class="s3">\n        </span><span class="s1">resolver.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We need to wait for JS chunks to register themselves within `registerChunk`</span><span class="s3">\n      </span><span class="s1">// before we can start instantiating runtime modules, hence the absence of</span><span class="s3">\n      </span><span class="s1">// `resolver.resolve()` in this branch.</span><span class="s3">\n\n      </span><span class="s1">return resolver.promise</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof importScripts === 'function') {</span><span class="s3">\n      </span><span class="s1">// We're in a web worker</span><span class="s3">\n      </span><span class="s1">if (isCss(chunkUrl)) {</span><span class="s3">\n        </span><span class="s1">// ignore</span><span class="s3">\n      </span><span class="s1">} else if (isJs(chunkUrl)) {</span><span class="s3">\n        </span><span class="s1">self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl)</span><span class="s3">\n        </span><span class="s1">importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`can't infer type of chunk from URL ${chunkUrl} in worker`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.</span><span class="s3">\n      </span><span class="s1">const decodedChunkUrl = decodeURI(chunkUrl)</span><span class="s3">\n\n      </span><span class="s1">if (isCss(chunkUrl)) {</span><span class="s3">\n        </span><span class="s1">const previousLinks = document.querySelectorAll(</span><span class="s3">\n          </span><span class="s1">`link[rel=stylesheet][href=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],link[rel=stylesheet][href^=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">],link[rel=stylesheet][href=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],link[rel=stylesheet][href^=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">]`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (previousLinks.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">// CSS chunks do not register themselves, and as such must be marked as</span><span class="s3">\n          </span><span class="s1">// loaded instantly.</span><span class="s3">\n          </span><span class="s1">resolver.resolve()</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const link = document.createElement('link')</span><span class="s3">\n          </span><span class="s1">link.rel = 'stylesheet'</span><span class="s3">\n          </span><span class="s1">link.href = chunkUrl</span><span class="s3">\n          </span><span class="s1">link.onerror = () =&gt; {</span><span class="s3">\n            </span><span class="s1">resolver.reject()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">link.onload = () =&gt; {</span><span class="s3">\n            </span><span class="s1">// CSS chunks do not register themselves, and as such must be marked as</span><span class="s3">\n            </span><span class="s1">// loaded instantly.</span><span class="s3">\n            </span><span class="s1">resolver.resolve()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Append to the `head` for webpack compatibility.</span><span class="s3">\n          </span><span class="s1">document.head.appendChild(link)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (isJs(chunkUrl)) {</span><span class="s3">\n        </span><span class="s1">const previousScripts = document.querySelectorAll(</span><span class="s3">\n          </span><span class="s1">`script[src=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],script[src^=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">],script[src=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],script[src^=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">]`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (previousScripts.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">// There is this edge where the script already failed loading, but we</span><span class="s3">\n          </span><span class="s1">// can't detect that. The Promise will never resolve in this case.</span><span class="s3">\n          </span><span class="s1">for (const script of Array.from(previousScripts)) {</span><span class="s3">\n            </span><span class="s1">script.addEventListener('error', () =&gt; {</span><span class="s3">\n              </span><span class="s1">resolver.reject()</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const script = document.createElement('script')</span><span class="s3">\n          </span><span class="s1">script.src = chunkUrl</span><span class="s3">\n          </span><span class="s1">// We'll only mark the chunk as loaded once the script has been executed,</span><span class="s3">\n          </span><span class="s1">// which happens in `registerChunk`. Hence the absence of `resolve()` in</span><span class="s3">\n          </span><span class="s1">// this branch.</span><span class="s3">\n          </span><span class="s1">script.onerror = () =&gt; {</span><span class="s3">\n            </span><span class="s1">resolver.reject()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Append to the `head` for webpack compatibility.</span><span class="s3">\n          </span><span class="s1">document.head.appendChild(script)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">resolver.loadingStarted = true</span><span class="s3">\n    </span><span class="s1">return resolver.promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function fetchWebAssembly(wasmChunkPath: ChunkPath) {</span><span class="s3">\n    </span><span class="s1">return fetch(getChunkRelativeUrl(wasmChunkPath))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})()</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1720</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack]/browser/runtime/dom/dev-backend-dom.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This file contains the runtime code specific to the Turbopack development</span><span class="s3">\n </span><span class="s1">* ECMAScript DOM runtime.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It will be appended to the base development runtime code.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable @typescript-eslint/no-unused-vars */</span><span class="s3">\n\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../base/runtime-base.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../base/dev-base.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">./runtime-backend-dom.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n</span><span class="s1">/// &lt;reference path=</span><span class="s3">\&quot;</span><span class="s1">../../../shared/require-type.d.ts</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n\n</span><span class="s1">let DEV_BACKEND: DevRuntimeBackend</span><span class="s3">\n</span><span class="s1">;(() =&gt; {</span><span class="s3">\n  </span><span class="s1">DEV_BACKEND = {</span><span class="s3">\n    </span><span class="s1">unloadChunk(chunkUrl) {</span><span class="s3">\n      </span><span class="s1">deleteResolver(chunkUrl)</span><span class="s3">\n\n      </span><span class="s1">// TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.</span><span class="s3">\n      </span><span class="s1">const decodedChunkUrl = decodeURI(chunkUrl)</span><span class="s3">\n\n      </span><span class="s1">if (isCss(chunkUrl)) {</span><span class="s3">\n        </span><span class="s1">const links = document.querySelectorAll(</span><span class="s3">\n          </span><span class="s1">`link[href=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],link[href^=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">],link[href=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],link[href^=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">]`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">for (const link of Array.from(links)) {</span><span class="s3">\n          </span><span class="s1">link.remove()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (isJs(chunkUrl)) {</span><span class="s3">\n        </span><span class="s1">// Unloading a JS chunk would have no effect, as it lives in the JS</span><span class="s3">\n        </span><span class="s1">// runtime once evaluated.</span><span class="s3">\n        </span><span class="s1">// However, we still want to remove the script tag from the DOM to keep</span><span class="s3">\n        </span><span class="s1">// the HTML somewhat consistent from the user's perspective.</span><span class="s3">\n        </span><span class="s1">const scripts = document.querySelectorAll(</span><span class="s3">\n          </span><span class="s1">`script[src=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],script[src^=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">],script[src=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],script[src^=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">]`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">for (const script of Array.from(scripts)) {</span><span class="s3">\n          </span><span class="s1">script.remove()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">reloadChunk(chunkUrl) {</span><span class="s3">\n      </span><span class="s1">return new Promise&lt;void&gt;((resolve, reject) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!isCss(chunkUrl)) {</span><span class="s3">\n          </span><span class="s1">reject(new Error('The DOM backend can only reload CSS chunks'))</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const decodedChunkUrl = decodeURI(chunkUrl)</span><span class="s3">\n        </span><span class="s1">const previousLinks = document.querySelectorAll(</span><span class="s3">\n          </span><span class="s1">`link[rel=stylesheet][href=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],link[rel=stylesheet][href^=</span><span class="s3">\&quot;</span><span class="s1">${chunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">],link[rel=stylesheet][href=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}</span><span class="s3">\&quot;</span><span class="s1">],link[rel=stylesheet][href^=</span><span class="s3">\&quot;</span><span class="s1">${decodedChunkUrl}?</span><span class="s3">\&quot;</span><span class="s1">]`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (previousLinks.length === 0) {</span><span class="s3">\n          </span><span class="s1">reject(new Error(`No link element found for chunk ${chunkUrl}`))</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const link = document.createElement('link')</span><span class="s3">\n        </span><span class="s1">link.rel = 'stylesheet'</span><span class="s3">\n\n        </span><span class="s1">if (navigator.userAgent.includes('Firefox')) {</span><span class="s3">\n          </span><span class="s1">// Firefox won't reload CSS files that were previously loaded on the current page,</span><span class="s3">\n          </span><span class="s1">// we need to add a query param to make sure CSS is actually reloaded from the server.</span><span class="s3">\n          </span><span class="s1">//</span><span class="s3">\n          </span><span class="s1">// I believe this is this issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1037506</span><span class="s3">\n          </span><span class="s1">//</span><span class="s3">\n          </span><span class="s1">// Safari has a similar issue, but only if you have a `&lt;link rel=preload ... /&gt;` tag</span><span class="s3">\n          </span><span class="s1">// pointing to the same URL as the stylesheet: https://bugs.webkit.org/show_bug.cgi?id=187726</span><span class="s3">\n          </span><span class="s1">link.href = `${chunkUrl}?ts=${Date.now()}`</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">link.href = chunkUrl</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">link.onerror = () =&gt; {</span><span class="s3">\n          </span><span class="s1">reject()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">link.onload = () =&gt; {</span><span class="s3">\n          </span><span class="s1">// First load the new CSS, then remove the old ones. This prevents visible</span><span class="s3">\n          </span><span class="s1">// flickering that would happen in-between removing the previous CSS and</span><span class="s3">\n          </span><span class="s1">// loading the new one.</span><span class="s3">\n          </span><span class="s1">for (const previousLink of Array.from(previousLinks))</span><span class="s3">\n            </span><span class="s1">previousLink.remove()</span><span class="s3">\n\n          </span><span class="s1">// CSS chunks do not register themselves, and as such must be marked as</span><span class="s3">\n          </span><span class="s1">// loaded instantly.</span><span class="s3">\n          </span><span class="s1">resolve()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Make sure to insert the new CSS right after the previous one, so that</span><span class="s3">\n        </span><span class="s1">// its precedence is higher.</span><span class="s3">\n        </span><span class="s1">previousLinks[0].parentElement!.insertBefore(</span><span class="s3">\n          </span><span class="s1">link,</span><span class="s3">\n          </span><span class="s1">previousLinks[0].nextSibling</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">restart: () =&gt; self.location.reload(),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function deleteResolver(chunkUrl: ChunkUrl) {</span><span class="s3">\n    </span><span class="s1">chunkResolvers.delete(chunkUrl)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})()</span><span class="s3">\n\n</span><span class="s1">function _eval({ code, url, map }: EcmascriptModuleEntry): ModuleFactory {</span><span class="s3">\n  </span><span class="s1">code += `</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n//# sourceURL=${encodeURI(</span><span class="s3">\n    </span><span class="s1">location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX_PATH</span><span class="s3">\n  </span><span class="s1">)}`</span><span class="s3">\n  </span><span class="s1">if (map) {</span><span class="s3">\n    </span><span class="s1">code += `</span><span class="s3">\\</span><span class="s1">n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(</span><span class="s3">\n      </span><span class="s1">// btoa doesn't handle nonlatin characters, so escape them as </span><span class="s3">\\</span><span class="s1">x sequences</span><span class="s3">\n      </span><span class="s1">// See https://stackoverflow.com/a/26603875</span><span class="s3">\n      </span><span class="s1">unescape(encodeURIComponent(map))</span><span class="s3">\n    </span><span class="s1">)}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// eslint-disable-next-line no-eval</span><span class="s3">\n  </span><span class="s1">return eval(code)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,gDAAgD;AAChD,4CAA4C;AAC5C,iDAAiD;AACjD,0DAA0D;AAE1D,IAAI;AACH,CAAC;IACA,cAAc;QACZ,aAAY,QAAQ;YAClB,eAAe;YAEf,gFAAgF;YAChF,MAAM,kBAAkB,UAAU;YAElC,IAAI,MAAM,WAAW;gBACnB,MAAM,QAAQ,SAAS,gBAAgB,CACrC,CAAC,WAAW,EAAE,SAAS,eAAe,EAAE,SAAS,eAAe,EAAE,gBAAgB,eAAe,EAAE,gBAAgB,GAAG,CAAC;gBAEzH,KAAK,MAAM,QAAQ,MAAM,IAAI,CAAC,OAAQ;oBACpC,KAAK,MAAM;gBACb;YACF,OAAO,IAAI,KAAK,WAAW;gBACzB,mEAAmE;gBACnE,0BAA0B;gBAC1B,uEAAuE;gBACvE,4DAA4D;gBAC5D,MAAM,UAAU,SAAS,gBAAgB,CACvC,CAAC,YAAY,EAAE,SAAS,gBAAgB,EAAE,SAAS,gBAAgB,EAAE,gBAAgB,gBAAgB,EAAE,gBAAgB,GAAG,CAAC;gBAE7H,KAAK,MAAM,UAAU,MAAM,IAAI,CAAC,SAAU;oBACxC,OAAO,MAAM;gBACf;YACF,OAAO;gBACL,MAAM,IAAI,MAAM,CAAC,mCAAmC,EAAE,UAAU;YAClE;QACF;QAEA,aAAY,QAAQ;YAClB,OAAO,IAAI,QAAc,CAAC,SAAS;gBACjC,IAAI,CAAC,MAAM,WAAW;oBACpB,OAAO,IAAI,MAAM;oBACjB;gBACF;gBAEA,MAAM,kBAAkB,UAAU;gBAClC,MAAM,gBAAgB,SAAS,gBAAgB,CAC7C,CAAC,2BAA2B,EAAE,SAAS,+BAA+B,EAAE,SAAS,+BAA+B,EAAE,gBAAgB,+BAA+B,EAAE,gBAAgB,GAAG,CAAC;gBAGzL,IAAI,cAAc,MAAM,KAAK,GAAG;oBAC9B,OAAO,IAAI,MAAM,CAAC,gCAAgC,EAAE,UAAU;oBAC9D;gBACF;gBAEA,MAAM,OAAO,SAAS,aAAa,CAAC;gBACpC,KAAK,GAAG,GAAG;gBAEX,IAAI,UAAU,SAAS,CAAC,QAAQ,CAAC,YAAY;oBAC3C,kFAAkF;oBAClF,sFAAsF;oBACtF,EAAE;oBACF,qFAAqF;oBACrF,EAAE;oBACF,oFAAoF;oBACpF,6FAA6F;oBAC7F,KAAK,IAAI,GAAG,GAAG,SAAS,IAAI,EAAE,KAAK,GAAG,IAAI;gBAC5C,OAAO;oBACL,KAAK,IAAI,GAAG;gBACd;gBAEA,KAAK,OAAO,GAAG;oBACb;gBACF;gBACA,KAAK,MAAM,GAAG;oBACZ,0EAA0E;oBAC1E,wEAAwE;oBACxE,uBAAuB;oBACvB,KAAK,MAAM,gBAAgB,MAAM,IAAI,CAAC,eACpC,aAAa,MAAM;oBAErB,uEAAuE;oBACvE,oBAAoB;oBACpB;gBACF;gBAEA,wEAAwE;gBACxE,4BAA4B;gBAC5B,aAAa,CAAC,EAAE,CAAC,aAAa,CAAE,YAAY,CAC1C,MACA,aAAa,CAAC,EAAE,CAAC,WAAW;YAEhC;QACF;QAEA,SAAS,IAAM,KAAK,QAAQ,CAAC,MAAM;IACrC;IAEA,SAAS,eAAe,QAAkB;QACxC,eAAe,MAAM,CAAC;IACxB;AACF,CAAC;AAED,SAAS,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAyB;IACtD,QAAQ,CAAC,kBAAkB,EAAE,UAC3B,SAAS,MAAM,GAAG,kBAAkB,MAAM,oBACzC;IACH,IAAI,KAAK;QACP,QAAQ,CAAC,kEAAkE,EAAE,KAC3E,0EAA0E;QAC1E,2CAA2C;QAC3C,SAAS,mBAAmB,QAC3B;IACL;IAEA,mCAAmC;IACnC,OAAO,KAAK;AACd&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}}]</span>
<span class="s0">}</span></pre>
</body>
</html>