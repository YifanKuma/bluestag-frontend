<html>
<head>
<title>headers.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
headers.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/request/headers.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">HeadersAdapter,</span><span class="s3">\n  </span><span class="s1">type ReadonlyHeaders,</span><span class="s3">\n</span><span class="s1">} from '../web/spec-extension/adapters/headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type WorkStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">throwForMissingRequestStore,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type PrerenderStoreModern,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">postponeWithTracking,</span><span class="s3">\n  </span><span class="s1">throwToInterruptStaticGeneration,</span><span class="s3">\n  </span><span class="s1">trackDynamicDataInDynamicRender,</span><span class="s3">\n  </span><span class="s1">trackSynchronousRequestDataAccessInDev,</span><span class="s3">\n</span><span class="s1">} from '../app-render/dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">makeDevtoolsIOAwarePromise,</span><span class="s3">\n  </span><span class="s1">makeHangingPromise,</span><span class="s3">\n</span><span class="s1">} from '../dynamic-rendering-utils'</span><span class="s3">\n</span><span class="s1">import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'</span><span class="s3">\n</span><span class="s1">import { isRequestAPICallableInsideAfter } from './utils'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* In this version of Next.js `headers()` returns a Promise however you can still reference the properties of the underlying Headers instance</span><span class="s3">\n </span><span class="s1">* synchronously to facilitate migration. The `UnsafeUnwrappedHeaders` type is added to your code by a codemod that attempts to automatically</span><span class="s3">\n </span><span class="s1">* updates callsites to reflect the new Promise return type. There are some cases where `headers()` cannot be automatically converted, namely</span><span class="s3">\n </span><span class="s1">* when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an</span><span class="s3">\n </span><span class="s1">* explicit type case to `UnsafeUnwrappedHeaders` to enable typescript to allow for the synchronous usage only where it is actually necessary.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* You should should update these callsites to either be async functions where the `headers()` value can be awaited or you should call `headers()`</span><span class="s3">\n </span><span class="s1">* from outside and await the return value before passing it into this function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* You can find instances that require manual migration by searching for `UnsafeUnwrappedHeaders` in your codebase or by search for a comment that</span><span class="s3">\n </span><span class="s1">* starts with `@next-codemod-error`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In a future version of Next.js `headers()` will only return a Promise and you will not be able to access the underlying Headers instance</span><span class="s3">\n </span><span class="s1">* without awaiting the return value first. When this change happens the type `UnsafeUnwrappedHeaders` will be updated to reflect that is it no longer</span><span class="s3">\n </span><span class="s1">* usable.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This type is marked deprecated to help identify it as target for refactoring away.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @deprecated</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type UnsafeUnwrappedHeaders = ReadonlyHeaders</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function allows you to read the HTTP incoming request headers in</span><span class="s3">\n </span><span class="s1">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span><span class="s3">\n </span><span class="s1">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),</span><span class="s3">\n </span><span class="s1">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and</span><span class="s3">\n </span><span class="s1">* [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function headers(): Promise&lt;ReadonlyHeaders&gt; {</span><span class="s3">\n  </span><span class="s1">const callingExpression = 'headers'</span><span class="s3">\n  </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n  </span><span class="s1">if (workStore) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">workUnitStore &amp;&amp;</span><span class="s3">\n      </span><span class="s1">workUnitStore.phase === 'after' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isRequestAPICallableInsideAfter()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Route ${workStore.route} used </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">inside </span><span class="s3">\&quot;</span><span class="s1">after(...)</span><span class="s3">\&quot;</span><span class="s1">. This is not supported. If you need this data inside an </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot; </span><span class="s1">callback, use </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (workStore.forceStatic) {</span><span class="s3">\n      </span><span class="s1">// When using forceStatic we override all other logic and always just return an empty</span><span class="s3">\n      </span><span class="s1">// headers object without tracking</span><span class="s3">\n      </span><span class="s1">const underlyingHeaders = HeadersAdapter.seal(new Headers({}))</span><span class="s3">\n      </span><span class="s1">return makeUntrackedExoticHeaders(underlyingHeaders)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n      </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n        </span><span class="s1">case 'cache': {</span><span class="s3">\n          </span><span class="s1">const error = new Error(</span><span class="s3">\n            </span><span class="s1">`Route ${workStore.route} used </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">inside </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot;</span><span class="s1">. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">Error.captureStackTrace(error, headers)</span><span class="s3">\n          </span><span class="s1">workStore.invalidDynamicUsageError ??= error</span><span class="s3">\n          </span><span class="s1">throw error</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'private-cache': {</span><span class="s3">\n          </span><span class="s1">const error = new Error(</span><span class="s3">\n            </span><span class="s1">`Route ${workStore.route} used </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">inside </span><span class="s3">\&quot;</span><span class="s1">use cache: private</span><span class="s3">\&quot;</span><span class="s1">. Accessing </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">inside a private cache scope is not supported. If you need this data inside a cached function use </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">Error.captureStackTrace(error, headers)</span><span class="s3">\n          </span><span class="s1">workStore.invalidDynamicUsageError ??= error</span><span class="s3">\n          </span><span class="s1">throw error</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">`Route ${workStore.route} used </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">inside a function cached with </span><span class="s3">\&quot;</span><span class="s1">unstable_cache(...)</span><span class="s3">\&quot;</span><span class="s1">. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use </span><span class="s3">\&quot;</span><span class="s1">headers</span><span class="s3">\&quot; </span><span class="s1">outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">case 'prerender':</span><span class="s3">\n        </span><span class="s1">case 'prerender-client':</span><span class="s3">\n        </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n        </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">case 'request':</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (workStore.dynamicShouldError) {</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n        </span><span class="s1">`Route ${workStore.route} with </span><span class="s3">\\</span><span class="s1">`dynamic = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;\\</span><span class="s1">` couldn't be rendered statically because it used </span><span class="s3">\\</span><span class="s1">`headers</span><span class="s3">\\</span><span class="s1">`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n      </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n        </span><span class="s1">case 'prerender':</span><span class="s3">\n        </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n          </span><span class="s1">return makeHangingHeaders(workStore, workUnitStore)</span><span class="s3">\n        </span><span class="s1">case 'prerender-client':</span><span class="s3">\n          </span><span class="s1">const exportName = '`headers`'</span><span class="s3">\n          </span><span class="s1">throw new InvariantError(</span><span class="s3">\n            </span><span class="s1">`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n          </span><span class="s1">// PPR Prerender (no cacheComponents)</span><span class="s3">\n          </span><span class="s1">// We are prerendering with PPR. We need track dynamic access here eagerly</span><span class="s3">\n          </span><span class="s1">// to keep continuity with how headers has worked in PPR without cacheComponents.</span><span class="s3">\n          </span><span class="s1">// TODO consider switching the semantic to throw on property access instead</span><span class="s3">\n          </span><span class="s1">return postponeWithTracking(</span><span class="s3">\n            </span><span class="s1">workStore.route,</span><span class="s3">\n            </span><span class="s1">callingExpression,</span><span class="s3">\n            </span><span class="s1">workUnitStore.dynamicTracking</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n          </span><span class="s1">// Legacy Prerender</span><span class="s3">\n          </span><span class="s1">// We are in a legacy static generation mode while prerendering</span><span class="s3">\n          </span><span class="s1">// We track dynamic access here so we don't need to wrap the headers in</span><span class="s3">\n          </span><span class="s1">// individual property access tracking.</span><span class="s3">\n          </span><span class="s1">return throwToInterruptStaticGeneration(</span><span class="s3">\n            </span><span class="s1">callingExpression,</span><span class="s3">\n            </span><span class="s1">workStore,</span><span class="s3">\n            </span><span class="s1">workUnitStore</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">case 'request':</span><span class="s3">\n          </span><span class="s1">trackDynamicDataInDynamicRender(workUnitStore)</span><span class="s3">\n\n          </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n            </span><span class="s1">// Semantically we only need the dev tracking when running in `next dev`</span><span class="s3">\n            </span><span class="s1">// but since you would never use next dev with production NODE_ENV we use this</span><span class="s3">\n            </span><span class="s1">// as a proxy so we can statically exclude this code from production builds.</span><span class="s3">\n            </span><span class="s1">if (process.env.__NEXT_CACHE_COMPONENTS) {</span><span class="s3">\n              </span><span class="s1">return makeUntrackedHeadersWithDevWarnings(</span><span class="s3">\n                </span><span class="s1">workUnitStore.headers,</span><span class="s3">\n                </span><span class="s1">workStore?.route</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return makeUntrackedExoticHeadersWithDevWarnings(</span><span class="s3">\n              </span><span class="s1">workUnitStore.headers,</span><span class="s3">\n              </span><span class="s1">workStore?.route</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">if (process.env.__NEXT_CACHE_COMPONENTS) {</span><span class="s3">\n              </span><span class="s1">return makeUntrackedHeaders(workUnitStore.headers)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return makeUntrackedExoticHeaders(workUnitStore.headers)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we end up here, there was no work store or work unit store present.</span><span class="s3">\n  </span><span class="s1">throwForMissingRequestStore(callingExpression)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface CacheLifetime {}</span><span class="s3">\n</span><span class="s1">const CachedHeaders = new WeakMap&lt;CacheLifetime, Promise&lt;ReadonlyHeaders&gt;&gt;()</span><span class="s3">\n\n</span><span class="s1">function makeHangingHeaders(</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStoreModern</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadonlyHeaders&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedHeaders = CachedHeaders.get(prerenderStore)</span><span class="s3">\n  </span><span class="s1">if (cachedHeaders) {</span><span class="s3">\n    </span><span class="s1">return cachedHeaders</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = makeHangingPromise&lt;ReadonlyHeaders&gt;(</span><span class="s3">\n    </span><span class="s1">prerenderStore.renderSignal,</span><span class="s3">\n    </span><span class="s1">workStore.route,</span><span class="s3">\n    </span><span class="s1">'`headers()`'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">CachedHeaders.set(prerenderStore, promise)</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeUntrackedHeaders(</span><span class="s3">\n  </span><span class="s1">underlyingHeaders: ReadonlyHeaders</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadonlyHeaders&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedHeaders = CachedHeaders.get(underlyingHeaders)</span><span class="s3">\n  </span><span class="s1">if (cachedHeaders) {</span><span class="s3">\n    </span><span class="s1">return cachedHeaders</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = Promise.resolve(underlyingHeaders)</span><span class="s3">\n  </span><span class="s1">CachedHeaders.set(underlyingHeaders, promise)</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeUntrackedExoticHeaders(</span><span class="s3">\n  </span><span class="s1">underlyingHeaders: ReadonlyHeaders</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadonlyHeaders&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedHeaders = CachedHeaders.get(underlyingHeaders)</span><span class="s3">\n  </span><span class="s1">if (cachedHeaders) {</span><span class="s3">\n    </span><span class="s1">return cachedHeaders</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = Promise.resolve(underlyingHeaders)</span><span class="s3">\n  </span><span class="s1">CachedHeaders.set(underlyingHeaders, promise)</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperties(promise, {</span><span class="s3">\n    </span><span class="s1">append: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.append.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">delete: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.delete.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">get: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.get.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">has: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.has.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.set.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">getSetCookie: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.getSetCookie.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">forEach: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.forEach.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">keys: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.keys.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">values: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.values.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">entries: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders.entries.bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">[Symbol.iterator]: {</span><span class="s3">\n      </span><span class="s1">value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders),</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">} satisfies HeadersExtensions)</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeUntrackedExoticHeadersWithDevWarnings(</span><span class="s3">\n  </span><span class="s1">underlyingHeaders: ReadonlyHeaders,</span><span class="s3">\n  </span><span class="s1">route?: string</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadonlyHeaders&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedHeaders = CachedHeaders.get(underlyingHeaders)</span><span class="s3">\n  </span><span class="s1">if (cachedHeaders) {</span><span class="s3">\n    </span><span class="s1">return cachedHeaders</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = makeDevtoolsIOAwarePromise(underlyingHeaders)</span><span class="s3">\n\n  </span><span class="s1">CachedHeaders.set(underlyingHeaders, promise)</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperties(promise, {</span><span class="s3">\n    </span><span class="s1">append: {</span><span class="s3">\n      </span><span class="s1">value: function append() {</span><span class="s3">\n        </span><span class="s1">const expression = `</span><span class="s3">\\</span><span class="s1">`headers().append(${describeNameArg(arguments[0])}, ...)</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.append.apply(</span><span class="s3">\n          </span><span class="s1">underlyingHeaders,</span><span class="s3">\n          </span><span class="s1">arguments as any</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">delete: {</span><span class="s3">\n      </span><span class="s1">value: function _delete() {</span><span class="s3">\n        </span><span class="s1">const expression = `</span><span class="s3">\\</span><span class="s1">`headers().delete(${describeNameArg(arguments[0])})</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.delete.apply(</span><span class="s3">\n          </span><span class="s1">underlyingHeaders,</span><span class="s3">\n          </span><span class="s1">arguments as any</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">get: {</span><span class="s3">\n      </span><span class="s1">value: function get() {</span><span class="s3">\n        </span><span class="s1">const expression = `</span><span class="s3">\\</span><span class="s1">`headers().get(${describeNameArg(arguments[0])})</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.get.apply(underlyingHeaders, arguments as any)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">has: {</span><span class="s3">\n      </span><span class="s1">value: function has() {</span><span class="s3">\n        </span><span class="s1">const expression = `</span><span class="s3">\\</span><span class="s1">`headers().has(${describeNameArg(arguments[0])})</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.has.apply(underlyingHeaders, arguments as any)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set: {</span><span class="s3">\n      </span><span class="s1">value: function set() {</span><span class="s3">\n        </span><span class="s1">const expression = `</span><span class="s3">\\</span><span class="s1">`headers().set(${describeNameArg(arguments[0])}, ...)</span><span class="s3">\\</span><span class="s1">``</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.set.apply(underlyingHeaders, arguments as any)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">getSetCookie: {</span><span class="s3">\n      </span><span class="s1">value: function getSetCookie() {</span><span class="s3">\n        </span><span class="s1">const expression = '`headers().getSetCookie()`'</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.getSetCookie.apply(</span><span class="s3">\n          </span><span class="s1">underlyingHeaders,</span><span class="s3">\n          </span><span class="s1">arguments as any</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">forEach: {</span><span class="s3">\n      </span><span class="s1">value: function forEach() {</span><span class="s3">\n        </span><span class="s1">const expression = '`headers().forEach(...)`'</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.forEach.apply(</span><span class="s3">\n          </span><span class="s1">underlyingHeaders,</span><span class="s3">\n          </span><span class="s1">arguments as any</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">keys: {</span><span class="s3">\n      </span><span class="s1">value: function keys() {</span><span class="s3">\n        </span><span class="s1">const expression = '`headers().keys()`'</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.keys.apply(underlyingHeaders, arguments as any)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">values: {</span><span class="s3">\n      </span><span class="s1">value: function values() {</span><span class="s3">\n        </span><span class="s1">const expression = '`headers().values()`'</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.values.apply(</span><span class="s3">\n          </span><span class="s1">underlyingHeaders,</span><span class="s3">\n          </span><span class="s1">arguments as any</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">entries: {</span><span class="s3">\n      </span><span class="s1">value: function entries() {</span><span class="s3">\n        </span><span class="s1">const expression = '`headers().entries()`'</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders.entries.apply(</span><span class="s3">\n          </span><span class="s1">underlyingHeaders,</span><span class="s3">\n          </span><span class="s1">arguments as any</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">[Symbol.iterator]: {</span><span class="s3">\n      </span><span class="s1">value: function () {</span><span class="s3">\n        </span><span class="s1">const expression = '`...headers()` or similar iteration'</span><span class="s3">\n        </span><span class="s1">syncIODev(route, expression)</span><span class="s3">\n        </span><span class="s1">return underlyingHeaders[Symbol.iterator].apply(</span><span class="s3">\n          </span><span class="s1">underlyingHeaders,</span><span class="s3">\n          </span><span class="s1">arguments as any</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">} satisfies HeadersExtensions)</span><span class="s3">\n\n  </span><span class="s1">return promise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the</span><span class="s3">\n</span><span class="s1">// sync access without actually defining the headers properties on the promise.</span><span class="s3">\n</span><span class="s1">function makeUntrackedHeadersWithDevWarnings(</span><span class="s3">\n  </span><span class="s1">underlyingHeaders: ReadonlyHeaders,</span><span class="s3">\n  </span><span class="s1">route?: string</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadonlyHeaders&gt; {</span><span class="s3">\n  </span><span class="s1">const cachedHeaders = CachedHeaders.get(underlyingHeaders)</span><span class="s3">\n  </span><span class="s1">if (cachedHeaders) {</span><span class="s3">\n    </span><span class="s1">return cachedHeaders</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const promise = makeDevtoolsIOAwarePromise(underlyingHeaders)</span><span class="s3">\n\n  </span><span class="s1">const proxiedPromise = new Proxy(promise, {</span><span class="s3">\n    </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n      </span><span class="s1">switch (prop) {</span><span class="s3">\n        </span><span class="s1">case Symbol.iterator: {</span><span class="s3">\n          </span><span class="s1">warnForSyncAccess(route, '`...headers()` or similar iteration')</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'append':</span><span class="s3">\n        </span><span class="s1">case 'delete':</span><span class="s3">\n        </span><span class="s1">case 'get':</span><span class="s3">\n        </span><span class="s1">case 'has':</span><span class="s3">\n        </span><span class="s1">case 'set':</span><span class="s3">\n        </span><span class="s1">case 'getSetCookie':</span><span class="s3">\n        </span><span class="s1">case 'forEach':</span><span class="s3">\n        </span><span class="s1">case 'keys':</span><span class="s3">\n        </span><span class="s1">case 'values':</span><span class="s3">\n        </span><span class="s1">case 'entries': {</span><span class="s3">\n          </span><span class="s1">warnForSyncAccess(route, `</span><span class="s3">\\</span><span class="s1">`headers().${prop}</span><span class="s3">\\</span><span class="s1">``)</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">default: {</span><span class="s3">\n          </span><span class="s1">// We only warn for well-defined properties of the headers object.</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">CachedHeaders.set(underlyingHeaders, proxiedPromise)</span><span class="s3">\n\n  </span><span class="s1">return proxiedPromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function describeNameArg(arg: unknown) {</span><span class="s3">\n  </span><span class="s1">return typeof arg === 'string' ? `'${arg}'` : '...'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function syncIODev(route: string | undefined, expression: string) {</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n      </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">if (workUnitStore.prerenderPhase === true) {</span><span class="s3">\n          </span><span class="s1">// When we're rendering dynamically in dev, we need to advance out of</span><span class="s3">\n          </span><span class="s1">// the Prerender environment when we read Request data synchronously.</span><span class="s3">\n          </span><span class="s1">trackSynchronousRequestDataAccessInDev(workUnitStore)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'prerender':</span><span class="s3">\n      </span><span class="s1">case 'prerender-client':</span><span class="s3">\n      </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n      </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n      </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n      </span><span class="s1">case 'cache':</span><span class="s3">\n      </span><span class="s1">case 'private-cache':</span><span class="s3">\n      </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// In all cases we warn normally</span><span class="s3">\n  </span><span class="s1">warnForSyncAccess(route, expression)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(</span><span class="s3">\n  </span><span class="s1">createHeadersAccessError</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">function createHeadersAccessError(</span><span class="s3">\n  </span><span class="s1">route: string | undefined,</span><span class="s3">\n  </span><span class="s1">expression: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const prefix = route ? `Route </span><span class="s3">\&quot;</span><span class="s1">${route}</span><span class="s3">\&quot; </span><span class="s1">` : 'This route '</span><span class="s3">\n  </span><span class="s1">return new Error(</span><span class="s3">\n    </span><span class="s1">`${prefix}used ${expression}. ` +</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`headers()</span><span class="s3">\\</span><span class="s1">` should be awaited before using its value. ` +</span><span class="s3">\n      </span><span class="s1">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type HeadersExtensions = {</span><span class="s3">\n  </span><span class="s1">[K in keyof ReadonlyHeaders]: unknown</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;callingExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;isRequestAPICallableInsideAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;forceStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;underlyingHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadersAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;seal&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedExoticHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;captureStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidDynamicUsageError&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicShouldError&quot;</span><span class="s0">,</span><span class="s1">&quot;StaticGenBailoutError&quot;</span><span class="s0">,</span><span class="s1">&quot;makeHangingHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;exportName&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;postponeWithTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;throwToInterruptStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;trackDynamicDataInDynamicRender&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CACHE_COMPONENTS&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedHeadersWithDevWarnings&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedExoticHeadersWithDevWarnings&quot;</span><span class="s0">,</span><span class="s1">&quot;makeUntrackedHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;throwForMissingRequestStore&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;makeHangingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;getSetCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;makeDevtoolsIOAwarePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;describeNameArg&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;syncIODev&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;_delete&quot;</span><span class="s0">,</span><span class="s1">&quot;proxiedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;warnForSyncAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;ReflectAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderPhase&quot;</span><span class="s0">,</span><span class="s1">&quot;trackSynchronousRequestDataAccessInDev&quot;</span><span class="s0">,</span><span class="s1">&quot;createDedupedByCallsiteServerErrorLoggerDev&quot;</span><span class="s0">,</span><span class="s1">&quot;createHeadersAccessError&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>