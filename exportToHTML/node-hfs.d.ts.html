<html>
<head>
<title>node-hfs.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node-hfs.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/// &lt;reference types=&quot;node&quot; resolution-mode=&quot;require&quot;/&gt;</span>
<span class="s0">/**</span>
 <span class="s0">* A class representing the Node.js implementation of Hfs.</span>
 <span class="s0">* </span><span class="s2">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s1">NodeHfsImpl </span><span class="s3">implements </span><span class="s1">HfsImpl {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{object} [options] The options for the instance.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{Fsp} [options.fsp] The file system module to use.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor({ fsp }?: {</span>
        <span class="s1">fsp?: Fsp;</span>
    <span class="s1">});</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads a file and returns the contents as an Uint8Array.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;Uint8Array|undefined&gt;} A promise that resolves with the contents</span>
     <span class="s0">*    of the file or undefined if the file doesn't exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">*/</span>
    <span class="s1">bytes(filePath: string | URL): Promise&lt;Uint8Array | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Writes a value to a file. If the value is a string, UTF-8 encoding is used.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} filePath The path to the file to write.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{Uint8Array} contents The contents to write to the</span>
     <span class="s0">*   file.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is</span>
     <span class="s0">*  written.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file cannot be written.</span>
     <span class="s0">*/</span>
    <span class="s1">write(filePath: string | URL, contents: Uint8Array): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Appends a value to a file. If the value is a string, UTF-8 encoding is used.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} filePath The path to the file to append to.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{Uint8Array} contents The contents to append to the</span>
     <span class="s0">*  file.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is</span>
     <span class="s0">* written.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file cannot be appended to.</span>
     <span class="s0">*/</span>
    <span class="s1">append(filePath: string | URL, contents: Uint8Array): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Checks if a file exists.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} filePath The path to the file to check.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves with true if the</span>
     <span class="s0">*    file exists or false if it does not.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the operation fails with a code other than ENOENT.</span>
     <span class="s0">*/</span>
    <span class="s1">isFile(filePath: string | URL): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Checks if a directory exists.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} dirPath The path to the directory to check.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves with true if the</span>
     <span class="s0">*    directory exists or false if it does not.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the operation fails with a code other than ENOENT.</span>
     <span class="s0">*/</span>
    <span class="s1">isDirectory(dirPath: string | URL): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a directory recursively.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} dirPath The path to the directory to create.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the directory is</span>
     <span class="s0">*   created.</span>
     <span class="s0">*/</span>
    <span class="s1">createDirectory(dirPath: string | URL): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Deletes a file or empty directory.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} fileOrDirPath The path to the file or directory to</span>
     <span class="s0">*   delete.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves when the file or</span>
     <span class="s0">*   directory is deleted, true if the file or directory is deleted, false</span>
     <span class="s0">*   if the file or directory does not exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file or directory path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file or directory cannot be deleted.</span>
     <span class="s0">*/</span>
    <span class="s3">delete</span><span class="s1">(fileOrDirPath: string | URL): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Deletes a file or directory recursively.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} fileOrDirPath The path to the file or directory to</span>
     <span class="s0">*   delete.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves when the file or</span>
     <span class="s0">*   directory is deleted, true if the file or directory is deleted, false</span>
     <span class="s0">*   if the file or directory does not exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file or directory path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file or directory cannot be deleted.</span>
     <span class="s0">*/</span>
    <span class="s1">deleteAll(fileOrDirPath: string | URL): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a list of directory entries for the given path.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} dirPath The path to the directory to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{AsyncIterable&lt;HfsDirectoryEntry&gt;} A promise that resolves with the</span>
     <span class="s0">*   directory entries.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the directory path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the directory cannot be read.</span>
     <span class="s0">*/</span>
    <span class="s1">list(dirPath: string | URL): AsyncIterable&lt;HfsDirectoryEntry&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the size of a file. This method handles ENOENT errors</span>
     <span class="s0">* and returns undefined in that case.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;number|undefined&gt;} A promise that resolves with the size of the</span>
     <span class="s0">*  file in bytes or undefined if the file doesn't exist.</span>
     <span class="s0">*/</span>
    <span class="s1">size(filePath: string | URL): Promise&lt;number | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the last modified date of a file or directory. This method handles ENOENT errors</span>
     <span class="s0">* and returns undefined in that case.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} fileOrDirPath The path to the file to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;Date|undefined&gt;} A promise that resolves with the last modified</span>
     <span class="s0">* date of the file or directory, or undefined if the file doesn't exist.</span>
     <span class="s0">*/</span>
    <span class="s1">lastModified(fileOrDirPath: string | URL): Promise&lt;Date | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Copies a file from one location to another.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} source The path to the file to copy.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} destination The path to copy the file to.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is copied.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the source file does not exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the source file is a directory.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the destination file is a directory.</span>
     <span class="s0">*/</span>
    <span class="s1">copy(source: string | URL, destination: string | URL): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Copies a file or directory from one location to another.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} source The path to the file or directory to copy.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} destination The path to copy the file or directory to.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file or directory is</span>
     <span class="s0">* copied.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the source file or directory does not exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the destination file or directory is a directory.</span>
     <span class="s0">*/</span>
    <span class="s1">copyAll(source: string | URL, destination: string | URL): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Moves a file from the source path to the destination path.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} source The location of the file to move.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} destination The destination of the file to move.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the move is complete.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file paths are not strings.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file cannot be moved.</span>
     <span class="s0">*/</span>
    <span class="s1">move(source: string | URL, destination: string | URL): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Moves a file or directory from the source path to the destination path.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} source The location of the file or directory to move.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|URL} destination The destination of the file or directory to move.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the move is complete.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file paths are not strings.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file or directory cannot be moved.</span>
     <span class="s0">*/</span>
    <span class="s1">moveAll(source: string | URL, destination: string | URL): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s1">#private;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* A class representing a file system utility library.</span>
 <span class="s0">* </span><span class="s2">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s1">NodeHfs </span><span class="s3">extends </span><span class="s1">Hfs </span><span class="s3">implements </span><span class="s1">HfsImpl {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{object} [options] The options for the instance.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{Fsp} [options.fsp] The file system module to use.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor({ fsp }?: {</span>
        <span class="s1">fsp?: Fsp;</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">export const </span><span class="s1">hfs: NodeHfs;</span>
<span class="s3">export </span><span class="s1">type HfsImpl = </span><span class="s3">import</span><span class="s1">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s1">).HfsImpl;</span>
<span class="s3">export </span><span class="s1">type HfsDirectoryEntry = </span><span class="s3">import</span><span class="s1">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s1">).HfsDirectoryEntry;</span>
<span class="s3">export </span><span class="s1">type Fsp = </span><span class="s3">typeof </span><span class="s1">nativeFsp;</span>
<span class="s3">export </span><span class="s1">type Dirent = </span><span class="s3">import</span><span class="s1">(</span><span class="s4">&quot;fs&quot;</span><span class="s1">).Dirent;</span>
<span class="s3">import </span><span class="s1">{ Hfs } from </span><span class="s4">&quot;@humanfs/core&quot;</span><span class="s1">;</span>
<span class="s3">import </span><span class="s1">nativeFsp from </span><span class="s4">&quot;node:fs/promises&quot;</span><span class="s1">;</span>
</pre>
</body>
</html>