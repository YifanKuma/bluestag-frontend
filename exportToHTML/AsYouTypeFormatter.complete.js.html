<html>
<head>
<title>AsYouTypeFormatter.complete.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
AsYouTypeFormatter.complete.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">checkNumberLength from </span><span class="s2">'./helpers/checkNumberLength.js'</span>
<span class="s0">import </span><span class="s1">parseDigits from </span><span class="s2">'./helpers/parseDigits.js'</span>
<span class="s0">import </span><span class="s1">formatNationalNumberUsingFormat from </span><span class="s2">'./helpers/formatNationalNumberUsingFormat.js'</span>

<span class="s0">export default function </span><span class="s1">formatCompleteNumber(state, format, {</span>
	<span class="s1">metadata,</span>
	<span class="s1">shouldTryNationalPrefixFormattingRule,</span>
	<span class="s1">getSeparatorAfterNationalPrefix</span>
<span class="s1">}) {</span>
	<span class="s0">const </span><span class="s1">matcher = </span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">`^(?:</span><span class="s1">${format.pattern()}</span><span class="s2">)$`</span><span class="s1">)</span>
	<span class="s0">if </span><span class="s1">(matcher.test(state.nationalSignificantNumber)) {</span>
		<span class="s0">return </span><span class="s1">formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(</span>
			<span class="s1">state,</span>
			<span class="s1">format,</span>
			<span class="s1">{</span>
				<span class="s1">metadata,</span>
				<span class="s1">shouldTryNationalPrefixFormattingRule,</span>
				<span class="s1">getSeparatorAfterNationalPrefix</span>
			<span class="s1">}</span>
		<span class="s1">)</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">export function </span><span class="s1">canFormatCompleteNumber(nationalSignificantNumber, country, metadata) {</span>
	<span class="s0">return </span><span class="s1">checkNumberLength(nationalSignificantNumber, country, metadata) === </span><span class="s2">'IS_POSSIBLE'</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {</span>
	<span class="s1">metadata,</span>
	<span class="s1">shouldTryNationalPrefixFormattingRule,</span>
	<span class="s1">getSeparatorAfterNationalPrefix</span>
<span class="s1">}) {</span>
	<span class="s3">// `format` has already been checked for `nationalPrefix` requirement.</span>

	<span class="s0">const </span><span class="s1">{</span>
		<span class="s1">nationalSignificantNumber,</span>
		<span class="s1">international,</span>
		<span class="s1">nationalPrefix,</span>
		<span class="s1">carrierCode</span>
	<span class="s1">} = state</span>

	<span class="s3">// Format the number with using `national_prefix_formatting_rule`.</span>
	<span class="s3">// If the resulting formatted number is a valid formatted number, then return it.</span>
	<span class="s3">//</span>
	<span class="s3">// Google's AsYouType formatter is different in a way that it doesn't try</span>
	<span class="s3">// to format using the &quot;national prefix formatting rule&quot;, and instead it</span>
	<span class="s3">// simply prepends a national prefix followed by a &quot; &quot; character.</span>
	<span class="s3">// This code does that too, but as a fallback.</span>
	<span class="s3">// The reason is that &quot;national prefix formatting rule&quot; may use parentheses,</span>
	<span class="s3">// which wouldn't be included has it used the simpler Google's way.</span>
	<span class="s3">//</span>
	<span class="s0">if </span><span class="s1">(shouldTryNationalPrefixFormattingRule(format)) {</span>
		<span class="s0">const </span><span class="s1">formattedNumber = formatNationalNumber(state, format, {</span>
			<span class="s1">useNationalPrefixFormattingRule: </span><span class="s0">true</span><span class="s1">,</span>
			<span class="s1">getSeparatorAfterNationalPrefix,</span>
			<span class="s1">metadata</span>
		<span class="s1">})</span>
		<span class="s0">if </span><span class="s1">(formattedNumber) {</span>
			<span class="s0">return </span><span class="s1">formattedNumber</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">// Format the number without using `national_prefix_formatting_rule`.</span>
	<span class="s0">return </span><span class="s1">formatNationalNumber(state, format, {</span>
		<span class="s1">useNationalPrefixFormattingRule: </span><span class="s0">false</span><span class="s1">,</span>
		<span class="s1">getSeparatorAfterNationalPrefix,</span>
		<span class="s1">metadata</span>
	<span class="s1">})</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">formatNationalNumber(state, format, {</span>
	<span class="s1">metadata,</span>
	<span class="s1">useNationalPrefixFormattingRule,</span>
	<span class="s1">getSeparatorAfterNationalPrefix</span>
<span class="s1">}) {</span>
	<span class="s0">let </span><span class="s1">formattedNationalNumber = formatNationalNumberUsingFormat(</span>
		<span class="s1">state.nationalSignificantNumber,</span>
		<span class="s1">format,</span>
		<span class="s1">{</span>
			<span class="s1">carrierCode: state.carrierCode,</span>
			<span class="s1">useInternationalFormat: state.international,</span>
			<span class="s1">withNationalPrefix: useNationalPrefixFormattingRule,</span>
			<span class="s1">metadata</span>
		<span class="s1">}</span>
	<span class="s1">)</span>
	<span class="s0">if </span><span class="s1">(!useNationalPrefixFormattingRule) {</span>
		<span class="s0">if </span><span class="s1">(state.nationalPrefix) {</span>
			<span class="s3">// If a national prefix was extracted, then just prepend it,</span>
			<span class="s3">// followed by a &quot; &quot; character.</span>
			<span class="s1">formattedNationalNumber = state.nationalPrefix +</span>
				<span class="s1">getSeparatorAfterNationalPrefix(format) +</span>
				<span class="s1">formattedNationalNumber</span>
		<span class="s1">} </span><span class="s0">else if </span><span class="s1">(state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix) {</span>
			<span class="s1">formattedNationalNumber = state.prefixBeforeNationalSignificantNumberThatIsNotNationalPrefix +</span>
				<span class="s2">' ' </span><span class="s1">+</span>
				<span class="s1">formattedNationalNumber</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s0">if </span><span class="s1">(isValidFormattedNationalNumber(formattedNationalNumber, state)) {</span>
		<span class="s0">return </span><span class="s1">formattedNationalNumber</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">// Check that the formatted phone number contains exactly</span>
<span class="s3">// the same digits that have been input by the user.</span>
<span class="s3">// For example, when &quot;0111523456789&quot; is input for `AR` country,</span>
<span class="s3">// the extracted `this.nationalSignificantNumber` is &quot;91123456789&quot;,</span>
<span class="s3">// which means that the national part of `this.digits` isn't simply equal to</span>
<span class="s3">// `this.nationalPrefix` + `this.nationalSignificantNumber`.</span>
<span class="s3">//</span>
<span class="s3">// Also, a `format` can add extra digits to the `this.nationalSignificantNumber`</span>
<span class="s3">// being formatted via `metadata[country].national_prefix_transform_rule`.</span>
<span class="s3">// For example, for `VI` country, it prepends `340` to the national number,</span>
<span class="s3">// and if this check hasn't been implemented, then there would be a bug</span>
<span class="s3">// when `340` &quot;area coude&quot; is &quot;duplicated&quot; during input for `VI` country:</span>
<span class="s3">// https://github.com/catamphetamine/libphonenumber-js/issues/318</span>
<span class="s3">//</span>
<span class="s3">// So, all these &quot;gotchas&quot; are filtered out.</span>
<span class="s3">//</span>
<span class="s3">// In the original Google's code, the comments say:</span>
<span class="s3">// &quot;Check that we didn't remove nor add any extra digits when we matched</span>
<span class="s3">// this formatting pattern. This usually happens after we entered the last</span>
<span class="s3">// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when</span>
<span class="s3">// formatted but AYTF should retain all the number entered and not change</span>
<span class="s3">// in order to match a format (of same leading digits and length) display</span>
<span class="s3">// in that way.&quot;</span>
<span class="s3">// &quot;If it's the same (i.e entered number and format is same), then it's</span>
<span class="s3">// safe to return this in formatted number as nothing is lost / added.&quot;</span>
<span class="s3">// Otherwise, don't use this format.</span>
<span class="s3">// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5</span>
<span class="s3">// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b</span>
<span class="s3">//</span>
<span class="s0">function </span><span class="s1">isValidFormattedNationalNumber(formattedNationalNumber, state) {</span>
	<span class="s0">return </span><span class="s1">parseDigits(formattedNationalNumber) === state.getNationalDigits()</span>
<span class="s1">}</span></pre>
</body>
</html>