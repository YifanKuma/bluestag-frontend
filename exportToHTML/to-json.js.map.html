<html>
<head>
<title>to-json.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
to-json.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/trace/report/to-json.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { traceGlobals, traceId } from '../shared'</span><span class="s3">\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import { PHASE_DEVELOPMENT_SERVER } from '../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import type { TraceEvent } from '../types'</span><span class="s3">\n\n</span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s3">\n</span><span class="s1">const localEndpoint = {</span><span class="s3">\n  </span><span class="s1">serviceName: 'nextjs',</span><span class="s3">\n  </span><span class="s1">ipv4: '127.0.0.1',</span><span class="s3">\n  </span><span class="s1">port: 9411,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type Event = TraceEvent &amp; {</span><span class="s3">\n  </span><span class="s1">localEndpoint?: typeof localEndpoint</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Batch events as zipkin allows for multiple events to be sent in one go</span><span class="s3">\n</span><span class="s1">export function batcher(reportEvents: (evts: Event[]) =&gt; Promise&lt;void&gt;) {</span><span class="s3">\n  </span><span class="s1">const events: Event[] = []</span><span class="s3">\n  </span><span class="s1">// Promise queue to ensure events are always sent on flushAll</span><span class="s3">\n  </span><span class="s1">const queue = new Set()</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">flushAll: async () =&gt; {</span><span class="s3">\n      </span><span class="s1">await Promise.all(queue)</span><span class="s3">\n      </span><span class="s1">if (events.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">await reportEvents(events)</span><span class="s3">\n        </span><span class="s1">events.length = 0</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">report: (event: Event) =&gt; {</span><span class="s3">\n      </span><span class="s1">events.push(event)</span><span class="s3">\n\n      </span><span class="s1">if (events.length &gt; 100) {</span><span class="s3">\n        </span><span class="s1">const evts = events.slice()</span><span class="s3">\n        </span><span class="s1">events.length = 0</span><span class="s3">\n        </span><span class="s1">const report = reportEvents(evts)</span><span class="s3">\n        </span><span class="s1">queue.add(report)</span><span class="s3">\n        </span><span class="s1">report.then(() =&gt; queue.delete(report))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let writeStream: RotatingWriteStream</span><span class="s3">\n</span><span class="s1">let batch: ReturnType&lt;typeof batcher&gt; | undefined</span><span class="s3">\n\n</span><span class="s1">const writeStreamOptions = {</span><span class="s3">\n  </span><span class="s1">flags: 'a',</span><span class="s3">\n  </span><span class="s1">encoding: 'utf8' as const,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class RotatingWriteStream {</span><span class="s3">\n  </span><span class="s1">file: string</span><span class="s3">\n  </span><span class="s1">writeStream!: fs.WriteStream</span><span class="s3">\n  </span><span class="s1">size: number</span><span class="s3">\n  </span><span class="s1">sizeLimit: number</span><span class="s3">\n  </span><span class="s1">private rotatePromise: Promise&lt;void&gt; | undefined</span><span class="s3">\n  </span><span class="s1">private drainPromise: Promise&lt;void&gt; | undefined</span><span class="s3">\n  </span><span class="s1">constructor(file: string, sizeLimit: number) {</span><span class="s3">\n    </span><span class="s1">this.file = file</span><span class="s3">\n    </span><span class="s1">this.size = 0</span><span class="s3">\n    </span><span class="s1">this.sizeLimit = sizeLimit</span><span class="s3">\n    </span><span class="s1">this.createWriteStream()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">private createWriteStream() {</span><span class="s3">\n    </span><span class="s1">this.writeStream = fs.createWriteStream(this.file, writeStreamOptions)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Recreate the file</span><span class="s3">\n  </span><span class="s1">private async rotate() {</span><span class="s3">\n    </span><span class="s1">await this.end()</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">fs.unlinkSync(this.file)</span><span class="s3">\n    </span><span class="s1">} catch (err: any) {</span><span class="s3">\n      </span><span class="s1">// It's fine if the file does not exist yet</span><span class="s3">\n      </span><span class="s1">if (err.code !== 'ENOENT') {</span><span class="s3">\n        </span><span class="s1">throw err</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.size = 0</span><span class="s3">\n    </span><span class="s1">this.createWriteStream()</span><span class="s3">\n    </span><span class="s1">this.rotatePromise = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">async write(data: string): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.rotatePromise) await this.rotatePromise</span><span class="s3">\n\n    </span><span class="s1">this.size += data.length</span><span class="s3">\n    </span><span class="s1">if (this.size &gt; this.sizeLimit) {</span><span class="s3">\n      </span><span class="s1">await (this.rotatePromise = this.rotate())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.writeStream.write(data, 'utf8')) {</span><span class="s3">\n      </span><span class="s1">if (this.drainPromise === undefined) {</span><span class="s3">\n        </span><span class="s1">this.drainPromise = new Promise&lt;void&gt;((resolve, _reject) =&gt; {</span><span class="s3">\n          </span><span class="s1">this.writeStream.once('drain', () =&gt; {</span><span class="s3">\n            </span><span class="s1">this.drainPromise = undefined</span><span class="s3">\n            </span><span class="s1">resolve()</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">await this.drainPromise</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">end(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return new Promise((resolve) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.writeStream.end(resolve)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const reportToLocalHost = (event: TraceEvent) =&gt; {</span><span class="s3">\n  </span><span class="s1">const distDir = traceGlobals.get('distDir')</span><span class="s3">\n  </span><span class="s1">const phase = traceGlobals.get('phase')</span><span class="s3">\n  </span><span class="s1">if (!distDir || !phase) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!batch) {</span><span class="s3">\n    </span><span class="s1">batch = batcher(async (events: Event[]) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!writeStream) {</span><span class="s3">\n        </span><span class="s1">await fs.promises.mkdir(distDir, { recursive: true })</span><span class="s3">\n        </span><span class="s1">const file = path.join(distDir, 'trace')</span><span class="s3">\n        </span><span class="s1">writeStream = new RotatingWriteStream(</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n          </span><span class="s1">// Development is limited to 50MB, production is unlimited</span><span class="s3">\n          </span><span class="s1">phase === PHASE_DEVELOPMENT_SERVER ? 52428800 : Infinity</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const eventsJson = JSON.stringify(events)</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">await writeStream.write(eventsJson + '</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">console.log(err)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">batch.report({</span><span class="s3">\n    </span><span class="s1">...event,</span><span class="s3">\n    </span><span class="s1">traceId,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default {</span><span class="s3">\n  </span><span class="s1">flushAll: (opts?: { end: boolean }) =&gt;</span><span class="s3">\n    </span><span class="s1">batch</span><span class="s3">\n      </span><span class="s1">? batch.flushAll().then(() =&gt; {</span><span class="s3">\n          </span><span class="s1">const phase = traceGlobals.get('phase')</span><span class="s3">\n          </span><span class="s1">// Only end writeStream when manually flushing in production</span><span class="s3">\n          </span><span class="s1">if (opts?.end || phase !== PHASE_DEVELOPMENT_SERVER) {</span><span class="s3">\n            </span><span class="s1">return writeStream.end()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">: undefined,</span><span class="s3">\n  </span><span class="s1">report: reportToLocalHost,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;localEndpoint&quot;</span><span class="s0">,</span><span class="s1">&quot;serviceName&quot;</span><span class="s0">,</span><span class="s1">&quot;ipv4&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;reportEvents&quot;</span><span class="s0">,</span><span class="s1">&quot;events&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;flushAll&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;report&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;evts&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;writeStream&quot;</span><span class="s0">,</span><span class="s1">&quot;batch&quot;</span><span class="s0">,</span><span class="s1">&quot;writeStreamOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;encoding&quot;</span><span class="s0">,</span><span class="s1">&quot;RotatingWriteStream&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;sizeLimit&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;createWriteStream&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;rotate&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;unlinkSync&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;rotatePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;write&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;drainPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;_reject&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;reportToLocalHost&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;traceGlobals&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;PHASE_DEVELOPMENT_SERVER&quot;</span><span class="s0">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s1">&quot;eventsJson&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;traceId&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>