<html>
<head>
<title>instrumentation-node-extensions.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
instrumentation-node-extensions.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/lib/router-utils/instrumentation-node-extensions.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This extension augments opentelemetry after registration if applicable.</span><span class="s3">\n </span><span class="s1">* This extension must only be loaded in Node environments.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type { Tracer } from '@opentelemetry/api'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type WorkUnitStore,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { isUseCacheFunction } from '../../../lib/client-and-server-references'</span><span class="s3">\n\n</span><span class="s1">export function afterRegistration(): void {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">'Node.js instrumentation extensions should not be loaded in the Edge runtime.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">extendTracerProviderForCacheComponents()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// In theory we only want to enable this extension when cacheComponents is enabled</span><span class="s3">\n</span><span class="s1">// however there are certain servers that might load instrumentation before nextConfig is available</span><span class="s3">\n</span><span class="s1">// and so gating it on the config might lead to skipping this extension even when it is necessary.</span><span class="s3">\n</span><span class="s1">// When cacheComponents is disabled this extension should be a no-op so we enable it universally.</span><span class="s3">\n</span><span class="s1">// Additionally, soon, cacheComponents will be enabled always so this just pulls the extension forward in time</span><span class="s3">\n</span><span class="s1">function extendTracerProviderForCacheComponents(): void {</span><span class="s3">\n  </span><span class="s1">let api: typeof import('next/dist/compiled/@opentelemetry/api')</span><span class="s3">\n\n  </span><span class="s1">// we want to allow users to use their own version of @opentelemetry/api if they</span><span class="s3">\n  </span><span class="s1">// want to, so we try to require it first, and if it fails we fall back to the</span><span class="s3">\n  </span><span class="s1">// version that is bundled with Next.js</span><span class="s3">\n  </span><span class="s1">// this is because @opentelemetry/api has to be synced with the version of</span><span class="s3">\n  </span><span class="s1">// @opentelemetry/tracing that is used, and we don't want to force users to use</span><span class="s3">\n  </span><span class="s1">// the version that is bundled with Next.js.</span><span class="s3">\n  </span><span class="s1">// the API is ~stable, so this should be fine</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">api =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/@opentelemetry/api') as typeof import('next/dist/compiled/@opentelemetry/api')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const provider = api.trace.getTracerProvider()</span><span class="s3">\n\n  </span><span class="s1">// When Cache Components is enabled we need to instrument the tracer</span><span class="s3">\n  </span><span class="s1">// to exit the workUnitAsyncStorage context when generating spans.</span><span class="s3">\n  </span><span class="s1">const originalGetTracer = provider.getTracer.bind(provider)</span><span class="s3">\n  </span><span class="s1">provider.getTracer = (...args) =&gt; {</span><span class="s3">\n    </span><span class="s1">const tracer = originalGetTracer.apply(provider, args)</span><span class="s3">\n    </span><span class="s1">if (WeakTracers.has(tracer)) {</span><span class="s3">\n      </span><span class="s1">return tracer</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const originalStartSpan = tracer.startSpan</span><span class="s3">\n    </span><span class="s1">tracer.startSpan = (...startSpanArgs) =&gt; {</span><span class="s3">\n      </span><span class="s1">return workUnitAsyncStorage.exit(() =&gt;</span><span class="s3">\n        </span><span class="s1">originalStartSpan.apply(tracer, startSpanArgs)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const originalStartActiveSpan = tracer.startActiveSpan</span><span class="s3">\n    </span><span class="s1">// @ts-ignore TS doesn't recognize the overloads correctly</span><span class="s3">\n    </span><span class="s1">tracer.startActiveSpan = (...startActiveSpanArgs: any[]) =&gt; {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">if (!workUnitStore) {</span><span class="s3">\n        </span><span class="s1">// @ts-ignore TS doesn't recognize the overloads correctly</span><span class="s3">\n        </span><span class="s1">return originalStartActiveSpan.apply(tracer, startActiveSpanArgs)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let fnIdx: number = 0</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">startActiveSpanArgs.length === 2 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof startActiveSpanArgs[1] === 'function'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">fnIdx = 1</span><span class="s3">\n      </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">startActiveSpanArgs.length === 3 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof startActiveSpanArgs[2] === 'function'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">fnIdx = 2</span><span class="s3">\n      </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">startActiveSpanArgs.length &gt; 3 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof startActiveSpanArgs[3] === 'function'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">fnIdx = 3</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (fnIdx) {</span><span class="s3">\n        </span><span class="s1">const originalFn = startActiveSpanArgs[fnIdx]</span><span class="s3">\n        </span><span class="s1">if (isUseCacheFunction(originalFn)) {</span><span class="s3">\n          </span><span class="s1">console.error(</span><span class="s3">\n            </span><span class="s1">'A Cache Function (`use cache`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">startActiveSpanArgs[fnIdx] = withWorkUnitContext(</span><span class="s3">\n          </span><span class="s1">workUnitStore,</span><span class="s3">\n          </span><span class="s1">originalFn</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return workUnitAsyncStorage.exit(() =&gt; {</span><span class="s3">\n        </span><span class="s1">// @ts-ignore TS doesn't recognize the overloads correctly</span><span class="s3">\n        </span><span class="s1">return originalStartActiveSpan.apply(tracer, startActiveSpanArgs)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">WeakTracers.add(tracer)</span><span class="s3">\n    </span><span class="s1">return tracer</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const WeakTracers = new WeakSet&lt;Tracer&gt;()</span><span class="s3">\n\n</span><span class="s1">function withWorkUnitContext(</span><span class="s3">\n  </span><span class="s1">workUnitStore: WorkUnitStore,</span><span class="s3">\n  </span><span class="s1">fn: (...args: any[]) =&gt; any</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (...args: any[]) =&gt;</span><span class="s3">\n    </span><span class="s1">workUnitAsyncStorage.run(workUnitStore, fn, ...args)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;afterRegistration&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;extendTracerProviderForCacheComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;api&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;provider&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracerProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;originalGetTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;tracer&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakTracers&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;originalStartSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;startSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;startSpanArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;originalStartActiveSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;startActiveSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;startActiveSpanArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;fnIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFn&quot;</span><span class="s0">,</span><span class="s1">&quot;isUseCacheFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;withWorkUnitContext&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;CAGC;;;;+BAUeA;;;eAAAA;;;8CAJT;gCACwB;2CACI;AAE5B,SAASA;IACd,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;QACvC,MAAM,qBAEL,CAFK,IAAIC,8BAAc,CACtB,iFADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEAC;AACF;AAEA,kFAAkF;AAClF,mGAAmG;AACnG,kGAAkG;AAClG,iGAAiG;AACjG,8GAA8G;AAC9G,SAASA;IACP,IAAIC;IAEJ,gFAAgF;IAChF,8EAA8E;IAC9E,uCAAuC;IACvC,0EAA0E;IAC1E,+EAA+E;IAC/E,4CAA4C;IAC5C,6CAA6C;IAC7C,IAAI;QACFA,MAAMC,QAAQ;IAChB,EAAE,OAAOC,KAAK;QACZF,MACEC,QAAQ;IACZ;IAEA,MAAME,WAAWH,IAAII,KAAK,CAACC,iBAAiB;IAE5C,oEAAoE;IACpE,kEAAkE;IAClE,MAAMC,oBAAoBH,SAASI,SAAS,CAACC,IAAI,CAACL;IAClDA,SAASI,SAAS,GAAG,CAAC,GAAGE;QACvB,MAAMC,SAASJ,kBAAkBK,KAAK,CAACR,UAAUM;QACjD,IAAIG,YAAYC,GAAG,CAACH,SAAS;YAC3B,OAAOA;QACT;QACA,MAAMI,oBAAoBJ,OAAOK,SAAS;QAC1CL,OAAOK,SAAS,GAAG,CAAC,GAAGC;YACrB,OAAOC,kDAAoB,CAACC,IAAI,CAAC,IAC/BJ,kBAAkBH,KAAK,CAACD,QAAQM;QAEpC;QAEA,MAAMG,0BAA0BT,OAAOU,eAAe;QACtD,0DAA0D;QAC1DV,OAAOU,eAAe,GAAG,CAAC,GAAGC;YAC3B,MAAMC,gBAAgBL,kDAAoB,CAACM,QAAQ;YACnD,IAAI,CAACD,eAAe;gBAClB,0DAA0D;gBAC1D,OAAOH,wBAAwBR,KAAK,CAACD,QAAQW;YAC/C;YAEA,IAAIG,QAAgB;YACpB,IACEH,oBAAoBI,MAAM,KAAK,KAC/B,OAAOJ,mBAAmB,CAAC,EAAE,KAAK,YAClC;gBACAG,QAAQ;YACV,OAAO,IACLH,oBAAoBI,MAAM,KAAK,KAC/B,OAAOJ,mBAAmB,CAAC,EAAE,KAAK,YAClC;gBACAG,QAAQ;YACV,OAAO,IACLH,oBAAoBI,MAAM,GAAG,KAC7B,OAAOJ,mBAAmB,CAAC,EAAE,KAAK,YAClC;gBACAG,QAAQ;YACV;YAEA,IAAIA,OAAO;gBACT,MAAME,aAAaL,mBAAmB,CAACG,MAAM;gBAC7C,IAAIG,IAAAA,6CAAkB,EAACD,aAAa;oBAClCE,QAAQC,KAAK,CACX;gBAEJ;gBACAR,mBAAmB,CAACG,MAAM,GAAGM,oBAC3BR,eACAI;YAEJ;YAEA,OAAOT,kDAAoB,CAACC,IAAI,CAAC;gBAC/B,0DAA0D;gBAC1D,OAAOC,wBAAwBR,KAAK,CAACD,QAAQW;YAC/C;QACF;QAEAT,YAAYmB,GAAG,CAACrB;QAChB,OAAOA;IACT;AACF;AAEA,MAAME,cAAc,IAAIoB;AAExB,SAASF,oBACPR,aAA4B,EAC5BW,EAA2B;IAE3B,OAAO,CAAC,GAAGxB,OACTQ,kDAAoB,CAACiB,GAAG,CAACZ,eAAeW,OAAOxB;AACnD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>