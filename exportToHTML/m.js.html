<html>
<head>
<title>m.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
m.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>

<span class="s2">var </span><span class="s1">jsxRuntime = require(</span><span class="s0">'react/jsx-runtime'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">motionUtils = require(</span><span class="s0">'motion-utils'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">react = require(</span><span class="s0">'react'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">motionDom = require(</span><span class="s0">'motion-dom'</span><span class="s1">);</span>

<span class="s2">const </span><span class="s1">LayoutGroupContext = react.createContext({});</span>

<span class="s2">const </span><span class="s1">LazyContext = react.createContext({ strict: </span><span class="s2">false </span><span class="s1">});</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@public</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">MotionConfigContext = react.createContext({</span>
    <span class="s1">transformPagePoint: (p) =&gt; p,</span>
    <span class="s1">isStatic: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">reducedMotion: </span><span class="s0">&quot;never&quot;</span><span class="s1">,</span>
<span class="s1">});</span>

<span class="s2">const </span><span class="s1">MotionContext = </span><span class="s3">/* @__PURE__ */ </span><span class="s1">react.createContext({});</span>

<span class="s2">function </span><span class="s1">isAnimationControls(v) {</span>
    <span class="s2">return </span><span class="s1">(v !== </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">v === </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">v.start === </span><span class="s0">&quot;function&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Decides if the supplied variable is variant label</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isVariantLabel(v) {</span>
    <span class="s2">return typeof </span><span class="s1">v === </span><span class="s0">&quot;string&quot; </span><span class="s1">|| Array.isArray(v);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">variantPriorityOrder = [</span>
    <span class="s0">&quot;animate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileInView&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileFocus&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileHover&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileTap&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileDrag&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;exit&quot;</span><span class="s1">,</span>
<span class="s1">];</span>
<span class="s2">const </span><span class="s1">variantProps = [</span><span class="s0">&quot;initial&quot;</span><span class="s1">, ...variantPriorityOrder];</span>

<span class="s2">function </span><span class="s1">isControllingVariants(props) {</span>
    <span class="s2">return </span><span class="s1">(isAnimationControls(props.animate) ||</span>
        <span class="s1">variantProps.some((name) =&gt; isVariantLabel(props[name])));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isVariantNode(props) {</span>
    <span class="s2">return </span><span class="s1">Boolean(isControllingVariants(props) || props.variants);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getCurrentTreeVariants(props, context) {</span>
    <span class="s2">if </span><span class="s1">(isControllingVariants(props)) {</span>
        <span class="s2">const </span><span class="s1">{ initial, animate } = props;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">initial: initial === </span><span class="s2">false </span><span class="s1">|| isVariantLabel(initial)</span>
                <span class="s1">? initial</span>
                <span class="s1">: undefined,</span>
            <span class="s1">animate: isVariantLabel(animate) ? animate : undefined,</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">props.inherit !== </span><span class="s2">false </span><span class="s1">? context : {};</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">useCreateMotionContext(props) {</span>
    <span class="s2">const </span><span class="s1">{ initial, animate } = getCurrentTreeVariants(props, react.useContext(MotionContext));</span>
    <span class="s2">return </span><span class="s1">react.useMemo(() =&gt; ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">variantLabelsAsDependency(prop) {</span>
    <span class="s2">return </span><span class="s1">Array.isArray(prop) ? prop.join(</span><span class="s0">&quot; &quot;</span><span class="s1">) : prop;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">scaleCorrectors = {};</span>

<span class="s2">function </span><span class="s1">isForcedMotionValue(key, { layout, layoutId }) {</span>
    <span class="s2">return </span><span class="s1">(motionDom.transformProps.has(key) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;origin&quot;</span><span class="s1">) ||</span>
        <span class="s1">((layout || layoutId !== undefined) &amp;&amp;</span>
            <span class="s1">(!!scaleCorrectors[key] || key === </span><span class="s0">&quot;opacity&quot;</span><span class="s1">)));</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">translateAlias = {</span>
    <span class="s1">x: </span><span class="s0">&quot;translateX&quot;</span><span class="s1">,</span>
    <span class="s1">y: </span><span class="s0">&quot;translateY&quot;</span><span class="s1">,</span>
    <span class="s1">z: </span><span class="s0">&quot;translateZ&quot;</span><span class="s1">,</span>
    <span class="s1">transformPerspective: </span><span class="s0">&quot;perspective&quot;</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">numTransforms = motionDom.transformPropOrder.length;</span>
<span class="s3">/**</span>
 <span class="s3">* Build a CSS transform style from individual x/y/scale etc properties.</span>
 <span class="s3">*</span>
 <span class="s3">* This outputs with a default order of transforms/scales/rotations, this can be customised by</span>
 <span class="s3">* providing a transformTemplate function.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">buildTransform(latestValues, transform, transformTemplate) {</span>
    <span class="s3">// The transform string we're going to build into.</span>
    <span class="s2">let </span><span class="s1">transformString = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">transformIsDefault = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Loop over all possible transforms in order, adding the ones that</span>
     <span class="s3">* are present to the transform string.</span>
     <span class="s3">*/</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; numTransforms; i++) {</span>
        <span class="s2">const </span><span class="s1">key = motionDom.transformPropOrder[i];</span>
        <span class="s2">const </span><span class="s1">value = latestValues[key];</span>
        <span class="s2">if </span><span class="s1">(value === undefined)</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">valueIsDefault = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
            <span class="s1">valueIsDefault = value === (key.startsWith(</span><span class="s0">&quot;scale&quot;</span><span class="s1">) ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">valueIsDefault = parseFloat(value) === </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!valueIsDefault || transformTemplate) {</span>
            <span class="s2">const </span><span class="s1">valueAsType = motionDom.getValueAsType(value, motionDom.numberValueTypes[key]);</span>
            <span class="s2">if </span><span class="s1">(!valueIsDefault) {</span>
                <span class="s1">transformIsDefault = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">transformName = translateAlias[key] || key;</span>
                <span class="s1">transformString += </span><span class="s0">`</span><span class="s1">${transformName}</span><span class="s0">(</span><span class="s1">${valueAsType}</span><span class="s0">) `</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(transformTemplate) {</span>
                <span class="s1">transform[key] = valueAsType;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">transformString = transformString.trim();</span>
    <span class="s3">// If we have a custom `transform` template, pass our transform values and</span>
    <span class="s3">// generated transformString to that before returning</span>
    <span class="s2">if </span><span class="s1">(transformTemplate) {</span>
        <span class="s1">transformString = transformTemplate(transform, transformIsDefault ? </span><span class="s0">&quot;&quot; </span><span class="s1">: transformString);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(transformIsDefault) {</span>
        <span class="s1">transformString = </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">transformString;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">buildHTMLStyles(state, latestValues, transformTemplate) {</span>
    <span class="s2">const </span><span class="s1">{ style, vars, transformOrigin } = state;</span>
    <span class="s3">// Track whether we encounter any transform or transformOrigin values.</span>
    <span class="s2">let </span><span class="s1">hasTransform = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">hasTransformOrigin = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Loop over all our latest animated values and decide whether to handle them</span>
     <span class="s3">* as a style or CSS variable.</span>
     <span class="s3">*</span>
     <span class="s3">* Transforms and transform origins are kept separately for further processing.</span>
     <span class="s3">*/</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">latestValues) {</span>
        <span class="s2">const </span><span class="s1">value = latestValues[key];</span>
        <span class="s2">if </span><span class="s1">(motionDom.transformProps.has(key)) {</span>
            <span class="s3">// If this is a transform, flag to enable further transform processing</span>
            <span class="s1">hasTransform = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(motionDom.isCSSVariableName(key)) {</span>
            <span class="s1">vars[key] = value;</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s3">// Convert the value to its default value type, ie 0 -&gt; &quot;0px&quot;</span>
            <span class="s2">const </span><span class="s1">valueAsType = motionDom.getValueAsType(value, motionDom.numberValueTypes[key]);</span>
            <span class="s2">if </span><span class="s1">(key.startsWith(</span><span class="s0">&quot;origin&quot;</span><span class="s1">)) {</span>
                <span class="s3">// If this is a transform origin, flag and enable further transform-origin processing</span>
                <span class="s1">hasTransformOrigin = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">transformOrigin[key] =</span>
                    <span class="s1">valueAsType;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">style[key] = valueAsType;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!latestValues.transform) {</span>
        <span class="s2">if </span><span class="s1">(hasTransform || transformTemplate) {</span>
            <span class="s1">style.transform = buildTransform(latestValues, state.transform, transformTemplate);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(style.transform) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If we have previously created a transform but currently don't have any,</span>
             <span class="s3">* reset transform style to none.</span>
             <span class="s3">*/</span>
            <span class="s1">style.transform = </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Build a transformOrigin style. Uses the same defaults as the browser for</span>
     <span class="s3">* undefined origins.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(hasTransformOrigin) {</span>
        <span class="s2">const </span><span class="s1">{ originX = </span><span class="s0">&quot;50%&quot;</span><span class="s1">, originY = </span><span class="s0">&quot;50%&quot;</span><span class="s1">, originZ = </span><span class="s5">0</span><span class="s1">, } = transformOrigin;</span>
        <span class="s1">style.transformOrigin = </span><span class="s0">`</span><span class="s1">${originX} ${originY} ${originZ}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createHtmlRenderState = () =&gt; ({</span>
    <span class="s1">style: {},</span>
    <span class="s1">transform: {},</span>
    <span class="s1">transformOrigin: {},</span>
    <span class="s1">vars: {},</span>
<span class="s1">});</span>

<span class="s2">function </span><span class="s1">copyRawValuesOnly(target, source, props) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">source) {</span>
        <span class="s2">if </span><span class="s1">(!motionDom.isMotionValue(source[key]) &amp;&amp; !isForcedMotionValue(key, props)) {</span>
            <span class="s1">target[key] = source[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useInitialMotionValues({ transformTemplate }, visualState) {</span>
    <span class="s2">return </span><span class="s1">react.useMemo(() =&gt; {</span>
        <span class="s2">const </span><span class="s1">state = createHtmlRenderState();</span>
        <span class="s1">buildHTMLStyles(state, visualState, transformTemplate);</span>
        <span class="s2">return </span><span class="s1">Object.assign({}, state.vars, state.style);</span>
    <span class="s1">}, [visualState]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useStyle(props, visualState) {</span>
    <span class="s2">const </span><span class="s1">styleProp = props.style || {};</span>
    <span class="s2">const </span><span class="s1">style = {};</span>
    <span class="s3">/**</span>
     <span class="s3">* Copy non-Motion Values straight into style</span>
     <span class="s3">*/</span>
    <span class="s1">copyRawValuesOnly(style, styleProp, props);</span>
    <span class="s1">Object.assign(style, useInitialMotionValues(props, visualState));</span>
    <span class="s2">return </span><span class="s1">style;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useHTMLProps(props, visualState) {</span>
    <span class="s3">// The `any` isn't ideal but it is the type of createElement props argument</span>
    <span class="s2">const </span><span class="s1">htmlProps = {};</span>
    <span class="s2">const </span><span class="s1">style = useStyle(props, visualState);</span>
    <span class="s2">if </span><span class="s1">(props.drag &amp;&amp; props.dragListener !== </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s3">// Disable the ghost element when a user drags</span>
        <span class="s1">htmlProps.draggable = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s3">// Disable text selection</span>
        <span class="s1">style.userSelect =</span>
            <span class="s1">style.WebkitUserSelect =</span>
                <span class="s1">style.WebkitTouchCallout =</span>
                    <span class="s0">&quot;none&quot;</span><span class="s1">;</span>
        <span class="s3">// Disable scrolling on the draggable direction</span>
        <span class="s1">style.touchAction =</span>
            <span class="s1">props.drag === </span><span class="s2">true</span>
                <span class="s1">? </span><span class="s0">&quot;none&quot;</span>
                <span class="s1">: </span><span class="s0">`pan-</span><span class="s1">${props.drag === </span><span class="s0">&quot;x&quot; </span><span class="s1">? </span><span class="s0">&quot;y&quot; </span><span class="s1">: </span><span class="s0">&quot;x&quot;</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(props.tabIndex === undefined &amp;&amp;</span>
        <span class="s1">(props.onTap || props.onTapStart || props.whileTap)) {</span>
        <span class="s1">htmlProps.tabIndex = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">htmlProps.style = style;</span>
    <span class="s2">return </span><span class="s1">htmlProps;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">dashKeys = {</span>
    <span class="s1">offset: </span><span class="s0">&quot;stroke-dashoffset&quot;</span><span class="s1">,</span>
    <span class="s1">array: </span><span class="s0">&quot;stroke-dasharray&quot;</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">camelKeys = {</span>
    <span class="s1">offset: </span><span class="s0">&quot;strokeDashoffset&quot;</span><span class="s1">,</span>
    <span class="s1">array: </span><span class="s0">&quot;strokeDasharray&quot;</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s3">/**</span>
 <span class="s3">* Build SVG path properties. Uses the path's measured length to convert</span>
 <span class="s3">* our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset</span>
 <span class="s3">* and stroke-dasharray attributes.</span>
 <span class="s3">*</span>
 <span class="s3">* This function is mutative to reduce per-frame GC.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">buildSVGPath(attrs, length, spacing = </span><span class="s5">1</span><span class="s1">, offset = </span><span class="s5">0</span><span class="s1">, useDashCase = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s3">// Normalise path length by setting SVG attribute pathLength to 1</span>
    <span class="s1">attrs.pathLength = </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s3">// We use dash case when setting attributes directly to the DOM node and camel case</span>
    <span class="s3">// when defining props on a React component.</span>
    <span class="s2">const </span><span class="s1">keys = useDashCase ? dashKeys : camelKeys;</span>
    <span class="s3">// Build the dash offset</span>
    <span class="s1">attrs[keys.offset] = motionDom.px.transform(-offset);</span>
    <span class="s3">// Build the dash array</span>
    <span class="s2">const </span><span class="s1">pathLength = motionDom.px.transform(length);</span>
    <span class="s2">const </span><span class="s1">pathSpacing = motionDom.px.transform(spacing);</span>
    <span class="s1">attrs[keys.array] = </span><span class="s0">`</span><span class="s1">${pathLength} ${pathSpacing}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Build SVG visual attributes, like cx and style.transform</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">buildSVGAttrs(state, { attrX, attrY, attrScale, pathLength, pathSpacing = </span><span class="s5">1</span><span class="s1">, pathOffset = </span><span class="s5">0</span><span class="s1">, </span>
<span class="s3">// This is object creation, which we try to avoid per-frame.</span>
<span class="s1">...latest }, isSVGTag, transformTemplate, styleProp) {</span>
    <span class="s1">buildHTMLStyles(state, latest, transformTemplate);</span>
    <span class="s3">/**</span>
     <span class="s3">* For svg tags we just want to make sure viewBox is animatable and treat all the styles</span>
     <span class="s3">* as normal HTML tags.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(isSVGTag) {</span>
        <span class="s2">if </span><span class="s1">(state.style.viewBox) {</span>
            <span class="s1">state.attrs.viewBox = state.style.viewBox;</span>
        <span class="s1">}</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">state.attrs = state.style;</span>
    <span class="s1">state.style = {};</span>
    <span class="s2">const </span><span class="s1">{ attrs, style } = state;</span>
    <span class="s3">/**</span>
     <span class="s3">* However, we apply transforms as CSS transforms.</span>
     <span class="s3">* So if we detect a transform, transformOrigin we take it from attrs and copy it into style.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(attrs.transform) {</span>
        <span class="s1">style.transform = attrs.transform;</span>
        <span class="s2">delete </span><span class="s1">attrs.transform;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(style.transform || attrs.transformOrigin) {</span>
        <span class="s1">style.transformOrigin = attrs.transformOrigin ?? </span><span class="s0">&quot;50% 50%&quot;</span><span class="s1">;</span>
        <span class="s2">delete </span><span class="s1">attrs.transformOrigin;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(style.transform) {</span>
        <span class="s3">/**</span>
         <span class="s3">* SVG's element transform-origin uses its own median as a reference.</span>
         <span class="s3">* Therefore, transformBox becomes a fill-box</span>
         <span class="s3">*/</span>
        <span class="s1">style.transformBox = styleProp?.transformBox ?? </span><span class="s0">&quot;fill-box&quot;</span><span class="s1">;</span>
        <span class="s2">delete </span><span class="s1">attrs.transformBox;</span>
    <span class="s1">}</span>
    <span class="s3">// Render attrX/attrY/attrScale as attributes</span>
    <span class="s2">if </span><span class="s1">(attrX !== undefined)</span>
        <span class="s1">attrs.x = attrX;</span>
    <span class="s2">if </span><span class="s1">(attrY !== undefined)</span>
        <span class="s1">attrs.y = attrY;</span>
    <span class="s2">if </span><span class="s1">(attrScale !== undefined)</span>
        <span class="s1">attrs.scale = attrScale;</span>
    <span class="s3">// Build SVG path if one has been defined</span>
    <span class="s2">if </span><span class="s1">(pathLength !== undefined) {</span>
        <span class="s1">buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createSvgRenderState = () =&gt; ({</span>
    <span class="s1">...createHtmlRenderState(),</span>
    <span class="s1">attrs: {},</span>
<span class="s1">});</span>

<span class="s2">const </span><span class="s1">isSVGTag = (tag) =&gt; </span><span class="s2">typeof </span><span class="s1">tag === </span><span class="s0">&quot;string&quot; </span><span class="s1">&amp;&amp; tag.toLowerCase() === </span><span class="s0">&quot;svg&quot;</span><span class="s1">;</span>

<span class="s2">function </span><span class="s1">useSVGProps(props, visualState, _isStatic, Component) {</span>
    <span class="s2">const </span><span class="s1">visualProps = react.useMemo(() =&gt; {</span>
        <span class="s2">const </span><span class="s1">state = createSvgRenderState();</span>
        <span class="s1">buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">...state.attrs,</span>
            <span class="s1">style: { ...state.style },</span>
        <span class="s1">};</span>
    <span class="s1">}, [visualState]);</span>
    <span class="s2">if </span><span class="s1">(props.style) {</span>
        <span class="s2">const </span><span class="s1">rawStyles = {};</span>
        <span class="s1">copyRawValuesOnly(rawStyles, props.style, props);</span>
        <span class="s1">visualProps.style = { ...rawStyles, ...visualProps.style };</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">visualProps;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* A list of all valid MotionProps.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@privateRemarks</span>
 <span class="s3">* This doesn't throw if a `MotionProp` name is missing - it should.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">validMotionProps = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s0">&quot;animate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;exit&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;variants&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;initial&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;style&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;values&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;variants&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;transition&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;transformTemplate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;custom&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;inherit&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onBeforeLayoutMeasure&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onAnimationStart&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onAnimationComplete&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onUpdate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDragStart&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDrag&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDragEnd&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onMeasureDragConstraints&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDirectionLock&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDragTransitionEnd&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;_dragX&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;_dragY&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onHoverStart&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onHoverEnd&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onViewportEnter&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onViewportLeave&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;globalTapTarget&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;ignoreStrict&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;viewport&quot;</span><span class="s1">,</span>
<span class="s1">]);</span>
<span class="s3">/**</span>
 <span class="s3">* Check whether a prop name is a valid `MotionProp` key.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">key - Name of the property to check</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">`true` is key is a valid `MotionProp`.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@public</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isValidMotionProp(key) {</span>
    <span class="s2">return </span><span class="s1">(key.startsWith(</span><span class="s0">&quot;while&quot;</span><span class="s1">) ||</span>
        <span class="s1">(key.startsWith(</span><span class="s0">&quot;drag&quot;</span><span class="s1">) &amp;&amp; key !== </span><span class="s0">&quot;draggable&quot;</span><span class="s1">) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;layout&quot;</span><span class="s1">) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;onTap&quot;</span><span class="s1">) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;onPan&quot;</span><span class="s1">) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;onLayout&quot;</span><span class="s1">) ||</span>
        <span class="s1">validMotionProps.has(key));</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">shouldForward = (key) =&gt; !isValidMotionProp(key);</span>
<span class="s2">function </span><span class="s1">loadExternalIsValidProp(isValidProp) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">isValidProp !== </span><span class="s0">&quot;function&quot;</span><span class="s1">)</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s3">// Explicitly filter our events</span>
    <span class="s1">shouldForward = (key) =&gt; key.startsWith(</span><span class="s0">&quot;on&quot;</span><span class="s1">) ? !isValidMotionProp(key) : isValidProp(key);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Emotion and Styled Components both allow users to pass through arbitrary props to their components</span>
 <span class="s3">* to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which</span>
 <span class="s3">* of these should be passed to the underlying DOM node.</span>
 <span class="s3">*</span>
 <span class="s3">* However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props</span>
 <span class="s3">* as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props</span>
 <span class="s3">* passed through the `custom` prop so it doesn't *need* the payload or computational overhead of</span>
 <span class="s3">* `@emotion/is-prop-valid`, however to fix this problem we need to use it.</span>
 <span class="s3">*</span>
 <span class="s3">* By making it an optionalDependency we can offer this functionality only in the situations where it's</span>
 <span class="s3">* actually required.</span>
 <span class="s3">*/</span>
<span class="s2">try </span><span class="s1">{</span>
    <span class="s3">/**</span>
     <span class="s3">* We attempt to import this package but require won't be defined in esm environments, in that case</span>
     <span class="s3">* isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed</span>
     <span class="s3">* in favour of explicit injection.</span>
     <span class="s3">*/</span>
    <span class="s1">loadExternalIsValidProp(require(</span><span class="s0">&quot;@emotion/is-prop-valid&quot;</span><span class="s1">).default);</span>
<span class="s1">}</span>
<span class="s2">catch </span><span class="s1">{</span>
    <span class="s3">// We don't need to actually do anything here - the fallback is the existing `isPropValid`.</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">filterProps(props, isDom, forwardMotionProps) {</span>
    <span class="s2">const </span><span class="s1">filteredProps = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
        <span class="s3">/**</span>
         <span class="s3">* values is considered a valid prop by Emotion, so if it's present</span>
         <span class="s3">* this will be rendered out to the DOM unless explicitly filtered.</span>
         <span class="s3">*</span>
         <span class="s3">* We check the type as it could be used with the `feColorMatrix`</span>
         <span class="s3">* element, which we support.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s0">&quot;values&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">props.values === </span><span class="s0">&quot;object&quot;</span><span class="s1">)</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(shouldForward(key) ||</span>
            <span class="s1">(forwardMotionProps === </span><span class="s2">true </span><span class="s1">&amp;&amp; isValidMotionProp(key)) ||</span>
            <span class="s1">(!isDom &amp;&amp; !isValidMotionProp(key)) ||</span>
            <span class="s3">// If trying to use native HTML drag events, forward drag listeners</span>
            <span class="s1">(props[</span><span class="s0">&quot;draggable&quot;</span><span class="s1">] &amp;&amp;</span>
                <span class="s1">key.startsWith(</span><span class="s0">&quot;onDrag&quot;</span><span class="s1">))) {</span>
            <span class="s1">filteredProps[key] =</span>
                <span class="s1">props[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">filteredProps;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* We keep these listed separately as we use the lowercase tag names as part</span>
 <span class="s3">* of the runtime bundle to detect SVG components</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">lowercaseSVGElements = [</span>
    <span class="s0">&quot;animate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;circle&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;defs&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;desc&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;ellipse&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;g&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;image&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;line&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;filter&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;marker&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;mask&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;metadata&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;path&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;pattern&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;polygon&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;polyline&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;rect&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;stop&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;switch&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;symbol&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;svg&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;text&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;tspan&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;use&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;view&quot;</span><span class="s1">,</span>
<span class="s1">];</span>

<span class="s2">function </span><span class="s1">isSVGComponent(Component) {</span>
    <span class="s2">if </span><span class="s1">(</span>
    <span class="s3">/**</span>
     <span class="s3">* If it's not a string, it's a custom React component. Currently we only support</span>
     <span class="s3">* HTML custom React components.</span>
     <span class="s3">*/</span>
    <span class="s2">typeof </span><span class="s1">Component !== </span><span class="s0">&quot;string&quot; </span><span class="s1">||</span>
        <span class="s3">/**</span>
         <span class="s3">* If it contains a dash, the element is a custom HTML webcomponent.</span>
         <span class="s3">*/</span>
        <span class="s1">Component.includes(</span><span class="s0">&quot;-&quot;</span><span class="s1">)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span>
    <span class="s3">/**</span>
     <span class="s3">* If it's in our list of lowercase SVG tags, it's an SVG component</span>
     <span class="s3">*/</span>
    <span class="s1">lowercaseSVGElements.indexOf(Component) &gt; -</span><span class="s5">1 </span><span class="s1">||</span>
        <span class="s3">/**</span>
         <span class="s3">* If it contains a capital letter, it's an SVG component</span>
         <span class="s3">*/</span>
        <span class="s6">/[A-Z]/u</span><span class="s1">.test(Component)) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">useRender(Component, props, ref, { latestValues, }, isStatic, forwardMotionProps = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">useVisualProps = isSVGComponent(Component)</span>
        <span class="s1">? useSVGProps</span>
        <span class="s1">: useHTMLProps;</span>
    <span class="s2">const </span><span class="s1">visualProps = useVisualProps(props, latestValues, isStatic, Component);</span>
    <span class="s2">const </span><span class="s1">filteredProps = filterProps(props, </span><span class="s2">typeof </span><span class="s1">Component === </span><span class="s0">&quot;string&quot;</span><span class="s1">, forwardMotionProps);</span>
    <span class="s2">const </span><span class="s1">elementProps = Component !== react.Fragment ? { ...filteredProps, ...visualProps, ref } : {};</span>
    <span class="s3">/**</span>
     <span class="s3">* If component has been handed a motion value as its child,</span>
     <span class="s3">* memoise its initial value and render that. Subsequent updates</span>
     <span class="s3">* will be handled by the onChange handler</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">{ children } = props;</span>
    <span class="s2">const </span><span class="s1">renderedChildren = react.useMemo(() =&gt; (motionDom.isMotionValue(children) ? children.get() : children), [children]);</span>
    <span class="s2">return </span><span class="s1">react.createElement(Component, {</span>
        <span class="s1">...elementProps,</span>
        <span class="s1">children: renderedChildren,</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@public</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">PresenceContext = </span>
<span class="s3">/* @__PURE__ */ </span><span class="s1">react.createContext(</span><span class="s2">null</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">getValueState(visualElement) {</span>
    <span class="s2">const </span><span class="s1">state = [{}, {}];</span>
    <span class="s2">return </span><span class="s1">state;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveVariantFromProps(props, definition, custom, visualElement) {</span>
    <span class="s3">/**</span>
     <span class="s3">* If the variant definition is a function, resolve.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">definition === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">[current, velocity] = getValueState();</span>
        <span class="s1">definition = definition(props.custom, current, velocity);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* If the variant definition is a variant label, or</span>
     <span class="s3">* the function returned a variant label, resolve.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">definition === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">definition = props.variants &amp;&amp; props.variants[definition];</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* At this point we've resolved both functions and variant labels,</span>
     <span class="s3">* but the resolved variant label might itself have been a function.</span>
     <span class="s3">* If so, resolve. This can only have returned a valid target object.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">definition === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">[current, velocity] = getValueState();</span>
        <span class="s1">definition = definition(props.custom, current, velocity);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">definition;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Creates a constant value over the lifecycle of a component.</span>
 <span class="s3">*</span>
 <span class="s3">* Even if `useMemo` is provided an empty array as its final argument, it doesn't offer</span>
 <span class="s3">* a guarantee that it won't re-run for performance reasons later on. By using `useConstant`</span>
 <span class="s3">* you can ensure that initialisers don't execute twice or more.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">useConstant(init) {</span>
    <span class="s2">const </span><span class="s1">ref = react.useRef(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(ref.current === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ref.current = init();</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ref.current;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself</span>
 <span class="s3">*</span>
 <span class="s3">* TODO: Remove and move to library</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">resolveMotionValue(value) {</span>
    <span class="s2">return </span><span class="s1">motionDom.isMotionValue(value) ? value.get() : value;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {</span>
    <span class="s2">const </span><span class="s1">state = {</span>
        <span class="s1">latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),</span>
        <span class="s1">renderState: createRenderState(),</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">state;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeLatestValues(props, context, presenceContext, scrapeMotionValues) {</span>
    <span class="s2">const </span><span class="s1">values = {};</span>
    <span class="s2">const </span><span class="s1">motionValues = scrapeMotionValues(props, {});</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">motionValues) {</span>
        <span class="s1">values[key] = resolveMotionValue(motionValues[key]);</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">{ initial, animate } = props;</span>
    <span class="s2">const </span><span class="s1">isControllingVariants$1 = isControllingVariants(props);</span>
    <span class="s2">const </span><span class="s1">isVariantNode$1 = isVariantNode(props);</span>
    <span class="s2">if </span><span class="s1">(context &amp;&amp;</span>
        <span class="s1">isVariantNode$1 &amp;&amp;</span>
        <span class="s1">!isControllingVariants$1 &amp;&amp;</span>
        <span class="s1">props.inherit !== </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(initial === undefined)</span>
            <span class="s1">initial = context.initial;</span>
        <span class="s2">if </span><span class="s1">(animate === undefined)</span>
            <span class="s1">animate = context.animate;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">isInitialAnimationBlocked = presenceContext</span>
        <span class="s1">? presenceContext.initial === </span><span class="s2">false</span>
        <span class="s1">: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">isInitialAnimationBlocked = isInitialAnimationBlocked || initial === </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">variantToSet = isInitialAnimationBlocked ? animate : initial;</span>
    <span class="s2">if </span><span class="s1">(variantToSet &amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">variantToSet !== </span><span class="s0">&quot;boolean&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!isAnimationControls(variantToSet)) {</span>
        <span class="s2">const </span><span class="s1">list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; list.length; i++) {</span>
            <span class="s2">const </span><span class="s1">resolved = resolveVariantFromProps(props, list[i]);</span>
            <span class="s2">if </span><span class="s1">(resolved) {</span>
                <span class="s2">const </span><span class="s1">{ transitionEnd, transition, ...target } = resolved;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">target) {</span>
                    <span class="s2">let </span><span class="s1">valueTarget = target[key];</span>
                    <span class="s2">if </span><span class="s1">(Array.isArray(valueTarget)) {</span>
                        <span class="s3">/**</span>
                         <span class="s3">* Take final keyframe if the initial animation is blocked because</span>
                         <span class="s3">* we want to initialise at the end of that blocked animation.</span>
                         <span class="s3">*/</span>
                        <span class="s2">const </span><span class="s1">index = isInitialAnimationBlocked</span>
                            <span class="s1">? valueTarget.length - </span><span class="s5">1</span>
                            <span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
                        <span class="s1">valueTarget = valueTarget[index];</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(valueTarget !== </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s1">values[key] = valueTarget;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">transitionEnd) {</span>
                    <span class="s1">values[key] = transitionEnd[key];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">values;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">makeUseVisualState = (config) =&gt; (props, isStatic) =&gt; {</span>
    <span class="s2">const </span><span class="s1">context = react.useContext(MotionContext);</span>
    <span class="s2">const </span><span class="s1">presenceContext = react.useContext(PresenceContext);</span>
    <span class="s2">const </span><span class="s1">make = () =&gt; makeState(config, props, context, presenceContext);</span>
    <span class="s2">return </span><span class="s1">isStatic ? make() : useConstant(make);</span>
<span class="s1">};</span>

<span class="s2">function </span><span class="s1">scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {</span>
    <span class="s2">const </span><span class="s1">{ style } = props;</span>
    <span class="s2">const </span><span class="s1">newValues = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">style) {</span>
        <span class="s2">if </span><span class="s1">(motionDom.isMotionValue(style[key]) ||</span>
            <span class="s1">(prevProps.style &amp;&amp;</span>
                <span class="s1">motionDom.isMotionValue(prevProps.style[key])) ||</span>
            <span class="s1">isForcedMotionValue(key, props) ||</span>
            <span class="s1">visualElement?.getValue(key)?.liveStyle !== undefined) {</span>
            <span class="s1">newValues[key] = style[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newValues;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">useHTMLVisualState = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">makeUseVisualState({</span>
    <span class="s1">scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,</span>
    <span class="s1">createRenderState: createHtmlRenderState,</span>
<span class="s1">});</span>

<span class="s2">function </span><span class="s1">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span>
    <span class="s2">const </span><span class="s1">newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
        <span class="s2">if </span><span class="s1">(motionDom.isMotionValue(props[key]) ||</span>
            <span class="s1">motionDom.isMotionValue(prevProps[key])) {</span>
            <span class="s2">const </span><span class="s1">targetKey = motionDom.transformPropOrder.indexOf(key) !== -</span><span class="s5">1</span>
                <span class="s1">? </span><span class="s0">&quot;attr&quot; </span><span class="s1">+ key.charAt(</span><span class="s5">0</span><span class="s1">).toUpperCase() + key.substring(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">: key;</span>
            <span class="s1">newValues[targetKey] = props[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newValues;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">useSVGVisualState = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">makeUseVisualState({</span>
    <span class="s1">scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,</span>
    <span class="s1">createRenderState: createSvgRenderState,</span>
<span class="s1">});</span>

<span class="s2">const </span><span class="s1">isBrowser = </span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">;</span>

<span class="s2">const </span><span class="s1">featureProps = {</span>
    <span class="s1">animation: [</span>
        <span class="s0">&quot;animate&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;variants&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileHover&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileTap&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;exit&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileInView&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileFocus&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileDrag&quot;</span><span class="s1">,</span>
    <span class="s1">],</span>
    <span class="s1">exit: [</span><span class="s0">&quot;exit&quot;</span><span class="s1">],</span>
    <span class="s1">drag: [</span><span class="s0">&quot;drag&quot;</span><span class="s1">, </span><span class="s0">&quot;dragControls&quot;</span><span class="s1">],</span>
    <span class="s1">focus: [</span><span class="s0">&quot;whileFocus&quot;</span><span class="s1">],</span>
    <span class="s1">hover: [</span><span class="s0">&quot;whileHover&quot;</span><span class="s1">, </span><span class="s0">&quot;onHoverStart&quot;</span><span class="s1">, </span><span class="s0">&quot;onHoverEnd&quot;</span><span class="s1">],</span>
    <span class="s1">tap: [</span><span class="s0">&quot;whileTap&quot;</span><span class="s1">, </span><span class="s0">&quot;onTap&quot;</span><span class="s1">, </span><span class="s0">&quot;onTapStart&quot;</span><span class="s1">, </span><span class="s0">&quot;onTapCancel&quot;</span><span class="s1">],</span>
    <span class="s1">pan: [</span><span class="s0">&quot;onPan&quot;</span><span class="s1">, </span><span class="s0">&quot;onPanStart&quot;</span><span class="s1">, </span><span class="s0">&quot;onPanSessionStart&quot;</span><span class="s1">, </span><span class="s0">&quot;onPanEnd&quot;</span><span class="s1">],</span>
    <span class="s1">inView: [</span><span class="s0">&quot;whileInView&quot;</span><span class="s1">, </span><span class="s0">&quot;onViewportEnter&quot;</span><span class="s1">, </span><span class="s0">&quot;onViewportLeave&quot;</span><span class="s1">],</span>
    <span class="s1">layout: [</span><span class="s0">&quot;layout&quot;</span><span class="s1">, </span><span class="s0">&quot;layoutId&quot;</span><span class="s1">],</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">featureDefinitions = {};</span>
<span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">featureProps) {</span>
    <span class="s1">featureDefinitions[key] = {</span>
        <span class="s1">isEnabled: (props) =&gt; featureProps[key].some((name) =&gt; !!props[name]),</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">motionComponentSymbol = Symbol.for(</span><span class="s0">&quot;motionComponentSymbol&quot;</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">isRefObject(ref) {</span>
    <span class="s2">return </span><span class="s1">(ref &amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">ref === </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">Object.prototype.hasOwnProperty.call(ref, </span><span class="s0">&quot;current&quot;</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Creates a ref function that, when called, hydrates the provided</span>
 <span class="s3">* external ref and VisualElement.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">useMotionRef(visualState, visualElement, externalRef) {</span>
    <span class="s2">return </span><span class="s1">react.useCallback((instance) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(instance) {</span>
            <span class="s1">visualState.onMount &amp;&amp; visualState.onMount(instance);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(visualElement) {</span>
            <span class="s2">if </span><span class="s1">(instance) {</span>
                <span class="s1">visualElement.mount(instance);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">visualElement.unmount();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(externalRef) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">externalRef === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
                <span class="s1">externalRef(instance);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isRefObject(externalRef)) {</span>
                <span class="s1">externalRef.current = instance;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}, </span>
    <span class="s3">/**</span>
     <span class="s3">* Include externalRef in dependencies to ensure the callback updates</span>
     <span class="s3">* when the ref changes, allowing proper ref forwarding.</span>
     <span class="s3">*/</span>
    <span class="s1">[visualElement]);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Convert camelCase to dash-case properties.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">camelToDash = (str) =&gt; str.replace(</span><span class="s6">/([a-z])([A-Z])/gu</span><span class="s1">, </span><span class="s0">&quot;$1-$2&quot;</span><span class="s1">).toLowerCase();</span>

<span class="s2">const </span><span class="s1">optimizedAppearDataId = </span><span class="s0">&quot;framerAppearId&quot;</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">optimizedAppearDataAttribute = </span><span class="s0">&quot;data-&quot; </span><span class="s1">+ camelToDash(optimizedAppearDataId);</span>

<span class="s3">/**</span>
 <span class="s3">* Internal, exported only for usage in Framer</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">SwitchLayoutGroupContext = react.createContext({});</span>

<span class="s2">const </span><span class="s1">useIsomorphicLayoutEffect = isBrowser ? react.useLayoutEffect : react.useEffect;</span>

<span class="s2">function </span><span class="s1">useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {</span>
    <span class="s2">const </span><span class="s1">{ visualElement: parent } = react.useContext(MotionContext);</span>
    <span class="s2">const </span><span class="s1">lazyContext = react.useContext(LazyContext);</span>
    <span class="s2">const </span><span class="s1">presenceContext = react.useContext(PresenceContext);</span>
    <span class="s2">const </span><span class="s1">reducedMotionConfig = react.useContext(MotionConfigContext).reducedMotion;</span>
    <span class="s2">const </span><span class="s1">visualElementRef = react.useRef(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s3">/**</span>
     <span class="s3">* If we haven't preloaded a renderer, check to see if we have one lazy-loaded</span>
     <span class="s3">*/</span>
    <span class="s1">createVisualElement =</span>
        <span class="s1">createVisualElement ||</span>
            <span class="s1">lazyContext.renderer;</span>
    <span class="s2">if </span><span class="s1">(!visualElementRef.current &amp;&amp; createVisualElement) {</span>
        <span class="s1">visualElementRef.current = createVisualElement(Component, {</span>
            <span class="s1">visualState,</span>
            <span class="s1">parent,</span>
            <span class="s1">props,</span>
            <span class="s1">presenceContext,</span>
            <span class="s1">blockInitialAnimation: presenceContext</span>
                <span class="s1">? presenceContext.initial === </span><span class="s2">false</span>
                <span class="s1">: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">reducedMotionConfig,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">visualElement = visualElementRef.current;</span>
    <span class="s3">/**</span>
     <span class="s3">* Load Motion gesture and animation features. These are rendered as renderless</span>
     <span class="s3">* components so each feature can optionally make use of React lifecycle methods.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">initialLayoutGroupConfig = react.useContext(SwitchLayoutGroupContext);</span>
    <span class="s2">if </span><span class="s1">(visualElement &amp;&amp;</span>
        <span class="s1">!visualElement.projection &amp;&amp;</span>
        <span class="s1">ProjectionNodeConstructor &amp;&amp;</span>
        <span class="s1">(visualElement.type === </span><span class="s0">&quot;html&quot; </span><span class="s1">|| visualElement.type === </span><span class="s0">&quot;svg&quot;</span><span class="s1">)) {</span>
        <span class="s1">createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">isMounted = react.useRef(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">react.useInsertionEffect(() =&gt; {</span>
        <span class="s3">/**</span>
         <span class="s3">* Check the component has already mounted before calling</span>
         <span class="s3">* `update` unnecessarily. This ensures we skip the initial update.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(visualElement &amp;&amp; isMounted.current) {</span>
            <span class="s1">visualElement.update(props, presenceContext);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">/**</span>
     <span class="s3">* Cache this value as we want to know whether HandoffAppearAnimations</span>
     <span class="s3">* was present on initial render - it will be deleted after this.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">optimisedAppearId = props[optimizedAppearDataAttribute];</span>
    <span class="s2">const </span><span class="s1">wantsHandoff = react.useRef(Boolean(optimisedAppearId) &amp;&amp;</span>
        <span class="s1">!window.MotionHandoffIsComplete?.(optimisedAppearId) &amp;&amp;</span>
        <span class="s1">window.MotionHasOptimisedAnimation?.(optimisedAppearId));</span>
    <span class="s1">useIsomorphicLayoutEffect(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!visualElement)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">isMounted.current = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">window.MotionIsMounted = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">visualElement.updateFeatures();</span>
        <span class="s1">visualElement.scheduleRenderMicrotask();</span>
        <span class="s3">/**</span>
         <span class="s3">* Ideally this function would always run in a useEffect.</span>
         <span class="s3">*</span>
         <span class="s3">* However, if we have optimised appear animations to handoff from,</span>
         <span class="s3">* it needs to happen synchronously to ensure there's no flash of</span>
         <span class="s3">* incorrect styles in the event of a hydration error.</span>
         <span class="s3">*</span>
         <span class="s3">* So if we detect a situtation where optimised appear animations</span>
         <span class="s3">* are running, we use useLayoutEffect to trigger animations.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(wantsHandoff.current &amp;&amp; visualElement.animationState) {</span>
            <span class="s1">visualElement.animationState.animateChanges();</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">react.useEffect(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!visualElement)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!wantsHandoff.current &amp;&amp; visualElement.animationState) {</span>
            <span class="s1">visualElement.animationState.animateChanges();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(wantsHandoff.current) {</span>
            <span class="s3">// This ensures all future calls to animateChanges() in this component will run in useEffect</span>
            <span class="s1">queueMicrotask(() =&gt; {</span>
                <span class="s1">window.MotionHandoffMarkAsComplete?.(optimisedAppearId);</span>
            <span class="s1">});</span>
            <span class="s1">wantsHandoff.current = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Now we've finished triggering animations for this element we</span>
         <span class="s3">* can wipe the enteringChildren set for the next render.</span>
         <span class="s3">*/</span>
        <span class="s1">visualElement.enteringChildren = undefined;</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">visualElement;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {</span>
    <span class="s2">const </span><span class="s1">{ layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;</span>
    <span class="s1">visualElement.projection = </span><span class="s2">new </span><span class="s1">ProjectionNodeConstructor(visualElement.latestValues, props[</span><span class="s0">&quot;data-framer-portal-id&quot;</span><span class="s1">]</span>
        <span class="s1">? undefined</span>
        <span class="s1">: getClosestProjectingNode(visualElement.parent));</span>
    <span class="s1">visualElement.projection.setOptions({</span>
        <span class="s1">layoutId,</span>
        <span class="s1">layout,</span>
        <span class="s1">alwaysMeasureLayout: Boolean(drag) || (dragConstraints &amp;&amp; isRefObject(dragConstraints)),</span>
        <span class="s1">visualElement,</span>
        <span class="s3">/**</span>
         <span class="s3">* TODO: Update options in an effect. This could be tricky as it'll be too late</span>
         <span class="s3">* to update by the time layout animations run.</span>
         <span class="s3">* We also need to fix this safeToRemove by linking it up to the one returned by usePresence,</span>
         <span class="s3">* ensuring it gets called if there's no potential layout animations.</span>
         <span class="s3">*</span>
         <span class="s3">*/</span>
        <span class="s1">animationType: </span><span class="s2">typeof </span><span class="s1">layout === </span><span class="s0">&quot;string&quot; </span><span class="s1">? layout : </span><span class="s0">&quot;both&quot;</span><span class="s1">,</span>
        <span class="s1">initialPromotionConfig,</span>
        <span class="s1">crossfade: layoutCrossfade,</span>
        <span class="s1">layoutScroll,</span>
        <span class="s1">layoutRoot,</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getClosestProjectingNode(visualElement) {</span>
    <span class="s2">if </span><span class="s1">(!visualElement)</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s2">return </span><span class="s1">visualElement.options.allowProjection !== </span><span class="s2">false</span>
        <span class="s1">? visualElement.projection</span>
        <span class="s1">: getClosestProjectingNode(visualElement.parent);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create a `motion` component.</span>
 <span class="s3">*</span>
 <span class="s3">* This function accepts a Component argument, which can be either a string (ie &quot;div&quot;</span>
 <span class="s3">* for `motion.div`), or an actual React component.</span>
 <span class="s3">*</span>
 <span class="s3">* Alongside this is a config option which provides a way of rendering the provided</span>
 <span class="s3">* component &quot;offline&quot;, or outside the React render cycle.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">createMotionComponent(Component, { forwardMotionProps = </span><span class="s2">false </span><span class="s1">} = {}, preloadedFeatures, createVisualElement) {</span>
    <span class="s2">const </span><span class="s1">useVisualState = isSVGComponent(Component)</span>
        <span class="s1">? useSVGVisualState</span>
        <span class="s1">: useHTMLVisualState;</span>
    <span class="s2">function </span><span class="s1">MotionDOMComponent(props, externalRef) {</span>
        <span class="s3">/**</span>
         <span class="s3">* If we need to measure the element we load this functionality in a</span>
         <span class="s3">* separate class component in order to gain access to getSnapshotBeforeUpdate.</span>
         <span class="s3">*/</span>
        <span class="s2">let </span><span class="s1">MeasureLayout;</span>
        <span class="s2">const </span><span class="s1">configAndProps = {</span>
            <span class="s1">...react.useContext(MotionConfigContext),</span>
            <span class="s1">...props,</span>
            <span class="s1">layoutId: useLayoutId(props),</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">{ isStatic } = configAndProps;</span>
        <span class="s2">const </span><span class="s1">context = useCreateMotionContext(props);</span>
        <span class="s2">const </span><span class="s1">visualState = useVisualState(props, isStatic);</span>
        <span class="s2">if </span><span class="s1">(!isStatic &amp;&amp; isBrowser) {</span>
            <span class="s1">useStrictMode(configAndProps, preloadedFeatures);</span>
            <span class="s2">const </span><span class="s1">layoutProjection = getProjectionFunctionality(configAndProps);</span>
            <span class="s1">MeasureLayout = layoutProjection.MeasureLayout;</span>
            <span class="s3">/**</span>
             <span class="s3">* Create a VisualElement for this component. A VisualElement provides a common</span>
             <span class="s3">* interface to renderer-specific APIs (ie DOM/Three.js etc) as well as</span>
             <span class="s3">* providing a way of rendering to these APIs outside of the React render loop</span>
             <span class="s3">* for more performant animations and interactions</span>
             <span class="s3">*/</span>
            <span class="s1">context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* The mount order and hierarchy is specific to ensure our element ref</span>
         <span class="s3">* is hydrated by the time features fire their effects.</span>
         <span class="s3">*/</span>
        <span class="s2">return </span><span class="s1">(jsxRuntime.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout &amp;&amp; context.visualElement ? (jsxRuntime.jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : </span><span class="s2">null</span><span class="s1">, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] }));</span>
    <span class="s1">}</span>
    <span class="s1">MotionDOMComponent.displayName = </span><span class="s0">`motion.</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">Component === </span><span class="s0">&quot;string&quot;</span>
        <span class="s1">? Component</span>
        <span class="s1">: </span><span class="s0">`create(</span><span class="s1">${Component.displayName ?? Component.name ?? </span><span class="s0">&quot;&quot;</span><span class="s1">}</span><span class="s0">)`</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">ForwardRefMotionComponent = react.forwardRef(MotionDOMComponent);</span>
    <span class="s1">ForwardRefMotionComponent[motionComponentSymbol] = Component;</span>
    <span class="s2">return </span><span class="s1">ForwardRefMotionComponent;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useLayoutId({ layoutId }) {</span>
    <span class="s2">const </span><span class="s1">layoutGroupId = react.useContext(LayoutGroupContext).id;</span>
    <span class="s2">return </span><span class="s1">layoutGroupId &amp;&amp; layoutId !== undefined</span>
        <span class="s1">? layoutGroupId + </span><span class="s0">&quot;-&quot; </span><span class="s1">+ layoutId</span>
        <span class="s1">: layoutId;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useStrictMode(configAndProps, preloadedFeatures) {</span>
    <span class="s2">const </span><span class="s1">isStrict = react.useContext(LazyContext).strict;</span>
    <span class="s3">/**</span>
     <span class="s3">* If we're in development mode, check to make sure we're not rendering a motion component</span>
     <span class="s3">* as a child of LazyMotion, as this will break the file-size benefits of using it.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">&quot;production&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">preloadedFeatures &amp;&amp;</span>
        <span class="s1">isStrict) {</span>
        <span class="s2">const </span><span class="s1">strictMessage = </span><span class="s0">&quot;You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.&quot;</span><span class="s1">;</span>
        <span class="s1">configAndProps.ignoreStrict</span>
            <span class="s1">? motionUtils.warning(</span><span class="s2">false</span><span class="s1">, strictMessage, </span><span class="s0">&quot;lazy-strict-mode&quot;</span><span class="s1">)</span>
            <span class="s1">: motionUtils.invariant(</span><span class="s2">false</span><span class="s1">, strictMessage, </span><span class="s0">&quot;lazy-strict-mode&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getProjectionFunctionality(props) {</span>
    <span class="s2">const </span><span class="s1">{ drag, layout } = featureDefinitions;</span>
    <span class="s2">if </span><span class="s1">(!drag &amp;&amp; !layout)</span>
        <span class="s2">return </span><span class="s1">{};</span>
    <span class="s2">const </span><span class="s1">combined = { ...drag, ...layout };</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)</span>
            <span class="s1">? combined.MeasureLayout</span>
            <span class="s1">: undefined,</span>
        <span class="s1">ProjectionNode: combined.ProjectionNode,</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">createMinimalMotionComponent(Component, options) {</span>
    <span class="s2">return </span><span class="s1">createMotionComponent(Component, options);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* HTML components</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">MotionA = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;a&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionAbbr = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;abbr&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionAddress = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;address&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionArea = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;area&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionArticle = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;article&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionAside = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;aside&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionAudio = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;audio&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionB = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;b&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionBase = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;base&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionBdi = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;bdi&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionBdo = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;bdo&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionBig = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;big&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionBlockquote = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;blockquote&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionBody = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionButton = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;button&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionCanvas = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;canvas&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionCaption = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;caption&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionCite = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;cite&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionCode = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;code&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionCol = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;col&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionColgroup = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;colgroup&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionData = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;data&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDatalist = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;datalist&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDd = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;dd&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDel = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;del&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDetails = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;details&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDfn = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;dfn&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDialog = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;dialog&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDiv = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;div&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDl = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;dl&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDt = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;dt&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionEm = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;em&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionEmbed = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;embed&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFieldset = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;fieldset&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFigcaption = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;figcaption&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFigure = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;figure&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFooter = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;footer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionForm = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;form&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionH1 = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;h1&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionH2 = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;h2&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionH3 = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;h3&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionH4 = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;h4&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionH5 = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;h5&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionH6 = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;h6&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionHead = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;head&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionHeader = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;header&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionHgroup = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;hgroup&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionHr = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;hr&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionHtml = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;html&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionI = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;i&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionIframe = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;iframe&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionImg = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;img&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionInput = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;input&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionIns = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;ins&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionKbd = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;kbd&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionKeygen = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;keygen&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionLabel = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;label&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionLegend = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;legend&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionLi = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;li&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionLink = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;link&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMain = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;main&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMap = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;map&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMark = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;mark&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMenu = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;menu&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMenuitem = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;menuitem&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMeter = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;meter&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionNav = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;nav&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionObject = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;object&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionOl = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;ol&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionOptgroup = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;optgroup&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionOption = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;option&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionOutput = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;output&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionP = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;p&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionParam = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;param&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionPicture = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;picture&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionPre = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;pre&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionProgress = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;progress&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionQ = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;q&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionRp = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;rp&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionRt = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;rt&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionRuby = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;ruby&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionS = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;s&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSamp = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;samp&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionScript = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;script&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSection = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;section&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSelect = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;select&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSmall = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;small&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSource = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;source&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSpan = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;span&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionStrong = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;strong&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionStyle = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;style&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSub = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;sub&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSummary = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;summary&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSup = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;sup&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTable = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;table&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTbody = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;tbody&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTd = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;td&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTextarea = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;textarea&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTfoot = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;tfoot&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTh = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;th&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionThead = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;thead&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTime = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;time&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTitle = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;title&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTr = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;tr&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTrack = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;track&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionU = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;u&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionUl = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;ul&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionVideo = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;video&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionWbr = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;wbr&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionWebview = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;webview&quot;</span><span class="s1">);</span>
<span class="s3">/**</span>
 <span class="s3">* SVG components</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">MotionAnimate = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;animate&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionCircle = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;circle&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDefs = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;defs&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionDesc = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;desc&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionEllipse = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;ellipse&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionG = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;g&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionImage = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;image&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionLine = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;line&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFilter = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;filter&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMarker = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;marker&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMask = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;mask&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionMetadata = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;metadata&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionPath = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionPattern = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;pattern&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionPolygon = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;polygon&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionPolyline = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;polyline&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionRect = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;rect&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionStop = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;stop&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSvg = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;svg&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionSymbol = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;symbol&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionText = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;text&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTspan = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;tspan&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionUse = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;use&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionView = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;view&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionClipPath = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;clipPath&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeBlend = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feBlend&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeColorMatrix = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feColorMatrix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeComponentTransfer = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feComponentTransfer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeComposite = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feComposite&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeConvolveMatrix = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feConvolveMatrix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeDiffuseLighting = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feDiffuseLighting&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeDisplacementMap = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feDisplacementMap&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeDistantLight = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feDistantLight&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeDropShadow = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feDropShadow&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeFlood = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feFlood&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeFuncA = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feFuncA&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeFuncB = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feFuncB&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeFuncG = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feFuncG&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeFuncR = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feFuncR&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeGaussianBlur = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feGaussianBlur&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeImage = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feImage&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeMerge = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feMerge&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeMergeNode = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feMergeNode&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeMorphology = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feMorphology&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeOffset = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feOffset&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFePointLight = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;fePointLight&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeSpecularLighting = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feSpecularLighting&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeSpotLight = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feSpotLight&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeTile = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feTile&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionFeTurbulence = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;feTurbulence&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionForeignObject = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;foreignObject&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionLinearGradient = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;linearGradient&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionRadialGradient = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;radialGradient&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">MotionTextPath = </span>
<span class="s3">/*@__PURE__*/ </span><span class="s1">createMinimalMotionComponent(</span><span class="s0">&quot;textPath&quot;</span><span class="s1">);</span>

<span class="s1">exports.a = MotionA;</span>
<span class="s1">exports.abbr = MotionAbbr;</span>
<span class="s1">exports.address = MotionAddress;</span>
<span class="s1">exports.animate = MotionAnimate;</span>
<span class="s1">exports.area = MotionArea;</span>
<span class="s1">exports.article = MotionArticle;</span>
<span class="s1">exports.aside = MotionAside;</span>
<span class="s1">exports.audio = MotionAudio;</span>
<span class="s1">exports.b = MotionB;</span>
<span class="s1">exports.base = MotionBase;</span>
<span class="s1">exports.bdi = MotionBdi;</span>
<span class="s1">exports.bdo = MotionBdo;</span>
<span class="s1">exports.big = MotionBig;</span>
<span class="s1">exports.blockquote = MotionBlockquote;</span>
<span class="s1">exports.body = MotionBody;</span>
<span class="s1">exports.button = MotionButton;</span>
<span class="s1">exports.canvas = MotionCanvas;</span>
<span class="s1">exports.caption = MotionCaption;</span>
<span class="s1">exports.circle = MotionCircle;</span>
<span class="s1">exports.cite = MotionCite;</span>
<span class="s1">exports.clipPath = MotionClipPath;</span>
<span class="s1">exports.code = MotionCode;</span>
<span class="s1">exports.col = MotionCol;</span>
<span class="s1">exports.colgroup = MotionColgroup;</span>
<span class="s1">exports.create = createMinimalMotionComponent;</span>
<span class="s1">exports.data = MotionData;</span>
<span class="s1">exports.datalist = MotionDatalist;</span>
<span class="s1">exports.dd = MotionDd;</span>
<span class="s1">exports.defs = MotionDefs;</span>
<span class="s1">exports.del = MotionDel;</span>
<span class="s1">exports.desc = MotionDesc;</span>
<span class="s1">exports.details = MotionDetails;</span>
<span class="s1">exports.dfn = MotionDfn;</span>
<span class="s1">exports.dialog = MotionDialog;</span>
<span class="s1">exports.div = MotionDiv;</span>
<span class="s1">exports.dl = MotionDl;</span>
<span class="s1">exports.dt = MotionDt;</span>
<span class="s1">exports.ellipse = MotionEllipse;</span>
<span class="s1">exports.em = MotionEm;</span>
<span class="s1">exports.embed = MotionEmbed;</span>
<span class="s1">exports.feBlend = MotionFeBlend;</span>
<span class="s1">exports.feColorMatrix = MotionFeColorMatrix;</span>
<span class="s1">exports.feComponentTransfer = MotionFeComponentTransfer;</span>
<span class="s1">exports.feComposite = MotionFeComposite;</span>
<span class="s1">exports.feConvolveMatrix = MotionFeConvolveMatrix;</span>
<span class="s1">exports.feDiffuseLighting = MotionFeDiffuseLighting;</span>
<span class="s1">exports.feDisplacementMap = MotionFeDisplacementMap;</span>
<span class="s1">exports.feDistantLight = MotionFeDistantLight;</span>
<span class="s1">exports.feDropShadow = MotionFeDropShadow;</span>
<span class="s1">exports.feFlood = MotionFeFlood;</span>
<span class="s1">exports.feFuncA = MotionFeFuncA;</span>
<span class="s1">exports.feFuncB = MotionFeFuncB;</span>
<span class="s1">exports.feFuncG = MotionFeFuncG;</span>
<span class="s1">exports.feFuncR = MotionFeFuncR;</span>
<span class="s1">exports.feGaussianBlur = MotionFeGaussianBlur;</span>
<span class="s1">exports.feImage = MotionFeImage;</span>
<span class="s1">exports.feMerge = MotionFeMerge;</span>
<span class="s1">exports.feMergeNode = MotionFeMergeNode;</span>
<span class="s1">exports.feMorphology = MotionFeMorphology;</span>
<span class="s1">exports.feOffset = MotionFeOffset;</span>
<span class="s1">exports.fePointLight = MotionFePointLight;</span>
<span class="s1">exports.feSpecularLighting = MotionFeSpecularLighting;</span>
<span class="s1">exports.feSpotLight = MotionFeSpotLight;</span>
<span class="s1">exports.feTile = MotionFeTile;</span>
<span class="s1">exports.feTurbulence = MotionFeTurbulence;</span>
<span class="s1">exports.fieldset = MotionFieldset;</span>
<span class="s1">exports.figcaption = MotionFigcaption;</span>
<span class="s1">exports.figure = MotionFigure;</span>
<span class="s1">exports.filter = MotionFilter;</span>
<span class="s1">exports.footer = MotionFooter;</span>
<span class="s1">exports.foreignObject = MotionForeignObject;</span>
<span class="s1">exports.form = MotionForm;</span>
<span class="s1">exports.g = MotionG;</span>
<span class="s1">exports.h1 = MotionH1;</span>
<span class="s1">exports.h2 = MotionH2;</span>
<span class="s1">exports.h3 = MotionH3;</span>
<span class="s1">exports.h4 = MotionH4;</span>
<span class="s1">exports.h5 = MotionH5;</span>
<span class="s1">exports.h6 = MotionH6;</span>
<span class="s1">exports.head = MotionHead;</span>
<span class="s1">exports.header = MotionHeader;</span>
<span class="s1">exports.hgroup = MotionHgroup;</span>
<span class="s1">exports.hr = MotionHr;</span>
<span class="s1">exports.html = MotionHtml;</span>
<span class="s1">exports.i = MotionI;</span>
<span class="s1">exports.iframe = MotionIframe;</span>
<span class="s1">exports.image = MotionImage;</span>
<span class="s1">exports.img = MotionImg;</span>
<span class="s1">exports.input = MotionInput;</span>
<span class="s1">exports.ins = MotionIns;</span>
<span class="s1">exports.kbd = MotionKbd;</span>
<span class="s1">exports.keygen = MotionKeygen;</span>
<span class="s1">exports.label = MotionLabel;</span>
<span class="s1">exports.legend = MotionLegend;</span>
<span class="s1">exports.li = MotionLi;</span>
<span class="s1">exports.line = MotionLine;</span>
<span class="s1">exports.linearGradient = MotionLinearGradient;</span>
<span class="s1">exports.link = MotionLink;</span>
<span class="s1">exports.main = MotionMain;</span>
<span class="s1">exports.map = MotionMap;</span>
<span class="s1">exports.mark = MotionMark;</span>
<span class="s1">exports.marker = MotionMarker;</span>
<span class="s1">exports.mask = MotionMask;</span>
<span class="s1">exports.menu = MotionMenu;</span>
<span class="s1">exports.menuitem = MotionMenuitem;</span>
<span class="s1">exports.metadata = MotionMetadata;</span>
<span class="s1">exports.meter = MotionMeter;</span>
<span class="s1">exports.nav = MotionNav;</span>
<span class="s1">exports.object = MotionObject;</span>
<span class="s1">exports.ol = MotionOl;</span>
<span class="s1">exports.optgroup = MotionOptgroup;</span>
<span class="s1">exports.option = MotionOption;</span>
<span class="s1">exports.output = MotionOutput;</span>
<span class="s1">exports.p = MotionP;</span>
<span class="s1">exports.param = MotionParam;</span>
<span class="s1">exports.path = MotionPath;</span>
<span class="s1">exports.pattern = MotionPattern;</span>
<span class="s1">exports.picture = MotionPicture;</span>
<span class="s1">exports.polygon = MotionPolygon;</span>
<span class="s1">exports.polyline = MotionPolyline;</span>
<span class="s1">exports.pre = MotionPre;</span>
<span class="s1">exports.progress = MotionProgress;</span>
<span class="s1">exports.q = MotionQ;</span>
<span class="s1">exports.radialGradient = MotionRadialGradient;</span>
<span class="s1">exports.rect = MotionRect;</span>
<span class="s1">exports.rp = MotionRp;</span>
<span class="s1">exports.rt = MotionRt;</span>
<span class="s1">exports.ruby = MotionRuby;</span>
<span class="s1">exports.s = MotionS;</span>
<span class="s1">exports.samp = MotionSamp;</span>
<span class="s1">exports.script = MotionScript;</span>
<span class="s1">exports.section = MotionSection;</span>
<span class="s1">exports.select = MotionSelect;</span>
<span class="s1">exports.small = MotionSmall;</span>
<span class="s1">exports.source = MotionSource;</span>
<span class="s1">exports.span = MotionSpan;</span>
<span class="s1">exports.stop = MotionStop;</span>
<span class="s1">exports.strong = MotionStrong;</span>
<span class="s1">exports.style = MotionStyle;</span>
<span class="s1">exports.sub = MotionSub;</span>
<span class="s1">exports.summary = MotionSummary;</span>
<span class="s1">exports.sup = MotionSup;</span>
<span class="s1">exports.svg = MotionSvg;</span>
<span class="s1">exports.symbol = MotionSymbol;</span>
<span class="s1">exports.table = MotionTable;</span>
<span class="s1">exports.tbody = MotionTbody;</span>
<span class="s1">exports.td = MotionTd;</span>
<span class="s1">exports.text = MotionText;</span>
<span class="s1">exports.textPath = MotionTextPath;</span>
<span class="s1">exports.textarea = MotionTextarea;</span>
<span class="s1">exports.tfoot = MotionTfoot;</span>
<span class="s1">exports.th = MotionTh;</span>
<span class="s1">exports.thead = MotionThead;</span>
<span class="s1">exports.time = MotionTime;</span>
<span class="s1">exports.title = MotionTitle;</span>
<span class="s1">exports.tr = MotionTr;</span>
<span class="s1">exports.track = MotionTrack;</span>
<span class="s1">exports.tspan = MotionTspan;</span>
<span class="s1">exports.u = MotionU;</span>
<span class="s1">exports.ul = MotionUl;</span>
<span class="s1">exports.use = MotionUse;</span>
<span class="s1">exports.video = MotionVideo;</span>
<span class="s1">exports.view = MotionView;</span>
<span class="s1">exports.wbr = MotionWbr;</span>
<span class="s1">exports.webview = MotionWebview;</span>
</pre>
</body>
</html>