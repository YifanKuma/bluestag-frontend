<html>
<head>
<title>resolve-href.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve-href.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/client/resolve-href.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { NextRouter, Url } from '../shared/lib/router/router'</span><span class="s3">\n\n</span><span class="s1">import { searchParamsToUrlQuery } from '../shared/lib/router/utils/querystring'</span><span class="s3">\n</span><span class="s1">import { formatWithValidation } from '../shared/lib/router/utils/format-url'</span><span class="s3">\n</span><span class="s1">import { omit } from '../shared/lib/router/utils/omit'</span><span class="s3">\n</span><span class="s1">import { normalizeRepeatedSlashes } from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { normalizePathTrailingSlash } from './normalize-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { isLocalURL } from '../shared/lib/router/utils/is-local-url'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import { interpolateAs } from '../shared/lib/router/utils/interpolate-as'</span><span class="s3">\n</span><span class="s1">import { getRouteRegex } from '../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Resolves a given hyperlink with a certain router state (basePath not included).</span><span class="s3">\n </span><span class="s1">* Preserves absolute urls.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function resolveHref(</span><span class="s3">\n  </span><span class="s1">router: NextRouter,</span><span class="s3">\n  </span><span class="s1">href: Url,</span><span class="s3">\n  </span><span class="s1">resolveAs: true</span><span class="s3">\n</span><span class="s1">): [string, string] | [string]</span><span class="s3">\n</span><span class="s1">export function resolveHref(</span><span class="s3">\n  </span><span class="s1">router: NextRouter,</span><span class="s3">\n  </span><span class="s1">href: Url,</span><span class="s3">\n  </span><span class="s1">resolveAs?: false</span><span class="s3">\n</span><span class="s1">): string</span><span class="s3">\n</span><span class="s1">export function resolveHref(</span><span class="s3">\n  </span><span class="s1">router: NextRouter,</span><span class="s3">\n  </span><span class="s1">href: Url,</span><span class="s3">\n  </span><span class="s1">resolveAs?: boolean</span><span class="s3">\n</span><span class="s1">): [string, string] | [string] | string {</span><span class="s3">\n  </span><span class="s1">// we use a dummy base url for relative urls</span><span class="s3">\n  </span><span class="s1">let base: URL</span><span class="s3">\n  </span><span class="s1">let urlAsString = typeof href === 'string' ? href : formatWithValidation(href)</span><span class="s3">\n\n  </span><span class="s1">// repeated slashes and backslashes in the URL are considered</span><span class="s3">\n  </span><span class="s1">// invalid and will never match a Next.js page/file</span><span class="s3">\n  </span><span class="s1">// https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1</span><span class="s3">\n  </span><span class="s1">const urlProtoMatch = urlAsString.match(/^[a-z][a-z0-9+.-]*:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//i)</span><span class="s3">\n  </span><span class="s1">const urlAsStringNoProto = urlProtoMatch</span><span class="s3">\n    </span><span class="s1">? urlAsString.slice(urlProtoMatch[0].length)</span><span class="s3">\n    </span><span class="s1">: urlAsString</span><span class="s3">\n\n  </span><span class="s1">const urlParts = urlAsStringNoProto.split('?', 1)</span><span class="s3">\n\n  </span><span class="s1">if ((urlParts[0] || '').match(/(</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/|</span><span class="s3">\\\\</span><span class="s1">)/)) {</span><span class="s3">\n    </span><span class="s1">console.error(</span><span class="s3">\n      </span><span class="s1">`Invalid href '${urlAsString}' passed to next/router in page: '${router.pathname}'. Repeated forward-slashes (//) or backslashes </span><span class="s3">\\\\ </span><span class="s1">are not valid in the href.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const normalizedUrl = normalizeRepeatedSlashes(urlAsStringNoProto)</span><span class="s3">\n    </span><span class="s1">urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Return because it cannot be routed by the Next.js router</span><span class="s3">\n  </span><span class="s1">if (!isLocalURL(urlAsString)) {</span><span class="s3">\n    </span><span class="s1">return (resolveAs ? [urlAsString] : urlAsString) as string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">let baseBase = urlAsString.startsWith('#') ? router.asPath : router.pathname</span><span class="s3">\n\n    </span><span class="s1">// If the provided href is only a query string, it is safer to use the asPath</span><span class="s3">\n    </span><span class="s1">// considering rewrites.</span><span class="s3">\n    </span><span class="s1">if (urlAsString.startsWith('?')) {</span><span class="s3">\n      </span><span class="s1">baseBase = router.asPath</span><span class="s3">\n\n      </span><span class="s1">// However, if is a dynamic route, we need to use the pathname to preserve the</span><span class="s3">\n      </span><span class="s1">// query interpolation and rewrites (router.pathname will look like </span><span class="s3">\&quot;</span><span class="s1">/[slug]</span><span class="s3">\&quot;</span><span class="s1">).</span><span class="s3">\n      </span><span class="s1">if (isDynamicRoute(router.pathname)) {</span><span class="s3">\n        </span><span class="s1">baseBase = router.pathname</span><span class="s3">\n\n        </span><span class="s1">const routeRegex = getRouteRegex(router.pathname)</span><span class="s3">\n        </span><span class="s1">const match = getRouteMatcher(routeRegex)(router.asPath)</span><span class="s3">\n\n        </span><span class="s1">// For dynamic routes, if asPath doesn't match the pathname regex, it is a rewritten path.</span><span class="s3">\n        </span><span class="s1">// In this case, should use asPath to preserve the current URL.</span><span class="s3">\n        </span><span class="s1">if (!match) {</span><span class="s3">\n          </span><span class="s1">baseBase = router.asPath</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Note: There is an edge case where the pathname is dynamic, and also a rewrite path to the same segment.</span><span class="s3">\n        </span><span class="s1">// E.g. in </span><span class="s3">\&quot;</span><span class="s1">/[slug]</span><span class="s3">\&quot; </span><span class="s1">path, rewrite </span><span class="s3">\&quot;</span><span class="s1">/foo</span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot;</span><span class="s1">/bar</span><span class="s3">\&quot;\n\n        </span><span class="s1">// In this case, it will be treated as a non-rewritten path and possibly interpolate the query string.</span><span class="s3">\n        </span><span class="s1">// E.g., </span><span class="s3">\&quot;</span><span class="s1">/any?slug=foo</span><span class="s3">\&quot; </span><span class="s1">will become the content of </span><span class="s3">\&quot;</span><span class="s1">/foo</span><span class="s3">\&quot;</span><span class="s1">, not rewritten as </span><span class="s3">\&quot;</span><span class="s1">/bar</span><span class="s3">\&quot;\n\n        </span><span class="s1">// This is currently a trade-off of not resolving rewrite paths on every Router/Link call,</span><span class="s3">\n        </span><span class="s1">// but using a lighter route regex pattern check.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">base = new URL(baseBase, 'http://n')</span><span class="s3">\n  </span><span class="s1">} catch (_) {</span><span class="s3">\n    </span><span class="s1">// fallback to / for invalid asPath values e.g. //</span><span class="s3">\n    </span><span class="s1">base = new URL('/', 'http://n')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const finalUrl = new URL(urlAsString, base)</span><span class="s3">\n    </span><span class="s1">finalUrl.pathname = normalizePathTrailingSlash(finalUrl.pathname)</span><span class="s3">\n    </span><span class="s1">let interpolatedAs = ''</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isDynamicRoute(finalUrl.pathname) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">finalUrl.searchParams &amp;&amp;</span><span class="s3">\n      </span><span class="s1">resolveAs</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const query = searchParamsToUrlQuery(finalUrl.searchParams)</span><span class="s3">\n\n      </span><span class="s1">const { result, params } = interpolateAs(</span><span class="s3">\n        </span><span class="s1">finalUrl.pathname,</span><span class="s3">\n        </span><span class="s1">finalUrl.pathname,</span><span class="s3">\n        </span><span class="s1">query</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (result) {</span><span class="s3">\n        </span><span class="s1">interpolatedAs = formatWithValidation({</span><span class="s3">\n          </span><span class="s1">pathname: result,</span><span class="s3">\n          </span><span class="s1">hash: finalUrl.hash,</span><span class="s3">\n          </span><span class="s1">query: omit(query, params),</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the origin didn't change, it means we received a relative href</span><span class="s3">\n    </span><span class="s1">const resolvedHref =</span><span class="s3">\n      </span><span class="s1">finalUrl.origin === base.origin</span><span class="s3">\n        </span><span class="s1">? finalUrl.href.slice(finalUrl.origin.length)</span><span class="s3">\n        </span><span class="s1">: finalUrl.href</span><span class="s3">\n\n    </span><span class="s1">return resolveAs</span><span class="s3">\n      </span><span class="s1">? [resolvedHref, interpolatedAs || resolvedHref]</span><span class="s3">\n      </span><span class="s1">: resolvedHref</span><span class="s3">\n  </span><span class="s1">} catch (_) {</span><span class="s3">\n    </span><span class="s1">return resolveAs ? [urlAsString] : urlAsString</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;resolveHref&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveAs&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;urlAsString&quot;</span><span class="s0">,</span><span class="s1">&quot;formatWithValidation&quot;</span><span class="s0">,</span><span class="s1">&quot;urlProtoMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;urlAsStringNoProto&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;urlParts&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRepeatedSlashes&quot;</span><span class="s0">,</span><span class="s1">&quot;isLocalURL&quot;</span><span class="s0">,</span><span class="s1">&quot;baseBase&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;asPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;routeRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;finalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePathTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolatedAs&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParamsToUrlQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolateAs&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;omit&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedHref&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>