<html>
<head>
<title>work-async-storage.external.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
work-async-storage.external.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/work-async-storage.external.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { AsyncLocalStorage } from 'async_hooks'</span><span class="s3">\n</span><span class="s1">import type { IncrementalCache } from '../lib/incremental-cache'</span><span class="s3">\n</span><span class="s1">import type { FetchMetrics } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'</span><span class="s3">\n</span><span class="s1">import type { AfterContext } from '../after/after-context'</span><span class="s3">\n</span><span class="s1">import type { CacheLife } from '../use-cache/cache-life'</span><span class="s3">\n\n</span><span class="s1">// Share the instance module in the next-shared layer</span><span class="s3">\n</span><span class="s1">import { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }</span><span class="s3">\n</span><span class="s1">import type { LazyResult } from '../lib/lazy-result'</span><span class="s3">\n\n</span><span class="s1">export interface WorkStore {</span><span class="s3">\n  </span><span class="s1">readonly isStaticGeneration: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The page that is being rendered. This relates to the path to the page file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly page: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The route that is being rendered. This is the page property without the</span><span class="s3">\n   </span><span class="s1">* trailing `/page` or `/route` suffix.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly route: string</span><span class="s3">\n\n  </span><span class="s1">readonly incrementalCache?: IncrementalCache</span><span class="s3">\n  </span><span class="s1">readonly cacheLifeProfiles?: { [profile: string]: CacheLife }</span><span class="s3">\n\n  </span><span class="s1">readonly isOnDemandRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">readonly isBuildTimePrerendering?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is true when:</span><span class="s3">\n   </span><span class="s1">* - source maps are generated</span><span class="s3">\n   </span><span class="s1">* - source maps are applied</span><span class="s3">\n   </span><span class="s1">* - minification is disabled</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly hasReadableErrorStacks?: boolean</span><span class="s3">\n\n  </span><span class="s1">readonly isRevalidate?: boolean</span><span class="s3">\n\n  </span><span class="s1">forceDynamic?: boolean</span><span class="s3">\n  </span><span class="s1">fetchCache?: AppSegmentConfig['fetchCache']</span><span class="s3">\n\n  </span><span class="s1">forceStatic?: boolean</span><span class="s3">\n  </span><span class="s1">dynamicShouldError?: boolean</span><span class="s3">\n  </span><span class="s1">pendingRevalidates?: Record&lt;string, Promise&lt;any&gt;&gt;</span><span class="s3">\n  </span><span class="s1">pendingRevalidateWrites?: Array&lt;Promise&lt;void&gt;&gt; // This is like pendingRevalidates but isn't used for deduping.</span><span class="s3">\n  </span><span class="s1">readonly afterContext: AfterContext</span><span class="s3">\n\n  </span><span class="s1">dynamicUsageDescription?: string</span><span class="s3">\n  </span><span class="s1">dynamicUsageStack?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Invalid dynamic usage errors might be caught in userland. We attach them to</span><span class="s3">\n   </span><span class="s1">* the work store to ensure we can still fail the build, or show en error in</span><span class="s3">\n   </span><span class="s1">* dev mode.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">// TODO: Collect an array of errors, and throw as AggregateError when</span><span class="s3">\n  </span><span class="s1">// `serializeError` and the Dev Overlay support it.</span><span class="s3">\n  </span><span class="s1">invalidDynamicUsageError?: Error</span><span class="s3">\n\n  </span><span class="s1">nextFetchId?: number</span><span class="s3">\n  </span><span class="s1">pathWasRevalidated?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Tags that were revalidated during the current request. They need to be sent</span><span class="s3">\n   </span><span class="s1">* to cache handlers to propagate their revalidation.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pendingRevalidatedTags?: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Tags that were previously revalidated (e.g. by a redirecting server action)</span><span class="s3">\n   </span><span class="s1">* and have already been sent to cache handlers. Retrieved cache entries that</span><span class="s3">\n   </span><span class="s1">* include any of these tags must be discarded.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly previouslyRevalidatedTags: readonly string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This map contains lazy results so that we can evaluate them when the first</span><span class="s3">\n   </span><span class="s1">* cache entry is read. It allows us to skip refreshing tags if no caches are</span><span class="s3">\n   </span><span class="s1">* read at all.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly refreshTagsByCacheKind: Map&lt;string, LazyResult&lt;void&gt;&gt;</span><span class="s3">\n\n  </span><span class="s1">fetchMetrics?: FetchMetrics</span><span class="s3">\n  </span><span class="s1">shouldTrackFetchMetrics: boolean</span><span class="s3">\n\n  </span><span class="s1">isDraftMode?: boolean</span><span class="s3">\n  </span><span class="s1">isUnstableNoStore?: boolean</span><span class="s3">\n  </span><span class="s1">isPrefetchRequest?: boolean</span><span class="s3">\n\n  </span><span class="s1">buildId: string</span><span class="s3">\n\n  </span><span class="s1">readonly reactLoadableManifest?: DeepReadonly&lt;</span><span class="s3">\n    </span><span class="s1">Record&lt;string, { files: string[] }&gt;</span><span class="s3">\n  </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">readonly assetPrefix?: string</span><span class="s3">\n\n  </span><span class="s1">cacheComponentsEnabled: boolean</span><span class="s3">\n  </span><span class="s1">dev: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Run the given function inside a clean AsyncLocalStorage snapshot. This is</span><span class="s3">\n   </span><span class="s1">* useful when generating cache entries, to ensure that the cache generation</span><span class="s3">\n   </span><span class="s1">* cannot read anything from the context we're currently executing in, which</span><span class="s3">\n   </span><span class="s1">* might include request-specific things like `cookies()` inside a</span><span class="s3">\n   </span><span class="s1">* `React.cache()`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">runInCleanSnapshot: &lt;R, TArgs extends any[]&gt;(</span><span class="s3">\n    </span><span class="s1">fn: (...args: TArgs) =&gt; R,</span><span class="s3">\n    </span><span class="s1">...args: TArgs</span><span class="s3">\n  </span><span class="s1">) =&gt; R</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type WorkAsyncStorage = AsyncLocalStorage&lt;WorkStore&gt;</span><span class="s3">\n\n</span><span class="s1">export { workAsyncStorageInstance as workAsyncStorage }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorageInstance&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAsHqCA;;;eAA5BC,kDAAwB;;;0CA7GQ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>