<html>
<head>
<title>uri.all.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
uri.all.js</font>
</center></td></tr></table>
<pre><span class="s0">/** </span><span class="s1">@license </span><span class="s0">URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */</span>
<span class="s2">(</span><span class="s3">function </span><span class="s2">(global, factory) {</span>
	<span class="s3">typeof </span><span class="s2">exports === </span><span class="s4">'object' </span><span class="s2">&amp;&amp; </span><span class="s3">typeof </span><span class="s2">module !== </span><span class="s4">'undefined' </span><span class="s2">? factory(exports) :</span>
	<span class="s3">typeof </span><span class="s2">define === </span><span class="s4">'function' </span><span class="s2">&amp;&amp; define.amd ? define([</span><span class="s4">'exports'</span><span class="s2">], factory) :</span>
	<span class="s2">(factory((global.URI = global.URI || {})));</span>
<span class="s2">}(</span><span class="s3">this</span><span class="s2">, (</span><span class="s3">function </span><span class="s2">(exports) { </span><span class="s4">'use strict'</span><span class="s2">;</span>

<span class="s3">function </span><span class="s2">merge() {</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">_len = arguments.length, sets = Array(_len), _key = </span><span class="s5">0</span><span class="s2">; _key &lt; _len; _key++) {</span>
        <span class="s2">sets[_key] = arguments[_key];</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(sets.length &gt; </span><span class="s5">1</span><span class="s2">) {</span>
        <span class="s2">sets[</span><span class="s5">0</span><span class="s2">] = sets[</span><span class="s5">0</span><span class="s2">].slice(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s3">var </span><span class="s2">xl = sets.length - </span><span class="s5">1</span><span class="s2">;</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">x = </span><span class="s5">1</span><span class="s2">; x &lt; xl; ++x) {</span>
            <span class="s2">sets[x] = sets[x].slice(</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s2">sets[xl] = sets[xl].slice(</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s3">return </span><span class="s2">sets.join(</span><span class="s4">''</span><span class="s2">);</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s2">sets[</span><span class="s5">0</span><span class="s2">];</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">subexp(str) {</span>
    <span class="s3">return </span><span class="s4">&quot;(?:&quot; </span><span class="s2">+ str + </span><span class="s4">&quot;)&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">typeOf(o) {</span>
    <span class="s3">return </span><span class="s2">o === undefined ? </span><span class="s4">&quot;undefined&quot; </span><span class="s2">: o === </span><span class="s3">null </span><span class="s2">? </span><span class="s4">&quot;null&quot; </span><span class="s2">: Object.prototype.toString.call(o).split(</span><span class="s4">&quot; &quot;</span><span class="s2">).pop().split(</span><span class="s4">&quot;]&quot;</span><span class="s2">).shift().toLowerCase();</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">toUpperCase(str) {</span>
    <span class="s3">return </span><span class="s2">str.toUpperCase();</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">toArray(obj) {</span>
    <span class="s3">return </span><span class="s2">obj !== undefined &amp;&amp; obj !== </span><span class="s3">null </span><span class="s2">? obj </span><span class="s3">instanceof </span><span class="s2">Array ? obj : </span><span class="s3">typeof </span><span class="s2">obj.length !== </span><span class="s4">&quot;number&quot; </span><span class="s2">|| obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">assign(target, source) {</span>
    <span class="s3">var </span><span class="s2">obj = target;</span>
    <span class="s3">if </span><span class="s2">(source) {</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">key </span><span class="s3">in </span><span class="s2">source) {</span>
            <span class="s2">obj[key] = source[key];</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">obj;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">buildExps(isIRI) {</span>
    <span class="s3">var </span><span class="s2">ALPHA$$ = </span><span class="s4">&quot;[A-Za-z]&quot;</span><span class="s2">,</span>
        <span class="s2">CR$ = </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">x0D]&quot;</span><span class="s2">,</span>
        <span class="s2">DIGIT$$ = </span><span class="s4">&quot;[0-9]&quot;</span><span class="s2">,</span>
        <span class="s2">DQUOTE$$ = </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">x22]&quot;</span><span class="s2">,</span>
        <span class="s2">HEXDIG$$ = merge(DIGIT$$, </span><span class="s4">&quot;[A-Fa-f]&quot;</span><span class="s2">),</span>
        <span class="s0">//case-insensitive</span>
    <span class="s2">LF$$ = </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">x0A]&quot;</span><span class="s2">,</span>
        <span class="s2">SP$$ = </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">x20]&quot;</span><span class="s2">,</span>
        <span class="s2">PCT_ENCODED$ = subexp(subexp(</span><span class="s4">&quot;%[EFef]&quot; </span><span class="s2">+ HEXDIG$$ + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ HEXDIG$$ + HEXDIG$$ + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;%[89A-Fa-f]&quot; </span><span class="s2">+ HEXDIG$$ + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;%&quot; </span><span class="s2">+ HEXDIG$$ + HEXDIG$$)),</span>
        <span class="s0">//expanded</span>
    <span class="s2">GEN_DELIMS$$ = </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">?</span><span class="s6">\\</span><span class="s4">#</span><span class="s6">\\</span><span class="s4">[</span><span class="s6">\\</span><span class="s4">]</span><span class="s6">\\</span><span class="s4">@]&quot;</span><span class="s2">,</span>
        <span class="s2">SUB_DELIMS$$ = </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">!</span><span class="s6">\\</span><span class="s4">$</span><span class="s6">\\</span><span class="s4">&amp;</span><span class="s6">\\</span><span class="s4">'</span><span class="s6">\\</span><span class="s4">(</span><span class="s6">\\</span><span class="s4">)</span><span class="s6">\\</span><span class="s4">*</span><span class="s6">\\</span><span class="s4">+</span><span class="s6">\\</span><span class="s4">,</span><span class="s6">\\</span><span class="s4">;</span><span class="s6">\\</span><span class="s4">=]&quot;</span><span class="s2">,</span>
        <span class="s2">RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),</span>
        <span class="s2">UCSCHAR$$ = isIRI ? </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">xA0-</span><span class="s6">\\</span><span class="s4">u200D</span><span class="s6">\\</span><span class="s4">u2010-</span><span class="s6">\\</span><span class="s4">u2029</span><span class="s6">\\</span><span class="s4">u202F-</span><span class="s6">\\</span><span class="s4">uD7FF</span><span class="s6">\\</span><span class="s4">uF900-</span><span class="s6">\\</span><span class="s4">uFDCF</span><span class="s6">\\</span><span class="s4">uFDF0-</span><span class="s6">\\</span><span class="s4">uFFEF]&quot; </span><span class="s2">: </span><span class="s4">&quot;[]&quot;</span><span class="s2">,</span>
        <span class="s0">//subset, excludes bidi control characters</span>
    <span class="s2">IPRIVATE$$ = isIRI ? </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">uE000-</span><span class="s6">\\</span><span class="s4">uF8FF]&quot; </span><span class="s2">: </span><span class="s4">&quot;[]&quot;</span><span class="s2">,</span>
        <span class="s0">//subset</span>
    <span class="s2">UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">-</span><span class="s6">\\</span><span class="s4">.</span><span class="s6">\\</span><span class="s4">_</span><span class="s6">\\</span><span class="s4">~]&quot;</span><span class="s2">, UCSCHAR$$),</span>
        <span class="s2">SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">+</span><span class="s6">\\</span><span class="s4">-</span><span class="s6">\\</span><span class="s4">.]&quot;</span><span class="s2">) + </span><span class="s4">&quot;*&quot;</span><span class="s2">),</span>
        <span class="s2">USERINFO$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">:]&quot;</span><span class="s2">)) + </span><span class="s4">&quot;*&quot;</span><span class="s2">),</span>
        <span class="s2">DEC_OCTET$ = subexp(subexp(</span><span class="s4">&quot;25[0-5]&quot;</span><span class="s2">) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;2[0-4]&quot; </span><span class="s2">+ DIGIT$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;1&quot; </span><span class="s2">+ DIGIT$$ + DIGIT$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;[1-9]&quot; </span><span class="s2">+ DIGIT$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ DIGIT$$),</span>
        <span class="s2">DEC_OCTET_RELAXED$ = subexp(subexp(</span><span class="s4">&quot;25[0-5]&quot;</span><span class="s2">) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;2[0-4]&quot; </span><span class="s2">+ DIGIT$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;1&quot; </span><span class="s2">+ DIGIT$$ + DIGIT$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;0?[1-9]&quot; </span><span class="s2">+ DIGIT$$) + </span><span class="s4">&quot;|0?0?&quot; </span><span class="s2">+ DIGIT$$),</span>
        <span class="s0">//relaxed parsing rules</span>
    <span class="s2">IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">.&quot; </span><span class="s2">+ DEC_OCTET_RELAXED$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">.&quot; </span><span class="s2">+ DEC_OCTET_RELAXED$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">.&quot; </span><span class="s2">+ DEC_OCTET_RELAXED$),</span>
        <span class="s2">H16$ = subexp(HEXDIG$$ + </span><span class="s4">&quot;{1,4}&quot;</span><span class="s2">),</span>
        <span class="s2">LS32$ = subexp(subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ H16$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ IPV4ADDRESS$),</span>
        <span class="s2">IPV6ADDRESS1$ = subexp(subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{6}&quot; </span><span class="s2">+ LS32$),</span>
        <span class="s0">//                           6( h16 &quot;:&quot; ) ls32</span>
    <span class="s2">IPV6ADDRESS2$ = subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{5}&quot; </span><span class="s2">+ LS32$),</span>
        <span class="s0">//                      &quot;::&quot; 5( h16 &quot;:&quot; ) ls32</span>
    <span class="s2">IPV6ADDRESS3$ = subexp(subexp(H16$) + </span><span class="s4">&quot;?</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{4}&quot; </span><span class="s2">+ LS32$),</span>
        <span class="s0">//[               h16 ] &quot;::&quot; 4( h16 &quot;:&quot; ) ls32</span>
    <span class="s2">IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{0,1}&quot; </span><span class="s2">+ H16$) + </span><span class="s4">&quot;?</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{3}&quot; </span><span class="s2">+ LS32$),</span>
        <span class="s0">//[ *1( h16 &quot;:&quot; ) h16 ] &quot;::&quot; 3( h16 &quot;:&quot; ) ls32</span>
    <span class="s2">IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{0,2}&quot; </span><span class="s2">+ H16$) + </span><span class="s4">&quot;?</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{2}&quot; </span><span class="s2">+ LS32$),</span>
        <span class="s0">//[ *2( h16 &quot;:&quot; ) h16 ] &quot;::&quot; 2( h16 &quot;:&quot; ) ls32</span>
    <span class="s2">IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{0,3}&quot; </span><span class="s2">+ H16$) + </span><span class="s4">&quot;?</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ LS32$),</span>
        <span class="s0">//[ *3( h16 &quot;:&quot; ) h16 ] &quot;::&quot;    h16 &quot;:&quot;   ls32</span>
    <span class="s2">IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{0,4}&quot; </span><span class="s2">+ H16$) + </span><span class="s4">&quot;?</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ LS32$),</span>
        <span class="s0">//[ *4( h16 &quot;:&quot; ) h16 ] &quot;::&quot;              ls32</span>
    <span class="s2">IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{0,5}&quot; </span><span class="s2">+ H16$) + </span><span class="s4">&quot;?</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ H16$),</span>
        <span class="s0">//[ *5( h16 &quot;:&quot; ) h16 ] &quot;::&quot;              h16</span>
    <span class="s2">IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">) + </span><span class="s4">&quot;{0,6}&quot; </span><span class="s2">+ H16$) + </span><span class="s4">&quot;?</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">:&quot;</span><span class="s2">),</span>
        <span class="s0">//[ *6( h16 &quot;:&quot; ) h16 ] &quot;::&quot;</span>
    <span class="s2">IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(</span><span class="s4">&quot;|&quot;</span><span class="s2">)),</span>
        <span class="s2">ZONEID$ = subexp(subexp(UNRESERVED$$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PCT_ENCODED$) + </span><span class="s4">&quot;+&quot;</span><span class="s2">),</span>
        <span class="s0">//RFC 6874</span>
    <span class="s2">IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">%25&quot; </span><span class="s2">+ ZONEID$),</span>
        <span class="s0">//RFC 6874</span>
    <span class="s2">IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">%25|</span><span class="s6">\\</span><span class="s4">%(?!&quot; </span><span class="s2">+ HEXDIG$$ + </span><span class="s4">&quot;{2})&quot;</span><span class="s2">) + ZONEID$),</span>
        <span class="s0">//RFC 6874, with relaxed parsing rules</span>
    <span class="s2">IPVFUTURE$ = subexp(</span><span class="s4">&quot;[vV]&quot; </span><span class="s2">+ HEXDIG$$ + </span><span class="s4">&quot;+</span><span class="s6">\\</span><span class="s4">.&quot; </span><span class="s2">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">:]&quot;</span><span class="s2">) + </span><span class="s4">&quot;+&quot;</span><span class="s2">),</span>
        <span class="s2">IP_LITERAL$ = subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">[&quot; </span><span class="s2">+ subexp(IPV6ADDRZ_RELAXED$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ IPV6ADDRESS$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ IPVFUTURE$) + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">]&quot;</span><span class="s2">),</span>
        <span class="s0">//RFC 6874</span>
    <span class="s2">REG_NAME$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ merge(UNRESERVED$$, SUB_DELIMS$$)) + </span><span class="s4">&quot;*&quot;</span><span class="s2">),</span>
        <span class="s2">HOST$ = subexp(IP_LITERAL$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ IPV4ADDRESS$ + </span><span class="s4">&quot;(?!&quot; </span><span class="s2">+ REG_NAME$ + </span><span class="s4">&quot;)&quot; </span><span class="s2">+ </span><span class="s4">&quot;|&quot; </span><span class="s2">+ REG_NAME$),</span>
        <span class="s2">PORT$ = subexp(DIGIT$$ + </span><span class="s4">&quot;*&quot;</span><span class="s2">),</span>
        <span class="s2">AUTHORITY$ = subexp(subexp(USERINFO$ + </span><span class="s4">&quot;@&quot;</span><span class="s2">) + </span><span class="s4">&quot;?&quot; </span><span class="s2">+ HOST$ + subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ PORT$) + </span><span class="s4">&quot;?&quot;</span><span class="s2">),</span>
        <span class="s2">PCHAR$ = subexp(PCT_ENCODED$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">@]&quot;</span><span class="s2">)),</span>
        <span class="s2">SEGMENT$ = subexp(PCHAR$ + </span><span class="s4">&quot;*&quot;</span><span class="s2">),</span>
        <span class="s2">SEGMENT_NZ$ = subexp(PCHAR$ + </span><span class="s4">&quot;+&quot;</span><span class="s2">),</span>
        <span class="s2">SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">@]&quot;</span><span class="s2">)) + </span><span class="s4">&quot;+&quot;</span><span class="s2">),</span>
        <span class="s2">PATH_ABEMPTY$ = subexp(subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">/&quot; </span><span class="s2">+ SEGMENT$) + </span><span class="s4">&quot;*&quot;</span><span class="s2">),</span>
        <span class="s2">PATH_ABSOLUTE$ = subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">/&quot; </span><span class="s2">+ subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + </span><span class="s4">&quot;?&quot;</span><span class="s2">),</span>
        <span class="s0">//simplified</span>
    <span class="s2">PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),</span>
        <span class="s0">//simplified</span>
    <span class="s2">PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),</span>
        <span class="s0">//simplified</span>
    <span class="s2">PATH_EMPTY$ = </span><span class="s4">&quot;(?!&quot; </span><span class="s2">+ PCHAR$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">,</span>
        <span class="s2">PATH$ = subexp(PATH_ABEMPTY$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ABSOLUTE$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_NOSCHEME$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ROOTLESS$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_EMPTY$),</span>
        <span class="s2">QUERY$ = subexp(subexp(PCHAR$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ merge(</span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">?]&quot;</span><span class="s2">, IPRIVATE$$)) + </span><span class="s4">&quot;*&quot;</span><span class="s2">),</span>
        <span class="s2">FRAGMENT$ = subexp(subexp(PCHAR$ + </span><span class="s4">&quot;|[</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">?]&quot;</span><span class="s2">) + </span><span class="s4">&quot;*&quot;</span><span class="s2">),</span>
        <span class="s2">HIER_PART$ = subexp(subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">/&quot; </span><span class="s2">+ AUTHORITY$ + PATH_ABEMPTY$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ABSOLUTE$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ROOTLESS$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_EMPTY$),</span>
        <span class="s2">URI$ = subexp(SCHEME$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ HIER_PART$ + subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">?&quot; </span><span class="s2">+ QUERY$) + </span><span class="s4">&quot;?&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">#&quot; </span><span class="s2">+ FRAGMENT$) + </span><span class="s4">&quot;?&quot;</span><span class="s2">),</span>
        <span class="s2">RELATIVE_PART$ = subexp(subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">/&quot; </span><span class="s2">+ AUTHORITY$ + PATH_ABEMPTY$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ABSOLUTE$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_NOSCHEME$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_EMPTY$),</span>
        <span class="s2">RELATIVE$ = subexp(RELATIVE_PART$ + subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">?&quot; </span><span class="s2">+ QUERY$) + </span><span class="s4">&quot;?&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">#&quot; </span><span class="s2">+ FRAGMENT$) + </span><span class="s4">&quot;?&quot;</span><span class="s2">),</span>
        <span class="s2">URI_REFERENCE$ = subexp(URI$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ RELATIVE$),</span>
        <span class="s2">ABSOLUTE_URI$ = subexp(SCHEME$ + </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ HIER_PART$ + subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">?&quot; </span><span class="s2">+ QUERY$) + </span><span class="s4">&quot;?&quot;</span><span class="s2">),</span>
        <span class="s2">GENERIC_REF$ = </span><span class="s4">&quot;^(&quot; </span><span class="s2">+ SCHEME$ + </span><span class="s4">&quot;)</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ subexp(subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">/(&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;(&quot; </span><span class="s2">+ USERINFO$ + </span><span class="s4">&quot;)@&quot;</span><span class="s2">) + </span><span class="s4">&quot;?(&quot; </span><span class="s2">+ HOST$ + </span><span class="s4">&quot;)&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:(&quot; </span><span class="s2">+ PORT$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?(&quot; </span><span class="s2">+ PATH_ABEMPTY$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ABSOLUTE$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ROOTLESS$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_EMPTY$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">?(&quot; </span><span class="s2">+ QUERY$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">#(&quot; </span><span class="s2">+ FRAGMENT$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?$&quot;</span><span class="s2">,</span>
        <span class="s2">RELATIVE_REF$ = </span><span class="s4">&quot;^(){0}&quot; </span><span class="s2">+ subexp(subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">/(&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;(&quot; </span><span class="s2">+ USERINFO$ + </span><span class="s4">&quot;)@&quot;</span><span class="s2">) + </span><span class="s4">&quot;?(&quot; </span><span class="s2">+ HOST$ + </span><span class="s4">&quot;)&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:(&quot; </span><span class="s2">+ PORT$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?(&quot; </span><span class="s2">+ PATH_ABEMPTY$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ABSOLUTE$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_NOSCHEME$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_EMPTY$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">?(&quot; </span><span class="s2">+ QUERY$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">#(&quot; </span><span class="s2">+ FRAGMENT$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?$&quot;</span><span class="s2">,</span>
        <span class="s2">ABSOLUTE_REF$ = </span><span class="s4">&quot;^(&quot; </span><span class="s2">+ SCHEME$ + </span><span class="s4">&quot;)</span><span class="s6">\\</span><span class="s4">:&quot; </span><span class="s2">+ subexp(subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">/(&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;(&quot; </span><span class="s2">+ USERINFO$ + </span><span class="s4">&quot;)@&quot;</span><span class="s2">) + </span><span class="s4">&quot;?(&quot; </span><span class="s2">+ HOST$ + </span><span class="s4">&quot;)&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:(&quot; </span><span class="s2">+ PORT$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?(&quot; </span><span class="s2">+ PATH_ABEMPTY$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ABSOLUTE$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_ROOTLESS$ + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ PATH_EMPTY$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">?(&quot; </span><span class="s2">+ QUERY$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?$&quot;</span><span class="s2">,</span>
        <span class="s2">SAMEDOC_REF$ = </span><span class="s4">&quot;^&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">#(&quot; </span><span class="s2">+ FRAGMENT$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?$&quot;</span><span class="s2">,</span>
        <span class="s2">AUTHORITY_REF$ = </span><span class="s4">&quot;^&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;(&quot; </span><span class="s2">+ USERINFO$ + </span><span class="s4">&quot;)@&quot;</span><span class="s2">) + </span><span class="s4">&quot;?(&quot; </span><span class="s2">+ HOST$ + </span><span class="s4">&quot;)&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">:(&quot; </span><span class="s2">+ PORT$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?$&quot;</span><span class="s2">;</span>
    <span class="s3">return </span><span class="s2">{</span>
        <span class="s2">NOT_SCHEME: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^]&quot;</span><span class="s2">, ALPHA$$, DIGIT$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">+</span><span class="s6">\\</span><span class="s4">-</span><span class="s6">\\</span><span class="s4">.]&quot;</span><span class="s2">), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">NOT_USERINFO: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^</span><span class="s6">\\</span><span class="s4">%</span><span class="s6">\\</span><span class="s4">:]&quot;</span><span class="s2">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">NOT_HOST: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^</span><span class="s6">\\</span><span class="s4">%</span><span class="s6">\\</span><span class="s4">[</span><span class="s6">\\</span><span class="s4">]</span><span class="s6">\\</span><span class="s4">:]&quot;</span><span class="s2">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">NOT_PATH: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^</span><span class="s6">\\</span><span class="s4">%</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">@]&quot;</span><span class="s2">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">NOT_PATH_NOSCHEME: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^</span><span class="s6">\\</span><span class="s4">%</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">@]&quot;</span><span class="s2">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">NOT_QUERY: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^</span><span class="s6">\\</span><span class="s4">%]&quot;</span><span class="s2">, UNRESERVED$$, SUB_DELIMS$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">@</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">?]&quot;</span><span class="s2">, IPRIVATE$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">NOT_FRAGMENT: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^</span><span class="s6">\\</span><span class="s4">%]&quot;</span><span class="s2">, UNRESERVED$$, SUB_DELIMS$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">@</span><span class="s6">\\</span><span class="s4">/</span><span class="s6">\\</span><span class="s4">?]&quot;</span><span class="s2">), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">ESCAPE: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^]&quot;</span><span class="s2">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">UNRESERVED: </span><span class="s3">new </span><span class="s2">RegExp(UNRESERVED$$, </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">OTHER_CHARS: </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^</span><span class="s6">\\</span><span class="s4">%]&quot;</span><span class="s2">, UNRESERVED$$, RESERVED$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">PCT_ENCODED: </span><span class="s3">new </span><span class="s2">RegExp(PCT_ENCODED$, </span><span class="s4">&quot;g&quot;</span><span class="s2">),</span>
        <span class="s2">IPV4ADDRESS: </span><span class="s3">new </span><span class="s2">RegExp(</span><span class="s4">&quot;^(&quot; </span><span class="s2">+ IPV4ADDRESS$ + </span><span class="s4">&quot;)$&quot;</span><span class="s2">),</span>
        <span class="s2">IPV6ADDRESS: </span><span class="s3">new </span><span class="s2">RegExp(</span><span class="s4">&quot;^</span><span class="s6">\\</span><span class="s4">[?(&quot; </span><span class="s2">+ IPV6ADDRESS$ + </span><span class="s4">&quot;)&quot; </span><span class="s2">+ subexp(subexp(</span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">%25|</span><span class="s6">\\</span><span class="s4">%(?!&quot; </span><span class="s2">+ HEXDIG$$ + </span><span class="s4">&quot;{2})&quot;</span><span class="s2">) + </span><span class="s4">&quot;(&quot; </span><span class="s2">+ ZONEID$ + </span><span class="s4">&quot;)&quot;</span><span class="s2">) + </span><span class="s4">&quot;?</span><span class="s6">\\</span><span class="s4">]?$&quot;</span><span class="s2">) </span><span class="s0">//RFC 6874, with relaxed parsing rules</span>
    <span class="s2">};</span>
<span class="s2">}</span>
<span class="s3">var </span><span class="s2">URI_PROTOCOL = buildExps(</span><span class="s3">false</span><span class="s2">);</span>

<span class="s3">var </span><span class="s2">IRI_PROTOCOL = buildExps(</span><span class="s3">true</span><span class="s2">);</span>

<span class="s3">var </span><span class="s2">slicedToArray = </span><span class="s3">function </span><span class="s2">() {</span>
  <span class="s3">function </span><span class="s2">sliceIterator(arr, i) {</span>
    <span class="s3">var </span><span class="s2">_arr = [];</span>
    <span class="s3">var </span><span class="s2">_n = </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s2">_d = </span><span class="s3">false</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s2">_e = undefined;</span>

    <span class="s3">try </span><span class="s2">{</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">_i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = </span><span class="s3">true</span><span class="s2">) {</span>
        <span class="s2">_arr.push(_s.value);</span>

        <span class="s3">if </span><span class="s2">(i &amp;&amp; _arr.length === i) </span><span class="s3">break</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s3">catch </span><span class="s2">(err) {</span>
      <span class="s2">_d = </span><span class="s3">true</span><span class="s2">;</span>
      <span class="s2">_e = err;</span>
    <span class="s2">} </span><span class="s3">finally </span><span class="s2">{</span>
      <span class="s3">try </span><span class="s2">{</span>
        <span class="s3">if </span><span class="s2">(!_n &amp;&amp; _i[</span><span class="s4">&quot;return&quot;</span><span class="s2">]) _i[</span><span class="s4">&quot;return&quot;</span><span class="s2">]();</span>
      <span class="s2">} </span><span class="s3">finally </span><span class="s2">{</span>
        <span class="s3">if </span><span class="s2">(_d) </span><span class="s3">throw </span><span class="s2">_e;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">_arr;</span>
  <span class="s2">}</span>

  <span class="s3">return function </span><span class="s2">(arr, i) {</span>
    <span class="s3">if </span><span class="s2">(Array.isArray(arr)) {</span>
      <span class="s3">return </span><span class="s2">arr;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(Symbol.iterator </span><span class="s3">in </span><span class="s2">Object(arr)) {</span>
      <span class="s3">return </span><span class="s2">sliceIterator(arr, i);</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">throw new </span><span class="s2">TypeError(</span><span class="s4">&quot;Invalid attempt to destructure non-iterable instance&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s2">}();</span>













<span class="s3">var </span><span class="s2">toConsumableArray = </span><span class="s3">function </span><span class="s2">(arr) {</span>
  <span class="s3">if </span><span class="s2">(Array.isArray(arr)) {</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">, arr2 = Array(arr.length); i &lt; arr.length; i++) arr2[i] = arr[i];</span>

    <span class="s3">return </span><span class="s2">arr2;</span>
  <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
    <span class="s3">return </span><span class="s2">Array.from(arr);</span>
  <span class="s2">}</span>
<span class="s2">};</span>

<span class="s0">/** Highest positive signed 32-bit float value */</span>

<span class="s3">var </span><span class="s2">maxInt = </span><span class="s5">2147483647</span><span class="s2">; </span><span class="s0">// aka. 0x7FFFFFFF or 2^31-1</span>

<span class="s0">/** Bootstring parameters */</span>
<span class="s3">var </span><span class="s2">base = </span><span class="s5">36</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">tMin = </span><span class="s5">1</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">tMax = </span><span class="s5">26</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">skew = </span><span class="s5">38</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">damp = </span><span class="s5">700</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">initialBias = </span><span class="s5">72</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">initialN = </span><span class="s5">128</span><span class="s2">; </span><span class="s0">// 0x80</span>
<span class="s3">var </span><span class="s2">delimiter = </span><span class="s4">'-'</span><span class="s2">; </span><span class="s0">// '\x2D'</span>

<span class="s0">/** Regular expressions */</span>
<span class="s3">var </span><span class="s2">regexPunycode = </span><span class="s7">/^xn--/</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">regexNonASCII = </span><span class="s7">/[^\0-\x7E]/</span><span class="s2">; </span><span class="s0">// non-ASCII chars</span>
<span class="s3">var </span><span class="s2">regexSeparators = </span><span class="s7">/[\x2E\u3002\uFF0E\uFF61]/g</span><span class="s2">; </span><span class="s0">// RFC 3490 separators</span>

<span class="s0">/** Error messages */</span>
<span class="s3">var </span><span class="s2">errors = {</span>
	<span class="s4">'overflow'</span><span class="s2">: </span><span class="s4">'Overflow: input needs wider integers to process'</span><span class="s2">,</span>
	<span class="s4">'not-basic'</span><span class="s2">: </span><span class="s4">'Illegal input &gt;= 0x80 (not a basic code point)'</span><span class="s2">,</span>
	<span class="s4">'invalid-input'</span><span class="s2">: </span><span class="s4">'Invalid input'</span>
<span class="s2">};</span>

<span class="s0">/** Convenience shortcuts */</span>
<span class="s3">var </span><span class="s2">baseMinusTMin = base - tMin;</span>
<span class="s3">var </span><span class="s2">floor = Math.floor;</span>
<span class="s3">var </span><span class="s2">stringFromCharCode = String.fromCharCode;</span>

<span class="s0">/*--------------------------------------------------------------------------*/</span>

<span class="s0">/**</span>
 <span class="s0">* A generic error utility function.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{String} type The error type.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Error} Throws a `RangeError` with the applicable error message.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">error$1(type) {</span>
	<span class="s3">throw new </span><span class="s2">RangeError(errors[type]);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* A generic `Array#map` utility function.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array} array The array to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback The function that gets called for every array</span>
 <span class="s0">* item.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array} A new array of values returned by the callback function.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">map(array, fn) {</span>
	<span class="s3">var </span><span class="s2">result = [];</span>
	<span class="s3">var </span><span class="s2">length = array.length;</span>
	<span class="s3">while </span><span class="s2">(length--) {</span>
		<span class="s2">result[length] = fn(array[length]);</span>
	<span class="s2">}</span>
	<span class="s3">return </span><span class="s2">result;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* A simple `Array#map`-like wrapper to work with domain name strings or email</span>
 <span class="s0">* addresses.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{String} domain The domain name or email address.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback The function that gets called for every</span>
 <span class="s0">* character.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array} A new string of characters returned by the callback</span>
 <span class="s0">* function.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mapDomain(string, fn) {</span>
	<span class="s3">var </span><span class="s2">parts = string.split(</span><span class="s4">'@'</span><span class="s2">);</span>
	<span class="s3">var </span><span class="s2">result = </span><span class="s4">''</span><span class="s2">;</span>
	<span class="s3">if </span><span class="s2">(parts.length &gt; </span><span class="s5">1</span><span class="s2">) {</span>
		<span class="s0">// In email addresses, only the domain name should be punycoded. Leave</span>
		<span class="s0">// the local part (i.e. everything up to `@`) intact.</span>
		<span class="s2">result = parts[</span><span class="s5">0</span><span class="s2">] + </span><span class="s4">'@'</span><span class="s2">;</span>
		<span class="s2">string = parts[</span><span class="s5">1</span><span class="s2">];</span>
	<span class="s2">}</span>
	<span class="s0">// Avoid `split(regex)` for IE8 compatibility. See #17.</span>
	<span class="s2">string = string.replace(regexSeparators, </span><span class="s4">'</span><span class="s6">\x2E</span><span class="s4">'</span><span class="s2">);</span>
	<span class="s3">var </span><span class="s2">labels = string.split(</span><span class="s4">'.'</span><span class="s2">);</span>
	<span class="s3">var </span><span class="s2">encoded = map(labels, fn).join(</span><span class="s4">'.'</span><span class="s2">);</span>
	<span class="s3">return </span><span class="s2">result + encoded;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an array containing the numeric code points of each Unicode</span>
 <span class="s0">* character in the string. While JavaScript uses UCS-2 internally,</span>
 <span class="s0">* this function will convert a pair of surrogate halves (each of which</span>
 <span class="s0">* UCS-2 exposes as separate characters) into a single code point,</span>
 <span class="s0">* matching UTF-16.</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">`punycode.ucs2.encode`</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">&lt;https://mathiasbynens.be/notes/javascript-encoding&gt;</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">punycode.ucs2</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">decode</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{String} string The Unicode input string (UCS-2).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array} The new array of code points.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">ucs2decode(string) {</span>
	<span class="s3">var </span><span class="s2">output = [];</span>
	<span class="s3">var </span><span class="s2">counter = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s3">var </span><span class="s2">length = string.length;</span>
	<span class="s3">while </span><span class="s2">(counter &lt; length) {</span>
		<span class="s3">var </span><span class="s2">value = string.charCodeAt(counter++);</span>
		<span class="s3">if </span><span class="s2">(value &gt;= </span><span class="s5">0xD800 </span><span class="s2">&amp;&amp; value &lt;= </span><span class="s5">0xDBFF </span><span class="s2">&amp;&amp; counter &lt; length) {</span>
			<span class="s0">// It's a high surrogate, and there is a next character.</span>
			<span class="s3">var </span><span class="s2">extra = string.charCodeAt(counter++);</span>
			<span class="s3">if </span><span class="s2">((extra &amp; </span><span class="s5">0xFC00</span><span class="s2">) == </span><span class="s5">0xDC00</span><span class="s2">) {</span>
				<span class="s0">// Low surrogate.</span>
				<span class="s2">output.push(((value &amp; </span><span class="s5">0x3FF</span><span class="s2">) &lt;&lt; </span><span class="s5">10</span><span class="s2">) + (extra &amp; </span><span class="s5">0x3FF</span><span class="s2">) + </span><span class="s5">0x10000</span><span class="s2">);</span>
			<span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
				<span class="s0">// It's an unmatched surrogate; only append this code unit, in case the</span>
				<span class="s0">// next code unit is the high surrogate of a surrogate pair.</span>
				<span class="s2">output.push(value);</span>
				<span class="s2">counter--;</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
			<span class="s2">output.push(value);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>
	<span class="s3">return </span><span class="s2">output;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a string based on an array of numeric code points.</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">`punycode.ucs2.decode`</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">punycode.ucs2</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">encode</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array} codePoints The array of numeric code points.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{String} The new Unicode string (UCS-2).</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">ucs2encode = </span><span class="s3">function </span><span class="s2">ucs2encode(array) {</span>
	<span class="s3">return </span><span class="s2">String.fromCodePoint.apply(String, toConsumableArray(array));</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a basic code point into a digit/integer.</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">`digitToBasic()`</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Number} codePoint The basic numeric code point value.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Number} The numeric value of a basic code point (for use in</span>
 <span class="s0">* representing integers) in the range `0` to `base - 1`, or `base` if</span>
 <span class="s0">* the code point does not represent a value.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">basicToDigit = </span><span class="s3">function </span><span class="s2">basicToDigit(codePoint) {</span>
	<span class="s3">if </span><span class="s2">(codePoint - </span><span class="s5">0x30 </span><span class="s2">&lt; </span><span class="s5">0x0A</span><span class="s2">) {</span>
		<span class="s3">return </span><span class="s2">codePoint - </span><span class="s5">0x16</span><span class="s2">;</span>
	<span class="s2">}</span>
	<span class="s3">if </span><span class="s2">(codePoint - </span><span class="s5">0x41 </span><span class="s2">&lt; </span><span class="s5">0x1A</span><span class="s2">) {</span>
		<span class="s3">return </span><span class="s2">codePoint - </span><span class="s5">0x41</span><span class="s2">;</span>
	<span class="s2">}</span>
	<span class="s3">if </span><span class="s2">(codePoint - </span><span class="s5">0x61 </span><span class="s2">&lt; </span><span class="s5">0x1A</span><span class="s2">) {</span>
		<span class="s3">return </span><span class="s2">codePoint - </span><span class="s5">0x61</span><span class="s2">;</span>
	<span class="s2">}</span>
	<span class="s3">return </span><span class="s2">base;</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a digit/integer into a basic code point.</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">`basicToDigit()`</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Number} digit The numeric value of a basic code point.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Number} The basic code point whose value (when used for</span>
 <span class="s0">* representing integers) is `digit`, which needs to be in the range</span>
 <span class="s0">* `0` to `base - 1`. If `flag` is non-zero, the uppercase form is</span>
 <span class="s0">* used; else, the lowercase form is used. The behavior is undefined</span>
 <span class="s0">* if `flag` is non-zero and `digit` has no uppercase form.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">digitToBasic = </span><span class="s3">function </span><span class="s2">digitToBasic(digit, flag) {</span>
	<span class="s0">//  0..25 map to ASCII a..z or A..Z</span>
	<span class="s0">// 26..35 map to ASCII 0..9</span>
	<span class="s3">return </span><span class="s2">digit + </span><span class="s5">22 </span><span class="s2">+ </span><span class="s5">75 </span><span class="s2">* (digit &lt; </span><span class="s5">26</span><span class="s2">) - ((flag != </span><span class="s5">0</span><span class="s2">) &lt;&lt; </span><span class="s5">5</span><span class="s2">);</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Bias adaptation function as per section 3.4 of RFC 3492.</span>
 <span class="s0">* https://tools.ietf.org/html/rfc3492#section-3.4</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">adapt = </span><span class="s3">function </span><span class="s2">adapt(delta, numPoints, firstTime) {</span>
	<span class="s3">var </span><span class="s2">k = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s2">delta = firstTime ? floor(delta / damp) : delta &gt;&gt; </span><span class="s5">1</span><span class="s2">;</span>
	<span class="s2">delta += floor(delta / numPoints);</span>
	<span class="s3">for </span><span class="s2">(; </span><span class="s0">/* no initialization */</span><span class="s2">delta &gt; baseMinusTMin * tMax &gt;&gt; </span><span class="s5">1</span><span class="s2">; k += base) {</span>
		<span class="s2">delta = floor(delta / baseMinusTMin);</span>
	<span class="s2">}</span>
	<span class="s3">return </span><span class="s2">floor(k + (baseMinusTMin + </span><span class="s5">1</span><span class="s2">) * delta / (delta + skew));</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a Punycode string of ASCII-only symbols to a string of Unicode</span>
 <span class="s0">* symbols.</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">punycode</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{String} input The Punycode string of ASCII-only symbols.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{String} The resulting string of Unicode symbols.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">decode = </span><span class="s3">function </span><span class="s2">decode(input) {</span>
	<span class="s0">// Don't use UCS-2.</span>
	<span class="s3">var </span><span class="s2">output = [];</span>
	<span class="s3">var </span><span class="s2">inputLength = input.length;</span>
	<span class="s3">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s3">var </span><span class="s2">n = initialN;</span>
	<span class="s3">var </span><span class="s2">bias = initialBias;</span>

	<span class="s0">// Handle the basic code points: let `basic` be the number of input code</span>
	<span class="s0">// points before the last delimiter, or `0` if there is none, then copy</span>
	<span class="s0">// the first basic code points to the output.</span>

	<span class="s3">var </span><span class="s2">basic = input.lastIndexOf(delimiter);</span>
	<span class="s3">if </span><span class="s2">(basic &lt; </span><span class="s5">0</span><span class="s2">) {</span>
		<span class="s2">basic = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">j = </span><span class="s5">0</span><span class="s2">; j &lt; basic; ++j) {</span>
		<span class="s0">// if it's not a basic code point</span>
		<span class="s3">if </span><span class="s2">(input.charCodeAt(j) &gt;= </span><span class="s5">0x80</span><span class="s2">) {</span>
			<span class="s2">error$1(</span><span class="s4">'not-basic'</span><span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s2">output.push(input.charCodeAt(j));</span>
	<span class="s2">}</span>

	<span class="s0">// Main decoding loop: start just after the last delimiter if any basic code</span>
	<span class="s0">// points were copied; start at the beginning otherwise.</span>

	<span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">index = basic &gt; </span><span class="s5">0 </span><span class="s2">? basic + </span><span class="s5">1 </span><span class="s2">: </span><span class="s5">0</span><span class="s2">; index &lt; inputLength;) </span><span class="s0">/* no final expression */</span><span class="s2">{</span>

		<span class="s0">// `index` is the index of the next character to be consumed.</span>
		<span class="s0">// Decode a generalized variable-length integer into `delta`,</span>
		<span class="s0">// which gets added to `i`. The overflow checking is easier</span>
		<span class="s0">// if we increase `i` as we go, then subtract off its starting</span>
		<span class="s0">// value at the end to obtain `delta`.</span>
		<span class="s3">var </span><span class="s2">oldi = i;</span>
		<span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">w = </span><span class="s5">1</span><span class="s2">, k = base;; </span><span class="s0">/* no condition */</span><span class="s2">k += base) {</span>

			<span class="s3">if </span><span class="s2">(index &gt;= inputLength) {</span>
				<span class="s2">error$1(</span><span class="s4">'invalid-input'</span><span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s3">var </span><span class="s2">digit = basicToDigit(input.charCodeAt(index++));</span>

			<span class="s3">if </span><span class="s2">(digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {</span>
				<span class="s2">error$1(</span><span class="s4">'overflow'</span><span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s2">i += digit * w;</span>
			<span class="s3">var </span><span class="s2">t = k &lt;= bias ? tMin : k &gt;= bias + tMax ? tMax : k - bias;</span>

			<span class="s3">if </span><span class="s2">(digit &lt; t) {</span>
				<span class="s3">break</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s3">var </span><span class="s2">baseMinusT = base - t;</span>
			<span class="s3">if </span><span class="s2">(w &gt; floor(maxInt / baseMinusT)) {</span>
				<span class="s2">error$1(</span><span class="s4">'overflow'</span><span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s2">w *= baseMinusT;</span>
		<span class="s2">}</span>

		<span class="s3">var </span><span class="s2">out = output.length + </span><span class="s5">1</span><span class="s2">;</span>
		<span class="s2">bias = adapt(i - oldi, out, oldi == </span><span class="s5">0</span><span class="s2">);</span>

		<span class="s0">// `i` was supposed to wrap around from `out` to `0`,</span>
		<span class="s0">// incrementing `n` each time, so we'll fix that now:</span>
		<span class="s3">if </span><span class="s2">(floor(i / out) &gt; maxInt - n) {</span>
			<span class="s2">error$1(</span><span class="s4">'overflow'</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s2">n += floor(i / out);</span>
		<span class="s2">i %= out;</span>

		<span class="s0">// Insert `n` at position `i` of the output.</span>
		<span class="s2">output.splice(i++, </span><span class="s5">0</span><span class="s2">, n);</span>
	<span class="s2">}</span>

	<span class="s3">return </span><span class="s2">String.fromCodePoint.apply(String, output);</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a string of Unicode symbols (e.g. a domain name label) to a</span>
 <span class="s0">* Punycode string of ASCII-only symbols.</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">punycode</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{String} input The string of Unicode symbols.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{String} The resulting Punycode string of ASCII-only symbols.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">encode = </span><span class="s3">function </span><span class="s2">encode(input) {</span>
	<span class="s3">var </span><span class="s2">output = [];</span>

	<span class="s0">// Convert the input in UCS-2 to an array of Unicode code points.</span>
	<span class="s2">input = ucs2decode(input);</span>

	<span class="s0">// Cache the length.</span>
	<span class="s3">var </span><span class="s2">inputLength = input.length;</span>

	<span class="s0">// Initialize the state.</span>
	<span class="s3">var </span><span class="s2">n = initialN;</span>
	<span class="s3">var </span><span class="s2">delta = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s3">var </span><span class="s2">bias = initialBias;</span>

	<span class="s0">// Handle the basic code points.</span>
	<span class="s3">var </span><span class="s2">_iteratorNormalCompletion = </span><span class="s3">true</span><span class="s2">;</span>
	<span class="s3">var </span><span class="s2">_didIteratorError = </span><span class="s3">false</span><span class="s2">;</span>
	<span class="s3">var </span><span class="s2">_iteratorError = undefined;</span>

	<span class="s3">try </span><span class="s2">{</span>
		<span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">_iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = </span><span class="s3">true</span><span class="s2">) {</span>
			<span class="s3">var </span><span class="s2">_currentValue2 = _step.value;</span>

			<span class="s3">if </span><span class="s2">(_currentValue2 &lt; </span><span class="s5">0x80</span><span class="s2">) {</span>
				<span class="s2">output.push(stringFromCharCode(_currentValue2));</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
	<span class="s2">} </span><span class="s3">catch </span><span class="s2">(err) {</span>
		<span class="s2">_didIteratorError = </span><span class="s3">true</span><span class="s2">;</span>
		<span class="s2">_iteratorError = err;</span>
	<span class="s2">} </span><span class="s3">finally </span><span class="s2">{</span>
		<span class="s3">try </span><span class="s2">{</span>
			<span class="s3">if </span><span class="s2">(!_iteratorNormalCompletion &amp;&amp; _iterator.return) {</span>
				<span class="s2">_iterator.return();</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s3">finally </span><span class="s2">{</span>
			<span class="s3">if </span><span class="s2">(_didIteratorError) {</span>
				<span class="s3">throw </span><span class="s2">_iteratorError;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s3">var </span><span class="s2">basicLength = output.length;</span>
	<span class="s3">var </span><span class="s2">handledCPCount = basicLength;</span>

	<span class="s0">// `handledCPCount` is the number of code points that have been handled;</span>
	<span class="s0">// `basicLength` is the number of basic code points.</span>

	<span class="s0">// Finish the basic string with a delimiter unless it's empty.</span>
	<span class="s3">if </span><span class="s2">(basicLength) {</span>
		<span class="s2">output.push(delimiter);</span>
	<span class="s2">}</span>

	<span class="s0">// Main encoding loop:</span>
	<span class="s3">while </span><span class="s2">(handledCPCount &lt; inputLength) {</span>

		<span class="s0">// All non-basic code points &lt; n have been handled already. Find the next</span>
		<span class="s0">// larger one:</span>
		<span class="s3">var </span><span class="s2">m = maxInt;</span>
		<span class="s3">var </span><span class="s2">_iteratorNormalCompletion2 = </span><span class="s3">true</span><span class="s2">;</span>
		<span class="s3">var </span><span class="s2">_didIteratorError2 = </span><span class="s3">false</span><span class="s2">;</span>
		<span class="s3">var </span><span class="s2">_iteratorError2 = undefined;</span>

		<span class="s3">try </span><span class="s2">{</span>
			<span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">_iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = </span><span class="s3">true</span><span class="s2">) {</span>
				<span class="s3">var </span><span class="s2">currentValue = _step2.value;</span>

				<span class="s3">if </span><span class="s2">(currentValue &gt;= n &amp;&amp; currentValue &lt; m) {</span>
					<span class="s2">m = currentValue;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s0">// Increase `delta` enough to advance the decoder's &lt;n,i&gt; state to &lt;m,0&gt;,</span>
			<span class="s0">// but guard against overflow.</span>
		<span class="s2">} </span><span class="s3">catch </span><span class="s2">(err) {</span>
			<span class="s2">_didIteratorError2 = </span><span class="s3">true</span><span class="s2">;</span>
			<span class="s2">_iteratorError2 = err;</span>
		<span class="s2">} </span><span class="s3">finally </span><span class="s2">{</span>
			<span class="s3">try </span><span class="s2">{</span>
				<span class="s3">if </span><span class="s2">(!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {</span>
					<span class="s2">_iterator2.return();</span>
				<span class="s2">}</span>
			<span class="s2">} </span><span class="s3">finally </span><span class="s2">{</span>
				<span class="s3">if </span><span class="s2">(_didIteratorError2) {</span>
					<span class="s3">throw </span><span class="s2">_iteratorError2;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s3">var </span><span class="s2">handledCPCountPlusOne = handledCPCount + </span><span class="s5">1</span><span class="s2">;</span>
		<span class="s3">if </span><span class="s2">(m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {</span>
			<span class="s2">error$1(</span><span class="s4">'overflow'</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s2">delta += (m - n) * handledCPCountPlusOne;</span>
		<span class="s2">n = m;</span>

		<span class="s3">var </span><span class="s2">_iteratorNormalCompletion3 = </span><span class="s3">true</span><span class="s2">;</span>
		<span class="s3">var </span><span class="s2">_didIteratorError3 = </span><span class="s3">false</span><span class="s2">;</span>
		<span class="s3">var </span><span class="s2">_iteratorError3 = undefined;</span>

		<span class="s3">try </span><span class="s2">{</span>
			<span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">_iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = </span><span class="s3">true</span><span class="s2">) {</span>
				<span class="s3">var </span><span class="s2">_currentValue = _step3.value;</span>

				<span class="s3">if </span><span class="s2">(_currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {</span>
					<span class="s2">error$1(</span><span class="s4">'overflow'</span><span class="s2">);</span>
				<span class="s2">}</span>
				<span class="s3">if </span><span class="s2">(_currentValue == n) {</span>
					<span class="s0">// Represent delta as a generalized variable-length integer.</span>
					<span class="s3">var </span><span class="s2">q = delta;</span>
					<span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">k = base;; </span><span class="s0">/* no condition */</span><span class="s2">k += base) {</span>
						<span class="s3">var </span><span class="s2">t = k &lt;= bias ? tMin : k &gt;= bias + tMax ? tMax : k - bias;</span>
						<span class="s3">if </span><span class="s2">(q &lt; t) {</span>
							<span class="s3">break</span><span class="s2">;</span>
						<span class="s2">}</span>
						<span class="s3">var </span><span class="s2">qMinusT = q - t;</span>
						<span class="s3">var </span><span class="s2">baseMinusT = base - t;</span>
						<span class="s2">output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, </span><span class="s5">0</span><span class="s2">)));</span>
						<span class="s2">q = floor(qMinusT / baseMinusT);</span>
					<span class="s2">}</span>

					<span class="s2">output.push(stringFromCharCode(digitToBasic(q, </span><span class="s5">0</span><span class="s2">)));</span>
					<span class="s2">bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);</span>
					<span class="s2">delta = </span><span class="s5">0</span><span class="s2">;</span>
					<span class="s2">++handledCPCount;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s3">catch </span><span class="s2">(err) {</span>
			<span class="s2">_didIteratorError3 = </span><span class="s3">true</span><span class="s2">;</span>
			<span class="s2">_iteratorError3 = err;</span>
		<span class="s2">} </span><span class="s3">finally </span><span class="s2">{</span>
			<span class="s3">try </span><span class="s2">{</span>
				<span class="s3">if </span><span class="s2">(!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) {</span>
					<span class="s2">_iterator3.return();</span>
				<span class="s2">}</span>
			<span class="s2">} </span><span class="s3">finally </span><span class="s2">{</span>
				<span class="s3">if </span><span class="s2">(_didIteratorError3) {</span>
					<span class="s3">throw </span><span class="s2">_iteratorError3;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s2">++delta;</span>
		<span class="s2">++n;</span>
	<span class="s2">}</span>
	<span class="s3">return </span><span class="s2">output.join(</span><span class="s4">''</span><span class="s2">);</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a Punycode string representing a domain name or an email address</span>
 <span class="s0">* to Unicode. Only the Punycoded parts of the input will be converted, i.e.</span>
 <span class="s0">* it doesn't matter if you call it on a string that has already been</span>
 <span class="s0">* converted to Unicode.</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">punycode</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{String} input The Punycoded domain name or email address to</span>
 <span class="s0">* convert to Unicode.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{String} The Unicode representation of the given Punycode</span>
 <span class="s0">* string.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">toUnicode = </span><span class="s3">function </span><span class="s2">toUnicode(input) {</span>
	<span class="s3">return </span><span class="s2">mapDomain(input, </span><span class="s3">function </span><span class="s2">(string) {</span>
		<span class="s3">return </span><span class="s2">regexPunycode.test(string) ? decode(string.slice(</span><span class="s5">4</span><span class="s2">).toLowerCase()) : string;</span>
	<span class="s2">});</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Converts a Unicode string representing a domain name or an email address to</span>
 <span class="s0">* Punycode. Only the non-ASCII parts of the domain name will be converted,</span>
 <span class="s0">* i.e. it doesn't matter if you call it with a domain that's already in</span>
 <span class="s0">* ASCII.</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">punycode</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{String} input The domain name or email address to convert, as a</span>
 <span class="s0">* Unicode string.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{String} The Punycode representation of the given domain name or</span>
 <span class="s0">* email address.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">toASCII = </span><span class="s3">function </span><span class="s2">toASCII(input) {</span>
	<span class="s3">return </span><span class="s2">mapDomain(input, </span><span class="s3">function </span><span class="s2">(string) {</span>
		<span class="s3">return </span><span class="s2">regexNonASCII.test(string) ? </span><span class="s4">'xn--' </span><span class="s2">+ encode(string) : string;</span>
	<span class="s2">});</span>
<span class="s2">};</span>

<span class="s0">/*--------------------------------------------------------------------------*/</span>

<span class="s0">/** Define the public API */</span>
<span class="s3">var </span><span class="s2">punycode = {</span>
	<span class="s0">/**</span>
  <span class="s0">* A string representing the current Punycode.js version number.</span>
  <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">punycode</span>
  <span class="s0">* </span><span class="s1">@type </span><span class="s0">String</span>
  <span class="s0">*/</span>
	<span class="s4">'version'</span><span class="s2">: </span><span class="s4">'2.1.0'</span><span class="s2">,</span>
	<span class="s0">/**</span>
  <span class="s0">* An object of methods to convert from JavaScript's internal character</span>
  <span class="s0">* representation (UCS-2) to Unicode code points, and back.</span>
  <span class="s0">* </span><span class="s1">@see </span><span class="s0">&lt;https://mathiasbynens.be/notes/javascript-encoding&gt;</span>
  <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">punycode</span>
  <span class="s0">* </span><span class="s1">@type </span><span class="s0">Object</span>
  <span class="s0">*/</span>
	<span class="s4">'ucs2'</span><span class="s2">: {</span>
		<span class="s4">'decode'</span><span class="s2">: ucs2decode,</span>
		<span class="s4">'encode'</span><span class="s2">: ucs2encode</span>
	<span class="s2">},</span>
	<span class="s4">'decode'</span><span class="s2">: decode,</span>
	<span class="s4">'encode'</span><span class="s2">: encode,</span>
	<span class="s4">'toASCII'</span><span class="s2">: toASCII,</span>
	<span class="s4">'toUnicode'</span><span class="s2">: toUnicode</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* URI.js</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">&lt;a href=&quot;mailto:gary.court@gmail.com&quot;&gt;Gary Court&lt;/a&gt;</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">http://github.com/garycourt/uri-js</span>
 <span class="s0">*/</span>
<span class="s0">/**</span>
 <span class="s0">* Copyright 2011 Gary Court. All rights reserved.</span>
 <span class="s0">*</span>
 <span class="s0">* Redistribution and use in source and binary forms, with or without modification, are</span>
 <span class="s0">* permitted provided that the following conditions are met:</span>
 <span class="s0">*</span>
 <span class="s0">*    1. Redistributions of source code must retain the above copyright notice, this list of</span>
 <span class="s0">*       conditions and the following disclaimer.</span>
 <span class="s0">*</span>
 <span class="s0">*    2. Redistributions in binary form must reproduce the above copyright notice, this list</span>
 <span class="s0">*       of conditions and the following disclaimer in the documentation and/or other materials</span>
 <span class="s0">*       provided with the distribution.</span>
 <span class="s0">*</span>
 <span class="s0">* THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
 <span class="s0">* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND</span>
 <span class="s0">* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR</span>
 <span class="s0">* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
 <span class="s0">* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
 <span class="s0">* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span>
 <span class="s0">* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
 <span class="s0">* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF</span>
 <span class="s0">* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
 <span class="s0">*</span>
 <span class="s0">* The views and conclusions contained in the software and documentation are those of the</span>
 <span class="s0">* authors and should not be interpreted as representing official policies, either expressed</span>
 <span class="s0">* or implied, of Gary Court.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">SCHEMES = {};</span>
<span class="s3">function </span><span class="s2">pctEncChar(chr) {</span>
    <span class="s3">var </span><span class="s2">c = chr.charCodeAt(</span><span class="s5">0</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s2">e = </span><span class="s3">void </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(c &lt; </span><span class="s5">16</span><span class="s2">) e = </span><span class="s4">&quot;%0&quot; </span><span class="s2">+ c.toString(</span><span class="s5">16</span><span class="s2">).toUpperCase();</span><span class="s3">else if </span><span class="s2">(c &lt; </span><span class="s5">128</span><span class="s2">) e = </span><span class="s4">&quot;%&quot; </span><span class="s2">+ c.toString(</span><span class="s5">16</span><span class="s2">).toUpperCase();</span><span class="s3">else if </span><span class="s2">(c &lt; </span><span class="s5">2048</span><span class="s2">) e = </span><span class="s4">&quot;%&quot; </span><span class="s2">+ (c &gt;&gt; </span><span class="s5">6 </span><span class="s2">| </span><span class="s5">192</span><span class="s2">).toString(</span><span class="s5">16</span><span class="s2">).toUpperCase() + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ (c &amp; </span><span class="s5">63 </span><span class="s2">| </span><span class="s5">128</span><span class="s2">).toString(</span><span class="s5">16</span><span class="s2">).toUpperCase();</span><span class="s3">else </span><span class="s2">e = </span><span class="s4">&quot;%&quot; </span><span class="s2">+ (c &gt;&gt; </span><span class="s5">12 </span><span class="s2">| </span><span class="s5">224</span><span class="s2">).toString(</span><span class="s5">16</span><span class="s2">).toUpperCase() + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ (c &gt;&gt; </span><span class="s5">6 </span><span class="s2">&amp; </span><span class="s5">63 </span><span class="s2">| </span><span class="s5">128</span><span class="s2">).toString(</span><span class="s5">16</span><span class="s2">).toUpperCase() + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ (c &amp; </span><span class="s5">63 </span><span class="s2">| </span><span class="s5">128</span><span class="s2">).toString(</span><span class="s5">16</span><span class="s2">).toUpperCase();</span>
    <span class="s3">return </span><span class="s2">e;</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">pctDecChars(str) {</span>
    <span class="s3">var </span><span class="s2">newStr = </span><span class="s4">&quot;&quot;</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s2">il = str.length;</span>
    <span class="s3">while </span><span class="s2">(i &lt; il) {</span>
        <span class="s3">var </span><span class="s2">c = parseInt(str.substr(i + </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
        <span class="s3">if </span><span class="s2">(c &lt; </span><span class="s5">128</span><span class="s2">) {</span>
            <span class="s2">newStr += String.fromCharCode(c);</span>
            <span class="s2">i += </span><span class="s5">3</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(c &gt;= </span><span class="s5">194 </span><span class="s2">&amp;&amp; c &lt; </span><span class="s5">224</span><span class="s2">) {</span>
            <span class="s3">if </span><span class="s2">(il - i &gt;= </span><span class="s5">6</span><span class="s2">) {</span>
                <span class="s3">var </span><span class="s2">c2 = parseInt(str.substr(i + </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
                <span class="s2">newStr += String.fromCharCode((c &amp; </span><span class="s5">31</span><span class="s2">) &lt;&lt; </span><span class="s5">6 </span><span class="s2">| c2 &amp; </span><span class="s5">63</span><span class="s2">);</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                <span class="s2">newStr += str.substr(i, </span><span class="s5">6</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s2">i += </span><span class="s5">6</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(c &gt;= </span><span class="s5">224</span><span class="s2">) {</span>
            <span class="s3">if </span><span class="s2">(il - i &gt;= </span><span class="s5">9</span><span class="s2">) {</span>
                <span class="s3">var </span><span class="s2">_c = parseInt(str.substr(i + </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
                <span class="s3">var </span><span class="s2">c3 = parseInt(str.substr(i + </span><span class="s5">7</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
                <span class="s2">newStr += String.fromCharCode((c &amp; </span><span class="s5">15</span><span class="s2">) &lt;&lt; </span><span class="s5">12 </span><span class="s2">| (_c &amp; </span><span class="s5">63</span><span class="s2">) &lt;&lt; </span><span class="s5">6 </span><span class="s2">| c3 &amp; </span><span class="s5">63</span><span class="s2">);</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                <span class="s2">newStr += str.substr(i, </span><span class="s5">9</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s2">i += </span><span class="s5">9</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s2">newStr += str.substr(i, </span><span class="s5">3</span><span class="s2">);</span>
            <span class="s2">i += </span><span class="s5">3</span><span class="s2">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">newStr;</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">_normalizeComponentEncoding(components, protocol) {</span>
    <span class="s3">function </span><span class="s2">decodeUnreserved(str) {</span>
        <span class="s3">var </span><span class="s2">decStr = pctDecChars(str);</span>
        <span class="s3">return </span><span class="s2">!decStr.match(protocol.UNRESERVED) ? str : decStr;</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, </span><span class="s4">&quot;&quot;</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s3">if </span><span class="s2">(components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s3">if </span><span class="s2">(components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s3">if </span><span class="s2">(components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s3">if </span><span class="s2">(components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s3">return </span><span class="s2">components;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">_stripLeadingZeros(str) {</span>
    <span class="s3">return </span><span class="s2">str.replace(</span><span class="s7">/^0*(.*)/</span><span class="s2">, </span><span class="s4">&quot;$1&quot;</span><span class="s2">) || </span><span class="s4">&quot;0&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">_normalizeIPv4(host, protocol) {</span>
    <span class="s3">var </span><span class="s2">matches = host.match(protocol.IPV4ADDRESS) || [];</span>

    <span class="s3">var </span><span class="s2">_matches = slicedToArray(matches, </span><span class="s5">2</span><span class="s2">),</span>
        <span class="s2">address = _matches[</span><span class="s5">1</span><span class="s2">];</span>

    <span class="s3">if </span><span class="s2">(address) {</span>
        <span class="s3">return </span><span class="s2">address.split(</span><span class="s4">&quot;.&quot;</span><span class="s2">).map(_stripLeadingZeros).join(</span><span class="s4">&quot;.&quot;</span><span class="s2">);</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s2">host;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">_normalizeIPv6(host, protocol) {</span>
    <span class="s3">var </span><span class="s2">matches = host.match(protocol.IPV6ADDRESS) || [];</span>

    <span class="s3">var </span><span class="s2">_matches2 = slicedToArray(matches, </span><span class="s5">3</span><span class="s2">),</span>
        <span class="s2">address = _matches2[</span><span class="s5">1</span><span class="s2">],</span>
        <span class="s2">zone = _matches2[</span><span class="s5">2</span><span class="s2">];</span>

    <span class="s3">if </span><span class="s2">(address) {</span>
        <span class="s3">var </span><span class="s2">_address$toLowerCase$ = address.toLowerCase().split(</span><span class="s4">'::'</span><span class="s2">).reverse(),</span>
            <span class="s2">_address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, </span><span class="s5">2</span><span class="s2">),</span>
            <span class="s2">last = _address$toLowerCase$2[</span><span class="s5">0</span><span class="s2">],</span>
            <span class="s2">first = _address$toLowerCase$2[</span><span class="s5">1</span><span class="s2">];</span>

        <span class="s3">var </span><span class="s2">firstFields = first ? first.split(</span><span class="s4">&quot;:&quot;</span><span class="s2">).map(_stripLeadingZeros) : [];</span>
        <span class="s3">var </span><span class="s2">lastFields = last.split(</span><span class="s4">&quot;:&quot;</span><span class="s2">).map(_stripLeadingZeros);</span>
        <span class="s3">var </span><span class="s2">isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - </span><span class="s5">1</span><span class="s2">]);</span>
        <span class="s3">var </span><span class="s2">fieldCount = isLastFieldIPv4Address ? </span><span class="s5">7 </span><span class="s2">: </span><span class="s5">8</span><span class="s2">;</span>
        <span class="s3">var </span><span class="s2">lastFieldsStart = lastFields.length - fieldCount;</span>
        <span class="s3">var </span><span class="s2">fields = Array(fieldCount);</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">x = </span><span class="s5">0</span><span class="s2">; x &lt; fieldCount; ++x) {</span>
            <span class="s2">fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || </span><span class="s4">''</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">if </span><span class="s2">(isLastFieldIPv4Address) {</span>
            <span class="s2">fields[fieldCount - </span><span class="s5">1</span><span class="s2">] = _normalizeIPv4(fields[fieldCount - </span><span class="s5">1</span><span class="s2">], protocol);</span>
        <span class="s2">}</span>
        <span class="s3">var </span><span class="s2">allZeroFields = fields.reduce(</span><span class="s3">function </span><span class="s2">(acc, field, index) {</span>
            <span class="s3">if </span><span class="s2">(!field || field === </span><span class="s4">&quot;0&quot;</span><span class="s2">) {</span>
                <span class="s3">var </span><span class="s2">lastLongest = acc[acc.length - </span><span class="s5">1</span><span class="s2">];</span>
                <span class="s3">if </span><span class="s2">(lastLongest &amp;&amp; lastLongest.index + lastLongest.length === index) {</span>
                    <span class="s2">lastLongest.length++;</span>
                <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                    <span class="s2">acc.push({ index: index, length: </span><span class="s5">1 </span><span class="s2">});</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">return </span><span class="s2">acc;</span>
        <span class="s2">}, []);</span>
        <span class="s3">var </span><span class="s2">longestZeroFields = allZeroFields.sort(</span><span class="s3">function </span><span class="s2">(a, b) {</span>
            <span class="s3">return </span><span class="s2">b.length - a.length;</span>
        <span class="s2">})[</span><span class="s5">0</span><span class="s2">];</span>
        <span class="s3">var </span><span class="s2">newHost = </span><span class="s3">void </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s3">if </span><span class="s2">(longestZeroFields &amp;&amp; longestZeroFields.length &gt; </span><span class="s5">1</span><span class="s2">) {</span>
            <span class="s3">var </span><span class="s2">newFirst = fields.slice(</span><span class="s5">0</span><span class="s2">, longestZeroFields.index);</span>
            <span class="s3">var </span><span class="s2">newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);</span>
            <span class="s2">newHost = newFirst.join(</span><span class="s4">&quot;:&quot;</span><span class="s2">) + </span><span class="s4">&quot;::&quot; </span><span class="s2">+ newLast.join(</span><span class="s4">&quot;:&quot;</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s2">newHost = fields.join(</span><span class="s4">&quot;:&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s3">if </span><span class="s2">(zone) {</span>
            <span class="s2">newHost += </span><span class="s4">&quot;%&quot; </span><span class="s2">+ zone;</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s2">newHost;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s2">host;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">var </span><span class="s2">URI_PARSE = </span><span class="s7">/^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">NO_MATCH_IS_UNDEFINED = </span><span class="s4">&quot;&quot;</span><span class="s2">.match(</span><span class="s7">/(){0}/</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">] === undefined;</span>
<span class="s3">function </span><span class="s2">parse(uriString) {</span>
    <span class="s3">var </span><span class="s2">options = arguments.length &gt; </span><span class="s5">1 </span><span class="s2">&amp;&amp; arguments[</span><span class="s5">1</span><span class="s2">] !== undefined ? arguments[</span><span class="s5">1</span><span class="s2">] : {};</span>

    <span class="s3">var </span><span class="s2">components = {};</span>
    <span class="s3">var </span><span class="s2">protocol = options.iri !== </span><span class="s3">false </span><span class="s2">? IRI_PROTOCOL : URI_PROTOCOL;</span>
    <span class="s3">if </span><span class="s2">(options.reference === </span><span class="s4">&quot;suffix&quot;</span><span class="s2">) uriString = (options.scheme ? options.scheme + </span><span class="s4">&quot;:&quot; </span><span class="s2">: </span><span class="s4">&quot;&quot;</span><span class="s2">) + </span><span class="s4">&quot;//&quot; </span><span class="s2">+ uriString;</span>
    <span class="s3">var </span><span class="s2">matches = uriString.match(URI_PARSE);</span>
    <span class="s3">if </span><span class="s2">(matches) {</span>
        <span class="s3">if </span><span class="s2">(NO_MATCH_IS_UNDEFINED) {</span>
            <span class="s0">//store each component</span>
            <span class="s2">components.scheme = matches[</span><span class="s5">1</span><span class="s2">];</span>
            <span class="s2">components.userinfo = matches[</span><span class="s5">3</span><span class="s2">];</span>
            <span class="s2">components.host = matches[</span><span class="s5">4</span><span class="s2">];</span>
            <span class="s2">components.port = parseInt(matches[</span><span class="s5">5</span><span class="s2">], </span><span class="s5">10</span><span class="s2">);</span>
            <span class="s2">components.path = matches[</span><span class="s5">6</span><span class="s2">] || </span><span class="s4">&quot;&quot;</span><span class="s2">;</span>
            <span class="s2">components.query = matches[</span><span class="s5">7</span><span class="s2">];</span>
            <span class="s2">components.fragment = matches[</span><span class="s5">8</span><span class="s2">];</span>
            <span class="s0">//fix port number</span>
            <span class="s3">if </span><span class="s2">(isNaN(components.port)) {</span>
                <span class="s2">components.port = matches[</span><span class="s5">5</span><span class="s2">];</span>
            <span class="s2">}</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s0">//IE FIX for improper RegExp matching</span>
            <span class="s0">//store each component</span>
            <span class="s2">components.scheme = matches[</span><span class="s5">1</span><span class="s2">] || undefined;</span>
            <span class="s2">components.userinfo = uriString.indexOf(</span><span class="s4">&quot;@&quot;</span><span class="s2">) !== -</span><span class="s5">1 </span><span class="s2">? matches[</span><span class="s5">3</span><span class="s2">] : undefined;</span>
            <span class="s2">components.host = uriString.indexOf(</span><span class="s4">&quot;//&quot;</span><span class="s2">) !== -</span><span class="s5">1 </span><span class="s2">? matches[</span><span class="s5">4</span><span class="s2">] : undefined;</span>
            <span class="s2">components.port = parseInt(matches[</span><span class="s5">5</span><span class="s2">], </span><span class="s5">10</span><span class="s2">);</span>
            <span class="s2">components.path = matches[</span><span class="s5">6</span><span class="s2">] || </span><span class="s4">&quot;&quot;</span><span class="s2">;</span>
            <span class="s2">components.query = uriString.indexOf(</span><span class="s4">&quot;?&quot;</span><span class="s2">) !== -</span><span class="s5">1 </span><span class="s2">? matches[</span><span class="s5">7</span><span class="s2">] : undefined;</span>
            <span class="s2">components.fragment = uriString.indexOf(</span><span class="s4">&quot;#&quot;</span><span class="s2">) !== -</span><span class="s5">1 </span><span class="s2">? matches[</span><span class="s5">8</span><span class="s2">] : undefined;</span>
            <span class="s0">//fix port number</span>
            <span class="s3">if </span><span class="s2">(isNaN(components.port)) {</span>
                <span class="s2">components.port = uriString.match(</span><span class="s7">/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/</span><span class="s2">) ? matches[</span><span class="s5">4</span><span class="s2">] : undefined;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">if </span><span class="s2">(components.host) {</span>
            <span class="s0">//normalize IP hosts</span>
            <span class="s2">components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);</span>
        <span class="s2">}</span>
        <span class="s0">//determine reference type</span>
        <span class="s3">if </span><span class="s2">(components.scheme === undefined &amp;&amp; components.userinfo === undefined &amp;&amp; components.host === undefined &amp;&amp; components.port === undefined &amp;&amp; !components.path &amp;&amp; components.query === undefined) {</span>
            <span class="s2">components.reference = </span><span class="s4">&quot;same-document&quot;</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(components.scheme === undefined) {</span>
            <span class="s2">components.reference = </span><span class="s4">&quot;relative&quot;</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(components.fragment === undefined) {</span>
            <span class="s2">components.reference = </span><span class="s4">&quot;absolute&quot;</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s2">components.reference = </span><span class="s4">&quot;uri&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s0">//check for reference errors</span>
        <span class="s3">if </span><span class="s2">(options.reference &amp;&amp; options.reference !== </span><span class="s4">&quot;suffix&quot; </span><span class="s2">&amp;&amp; options.reference !== components.reference) {</span>
            <span class="s2">components.error = components.error || </span><span class="s4">&quot;URI is not a &quot; </span><span class="s2">+ options.reference + </span><span class="s4">&quot; reference.&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s0">//find scheme handler</span>
        <span class="s3">var </span><span class="s2">schemeHandler = SCHEMES[(options.scheme || components.scheme || </span><span class="s4">&quot;&quot;</span><span class="s2">).toLowerCase()];</span>
        <span class="s0">//check if scheme can't handle IRIs</span>
        <span class="s3">if </span><span class="s2">(!options.unicodeSupport &amp;&amp; (!schemeHandler || !schemeHandler.unicodeSupport)) {</span>
            <span class="s0">//if host component is a domain name</span>
            <span class="s3">if </span><span class="s2">(components.host &amp;&amp; (options.domainHost || schemeHandler &amp;&amp; schemeHandler.domainHost)) {</span>
                <span class="s0">//convert Unicode IDN -&gt; ASCII IDN</span>
                <span class="s3">try </span><span class="s2">{</span>
                    <span class="s2">components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());</span>
                <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
                    <span class="s2">components.error = components.error || </span><span class="s4">&quot;Host's domain name can not be converted to ASCII via punycode: &quot; </span><span class="s2">+ e;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s0">//convert IRI -&gt; URI</span>
            <span class="s2">_normalizeComponentEncoding(components, URI_PROTOCOL);</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s0">//normalize encodings</span>
            <span class="s2">_normalizeComponentEncoding(components, protocol);</span>
        <span class="s2">}</span>
        <span class="s0">//perform scheme specific parsing</span>
        <span class="s3">if </span><span class="s2">(schemeHandler &amp;&amp; schemeHandler.parse) {</span>
            <span class="s2">schemeHandler.parse(components, options);</span>
        <span class="s2">}</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s2">components.error = components.error || </span><span class="s4">&quot;URI can not be parsed.&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">components;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">_recomposeAuthority(components, options) {</span>
    <span class="s3">var </span><span class="s2">protocol = options.iri !== </span><span class="s3">false </span><span class="s2">? IRI_PROTOCOL : URI_PROTOCOL;</span>
    <span class="s3">var </span><span class="s2">uriTokens = [];</span>
    <span class="s3">if </span><span class="s2">(components.userinfo !== undefined) {</span>
        <span class="s2">uriTokens.push(components.userinfo);</span>
        <span class="s2">uriTokens.push(</span><span class="s4">&quot;@&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(components.host !== undefined) {</span>
        <span class="s0">//normalize IP hosts, add brackets and escape zone separator for IPv6</span>
        <span class="s2">uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, </span><span class="s3">function </span><span class="s2">(_, $1, $2) {</span>
            <span class="s3">return </span><span class="s4">&quot;[&quot; </span><span class="s2">+ $1 + ($2 ? </span><span class="s4">&quot;%25&quot; </span><span class="s2">+ $2 : </span><span class="s4">&quot;&quot;</span><span class="s2">) + </span><span class="s4">&quot;]&quot;</span><span class="s2">;</span>
        <span class="s2">}));</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">components.port === </span><span class="s4">&quot;number&quot; </span><span class="s2">|| </span><span class="s3">typeof </span><span class="s2">components.port === </span><span class="s4">&quot;string&quot;</span><span class="s2">) {</span>
        <span class="s2">uriTokens.push(</span><span class="s4">&quot;:&quot;</span><span class="s2">);</span>
        <span class="s2">uriTokens.push(String(components.port));</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">uriTokens.length ? uriTokens.join(</span><span class="s4">&quot;&quot;</span><span class="s2">) : undefined;</span>
<span class="s2">}</span>

<span class="s3">var </span><span class="s2">RDS1 = </span><span class="s7">/^\.\.?\//</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">RDS2 = </span><span class="s7">/^\/\.(\/|$)/</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">RDS3 = </span><span class="s7">/^\/\.\.(\/|$)/</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">RDS5 = </span><span class="s7">/^\/?(?:.|\n)*?(?=\/|$)/</span><span class="s2">;</span>
<span class="s3">function </span><span class="s2">removeDotSegments(input) {</span>
    <span class="s3">var </span><span class="s2">output = [];</span>
    <span class="s3">while </span><span class="s2">(input.length) {</span>
        <span class="s3">if </span><span class="s2">(input.match(RDS1)) {</span>
            <span class="s2">input = input.replace(RDS1, </span><span class="s4">&quot;&quot;</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(input.match(RDS2)) {</span>
            <span class="s2">input = input.replace(RDS2, </span><span class="s4">&quot;/&quot;</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(input.match(RDS3)) {</span>
            <span class="s2">input = input.replace(RDS3, </span><span class="s4">&quot;/&quot;</span><span class="s2">);</span>
            <span class="s2">output.pop();</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(input === </span><span class="s4">&quot;.&quot; </span><span class="s2">|| input === </span><span class="s4">&quot;..&quot;</span><span class="s2">) {</span>
            <span class="s2">input = </span><span class="s4">&quot;&quot;</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s3">var </span><span class="s2">im = input.match(RDS5);</span>
            <span class="s3">if </span><span class="s2">(im) {</span>
                <span class="s3">var </span><span class="s2">s = im[</span><span class="s5">0</span><span class="s2">];</span>
                <span class="s2">input = input.slice(s.length);</span>
                <span class="s2">output.push(s);</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                <span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">&quot;Unexpected dot segment condition&quot;</span><span class="s2">);</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">output.join(</span><span class="s4">&quot;&quot;</span><span class="s2">);</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">serialize(components) {</span>
    <span class="s3">var </span><span class="s2">options = arguments.length &gt; </span><span class="s5">1 </span><span class="s2">&amp;&amp; arguments[</span><span class="s5">1</span><span class="s2">] !== undefined ? arguments[</span><span class="s5">1</span><span class="s2">] : {};</span>

    <span class="s3">var </span><span class="s2">protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;</span>
    <span class="s3">var </span><span class="s2">uriTokens = [];</span>
    <span class="s0">//find scheme handler</span>
    <span class="s3">var </span><span class="s2">schemeHandler = SCHEMES[(options.scheme || components.scheme || </span><span class="s4">&quot;&quot;</span><span class="s2">).toLowerCase()];</span>
    <span class="s0">//perform scheme specific serialization</span>
    <span class="s3">if </span><span class="s2">(schemeHandler &amp;&amp; schemeHandler.serialize) schemeHandler.serialize(components, options);</span>
    <span class="s3">if </span><span class="s2">(components.host) {</span>
        <span class="s0">//if host component is an IPv6 address</span>
        <span class="s3">if </span><span class="s2">(protocol.IPV6ADDRESS.test(components.host)) {}</span>
        <span class="s0">//TODO: normalize IPv6 address as per RFC 5952</span>

        <span class="s0">//if host component is a domain name</span>
        <span class="s3">else if </span><span class="s2">(options.domainHost || schemeHandler &amp;&amp; schemeHandler.domainHost) {</span>
                <span class="s0">//convert IDN via punycode</span>
                <span class="s3">try </span><span class="s2">{</span>
                    <span class="s2">components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);</span>
                <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
                    <span class="s2">components.error = components.error || </span><span class="s4">&quot;Host's domain name can not be converted to &quot; </span><span class="s2">+ (!options.iri ? </span><span class="s4">&quot;ASCII&quot; </span><span class="s2">: </span><span class="s4">&quot;Unicode&quot;</span><span class="s2">) + </span><span class="s4">&quot; via punycode: &quot; </span><span class="s2">+ e;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s0">//normalize encoding</span>
    <span class="s2">_normalizeComponentEncoding(components, protocol);</span>
    <span class="s3">if </span><span class="s2">(options.reference !== </span><span class="s4">&quot;suffix&quot; </span><span class="s2">&amp;&amp; components.scheme) {</span>
        <span class="s2">uriTokens.push(components.scheme);</span>
        <span class="s2">uriTokens.push(</span><span class="s4">&quot;:&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">var </span><span class="s2">authority = _recomposeAuthority(components, options);</span>
    <span class="s3">if </span><span class="s2">(authority !== undefined) {</span>
        <span class="s3">if </span><span class="s2">(options.reference !== </span><span class="s4">&quot;suffix&quot;</span><span class="s2">) {</span>
            <span class="s2">uriTokens.push(</span><span class="s4">&quot;//&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s2">uriTokens.push(authority);</span>
        <span class="s3">if </span><span class="s2">(components.path &amp;&amp; components.path.charAt(</span><span class="s5">0</span><span class="s2">) !== </span><span class="s4">&quot;/&quot;</span><span class="s2">) {</span>
            <span class="s2">uriTokens.push(</span><span class="s4">&quot;/&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(components.path !== undefined) {</span>
        <span class="s3">var </span><span class="s2">s = components.path;</span>
        <span class="s3">if </span><span class="s2">(!options.absolutePath &amp;&amp; (!schemeHandler || !schemeHandler.absolutePath)) {</span>
            <span class="s2">s = removeDotSegments(s);</span>
        <span class="s2">}</span>
        <span class="s3">if </span><span class="s2">(authority === undefined) {</span>
            <span class="s2">s = s.replace(</span><span class="s7">/^\/\//</span><span class="s2">, </span><span class="s4">&quot;/%2F&quot;</span><span class="s2">); </span><span class="s0">//don't allow the path to start with &quot;//&quot;</span>
        <span class="s2">}</span>
        <span class="s2">uriTokens.push(s);</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(components.query !== undefined) {</span>
        <span class="s2">uriTokens.push(</span><span class="s4">&quot;?&quot;</span><span class="s2">);</span>
        <span class="s2">uriTokens.push(components.query);</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(components.fragment !== undefined) {</span>
        <span class="s2">uriTokens.push(</span><span class="s4">&quot;#&quot;</span><span class="s2">);</span>
        <span class="s2">uriTokens.push(components.fragment);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">uriTokens.join(</span><span class="s4">&quot;&quot;</span><span class="s2">); </span><span class="s0">//merge tokens into a string</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveComponents(base, relative) {</span>
    <span class="s3">var </span><span class="s2">options = arguments.length &gt; </span><span class="s5">2 </span><span class="s2">&amp;&amp; arguments[</span><span class="s5">2</span><span class="s2">] !== undefined ? arguments[</span><span class="s5">2</span><span class="s2">] : {};</span>
    <span class="s3">var </span><span class="s2">skipNormalization = arguments[</span><span class="s5">3</span><span class="s2">];</span>

    <span class="s3">var </span><span class="s2">target = {};</span>
    <span class="s3">if </span><span class="s2">(!skipNormalization) {</span>
        <span class="s2">base = parse(serialize(base, options), options); </span><span class="s0">//normalize base components</span>
        <span class="s2">relative = parse(serialize(relative, options), options); </span><span class="s0">//normalize relative components</span>
    <span class="s2">}</span>
    <span class="s2">options = options || {};</span>
    <span class="s3">if </span><span class="s2">(!options.tolerant &amp;&amp; relative.scheme) {</span>
        <span class="s2">target.scheme = relative.scheme;</span>
        <span class="s0">//target.authority = relative.authority;</span>
        <span class="s2">target.userinfo = relative.userinfo;</span>
        <span class="s2">target.host = relative.host;</span>
        <span class="s2">target.port = relative.port;</span>
        <span class="s2">target.path = removeDotSegments(relative.path || </span><span class="s4">&quot;&quot;</span><span class="s2">);</span>
        <span class="s2">target.query = relative.query;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">if </span><span class="s2">(relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {</span>
            <span class="s0">//target.authority = relative.authority;</span>
            <span class="s2">target.userinfo = relative.userinfo;</span>
            <span class="s2">target.host = relative.host;</span>
            <span class="s2">target.port = relative.port;</span>
            <span class="s2">target.path = removeDotSegments(relative.path || </span><span class="s4">&quot;&quot;</span><span class="s2">);</span>
            <span class="s2">target.query = relative.query;</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s3">if </span><span class="s2">(!relative.path) {</span>
                <span class="s2">target.path = base.path;</span>
                <span class="s3">if </span><span class="s2">(relative.query !== undefined) {</span>
                    <span class="s2">target.query = relative.query;</span>
                <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                    <span class="s2">target.query = base.query;</span>
                <span class="s2">}</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                <span class="s3">if </span><span class="s2">(relative.path.charAt(</span><span class="s5">0</span><span class="s2">) === </span><span class="s4">&quot;/&quot;</span><span class="s2">) {</span>
                    <span class="s2">target.path = removeDotSegments(relative.path);</span>
                <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                    <span class="s3">if </span><span class="s2">((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) &amp;&amp; !base.path) {</span>
                        <span class="s2">target.path = </span><span class="s4">&quot;/&quot; </span><span class="s2">+ relative.path;</span>
                    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(!base.path) {</span>
                        <span class="s2">target.path = relative.path;</span>
                    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                        <span class="s2">target.path = base.path.slice(</span><span class="s5">0</span><span class="s2">, base.path.lastIndexOf(</span><span class="s4">&quot;/&quot;</span><span class="s2">) + </span><span class="s5">1</span><span class="s2">) + relative.path;</span>
                    <span class="s2">}</span>
                    <span class="s2">target.path = removeDotSegments(target.path);</span>
                <span class="s2">}</span>
                <span class="s2">target.query = relative.query;</span>
            <span class="s2">}</span>
            <span class="s0">//target.authority = base.authority;</span>
            <span class="s2">target.userinfo = base.userinfo;</span>
            <span class="s2">target.host = base.host;</span>
            <span class="s2">target.port = base.port;</span>
        <span class="s2">}</span>
        <span class="s2">target.scheme = base.scheme;</span>
    <span class="s2">}</span>
    <span class="s2">target.fragment = relative.fragment;</span>
    <span class="s3">return </span><span class="s2">target;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolve(baseURI, relativeURI, options) {</span>
    <span class="s3">var </span><span class="s2">schemelessOptions = assign({ scheme: </span><span class="s4">'null' </span><span class="s2">}, options);</span>
    <span class="s3">return </span><span class="s2">serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, </span><span class="s3">true</span><span class="s2">), schemelessOptions);</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">normalize(uri, options) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">uri === </span><span class="s4">&quot;string&quot;</span><span class="s2">) {</span>
        <span class="s2">uri = serialize(parse(uri, options), options);</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(typeOf(uri) === </span><span class="s4">&quot;object&quot;</span><span class="s2">) {</span>
        <span class="s2">uri = parse(serialize(uri, options), options);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">uri;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">equal(uriA, uriB, options) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">uriA === </span><span class="s4">&quot;string&quot;</span><span class="s2">) {</span>
        <span class="s2">uriA = serialize(parse(uriA, options), options);</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(typeOf(uriA) === </span><span class="s4">&quot;object&quot;</span><span class="s2">) {</span>
        <span class="s2">uriA = serialize(uriA, options);</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">uriB === </span><span class="s4">&quot;string&quot;</span><span class="s2">) {</span>
        <span class="s2">uriB = serialize(parse(uriB, options), options);</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(typeOf(uriB) === </span><span class="s4">&quot;object&quot;</span><span class="s2">) {</span>
        <span class="s2">uriB = serialize(uriB, options);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s2">uriA === uriB;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">escapeComponent(str, options) {</span>
    <span class="s3">return </span><span class="s2">str &amp;&amp; str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">unescapeComponent(str, options) {</span>
    <span class="s3">return </span><span class="s2">str &amp;&amp; str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);</span>
<span class="s2">}</span>

<span class="s3">var </span><span class="s2">handler = {</span>
    <span class="s2">scheme: </span><span class="s4">&quot;http&quot;</span><span class="s2">,</span>
    <span class="s2">domainHost: </span><span class="s3">true</span><span class="s2">,</span>
    <span class="s2">parse: </span><span class="s3">function </span><span class="s2">parse(components, options) {</span>
        <span class="s0">//report missing host</span>
        <span class="s3">if </span><span class="s2">(!components.host) {</span>
            <span class="s2">components.error = components.error || </span><span class="s4">&quot;HTTP URIs must have a host.&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s2">components;</span>
    <span class="s2">},</span>
    <span class="s2">serialize: </span><span class="s3">function </span><span class="s2">serialize(components, options) {</span>
        <span class="s3">var </span><span class="s2">secure = String(components.scheme).toLowerCase() === </span><span class="s4">&quot;https&quot;</span><span class="s2">;</span>
        <span class="s0">//normalize the default port</span>
        <span class="s3">if </span><span class="s2">(components.port === (secure ? </span><span class="s5">443 </span><span class="s2">: </span><span class="s5">80</span><span class="s2">) || components.port === </span><span class="s4">&quot;&quot;</span><span class="s2">) {</span>
            <span class="s2">components.port = undefined;</span>
        <span class="s2">}</span>
        <span class="s0">//normalize the empty path</span>
        <span class="s3">if </span><span class="s2">(!components.path) {</span>
            <span class="s2">components.path = </span><span class="s4">&quot;/&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s0">//NOTE: We do not parse query strings for HTTP URIs</span>
        <span class="s0">//as WWW Form Url Encoded query strings are part of the HTML4+ spec,</span>
        <span class="s0">//and not the HTTP spec.</span>
        <span class="s3">return </span><span class="s2">components;</span>
    <span class="s2">}</span>
<span class="s2">};</span>

<span class="s3">var </span><span class="s2">handler$1 = {</span>
    <span class="s2">scheme: </span><span class="s4">&quot;https&quot;</span><span class="s2">,</span>
    <span class="s2">domainHost: handler.domainHost,</span>
    <span class="s2">parse: handler.parse,</span>
    <span class="s2">serialize: handler.serialize</span>
<span class="s2">};</span>

<span class="s3">function </span><span class="s2">isSecure(wsComponents) {</span>
    <span class="s3">return typeof </span><span class="s2">wsComponents.secure === </span><span class="s4">'boolean' </span><span class="s2">? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === </span><span class="s4">&quot;wss&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">//RFC 6455</span>
<span class="s3">var </span><span class="s2">handler$2 = {</span>
    <span class="s2">scheme: </span><span class="s4">&quot;ws&quot;</span><span class="s2">,</span>
    <span class="s2">domainHost: </span><span class="s3">true</span><span class="s2">,</span>
    <span class="s2">parse: </span><span class="s3">function </span><span class="s2">parse(components, options) {</span>
        <span class="s3">var </span><span class="s2">wsComponents = components;</span>
        <span class="s0">//indicate if the secure flag is set</span>
        <span class="s2">wsComponents.secure = isSecure(wsComponents);</span>
        <span class="s0">//construct resouce name</span>
        <span class="s2">wsComponents.resourceName = (wsComponents.path || </span><span class="s4">'/'</span><span class="s2">) + (wsComponents.query ? </span><span class="s4">'?' </span><span class="s2">+ wsComponents.query : </span><span class="s4">''</span><span class="s2">);</span>
        <span class="s2">wsComponents.path = undefined;</span>
        <span class="s2">wsComponents.query = undefined;</span>
        <span class="s3">return </span><span class="s2">wsComponents;</span>
    <span class="s2">},</span>
    <span class="s2">serialize: </span><span class="s3">function </span><span class="s2">serialize(wsComponents, options) {</span>
        <span class="s0">//normalize the default port</span>
        <span class="s3">if </span><span class="s2">(wsComponents.port === (isSecure(wsComponents) ? </span><span class="s5">443 </span><span class="s2">: </span><span class="s5">80</span><span class="s2">) || wsComponents.port === </span><span class="s4">&quot;&quot;</span><span class="s2">) {</span>
            <span class="s2">wsComponents.port = undefined;</span>
        <span class="s2">}</span>
        <span class="s0">//ensure scheme matches secure flag</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">wsComponents.secure === </span><span class="s4">'boolean'</span><span class="s2">) {</span>
            <span class="s2">wsComponents.scheme = wsComponents.secure ? </span><span class="s4">'wss' </span><span class="s2">: </span><span class="s4">'ws'</span><span class="s2">;</span>
            <span class="s2">wsComponents.secure = undefined;</span>
        <span class="s2">}</span>
        <span class="s0">//reconstruct path from resource name</span>
        <span class="s3">if </span><span class="s2">(wsComponents.resourceName) {</span>
            <span class="s3">var </span><span class="s2">_wsComponents$resourc = wsComponents.resourceName.split(</span><span class="s4">'?'</span><span class="s2">),</span>
                <span class="s2">_wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, </span><span class="s5">2</span><span class="s2">),</span>
                <span class="s2">path = _wsComponents$resourc2[</span><span class="s5">0</span><span class="s2">],</span>
                <span class="s2">query = _wsComponents$resourc2[</span><span class="s5">1</span><span class="s2">];</span>

            <span class="s2">wsComponents.path = path &amp;&amp; path !== </span><span class="s4">'/' </span><span class="s2">? path : undefined;</span>
            <span class="s2">wsComponents.query = query;</span>
            <span class="s2">wsComponents.resourceName = undefined;</span>
        <span class="s2">}</span>
        <span class="s0">//forbid fragment component</span>
        <span class="s2">wsComponents.fragment = undefined;</span>
        <span class="s3">return </span><span class="s2">wsComponents;</span>
    <span class="s2">}</span>
<span class="s2">};</span>

<span class="s3">var </span><span class="s2">handler$3 = {</span>
    <span class="s2">scheme: </span><span class="s4">&quot;wss&quot;</span><span class="s2">,</span>
    <span class="s2">domainHost: handler$2.domainHost,</span>
    <span class="s2">parse: handler$2.parse,</span>
    <span class="s2">serialize: handler$2.serialize</span>
<span class="s2">};</span>

<span class="s3">var </span><span class="s2">O = {};</span>
<span class="s3">var </span><span class="s2">isIRI = </span><span class="s3">true</span><span class="s2">;</span>
<span class="s0">//RFC 3986</span>
<span class="s3">var </span><span class="s2">UNRESERVED$$ = </span><span class="s4">&quot;[A-Za-z0-9</span><span class="s6">\\</span><span class="s4">-</span><span class="s6">\\</span><span class="s4">.</span><span class="s6">\\</span><span class="s4">_</span><span class="s6">\\</span><span class="s4">~&quot; </span><span class="s2">+ (isIRI ? </span><span class="s4">&quot;</span><span class="s6">\\</span><span class="s4">xA0-</span><span class="s6">\\</span><span class="s4">u200D</span><span class="s6">\\</span><span class="s4">u2010-</span><span class="s6">\\</span><span class="s4">u2029</span><span class="s6">\\</span><span class="s4">u202F-</span><span class="s6">\\</span><span class="s4">uD7FF</span><span class="s6">\\</span><span class="s4">uF900-</span><span class="s6">\\</span><span class="s4">uFDCF</span><span class="s6">\\</span><span class="s4">uFDF0-</span><span class="s6">\\</span><span class="s4">uFFEF&quot; </span><span class="s2">: </span><span class="s4">&quot;&quot;</span><span class="s2">) + </span><span class="s4">&quot;]&quot;</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">HEXDIG$$ = </span><span class="s4">&quot;[0-9A-Fa-f]&quot;</span><span class="s2">; </span><span class="s0">//case-insensitive</span>
<span class="s3">var </span><span class="s2">PCT_ENCODED$ = subexp(subexp(</span><span class="s4">&quot;%[EFef]&quot; </span><span class="s2">+ HEXDIG$$ + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ HEXDIG$$ + HEXDIG$$ + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;%[89A-Fa-f]&quot; </span><span class="s2">+ HEXDIG$$ + </span><span class="s4">&quot;%&quot; </span><span class="s2">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s4">&quot;|&quot; </span><span class="s2">+ subexp(</span><span class="s4">&quot;%&quot; </span><span class="s2">+ HEXDIG$$ + HEXDIG$$)); </span><span class="s0">//expanded</span>
<span class="s0">//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] &amp; ; =</span>
<span class="s0">//const ATEXT$$ = &quot;[A-Za-z0-9\\!\\#\\$\\%\\&amp;\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]&quot;;</span>
<span class="s0">//const WSP$$ = &quot;[\\x20\\x09]&quot;;</span>
<span class="s0">//const OBS_QTEXT$$ = &quot;[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]&quot;;  //(%d1-8 / %d11-12 / %d14-31 / %d127)</span>
<span class="s0">//const QTEXT$$ = merge(&quot;[\\x21\\x23-\\x5B\\x5D-\\x7E]&quot;, OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext</span>
<span class="s0">//const VCHAR$$ = &quot;[\\x21-\\x7E]&quot;;</span>
<span class="s0">//const WSP$$ = &quot;[\\x20\\x09]&quot;;</span>
<span class="s0">//const OBS_QP$ = subexp(&quot;\\\\&quot; + merge(&quot;[\\x00\\x0D\\x0A]&quot;, OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext</span>
<span class="s0">//const FWS$ = subexp(subexp(WSP$$ + &quot;*&quot; + &quot;\\x0D\\x0A&quot;) + &quot;?&quot; + WSP$$ + &quot;+&quot;);</span>
<span class="s0">//const QUOTED_PAIR$ = subexp(subexp(&quot;\\\\&quot; + subexp(VCHAR$$ + &quot;|&quot; + WSP$$)) + &quot;|&quot; + OBS_QP$);</span>
<span class="s0">//const QUOTED_STRING$ = subexp('\\&quot;' + subexp(FWS$ + &quot;?&quot; + QCONTENT$) + &quot;*&quot; + FWS$ + &quot;?&quot; + '\\&quot;');</span>
<span class="s3">var </span><span class="s2">ATEXT$$ = </span><span class="s4">&quot;[A-Za-z0-9</span><span class="s6">\\</span><span class="s4">!</span><span class="s6">\\</span><span class="s4">$</span><span class="s6">\\</span><span class="s4">%</span><span class="s6">\\</span><span class="s4">'</span><span class="s6">\\</span><span class="s4">*</span><span class="s6">\\</span><span class="s4">+</span><span class="s6">\\</span><span class="s4">-</span><span class="s6">\\</span><span class="s4">^</span><span class="s6">\\</span><span class="s4">_</span><span class="s6">\\</span><span class="s4">`</span><span class="s6">\\</span><span class="s4">{</span><span class="s6">\\</span><span class="s4">|</span><span class="s6">\\</span><span class="s4">}</span><span class="s6">\\</span><span class="s4">~]&quot;</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">QTEXT$$ = </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">!</span><span class="s6">\\</span><span class="s4">$</span><span class="s6">\\</span><span class="s4">%</span><span class="s6">\\</span><span class="s4">'</span><span class="s6">\\</span><span class="s4">(</span><span class="s6">\\</span><span class="s4">)</span><span class="s6">\\</span><span class="s4">*</span><span class="s6">\\</span><span class="s4">+</span><span class="s6">\\</span><span class="s4">,</span><span class="s6">\\</span><span class="s4">-</span><span class="s6">\\</span><span class="s4">.0-9</span><span class="s6">\\</span><span class="s4">&lt;</span><span class="s6">\\</span><span class="s4">&gt;A-Z</span><span class="s6">\\</span><span class="s4">x5E-</span><span class="s6">\\</span><span class="s4">x7E]&quot;</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">VCHAR$$ = merge(QTEXT$$, </span><span class="s4">&quot;[</span><span class="s6">\\\&quot;\\\\</span><span class="s4">]&quot;</span><span class="s2">);</span>
<span class="s3">var </span><span class="s2">SOME_DELIMS$$ = </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">!</span><span class="s6">\\</span><span class="s4">$</span><span class="s6">\\</span><span class="s4">'</span><span class="s6">\\</span><span class="s4">(</span><span class="s6">\\</span><span class="s4">)</span><span class="s6">\\</span><span class="s4">*</span><span class="s6">\\</span><span class="s4">+</span><span class="s6">\\</span><span class="s4">,</span><span class="s6">\\</span><span class="s4">;</span><span class="s6">\\</span><span class="s4">:</span><span class="s6">\\</span><span class="s4">@]&quot;</span><span class="s2">;</span>
<span class="s3">var </span><span class="s2">UNRESERVED = </span><span class="s3">new </span><span class="s2">RegExp(UNRESERVED$$, </span><span class="s4">&quot;g&quot;</span><span class="s2">);</span>
<span class="s3">var </span><span class="s2">PCT_ENCODED = </span><span class="s3">new </span><span class="s2">RegExp(PCT_ENCODED$, </span><span class="s4">&quot;g&quot;</span><span class="s2">);</span>
<span class="s3">var </span><span class="s2">NOT_LOCAL_PART = </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^]&quot;</span><span class="s2">, ATEXT$$, </span><span class="s4">&quot;[</span><span class="s6">\\</span><span class="s4">.]&quot;</span><span class="s2">, </span><span class="s4">'[</span><span class="s6">\\</span><span class="s4">&quot;]'</span><span class="s2">, VCHAR$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">);</span>
<span class="s3">var </span><span class="s2">NOT_HFNAME = </span><span class="s3">new </span><span class="s2">RegExp(merge(</span><span class="s4">&quot;[^]&quot;</span><span class="s2">, UNRESERVED$$, SOME_DELIMS$$), </span><span class="s4">&quot;g&quot;</span><span class="s2">);</span>
<span class="s3">var </span><span class="s2">NOT_HFVALUE = NOT_HFNAME;</span>
<span class="s3">function </span><span class="s2">decodeUnreserved(str) {</span>
    <span class="s3">var </span><span class="s2">decStr = pctDecChars(str);</span>
    <span class="s3">return </span><span class="s2">!decStr.match(UNRESERVED) ? str : decStr;</span>
<span class="s2">}</span>
<span class="s3">var </span><span class="s2">handler$4 = {</span>
    <span class="s2">scheme: </span><span class="s4">&quot;mailto&quot;</span><span class="s2">,</span>
    <span class="s2">parse: </span><span class="s3">function </span><span class="s2">parse$$1(components, options) {</span>
        <span class="s3">var </span><span class="s2">mailtoComponents = components;</span>
        <span class="s3">var </span><span class="s2">to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(</span><span class="s4">&quot;,&quot;</span><span class="s2">) : [];</span>
        <span class="s2">mailtoComponents.path = undefined;</span>
        <span class="s3">if </span><span class="s2">(mailtoComponents.query) {</span>
            <span class="s3">var </span><span class="s2">unknownHeaders = </span><span class="s3">false</span><span class="s2">;</span>
            <span class="s3">var </span><span class="s2">headers = {};</span>
            <span class="s3">var </span><span class="s2">hfields = mailtoComponents.query.split(</span><span class="s4">&quot;&amp;&quot;</span><span class="s2">);</span>
            <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">x = </span><span class="s5">0</span><span class="s2">, xl = hfields.length; x &lt; xl; ++x) {</span>
                <span class="s3">var </span><span class="s2">hfield = hfields[x].split(</span><span class="s4">&quot;=&quot;</span><span class="s2">);</span>
                <span class="s3">switch </span><span class="s2">(hfield[</span><span class="s5">0</span><span class="s2">]) {</span>
                    <span class="s3">case </span><span class="s4">&quot;to&quot;</span><span class="s2">:</span>
                        <span class="s3">var </span><span class="s2">toAddrs = hfield[</span><span class="s5">1</span><span class="s2">].split(</span><span class="s4">&quot;,&quot;</span><span class="s2">);</span>
                        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">_x = </span><span class="s5">0</span><span class="s2">, _xl = toAddrs.length; _x &lt; _xl; ++_x) {</span>
                            <span class="s2">to.push(toAddrs[_x]);</span>
                        <span class="s2">}</span>
                        <span class="s3">break</span><span class="s2">;</span>
                    <span class="s3">case </span><span class="s4">&quot;subject&quot;</span><span class="s2">:</span>
                        <span class="s2">mailtoComponents.subject = unescapeComponent(hfield[</span><span class="s5">1</span><span class="s2">], options);</span>
                        <span class="s3">break</span><span class="s2">;</span>
                    <span class="s3">case </span><span class="s4">&quot;body&quot;</span><span class="s2">:</span>
                        <span class="s2">mailtoComponents.body = unescapeComponent(hfield[</span><span class="s5">1</span><span class="s2">], options);</span>
                        <span class="s3">break</span><span class="s2">;</span>
                    <span class="s3">default</span><span class="s2">:</span>
                        <span class="s2">unknownHeaders = </span><span class="s3">true</span><span class="s2">;</span>
                        <span class="s2">headers[unescapeComponent(hfield[</span><span class="s5">0</span><span class="s2">], options)] = unescapeComponent(hfield[</span><span class="s5">1</span><span class="s2">], options);</span>
                        <span class="s3">break</span><span class="s2">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">if </span><span class="s2">(unknownHeaders) mailtoComponents.headers = headers;</span>
        <span class="s2">}</span>
        <span class="s2">mailtoComponents.query = undefined;</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">_x2 = </span><span class="s5">0</span><span class="s2">, _xl2 = to.length; _x2 &lt; _xl2; ++_x2) {</span>
            <span class="s3">var </span><span class="s2">addr = to[_x2].split(</span><span class="s4">&quot;@&quot;</span><span class="s2">);</span>
            <span class="s2">addr[</span><span class="s5">0</span><span class="s2">] = unescapeComponent(addr[</span><span class="s5">0</span><span class="s2">]);</span>
            <span class="s3">if </span><span class="s2">(!options.unicodeSupport) {</span>
                <span class="s0">//convert Unicode IDN -&gt; ASCII IDN</span>
                <span class="s3">try </span><span class="s2">{</span>
                    <span class="s2">addr[</span><span class="s5">1</span><span class="s2">] = punycode.toASCII(unescapeComponent(addr[</span><span class="s5">1</span><span class="s2">], options).toLowerCase());</span>
                <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
                    <span class="s2">mailtoComponents.error = mailtoComponents.error || </span><span class="s4">&quot;Email address's domain name can not be converted to ASCII via punycode: &quot; </span><span class="s2">+ e;</span>
                <span class="s2">}</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                <span class="s2">addr[</span><span class="s5">1</span><span class="s2">] = unescapeComponent(addr[</span><span class="s5">1</span><span class="s2">], options).toLowerCase();</span>
            <span class="s2">}</span>
            <span class="s2">to[_x2] = addr.join(</span><span class="s4">&quot;@&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s2">mailtoComponents;</span>
    <span class="s2">},</span>
    <span class="s2">serialize: </span><span class="s3">function </span><span class="s2">serialize$$1(mailtoComponents, options) {</span>
        <span class="s3">var </span><span class="s2">components = mailtoComponents;</span>
        <span class="s3">var </span><span class="s2">to = toArray(mailtoComponents.to);</span>
        <span class="s3">if </span><span class="s2">(to) {</span>
            <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">x = </span><span class="s5">0</span><span class="s2">, xl = to.length; x &lt; xl; ++x) {</span>
                <span class="s3">var </span><span class="s2">toAddr = String(to[x]);</span>
                <span class="s3">var </span><span class="s2">atIdx = toAddr.lastIndexOf(</span><span class="s4">&quot;@&quot;</span><span class="s2">);</span>
                <span class="s3">var </span><span class="s2">localPart = toAddr.slice(</span><span class="s5">0</span><span class="s2">, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);</span>
                <span class="s3">var </span><span class="s2">domain = toAddr.slice(atIdx + </span><span class="s5">1</span><span class="s2">);</span>
                <span class="s0">//convert IDN via punycode</span>
                <span class="s3">try </span><span class="s2">{</span>
                    <span class="s2">domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);</span>
                <span class="s2">} </span><span class="s3">catch </span><span class="s2">(e) {</span>
                    <span class="s2">components.error = components.error || </span><span class="s4">&quot;Email address's domain name can not be converted to &quot; </span><span class="s2">+ (!options.iri ? </span><span class="s4">&quot;ASCII&quot; </span><span class="s2">: </span><span class="s4">&quot;Unicode&quot;</span><span class="s2">) + </span><span class="s4">&quot; via punycode: &quot; </span><span class="s2">+ e;</span>
                <span class="s2">}</span>
                <span class="s2">to[x] = localPart + </span><span class="s4">&quot;@&quot; </span><span class="s2">+ domain;</span>
            <span class="s2">}</span>
            <span class="s2">components.path = to.join(</span><span class="s4">&quot;,&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s3">var </span><span class="s2">headers = mailtoComponents.headers = mailtoComponents.headers || {};</span>
        <span class="s3">if </span><span class="s2">(mailtoComponents.subject) headers[</span><span class="s4">&quot;subject&quot;</span><span class="s2">] = mailtoComponents.subject;</span>
        <span class="s3">if </span><span class="s2">(mailtoComponents.body) headers[</span><span class="s4">&quot;body&quot;</span><span class="s2">] = mailtoComponents.body;</span>
        <span class="s3">var </span><span class="s2">fields = [];</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s2">name </span><span class="s3">in </span><span class="s2">headers) {</span>
            <span class="s3">if </span><span class="s2">(headers[name] !== O[name]) {</span>
                <span class="s2">fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + </span><span class="s4">&quot;=&quot; </span><span class="s2">+ headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">if </span><span class="s2">(fields.length) {</span>
            <span class="s2">components.query = fields.join(</span><span class="s4">&quot;&amp;&quot;</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s2">components;</span>
    <span class="s2">}</span>
<span class="s2">};</span>

<span class="s3">var </span><span class="s2">URN_PARSE = </span><span class="s7">/^([^\:]+)\:(.*)/</span><span class="s2">;</span>
<span class="s0">//RFC 2141</span>
<span class="s3">var </span><span class="s2">handler$5 = {</span>
    <span class="s2">scheme: </span><span class="s4">&quot;urn&quot;</span><span class="s2">,</span>
    <span class="s2">parse: </span><span class="s3">function </span><span class="s2">parse$$1(components, options) {</span>
        <span class="s3">var </span><span class="s2">matches = components.path &amp;&amp; components.path.match(URN_PARSE);</span>
        <span class="s3">var </span><span class="s2">urnComponents = components;</span>
        <span class="s3">if </span><span class="s2">(matches) {</span>
            <span class="s3">var </span><span class="s2">scheme = options.scheme || urnComponents.scheme || </span><span class="s4">&quot;urn&quot;</span><span class="s2">;</span>
            <span class="s3">var </span><span class="s2">nid = matches[</span><span class="s5">1</span><span class="s2">].toLowerCase();</span>
            <span class="s3">var </span><span class="s2">nss = matches[</span><span class="s5">2</span><span class="s2">];</span>
            <span class="s3">var </span><span class="s2">urnScheme = scheme + </span><span class="s4">&quot;:&quot; </span><span class="s2">+ (options.nid || nid);</span>
            <span class="s3">var </span><span class="s2">schemeHandler = SCHEMES[urnScheme];</span>
            <span class="s2">urnComponents.nid = nid;</span>
            <span class="s2">urnComponents.nss = nss;</span>
            <span class="s2">urnComponents.path = undefined;</span>
            <span class="s3">if </span><span class="s2">(schemeHandler) {</span>
                <span class="s2">urnComponents = schemeHandler.parse(urnComponents, options);</span>
            <span class="s2">}</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s2">urnComponents.error = urnComponents.error || </span><span class="s4">&quot;URN can not be parsed.&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s2">urnComponents;</span>
    <span class="s2">},</span>
    <span class="s2">serialize: </span><span class="s3">function </span><span class="s2">serialize$$1(urnComponents, options) {</span>
        <span class="s3">var </span><span class="s2">scheme = options.scheme || urnComponents.scheme || </span><span class="s4">&quot;urn&quot;</span><span class="s2">;</span>
        <span class="s3">var </span><span class="s2">nid = urnComponents.nid;</span>
        <span class="s3">var </span><span class="s2">urnScheme = scheme + </span><span class="s4">&quot;:&quot; </span><span class="s2">+ (options.nid || nid);</span>
        <span class="s3">var </span><span class="s2">schemeHandler = SCHEMES[urnScheme];</span>
        <span class="s3">if </span><span class="s2">(schemeHandler) {</span>
            <span class="s2">urnComponents = schemeHandler.serialize(urnComponents, options);</span>
        <span class="s2">}</span>
        <span class="s3">var </span><span class="s2">uriComponents = urnComponents;</span>
        <span class="s3">var </span><span class="s2">nss = urnComponents.nss;</span>
        <span class="s2">uriComponents.path = (nid || options.nid) + </span><span class="s4">&quot;:&quot; </span><span class="s2">+ nss;</span>
        <span class="s3">return </span><span class="s2">uriComponents;</span>
    <span class="s2">}</span>
<span class="s2">};</span>

<span class="s3">var </span><span class="s2">UUID = </span><span class="s7">/^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/</span><span class="s2">;</span>
<span class="s0">//RFC 4122</span>
<span class="s3">var </span><span class="s2">handler$6 = {</span>
    <span class="s2">scheme: </span><span class="s4">&quot;urn:uuid&quot;</span><span class="s2">,</span>
    <span class="s2">parse: </span><span class="s3">function </span><span class="s2">parse(urnComponents, options) {</span>
        <span class="s3">var </span><span class="s2">uuidComponents = urnComponents;</span>
        <span class="s2">uuidComponents.uuid = uuidComponents.nss;</span>
        <span class="s2">uuidComponents.nss = undefined;</span>
        <span class="s3">if </span><span class="s2">(!options.tolerant &amp;&amp; (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {</span>
            <span class="s2">uuidComponents.error = uuidComponents.error || </span><span class="s4">&quot;UUID is not valid.&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s2">uuidComponents;</span>
    <span class="s2">},</span>
    <span class="s2">serialize: </span><span class="s3">function </span><span class="s2">serialize(uuidComponents, options) {</span>
        <span class="s3">var </span><span class="s2">urnComponents = uuidComponents;</span>
        <span class="s0">//normalize UUID</span>
        <span class="s2">urnComponents.nss = (uuidComponents.uuid || </span><span class="s4">&quot;&quot;</span><span class="s2">).toLowerCase();</span>
        <span class="s3">return </span><span class="s2">urnComponents;</span>
    <span class="s2">}</span>
<span class="s2">};</span>

<span class="s2">SCHEMES[handler.scheme] = handler;</span>
<span class="s2">SCHEMES[handler$1.scheme] = handler$1;</span>
<span class="s2">SCHEMES[handler$2.scheme] = handler$2;</span>
<span class="s2">SCHEMES[handler$3.scheme] = handler$3;</span>
<span class="s2">SCHEMES[handler$4.scheme] = handler$4;</span>
<span class="s2">SCHEMES[handler$5.scheme] = handler$5;</span>
<span class="s2">SCHEMES[handler$6.scheme] = handler$6;</span>

<span class="s2">exports.SCHEMES = SCHEMES;</span>
<span class="s2">exports.pctEncChar = pctEncChar;</span>
<span class="s2">exports.pctDecChars = pctDecChars;</span>
<span class="s2">exports.parse = parse;</span>
<span class="s2">exports.removeDotSegments = removeDotSegments;</span>
<span class="s2">exports.serialize = serialize;</span>
<span class="s2">exports.resolveComponents = resolveComponents;</span>
<span class="s2">exports.resolve = resolve;</span>
<span class="s2">exports.normalize = normalize;</span>
<span class="s2">exports.equal = equal;</span>
<span class="s2">exports.escapeComponent = escapeComponent;</span>
<span class="s2">exports.unescapeComponent = unescapeComponent;</span>

<span class="s2">Object.defineProperty(exports, </span><span class="s4">'__esModule'</span><span class="s2">, { value: </span><span class="s3">true </span><span class="s2">});</span>

<span class="s2">})));</span>
<span class="s0">//# sourceMappingURL=uri.all.js.map</span>
</pre>
</body>
</html>