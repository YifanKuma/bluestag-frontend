<html>
<head>
<title>turbopack-_cdba956c._.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #264eff;}
.s7 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
turbopack-_cdba956c._.js</font>
</center></td></tr></table>
<pre><span class="s0">(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([</span>
    <span class="s1">typeof </span><span class="s0">document === </span><span class="s2">&quot;object&quot; </span><span class="s0">? document.currentScript : undefined,</span>
    <span class="s0">{</span><span class="s2">&quot;otherChunks&quot;</span><span class="s0">:[</span><span class="s2">&quot;static/chunks/[turbopack]_browser_dev_hmr-client_hmr-client_ts_57d40746._.js&quot;</span><span class="s0">,</span><span class="s2">&quot;static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js&quot;</span><span class="s0">,</span><span class="s2">&quot;static/chunks/node_modules_next_dist_compiled_next-devtools_index_a9cb0712.js&quot;</span><span class="s0">,</span><span class="s2">&quot;static/chunks/node_modules_next_dist_compiled_5150ccfd._.js&quot;</span><span class="s0">,</span><span class="s2">&quot;static/chunks/node_modules_next_dist_client_cf1d9188._.js&quot;</span><span class="s0">,</span><span class="s2">&quot;static/chunks/node_modules_next_dist_b0daae9a._.js&quot;</span><span class="s0">,</span><span class="s2">&quot;static/chunks/node_modules_@swc_helpers_cjs_b3dc30d6._.js&quot;</span><span class="s0">],</span><span class="s2">&quot;runtimeModuleIds&quot;</span><span class="s0">:[</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">,</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-next-turbopack.js [app-client] (ecmascript)&quot;</span><span class="s0">]}</span>
<span class="s0">]);</span>
<span class="s0">(() =&gt; {</span>
<span class="s1">if </span><span class="s0">(!Array.isArray(globalThis.TURBOPACK)) {</span>
    <span class="s1">return</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">const </span><span class="s0">CHUNK_BASE_PATH = </span><span class="s2">&quot;/_next/&quot;</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">CHUNK_SUFFIX_PATH = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">RELATIVE_ROOT_PATH = </span><span class="s2">&quot;/ROOT&quot;</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">RUNTIME_PUBLIC_PATH = </span><span class="s2">&quot;/_next/&quot;</span><span class="s0">;</span>
<span class="s3">/**</span>
 <span class="s3">* This file contains runtime types and functions that are shared between all</span>
 <span class="s3">* TurboPack ECMAScript runtimes.</span>
 <span class="s3">*</span>
 <span class="s3">* It will be prepended to the runtime code of each runtime.</span>
 <span class="s3">*/ /* eslint-disable @typescript-eslint/no-unused-vars */ /// &lt;reference path=&quot;./runtime-types.d.ts&quot; /&gt;</span>
<span class="s1">const </span><span class="s0">REEXPORTED_OBJECTS = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
<span class="s3">/**</span>
 <span class="s3">* Constructs the `__turbopack_context__` object for a module.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">Context(module, exports) {</span>
    <span class="s1">this</span><span class="s0">.m = module;</span>
    <span class="s3">// We need to store this here instead of accessing it from the module object to:</span>
    <span class="s3">// 1. Make it available to factories directly, since we rewrite `this` to</span>
    <span class="s3">//    `__turbopack_context__.e` in CJS modules.</span>
    <span class="s3">// 2. Support async modules which rewrite `module.exports` to a promise, so we</span>
    <span class="s3">//    can still access the original exports object from functions like</span>
    <span class="s3">//    `esmExport`</span>
    <span class="s3">// Ideally we could find a new approach for async modules and drop this property altogether.</span>
    <span class="s1">this</span><span class="s0">.e = exports;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">contextPrototype = Context.prototype;</span>
<span class="s1">const </span><span class="s0">hasOwnProperty = Object.prototype.hasOwnProperty;</span>
<span class="s1">const </span><span class="s0">toStringTag = </span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; Symbol.toStringTag;</span>
<span class="s1">function </span><span class="s0">defineProp(obj, name, options) {</span>
    <span class="s1">if </span><span class="s0">(!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getOverwrittenModule(moduleCache, id) {</span>
    <span class="s1">let </span><span class="s0">module = moduleCache[id];</span>
    <span class="s1">if </span><span class="s0">(!module) {</span>
        <span class="s3">// This is invoked when a module is merged into another module, thus it wasn't invoked via</span>
        <span class="s3">// instantiateModule and the cache entry wasn't created yet.</span>
        <span class="s0">module = createModuleObject(id);</span>
        <span class="s0">moduleCache[id] = module;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">module;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Creates the module object. Only done here to ensure all module objects have the same shape.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">createModuleObject(id) {</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">exports: {},</span>
        <span class="s0">error: undefined,</span>
        <span class="s0">id,</span>
        <span class="s0">namespaceObject: undefined</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Adds the getters to the exports object.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">esm(exports, getters) {</span>
    <span class="s0">defineProp(exports, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s1">if </span><span class="s0">(toStringTag) defineProp(exports, toStringTag, {</span>
        <span class="s0">value: </span><span class="s2">'Module'</span>
    <span class="s0">});</span>
    <span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">while</span><span class="s0">(i &lt; getters.length){</span>
        <span class="s1">const </span><span class="s0">propName = getters[i++];</span>
        <span class="s3">// TODO(luke.sandberg): we could support raw values here, but would need a discriminator beyond 'not a function'</span>
        <span class="s1">const </span><span class="s0">getter = getters[i++];</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">getters[i] === </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s3">// a setter</span>
            <span class="s0">defineProp(exports, propName, {</span>
                <span class="s0">get: getter,</span>
                <span class="s0">set: getters[i++],</span>
                <span class="s0">enumerable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">defineProp(exports, propName, {</span>
                <span class="s0">get: getter,</span>
                <span class="s0">enumerable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">Object.seal(exports);</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Makes the module an ESM with exports</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">esmExport(getters, id) {</span>
    <span class="s1">let </span><span class="s0">module;</span>
    <span class="s1">let </span><span class="s0">exports;</span>
    <span class="s1">if </span><span class="s0">(id != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">module = getOverwrittenModule(</span><span class="s1">this</span><span class="s0">.c, id);</span>
        <span class="s0">exports = module.exports;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">module = </span><span class="s1">this</span><span class="s0">.m;</span>
        <span class="s0">exports = </span><span class="s1">this</span><span class="s0">.e;</span>
    <span class="s0">}</span>
    <span class="s0">module.namespaceObject = exports;</span>
    <span class="s0">esm(exports, getters);</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.s = esmExport;</span>
<span class="s1">function </span><span class="s0">ensureDynamicExports(module, exports) {</span>
    <span class="s1">let </span><span class="s0">reexportedObjects = REEXPORTED_OBJECTS.get(module);</span>
    <span class="s1">if </span><span class="s0">(!reexportedObjects) {</span>
        <span class="s0">REEXPORTED_OBJECTS.set(module, reexportedObjects = []);</span>
        <span class="s0">module.exports = module.namespaceObject = </span><span class="s1">new </span><span class="s0">Proxy(exports, {</span>
            <span class="s0">get (target, prop) {</span>
                <span class="s1">if </span><span class="s0">(hasOwnProperty.call(target, prop) || prop === </span><span class="s2">'default' </span><span class="s0">|| prop === </span><span class="s2">'__esModule'</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s0">Reflect.get(target, prop);</span>
                <span class="s0">}</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">obj of reexportedObjects){</span>
                    <span class="s1">const </span><span class="s0">value = Reflect.get(obj, prop);</span>
                    <span class="s1">if </span><span class="s0">(value !== undefined) </span><span class="s1">return </span><span class="s0">value;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">undefined;</span>
            <span class="s0">},</span>
            <span class="s0">ownKeys (target) {</span>
                <span class="s1">const </span><span class="s0">keys = Reflect.ownKeys(target);</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">obj of reexportedObjects){</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key of Reflect.ownKeys(obj)){</span>
                        <span class="s1">if </span><span class="s0">(key !== </span><span class="s2">'default' </span><span class="s0">&amp;&amp; !keys.includes(key)) keys.push(key);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">keys;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">reexportedObjects;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Dynamically exports properties from an object</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">dynamicExport(object, id) {</span>
    <span class="s1">let </span><span class="s0">module;</span>
    <span class="s1">let </span><span class="s0">exports;</span>
    <span class="s1">if </span><span class="s0">(id != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">module = getOverwrittenModule(</span><span class="s1">this</span><span class="s0">.c, id);</span>
        <span class="s0">exports = module.exports;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">module = </span><span class="s1">this</span><span class="s0">.m;</span>
        <span class="s0">exports = </span><span class="s1">this</span><span class="s0">.e;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">reexportedObjects = ensureDynamicExports(module, exports);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">object === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; object !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">reexportedObjects.push(object);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.j = dynamicExport;</span>
<span class="s1">function </span><span class="s0">exportValue(value, id) {</span>
    <span class="s1">let </span><span class="s0">module;</span>
    <span class="s1">if </span><span class="s0">(id != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">module = getOverwrittenModule(</span><span class="s1">this</span><span class="s0">.c, id);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">module = </span><span class="s1">this</span><span class="s0">.m;</span>
    <span class="s0">}</span>
    <span class="s0">module.exports = value;</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.v = exportValue;</span>
<span class="s1">function </span><span class="s0">exportNamespace(namespace, id) {</span>
    <span class="s1">let </span><span class="s0">module;</span>
    <span class="s1">if </span><span class="s0">(id != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">module = getOverwrittenModule(</span><span class="s1">this</span><span class="s0">.c, id);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">module = </span><span class="s1">this</span><span class="s0">.m;</span>
    <span class="s0">}</span>
    <span class="s0">module.exports = module.namespaceObject = namespace;</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.n = exportNamespace;</span>
<span class="s1">function </span><span class="s0">createGetter(obj, key) {</span>
    <span class="s1">return </span><span class="s0">()=&gt;obj[key];</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@returns </span><span class="s3">prototype of the object</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">getProto = Object.getPrototypeOf ? (obj)=&gt;Object.getPrototypeOf(obj) : (obj)=&gt;obj.__proto__;</span>
<span class="s3">/** Prototypes that are not expanded for exports */ </span><span class="s1">const </span><span class="s0">LEAF_PROTOTYPES = [</span>
    <span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getProto({}),</span>
    <span class="s0">getProto([]),</span>
    <span class="s0">getProto(getProto)</span>
<span class="s0">];</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@param </span><span class="s3">raw</span>
 <span class="s3">* </span><span class="s5">@param </span><span class="s3">ns</span>
 <span class="s3">* </span><span class="s5">@param </span><span class="s3">allowExportDefault</span>
 <span class="s3">*   * `false`: will have the raw module as default export</span>
 <span class="s3">*   * `true`: will have the default property as default export</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">interopEsm(raw, ns, allowExportDefault) {</span>
    <span class="s1">const </span><span class="s0">getters = [];</span>
    <span class="s3">// The index of the `default` export if any</span>
    <span class="s1">let </span><span class="s0">defaultLocation = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">current = raw; (</span><span class="s1">typeof </span><span class="s0">current === </span><span class="s2">'object' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">current === </span><span class="s2">'function'</span><span class="s0">) &amp;&amp; !LEAF_PROTOTYPES.includes(current); current = getProto(current)){</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key of Object.getOwnPropertyNames(current)){</span>
            <span class="s0">getters.push(key, createGetter(raw, key));</span>
            <span class="s1">if </span><span class="s0">(defaultLocation === -</span><span class="s4">1 </span><span class="s0">&amp;&amp; key === </span><span class="s2">'default'</span><span class="s0">) {</span>
                <span class="s0">defaultLocation = getters.length - </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// this is not really correct</span>
    <span class="s3">// we should set the `default` getter if the imported module is a `.cjs file`</span>
    <span class="s1">if </span><span class="s0">(!(allowExportDefault &amp;&amp; defaultLocation &gt;= </span><span class="s4">0</span><span class="s0">)) {</span>
        <span class="s3">// Replace the binding with one for the namespace itself in order to preserve iteration order.</span>
        <span class="s1">if </span><span class="s0">(defaultLocation &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">getters[defaultLocation] = ()=&gt;raw;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">getters.push(</span><span class="s2">'default'</span><span class="s0">, ()=&gt;raw);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">esm(ns, getters);</span>
    <span class="s1">return </span><span class="s0">ns;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createNS(raw) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">raw === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s1">return function</span><span class="s0">(...args) {</span>
            <span class="s1">return </span><span class="s0">raw.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
        <span class="s0">};</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">Object.create(</span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">esmImport(id) {</span>
    <span class="s1">const </span><span class="s0">module = getOrInstantiateModuleFromParent(id, </span><span class="s1">this</span><span class="s0">.m);</span>
    <span class="s3">// any ES module has to have `module.namespaceObject` defined.</span>
    <span class="s1">if </span><span class="s0">(module.namespaceObject) </span><span class="s1">return </span><span class="s0">module.namespaceObject;</span>
    <span class="s3">// only ESM can be an async module, so we don't need to worry about exports being a promise here.</span>
    <span class="s1">const </span><span class="s0">raw = module.exports;</span>
    <span class="s1">return </span><span class="s0">module.namespaceObject = interopEsm(raw, createNS(raw), raw &amp;&amp; raw.__esModule);</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.i = esmImport;</span>
<span class="s1">function </span><span class="s0">asyncLoader(moduleId) {</span>
    <span class="s1">const </span><span class="s0">loader = </span><span class="s1">this</span><span class="s0">.r(moduleId);</span>
    <span class="s1">return </span><span class="s0">loader(</span><span class="s1">this</span><span class="s0">.i.bind(</span><span class="s1">this</span><span class="s0">));</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.A = asyncLoader;</span>
<span class="s3">// Add a simple runtime require so that environments without one can still pass</span>
<span class="s3">// `typeof require` CommonJS checks so that exports are correctly registered.</span>
<span class="s1">const </span><span class="s0">runtimeRequire = </span><span class="s3">// @ts-ignore</span>
<span class="s1">typeof </span><span class="s0">require === </span><span class="s2">'function' </span><span class="s0">? require : </span><span class="s1">function </span><span class="s0">require1() {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Unexpected use of runtime require'</span><span class="s0">);</span>
<span class="s0">};</span>
<span class="s0">contextPrototype.t = runtimeRequire;</span>
<span class="s1">function </span><span class="s0">commonJsRequire(id) {</span>
    <span class="s1">return </span><span class="s0">getOrInstantiateModuleFromParent(id, </span><span class="s1">this</span><span class="s0">.m).exports;</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.r = commonJsRequire;</span>
<span class="s3">/**</span>
 <span class="s3">* `require.context` and require/import expression runtime.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">moduleContext(map) {</span>
    <span class="s1">function </span><span class="s0">moduleContext(id) {</span>
        <span class="s1">if </span><span class="s0">(hasOwnProperty.call(map, id)) {</span>
            <span class="s1">return </span><span class="s0">map[id].module();</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">e = </span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">`Cannot find module '</span><span class="s0">${id}</span><span class="s2">'`</span><span class="s0">);</span>
        <span class="s0">e.code = </span><span class="s2">'MODULE_NOT_FOUND'</span><span class="s0">;</span>
        <span class="s1">throw </span><span class="s0">e;</span>
    <span class="s0">}</span>
    <span class="s0">moduleContext.keys = ()=&gt;{</span>
        <span class="s1">return </span><span class="s0">Object.keys(map);</span>
    <span class="s0">};</span>
    <span class="s0">moduleContext.resolve = (id)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(hasOwnProperty.call(map, id)) {</span>
            <span class="s1">return </span><span class="s0">map[id].id();</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">e = </span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">`Cannot find module '</span><span class="s0">${id}</span><span class="s2">'`</span><span class="s0">);</span>
        <span class="s0">e.code = </span><span class="s2">'MODULE_NOT_FOUND'</span><span class="s0">;</span>
        <span class="s1">throw </span><span class="s0">e;</span>
    <span class="s0">};</span>
    <span class="s0">moduleContext.import = async (id)=&gt;{</span>
        <span class="s1">return await </span><span class="s0">moduleContext(id);</span>
    <span class="s0">};</span>
    <span class="s1">return </span><span class="s0">moduleContext;</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.f = moduleContext;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns the path of a chunk defined by its data.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">getChunkPath(chunkData) {</span>
    <span class="s1">return typeof </span><span class="s0">chunkData === </span><span class="s2">'string' </span><span class="s0">? chunkData : chunkData.path;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isPromise(maybePromise) {</span>
    <span class="s1">return </span><span class="s0">maybePromise != </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">maybePromise === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s2">'then' </span><span class="s1">in </span><span class="s0">maybePromise &amp;&amp; </span><span class="s1">typeof </span><span class="s0">maybePromise.then === </span><span class="s2">'function'</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isAsyncModuleExt(obj) {</span>
    <span class="s1">return </span><span class="s0">turbopackQueues </span><span class="s1">in </span><span class="s0">obj;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createPromise() {</span>
    <span class="s1">let </span><span class="s0">resolve;</span>
    <span class="s1">let </span><span class="s0">reject;</span>
    <span class="s1">const </span><span class="s0">promise = </span><span class="s1">new </span><span class="s0">Promise((res, rej)=&gt;{</span>
        <span class="s0">reject = rej;</span>
        <span class="s0">resolve = res;</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">promise,</span>
        <span class="s0">resolve: resolve,</span>
        <span class="s0">reject: reject</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.</span>
<span class="s3">// The CompressedModuleFactories format is</span>
<span class="s3">// - 1 or more module ids</span>
<span class="s3">// - a module factory function</span>
<span class="s3">// So walking this is a little complex but the flat structure is also fast to</span>
<span class="s3">// traverse, we can use `typeof` operators to distinguish the two cases.</span>
<span class="s1">function </span><span class="s0">installCompressedModuleFactories(chunkModules, offset, moduleFactories, newModuleId) {</span>
    <span class="s1">let </span><span class="s0">i = offset;</span>
    <span class="s1">while</span><span class="s0">(i &lt; chunkModules.length){</span>
        <span class="s1">let </span><span class="s0">moduleId = chunkModules[i];</span>
        <span class="s1">let </span><span class="s0">end = i + </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s3">// Find our factory function</span>
        <span class="s1">while</span><span class="s0">(end &lt; chunkModules.length &amp;&amp; </span><span class="s1">typeof </span><span class="s0">chunkModules[end] !== </span><span class="s2">'function'</span><span class="s0">){</span>
            <span class="s0">end++;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(end === chunkModules.length) {</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'malformed chunk format, expected a factory function'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s3">// Each chunk item has a 'primary id' and optional additional ids. If the primary id is already</span>
        <span class="s3">// present we know all the additional ids are also present, so we don't need to check.</span>
        <span class="s1">if </span><span class="s0">(!moduleFactories.has(moduleId)) {</span>
            <span class="s1">const </span><span class="s0">moduleFactoryFn = chunkModules[end];</span>
            <span class="s0">applyModuleFactoryName(moduleFactoryFn);</span>
            <span class="s0">newModuleId?.(moduleId);</span>
            <span class="s1">for</span><span class="s0">(; i &lt; end; i++){</span>
                <span class="s0">moduleId = chunkModules[i];</span>
                <span class="s0">moduleFactories.set(moduleId, moduleFactoryFn);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">i = end + </span><span class="s4">1</span><span class="s0">; </span><span class="s3">// end is pointing at the last factory advance to the next id or the end of the array.</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s3">// everything below is adapted from webpack</span>
<span class="s3">// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13</span>
<span class="s1">const </span><span class="s0">turbopackQueues = Symbol(</span><span class="s2">'turbopack queues'</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">turbopackExports = Symbol(</span><span class="s2">'turbopack exports'</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">turbopackError = Symbol(</span><span class="s2">'turbopack error'</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">resolveQueue(queue) {</span>
    <span class="s1">if </span><span class="s0">(queue &amp;&amp; queue.status !== </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">queue.status = </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">queue.forEach((fn)=&gt;fn.queueCount--);</span>
        <span class="s0">queue.forEach((fn)=&gt;fn.queueCount-- ? fn.queueCount++ : fn());</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">wrapDeps(deps) {</span>
    <span class="s1">return </span><span class="s0">deps.map((dep)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(dep !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">dep === </span><span class="s2">'object'</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(isAsyncModuleExt(dep)) </span><span class="s1">return </span><span class="s0">dep;</span>
            <span class="s1">if </span><span class="s0">(isPromise(dep)) {</span>
                <span class="s1">const </span><span class="s0">queue = Object.assign([], {</span>
                    <span class="s0">status: </span><span class="s4">0</span>
                <span class="s0">});</span>
                <span class="s1">const </span><span class="s0">obj = {</span>
                    <span class="s0">[turbopackExports]: {},</span>
                    <span class="s0">[turbopackQueues]: (fn)=&gt;fn(queue)</span>
                <span class="s0">};</span>
                <span class="s0">dep.then((res)=&gt;{</span>
                    <span class="s0">obj[turbopackExports] = res;</span>
                    <span class="s0">resolveQueue(queue);</span>
                <span class="s0">}, (err)=&gt;{</span>
                    <span class="s0">obj[turbopackError] = err;</span>
                    <span class="s0">resolveQueue(queue);</span>
                <span class="s0">});</span>
                <span class="s1">return </span><span class="s0">obj;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">[turbopackExports]: dep,</span>
            <span class="s0">[turbopackQueues]: ()=&gt;{}</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">asyncModule(body, hasAwait) {</span>
    <span class="s1">const </span><span class="s0">module = </span><span class="s1">this</span><span class="s0">.m;</span>
    <span class="s1">const </span><span class="s0">queue = hasAwait ? Object.assign([], {</span>
        <span class="s0">status: -</span><span class="s4">1</span>
    <span class="s0">}) : undefined;</span>
    <span class="s1">const </span><span class="s0">depQueues = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">{ resolve, reject, promise: rawPromise } = createPromise();</span>
    <span class="s1">const </span><span class="s0">promise = Object.assign(rawPromise, {</span>
        <span class="s0">[turbopackExports]: module.exports,</span>
        <span class="s0">[turbopackQueues]: (fn)=&gt;{</span>
            <span class="s0">queue &amp;&amp; fn(queue);</span>
            <span class="s0">depQueues.forEach(fn);</span>
            <span class="s0">promise[</span><span class="s2">'catch'</span><span class="s0">](()=&gt;{});</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">attributes = {</span>
        <span class="s0">get () {</span>
            <span class="s1">return </span><span class="s0">promise;</span>
        <span class="s0">},</span>
        <span class="s0">set (v) {</span>
            <span class="s3">// Calling `esmExport` leads to this.</span>
            <span class="s1">if </span><span class="s0">(v !== promise) {</span>
                <span class="s0">promise[turbopackExports] = v;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s0">Object.defineProperty(module, </span><span class="s2">'exports'</span><span class="s0">, attributes);</span>
    <span class="s0">Object.defineProperty(module, </span><span class="s2">'namespaceObject'</span><span class="s0">, attributes);</span>
    <span class="s1">function </span><span class="s0">handleAsyncDependencies(deps) {</span>
        <span class="s1">const </span><span class="s0">currentDeps = wrapDeps(deps);</span>
        <span class="s1">const </span><span class="s0">getResult = ()=&gt;currentDeps.map((d)=&gt;{</span>
                <span class="s1">if </span><span class="s0">(d[turbopackError]) </span><span class="s1">throw </span><span class="s0">d[turbopackError];</span>
                <span class="s1">return </span><span class="s0">d[turbopackExports];</span>
            <span class="s0">});</span>
        <span class="s1">const </span><span class="s0">{ promise, resolve } = createPromise();</span>
        <span class="s1">const </span><span class="s0">fn = Object.assign(()=&gt;resolve(getResult), {</span>
            <span class="s0">queueCount: </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s1">function </span><span class="s0">fnQueue(q) {</span>
            <span class="s1">if </span><span class="s0">(q !== queue &amp;&amp; !depQueues.has(q)) {</span>
                <span class="s0">depQueues.add(q);</span>
                <span class="s1">if </span><span class="s0">(q &amp;&amp; q.status === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">fn.queueCount++;</span>
                    <span class="s0">q.push(fn);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">currentDeps.map((dep)=&gt;dep[turbopackQueues](fnQueue));</span>
        <span class="s1">return </span><span class="s0">fn.queueCount ? promise : getResult();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">asyncResult(err) {</span>
        <span class="s1">if </span><span class="s0">(err) {</span>
            <span class="s0">reject(promise[turbopackError] = err);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">resolve(promise[turbopackExports]);</span>
        <span class="s0">}</span>
        <span class="s0">resolveQueue(queue);</span>
    <span class="s0">}</span>
    <span class="s0">body(handleAsyncDependencies, asyncResult);</span>
    <span class="s1">if </span><span class="s0">(queue &amp;&amp; queue.status === -</span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">queue.status = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.a = asyncModule;</span>
<span class="s3">/**</span>
 <span class="s3">* A pseudo &quot;fake&quot; URL object to resolve to its relative path.</span>
 <span class="s3">*</span>
 <span class="s3">* When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this</span>
 <span class="s3">* runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid</span>
 <span class="s3">* hydration mismatch.</span>
 <span class="s3">*</span>
 <span class="s3">* This is based on webpack's existing implementation:</span>
 <span class="s3">* https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">relativeURL = </span><span class="s1">function </span><span class="s0">relativeURL(inputUrl) {</span>
    <span class="s1">const </span><span class="s0">realUrl = </span><span class="s1">new </span><span class="s0">URL(inputUrl, </span><span class="s2">'x:/'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">values = {};</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">realUrl)values[key] = realUrl[key];</span>
    <span class="s0">values.href = inputUrl;</span>
    <span class="s0">values.pathname = inputUrl.replace(</span><span class="s6">/[?#].*/</span><span class="s0">, </span><span class="s2">''</span><span class="s0">);</span>
    <span class="s0">values.origin = values.protocol = </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">values.toString = values.toJSON = (..._args)=&gt;inputUrl;</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">values)Object.defineProperty(</span><span class="s1">this</span><span class="s0">, key, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">value: values[key]</span>
    <span class="s0">});</span>
<span class="s0">};</span>
<span class="s0">relativeURL.prototype = URL.prototype;</span>
<span class="s0">contextPrototype.U = relativeURL;</span>
<span class="s3">/**</span>
 <span class="s3">* Utility function to ensure all variants of an enum are handled.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">invariant(never, computeMessage) {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`Invariant: </span><span class="s0">${computeMessage(never)}</span><span class="s2">`</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* A stub function to make `require` available but non-functional in ESM.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">requireStub(_moduleId) {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'dynamic usage of require is not supported'</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.z = requireStub;</span>
<span class="s3">// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.</span>
<span class="s0">contextPrototype.g = globalThis;</span>
<span class="s1">function </span><span class="s0">applyModuleFactoryName(factory) {</span>
    <span class="s3">// Give the module factory a nice name to improve stack traces.</span>
    <span class="s0">Object.defineProperty(factory, </span><span class="s2">'name'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">'__TURBOPACK__module__evaluation__'</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* This file contains runtime types and functions that are shared between all</span>
 <span class="s3">* Turbopack *development* ECMAScript runtimes.</span>
 <span class="s3">*</span>
 <span class="s3">* It will be appended to the runtime code of each runtime right after the</span>
 <span class="s3">* shared runtime utils.</span>
 <span class="s3">*/ /* eslint-disable @typescript-eslint/no-unused-vars */ /// &lt;reference path=&quot;../base/globals.d.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;../../../shared/runtime-utils.ts&quot; /&gt;</span>
<span class="s3">// Used in WebWorkers to tell the runtime about the chunk base path</span>
<span class="s1">const </span><span class="s0">browserContextPrototype = Context.prototype;</span>
<span class="s1">var </span><span class="s0">SourceType = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">function</span><span class="s0">(SourceType) {</span>
    <span class="s3">/**</span>
   <span class="s3">* The module was instantiated because it was included in an evaluated chunk's</span>
   <span class="s3">* runtime.</span>
   <span class="s3">* SourceData is a ChunkPath.</span>
   <span class="s3">*/ </span><span class="s0">SourceType[SourceType[</span><span class="s2">&quot;Runtime&quot;</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">] = </span><span class="s2">&quot;Runtime&quot;</span><span class="s0">;</span>
    <span class="s3">/**</span>
   <span class="s3">* The module was instantiated because a parent module imported it.</span>
   <span class="s3">* SourceData is a ModuleId.</span>
   <span class="s3">*/ </span><span class="s0">SourceType[SourceType[</span><span class="s2">&quot;Parent&quot;</span><span class="s0">] = </span><span class="s4">1</span><span class="s0">] = </span><span class="s2">&quot;Parent&quot;</span><span class="s0">;</span>
    <span class="s3">/**</span>
   <span class="s3">* The module was instantiated because it was included in a chunk's hot module</span>
   <span class="s3">* update.</span>
   <span class="s3">* SourceData is an array of ModuleIds or undefined.</span>
   <span class="s3">*/ </span><span class="s0">SourceType[SourceType[</span><span class="s2">&quot;Update&quot;</span><span class="s0">] = </span><span class="s4">2</span><span class="s0">] = </span><span class="s2">&quot;Update&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">SourceType;</span>
<span class="s0">}(SourceType || {});</span>
<span class="s1">const </span><span class="s0">moduleFactories = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s0">contextPrototype.M = moduleFactories;</span>
<span class="s1">const </span><span class="s0">availableModules = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">const </span><span class="s0">availableModuleChunks = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">function </span><span class="s0">factoryNotAvailable(moduleId, sourceType, sourceData) {</span>
    <span class="s1">let </span><span class="s0">instantiationReason;</span>
    <span class="s1">switch</span><span class="s0">(sourceType){</span>
        <span class="s1">case </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">instantiationReason = </span><span class="s2">`as a runtime entry of chunk </span><span class="s0">${sourceData}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">instantiationReason = </span><span class="s2">`because it was required from module </span><span class="s0">${sourceData}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s0">instantiationReason = </span><span class="s2">'because of an HMR update'</span><span class="s0">;</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">invariant(sourceType, (sourceType)=&gt;</span><span class="s2">`Unknown source type: </span><span class="s0">${sourceType}</span><span class="s2">`</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`Module </span><span class="s0">${moduleId} </span><span class="s2">was instantiated </span><span class="s0">${instantiationReason}</span><span class="s2">, but the module factory is not available. It might have been deleted in an HMR update.`</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">loadChunk(chunkData) {</span>
    <span class="s1">return </span><span class="s0">loadChunkInternal(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.m.id, chunkData);</span>
<span class="s0">}</span>
<span class="s0">browserContextPrototype.l = loadChunk;</span>
<span class="s1">function </span><span class="s0">loadInitialChunk(chunkPath, chunkData) {</span>
    <span class="s1">return </span><span class="s0">loadChunkInternal(</span><span class="s4">0</span><span class="s0">, chunkPath, chunkData);</span>
<span class="s0">}</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">loadChunkInternal(sourceType, sourceData, chunkData) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">chunkData === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">loadChunkPath(sourceType, sourceData, chunkData);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">includedList = chunkData.included || [];</span>
    <span class="s1">const </span><span class="s0">modulesPromises = includedList.map((included)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(moduleFactories.has(included)) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">availableModules.get(included);</span>
    <span class="s0">});</span>
    <span class="s1">if </span><span class="s0">(modulesPromises.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; modulesPromises.every((p)=&gt;p)) {</span>
        <span class="s3">// When all included items are already loaded or loading, we can skip loading ourselves</span>
        <span class="s1">await </span><span class="s0">Promise.all(modulesPromises);</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">includedModuleChunksList = chunkData.moduleChunks || [];</span>
    <span class="s1">const </span><span class="s0">moduleChunksPromises = includedModuleChunksList.map((included)=&gt;{</span>
        <span class="s3">// TODO(alexkirsz) Do we need this check?</span>
        <span class="s3">// if (moduleFactories[included]) return true;</span>
        <span class="s1">return </span><span class="s0">availableModuleChunks.get(included);</span>
    <span class="s0">}).filter((p)=&gt;p);</span>
    <span class="s1">let </span><span class="s0">promise;</span>
    <span class="s1">if </span><span class="s0">(moduleChunksPromises.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s3">// Some module chunks are already loaded or loading.</span>
        <span class="s1">if </span><span class="s0">(moduleChunksPromises.length === includedModuleChunksList.length) {</span>
            <span class="s3">// When all included module chunks are already loaded or loading, we can skip loading ourselves</span>
            <span class="s1">await </span><span class="s0">Promise.all(moduleChunksPromises);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">moduleChunksToLoad = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleChunk of includedModuleChunksList){</span>
            <span class="s1">if </span><span class="s0">(!availableModuleChunks.has(moduleChunk)) {</span>
                <span class="s0">moduleChunksToLoad.add(moduleChunk);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleChunkToLoad of moduleChunksToLoad){</span>
            <span class="s1">const </span><span class="s0">promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad);</span>
            <span class="s0">availableModuleChunks.set(moduleChunkToLoad, promise);</span>
            <span class="s0">moduleChunksPromises.push(promise);</span>
        <span class="s0">}</span>
        <span class="s0">promise = Promise.all(moduleChunksPromises);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">promise = loadChunkPath(sourceType, sourceData, chunkData.path);</span>
        <span class="s3">// Mark all included module chunks as loading if they are not already loaded or loading.</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">includedModuleChunk of includedModuleChunksList){</span>
            <span class="s1">if </span><span class="s0">(!availableModuleChunks.has(includedModuleChunk)) {</span>
                <span class="s0">availableModuleChunks.set(includedModuleChunk, promise);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">included of includedList){</span>
        <span class="s1">if </span><span class="s0">(!availableModules.has(included)) {</span>
            <span class="s3">// It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.</span>
            <span class="s3">// In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.</span>
            <span class="s0">availableModules.set(included, promise);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">await </span><span class="s0">promise;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">loadedChunk = Promise.resolve(undefined);</span>
<span class="s1">const </span><span class="s0">instrumentedBackendLoadChunks = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
<span class="s3">// Do not make this async. React relies on referential equality of the returned Promise.</span>
<span class="s1">function </span><span class="s0">loadChunkByUrl(chunkUrl) {</span>
    <span class="s1">return </span><span class="s0">loadChunkByUrlInternal(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.m.id, chunkUrl);</span>
<span class="s0">}</span>
<span class="s0">browserContextPrototype.L = loadChunkByUrl;</span>
<span class="s3">// Do not make this async. React relies on referential equality of the returned Promise.</span>
<span class="s1">function </span><span class="s0">loadChunkByUrlInternal(sourceType, sourceData, chunkUrl) {</span>
    <span class="s1">const </span><span class="s0">thenable = BACKEND.loadChunkCached(sourceType, chunkUrl);</span>
    <span class="s1">let </span><span class="s0">entry = instrumentedBackendLoadChunks.get(thenable);</span>
    <span class="s1">if </span><span class="s0">(entry === undefined) {</span>
        <span class="s1">const </span><span class="s0">resolve = instrumentedBackendLoadChunks.set.bind(instrumentedBackendLoadChunks, thenable, loadedChunk);</span>
        <span class="s0">entry = thenable.then(resolve).catch((error)=&gt;{</span>
            <span class="s1">let </span><span class="s0">loadReason;</span>
            <span class="s1">switch</span><span class="s0">(sourceType){</span>
                <span class="s1">case </span><span class="s4">0</span><span class="s0">:</span>
                    <span class="s0">loadReason = </span><span class="s2">`as a runtime dependency of chunk </span><span class="s0">${sourceData}</span><span class="s2">`</span><span class="s0">;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">case </span><span class="s4">1</span><span class="s0">:</span>
                    <span class="s0">loadReason = </span><span class="s2">`from module </span><span class="s0">${sourceData}</span><span class="s2">`</span><span class="s0">;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">case </span><span class="s4">2</span><span class="s0">:</span>
                    <span class="s0">loadReason = </span><span class="s2">'from an HMR update'</span><span class="s0">;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">default</span><span class="s0">:</span>
                    <span class="s0">invariant(sourceType, (sourceType)=&gt;</span><span class="s2">`Unknown source type: </span><span class="s0">${sourceType}</span><span class="s2">`</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`Failed to load chunk </span><span class="s0">${chunkUrl} ${loadReason}${error ? </span><span class="s2">`: </span><span class="s0">${error}</span><span class="s2">` </span><span class="s0">: </span><span class="s2">''</span><span class="s0">}</span><span class="s2">`</span><span class="s0">, error ? {</span>
                <span class="s0">cause: error</span>
            <span class="s0">} : undefined);</span>
        <span class="s0">});</span>
        <span class="s0">instrumentedBackendLoadChunks.set(thenable, entry);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">entry;</span>
<span class="s0">}</span>
<span class="s3">// Do not make this async. React relies on referential equality of the returned Promise.</span>
<span class="s1">function </span><span class="s0">loadChunkPath(sourceType, sourceData, chunkPath) {</span>
    <span class="s1">const </span><span class="s0">url = getChunkRelativeUrl(chunkPath);</span>
    <span class="s1">return </span><span class="s0">loadChunkByUrlInternal(sourceType, sourceData, url);</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Returns an absolute url to an asset.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">resolvePathFromModule(moduleId) {</span>
    <span class="s1">const </span><span class="s0">exported = </span><span class="s1">this</span><span class="s0">.r(moduleId);</span>
    <span class="s1">return </span><span class="s0">exported?.default ?? exported;</span>
<span class="s0">}</span>
<span class="s0">browserContextPrototype.R = resolvePathFromModule;</span>
<span class="s3">/**</span>
 <span class="s3">* no-op for browser</span>
 <span class="s3">* </span><span class="s5">@param </span><span class="s3">modulePath</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">resolveAbsolutePath(modulePath) {</span>
    <span class="s1">return </span><span class="s2">`/ROOT/</span><span class="s0">${modulePath ?? </span><span class="s2">''</span><span class="s0">}</span><span class="s2">`</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s0">browserContextPrototype.P = resolveAbsolutePath;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns a blob URL for the worker.</span>
 <span class="s3">* </span><span class="s5">@param </span><span class="s3">chunks list of chunks to load</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">getWorkerBlobURL(chunks) {</span>
    <span class="s3">// It is important to reverse the array so when bootstrapping we can infer what chunk is being</span>
    <span class="s3">// evaluated by poping urls off of this array.  See `getPathFromScript`</span>
    <span class="s1">let </span><span class="s0">bootstrap = </span><span class="s2">`self.TURBOPACK_WORKER_LOCATION = </span><span class="s0">${JSON.stringify(location.origin)}</span><span class="s2">; 
self.TURBOPACK_NEXT_CHUNK_URLS = </span><span class="s0">${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), </span><span class="s1">null</span><span class="s0">, </span><span class="s4">2</span><span class="s0">)}</span><span class="s2">; 
importScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c =&gt; self.TURBOPACK_WORKER_LOCATION + c).reverse());`</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">blob = </span><span class="s1">new </span><span class="s0">Blob([</span>
        <span class="s0">bootstrap</span>
    <span class="s0">], {</span>
        <span class="s0">type: </span><span class="s2">'text/javascript'</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">URL.createObjectURL(blob);</span>
<span class="s0">}</span>
<span class="s0">browserContextPrototype.b = getWorkerBlobURL;</span>
<span class="s3">/**</span>
 <span class="s3">* Instantiates a runtime module.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">instantiateRuntimeModule(moduleId, chunkPath) {</span>
    <span class="s1">return </span><span class="s0">instantiateModule(moduleId, </span><span class="s4">0</span><span class="s0">, chunkPath);</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Returns the URL relative to the origin where a chunk can be fetched from.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">getChunkRelativeUrl(chunkPath) {</span>
    <span class="s1">return </span><span class="s2">`</span><span class="s0">${CHUNK_BASE_PATH}${chunkPath.split(</span><span class="s2">'/'</span><span class="s0">).map((p)=&gt;encodeURIComponent(p)).join(</span><span class="s2">'/'</span><span class="s0">)}${CHUNK_SUFFIX_PATH}</span><span class="s2">`</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getPathFromScript(chunkScript) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">chunkScript === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">chunkScript;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">chunkUrl = </span><span class="s1">typeof </span><span class="s0">TURBOPACK_NEXT_CHUNK_URLS !== </span><span class="s2">'undefined' </span><span class="s0">? TURBOPACK_NEXT_CHUNK_URLS.pop() : chunkScript.getAttribute(</span><span class="s2">'src'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">src = decodeURIComponent(chunkUrl.replace(</span><span class="s6">/[?#].*$/</span><span class="s0">, </span><span class="s2">''</span><span class="s0">));</span>
    <span class="s1">const </span><span class="s0">path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;</span>
    <span class="s1">return </span><span class="s0">path;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">regexJsUrl = </span><span class="s6">/\.js(?:\?[^#]*)?(?:#.*)?$/</span><span class="s0">;</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">isJs(chunkUrlOrPath) {</span>
    <span class="s1">return </span><span class="s0">regexJsUrl.test(chunkUrlOrPath);</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">regexCssUrl = </span><span class="s6">/\.css(?:\?[^#]*)?(?:#.*)?$/</span><span class="s0">;</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">isCss(chunkUrl) {</span>
    <span class="s1">return </span><span class="s0">regexCssUrl.test(chunkUrl);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">loadWebAssembly(chunkPath, edgeModule, importsObj) {</span>
    <span class="s1">return </span><span class="s0">BACKEND.loadWebAssembly(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.m.id, chunkPath, edgeModule, importsObj);</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.w = loadWebAssembly;</span>
<span class="s1">function </span><span class="s0">loadWebAssemblyModule(chunkPath, edgeModule) {</span>
    <span class="s1">return </span><span class="s0">BACKEND.loadWebAssemblyModule(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.m.id, chunkPath, edgeModule);</span>
<span class="s0">}</span>
<span class="s0">contextPrototype.u = loadWebAssemblyModule;</span>
<span class="s3">/// &lt;reference path=&quot;./dev-globals.d.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;./dev-protocol.d.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;./dev-extensions.ts&quot; /&gt;</span>
<span class="s1">const </span><span class="s0">devContextPrototype = Context.prototype;</span>
<span class="s3">/**</span>
 <span class="s3">* This file contains runtime types and functions that are shared between all</span>
 <span class="s3">* Turbopack *development* ECMAScript runtimes.</span>
 <span class="s3">*</span>
 <span class="s3">* It will be appended to the runtime code of each runtime right after the</span>
 <span class="s3">* shared runtime utils.</span>
 <span class="s3">*/ /* eslint-disable @typescript-eslint/no-unused-vars */ </span><span class="s1">const </span><span class="s0">devModuleCache = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
<span class="s0">devContextPrototype.c = devModuleCache;</span>
<span class="s1">class </span><span class="s0">UpdateApplyError </span><span class="s1">extends </span><span class="s0">Error {</span>
    <span class="s0">name = </span><span class="s2">'UpdateApplyError'</span><span class="s0">;</span>
    <span class="s0">dependencyChain;</span>
    <span class="s0">constructor(message, dependencyChain){</span>
        <span class="s1">super</span><span class="s0">(message);</span>
        <span class="s1">this</span><span class="s0">.dependencyChain = dependencyChain;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Module IDs that are instantiated as part of the runtime of a chunk.</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">runtimeModules = </span><span class="s1">new </span><span class="s0">Set();</span>
<span class="s3">/**</span>
 <span class="s3">* Map from module ID to the chunks that contain this module.</span>
 <span class="s3">*</span>
 <span class="s3">* In HMR, we need to keep track of which modules are contained in which so</span>
 <span class="s3">* chunks. This is so we don't eagerly dispose of a module when it is removed</span>
 <span class="s3">* from chunk A, but still exists in chunk B.</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">moduleChunksMap = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s3">/**</span>
 <span class="s3">* Map from a chunk path to all modules it contains.</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">chunkModulesMap = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s3">/**</span>
 <span class="s3">* Chunk lists that contain a runtime. When these chunk lists receive an update</span>
 <span class="s3">* that can't be reconciled with the current state of the page, we need to</span>
 <span class="s3">* reload the runtime entirely.</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">runtimeChunkLists = </span><span class="s1">new </span><span class="s0">Set();</span>
<span class="s3">/**</span>
 <span class="s3">* Map from a chunk list to the chunk paths it contains.</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">chunkListChunksMap = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s3">/**</span>
 <span class="s3">* Map from a chunk path to the chunk lists it belongs to.</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">chunkChunkListsMap = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s3">/**</span>
 <span class="s3">* Maps module IDs to persisted data between executions of their hot module</span>
 <span class="s3">* implementation (`hot.data`).</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">moduleHotData = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s3">/**</span>
 <span class="s3">* Maps module instances to their hot module state.</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">moduleHotState = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s3">/**</span>
 <span class="s3">* Modules that call `module.hot.invalidate()` (while being updated).</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">queuedInvalidatedModules = </span><span class="s1">new </span><span class="s0">Set();</span>
<span class="s3">/**</span>
 <span class="s3">* Gets or instantiates a runtime module.</span>
 <span class="s3">*/ // @ts-ignore</span>
<span class="s1">function </span><span class="s0">getOrInstantiateRuntimeModule(chunkPath, moduleId) {</span>
    <span class="s1">const </span><span class="s0">module = devModuleCache[moduleId];</span>
    <span class="s1">if </span><span class="s0">(module) {</span>
        <span class="s1">if </span><span class="s0">(module.error) {</span>
            <span class="s1">throw </span><span class="s0">module.error;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">module;</span>
    <span class="s0">}</span>
    <span class="s3">// @ts-ignore</span>
    <span class="s1">return </span><span class="s0">instantiateModule(moduleId, SourceType.Runtime, chunkPath);</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Retrieves a module from the cache, or instantiate it if it is not cached.</span>
 <span class="s3">*/ // @ts-ignore Defined in `runtime-utils.ts`</span>
<span class="s1">const </span><span class="s0">getOrInstantiateModuleFromParent = (id, sourceModule)=&gt;{</span>
    <span class="s1">if </span><span class="s0">(!sourceModule.hot.active) {</span>
        <span class="s0">console.warn(</span><span class="s2">`Unexpected import of module </span><span class="s0">${id} </span><span class="s2">from module </span><span class="s0">${sourceModule.id}</span><span class="s2">, which was deleted by an HMR update`</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">module = devModuleCache[id];</span>
    <span class="s1">if </span><span class="s0">(sourceModule.children.indexOf(id) === -</span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">sourceModule.children.push(id);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(module) {</span>
        <span class="s1">if </span><span class="s0">(module.error) {</span>
            <span class="s1">throw </span><span class="s0">module.error;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(module.parents.indexOf(sourceModule.id) === -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s0">module.parents.push(sourceModule.id);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">module;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">instantiateModule(id, SourceType.Parent, sourceModule.id);</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">DevContext(module, exports, refresh) {</span>
    <span class="s0">Context.call(</span><span class="s1">this</span><span class="s0">, module, exports);</span>
    <span class="s1">this</span><span class="s0">.k = refresh;</span>
<span class="s0">}</span>
<span class="s0">DevContext.prototype = Context.prototype;</span>
<span class="s1">function </span><span class="s0">instantiateModule(moduleId, sourceType, sourceData) {</span>
    <span class="s3">// We are in development, this is always a string.</span>
    <span class="s1">let </span><span class="s0">id = moduleId;</span>
    <span class="s1">const </span><span class="s0">moduleFactory = moduleFactories.get(id);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">moduleFactory !== </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s3">// This can happen if modules incorrectly handle HMR disposes/updates,</span>
        <span class="s3">// e.g. when they keep a `setTimeout` around which still executes old code</span>
        <span class="s3">// and contains e.g. a `require(&quot;something&quot;)` call.</span>
        <span class="s0">factoryNotAvailable(id, sourceType, sourceData);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">hotData = moduleHotData.get(id);</span>
    <span class="s1">const </span><span class="s0">{ hot, hotState } = createModuleHot(id, hotData);</span>
    <span class="s1">let </span><span class="s0">parents;</span>
    <span class="s1">switch</span><span class="s0">(sourceType){</span>
        <span class="s1">case </span><span class="s0">SourceType.Runtime:</span>
            <span class="s0">runtimeModules.add(id);</span>
            <span class="s0">parents = [];</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s0">SourceType.Parent:</span>
            <span class="s3">// No need to add this module as a child of the parent module here, this</span>
            <span class="s3">// has already been taken care of in `getOrInstantiateModuleFromParent`.</span>
            <span class="s0">parents = [</span>
                <span class="s0">sourceData</span>
            <span class="s0">];</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s0">SourceType.Update:</span>
            <span class="s0">parents = sourceData || [];</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">invariant(sourceType, (sourceType)=&gt;</span><span class="s2">`Unknown source type: </span><span class="s0">${sourceType}</span><span class="s2">`</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">module = createModuleObject(id);</span>
    <span class="s1">const </span><span class="s0">exports = module.exports;</span>
    <span class="s0">module.parents = parents;</span>
    <span class="s0">module.children = [];</span>
    <span class="s0">module.hot = hot;</span>
    <span class="s0">devModuleCache[id] = module;</span>
    <span class="s0">moduleHotState.set(module, hotState);</span>
    <span class="s3">// NOTE(alexkirsz) This can fail when the module encounters a runtime error.</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">runModuleExecutionHooks(module, (refresh)=&gt;{</span>
            <span class="s1">const </span><span class="s0">context = </span><span class="s1">new </span><span class="s0">DevContext(module, exports, refresh);</span>
            <span class="s0">moduleFactory(context, module, exports);</span>
        <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
        <span class="s0">module.error = error;</span>
        <span class="s1">throw </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(module.namespaceObject &amp;&amp; module.exports !== module.namespaceObject) {</span>
        <span class="s3">// in case of a circular dependency: cjs1 -&gt; esm2 -&gt; cjs1</span>
        <span class="s0">interopEsm(module.exports, module.namespaceObject);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">module;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">DUMMY_REFRESH_CONTEXT = {</span>
    <span class="s0">register: (_type, _id)=&gt;{},</span>
    <span class="s0">signature: ()=&gt;(_type)=&gt;{},</span>
    <span class="s0">registerExports: (_module, _helpers)=&gt;{}</span>
<span class="s0">};</span>
<span class="s3">/**</span>
 <span class="s3">* NOTE(alexkirsz) Webpack has a &quot;module execution&quot; interception hook that</span>
 <span class="s3">* Next.js' React Refresh runtime hooks into to add module context to the</span>
 <span class="s3">* refresh registry.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">runModuleExecutionHooks(module, executeModule) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">globalThis.$RefreshInterceptModuleExecution$ === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">cleanupReactRefreshIntercept = globalThis.$RefreshInterceptModuleExecution$(module.id);</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">executeModule({</span>
                <span class="s0">register: globalThis.$RefreshReg$,</span>
                <span class="s0">signature: globalThis.$RefreshSig$,</span>
                <span class="s0">registerExports: registerExportsAndSetupBoundaryForReactRefresh</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">finally</span><span class="s0">{</span>
            <span class="s3">// Always cleanup the intercept, even if module execution failed.</span>
            <span class="s0">cleanupReactRefreshIntercept();</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// If the react refresh hooks are not installed we need to bind dummy functions.</span>
        <span class="s3">// This is expected when running in a Web Worker.  It is also common in some of</span>
        <span class="s3">// our test environments.</span>
        <span class="s0">executeModule(DUMMY_REFRESH_CONTEXT);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">registerExportsAndSetupBoundaryForReactRefresh(module, helpers) {</span>
    <span class="s1">const </span><span class="s0">currentExports = module.exports;</span>
    <span class="s1">const </span><span class="s0">prevExports = module.hot.data.prevExports ?? </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">helpers.registerExportsForReactRefresh(currentExports, module.id);</span>
    <span class="s3">// A module can be accepted automatically based on its exports, e.g. when</span>
    <span class="s3">// it is a Refresh Boundary.</span>
    <span class="s1">if </span><span class="s0">(helpers.isReactRefreshBoundary(currentExports)) {</span>
        <span class="s3">// Save the previous exports on update, so we can compare the boundary</span>
        <span class="s3">// signatures.</span>
        <span class="s0">module.hot.dispose((data)=&gt;{</span>
            <span class="s0">data.prevExports = currentExports;</span>
        <span class="s0">});</span>
        <span class="s3">// Unconditionally accept an update to this module, we'll check if it's</span>
        <span class="s3">// still a Refresh Boundary later.</span>
        <span class="s0">module.hot.accept();</span>
        <span class="s3">// This field is set when the previous version of this module was a</span>
        <span class="s3">// Refresh Boundary, letting us know we need to check for invalidation or</span>
        <span class="s3">// enqueue an update.</span>
        <span class="s1">if </span><span class="s0">(prevExports !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s3">// A boundary can become ineligible if its exports are incompatible</span>
            <span class="s3">// with the previous exports.</span>
            <span class="s3">//</span>
            <span class="s3">// For example, if you add/remove/change exports, we'll want to</span>
            <span class="s3">// re-execute the importing modules, and force those components to</span>
            <span class="s3">// re-render. Similarly, if you convert a class component to a</span>
            <span class="s3">// function, we want to invalidate the boundary.</span>
            <span class="s1">if </span><span class="s0">(helpers.shouldInvalidateReactRefreshBoundary(helpers.getRefreshBoundarySignature(prevExports), helpers.getRefreshBoundarySignature(currentExports))) {</span>
                <span class="s0">module.hot.invalidate();</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">helpers.scheduleUpdate();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// Since we just executed the code for the module, it's possible that the</span>
        <span class="s3">// new exports made it ineligible for being a boundary.</span>
        <span class="s3">// We only care about the case when we were _previously_ a boundary,</span>
        <span class="s3">// because we already accepted this update (accidental side effect).</span>
        <span class="s1">const </span><span class="s0">isNoLongerABoundary = prevExports !== </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(isNoLongerABoundary) {</span>
            <span class="s0">module.hot.invalidate();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">formatDependencyChain(dependencyChain) {</span>
    <span class="s1">return </span><span class="s2">`Dependency chain: </span><span class="s0">${dependencyChain.join(</span><span class="s2">' -&gt; '</span><span class="s0">)}</span><span class="s2">`</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">computeOutdatedModules(added, modified) {</span>
    <span class="s1">const </span><span class="s0">newModuleFactories = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[moduleId, entry] of added){</span>
        <span class="s1">if </span><span class="s0">(entry != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">newModuleFactories.set(moduleId, _eval(entry));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">outdatedModules = computedInvalidatedModules(modified.keys());</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[moduleId, entry] of modified){</span>
        <span class="s0">newModuleFactories.set(moduleId, _eval(entry));</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">outdatedModules,</span>
        <span class="s0">newModuleFactories</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">computedInvalidatedModules(invalidated) {</span>
    <span class="s1">const </span><span class="s0">outdatedModules = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of invalidated){</span>
        <span class="s1">const </span><span class="s0">effect = getAffectedModuleEffects(moduleId);</span>
        <span class="s1">switch</span><span class="s0">(effect.type){</span>
            <span class="s1">case </span><span class="s2">'unaccepted'</span><span class="s0">:</span>
                <span class="s1">throw new </span><span class="s0">UpdateApplyError(</span><span class="s2">`cannot apply update: unaccepted module. </span><span class="s0">${formatDependencyChain(effect.dependencyChain)}</span><span class="s2">.`</span><span class="s0">, effect.dependencyChain);</span>
            <span class="s1">case </span><span class="s2">'self-declined'</span><span class="s0">:</span>
                <span class="s1">throw new </span><span class="s0">UpdateApplyError(</span><span class="s2">`cannot apply update: self-declined module. </span><span class="s0">${formatDependencyChain(effect.dependencyChain)}</span><span class="s2">.`</span><span class="s0">, effect.dependencyChain);</span>
            <span class="s1">case </span><span class="s2">'accepted'</span><span class="s0">:</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">outdatedModuleId of effect.outdatedModules){</span>
                    <span class="s0">outdatedModules.add(outdatedModuleId);</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s3">// TODO(alexkirsz) Dependencies: handle dependencies effects.</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">invariant(effect, (effect)=&gt;</span><span class="s2">`Unknown effect type: </span><span class="s0">${effect?.type}</span><span class="s2">`</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">outdatedModules;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">computeOutdatedSelfAcceptedModules(outdatedModules) {</span>
    <span class="s1">const </span><span class="s0">outdatedSelfAcceptedModules = [];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of outdatedModules){</span>
        <span class="s1">const </span><span class="s0">module = devModuleCache[moduleId];</span>
        <span class="s1">const </span><span class="s0">hotState = moduleHotState.get(module);</span>
        <span class="s1">if </span><span class="s0">(module &amp;&amp; hotState.selfAccepted &amp;&amp; !hotState.selfInvalidated) {</span>
            <span class="s0">outdatedSelfAcceptedModules.push({</span>
                <span class="s0">moduleId,</span>
                <span class="s0">errorHandler: hotState.selfAccepted</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">outdatedSelfAcceptedModules;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Adds, deletes, and moves modules between chunks. This must happen before the</span>
 <span class="s3">* dispose phase as it needs to know which modules were removed from all chunks,</span>
 <span class="s3">* which we can only compute *after* taking care of added and moved modules.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">updateChunksPhase(chunksAddedModules, chunksDeletedModules) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, addedModuleIds] of chunksAddedModules){</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of addedModuleIds){</span>
            <span class="s0">addModuleToChunk(moduleId, chunkPath);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">disposedModules = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, addedModuleIds] of chunksDeletedModules){</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of addedModuleIds){</span>
            <span class="s1">if </span><span class="s0">(removeModuleFromChunk(moduleId, chunkPath)) {</span>
                <span class="s0">disposedModules.add(moduleId);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">disposedModules</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">disposePhase(outdatedModules, disposedModules) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of outdatedModules){</span>
        <span class="s0">disposeModule(moduleId, </span><span class="s2">'replace'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of disposedModules){</span>
        <span class="s0">disposeModule(moduleId, </span><span class="s2">'clear'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s3">// Removing modules from the module cache is a separate step.</span>
    <span class="s3">// We also want to keep track of previous parents of the outdated modules.</span>
    <span class="s1">const </span><span class="s0">outdatedModuleParents = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of outdatedModules){</span>
        <span class="s1">const </span><span class="s0">oldModule = devModuleCache[moduleId];</span>
        <span class="s0">outdatedModuleParents.set(moduleId, oldModule?.parents);</span>
        <span class="s1">delete </span><span class="s0">devModuleCache[moduleId];</span>
    <span class="s0">}</span>
    <span class="s3">// TODO(alexkirsz) Dependencies: remove outdated dependency from module</span>
    <span class="s3">// children.</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">outdatedModuleParents</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Disposes of an instance of a module.</span>
 <span class="s3">*</span>
 <span class="s3">* Returns the persistent hot data that should be kept for the next module</span>
 <span class="s3">* instance.</span>
 <span class="s3">*</span>
 <span class="s3">* NOTE: mode = &quot;replace&quot; will not remove modules from the devModuleCache</span>
 <span class="s3">* This must be done in a separate step afterwards.</span>
 <span class="s3">* This is important because all modules need to be disposed to update the</span>
 <span class="s3">* parent/child relationships before they are actually removed from the devModuleCache.</span>
 <span class="s3">* If this was done in this method, the following disposeModule calls won't find</span>
 <span class="s3">* the module from the module id in the cache.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">disposeModule(moduleId, mode) {</span>
    <span class="s1">const </span><span class="s0">module = devModuleCache[moduleId];</span>
    <span class="s1">if </span><span class="s0">(!module) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">hotState = moduleHotState.get(module);</span>
    <span class="s1">const </span><span class="s0">data = {};</span>
    <span class="s3">// Run the `hot.dispose` handler, if any, passing in the persistent</span>
    <span class="s3">// `hot.data` object.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">disposeHandler of hotState.disposeHandlers){</span>
        <span class="s0">disposeHandler(data);</span>
    <span class="s0">}</span>
    <span class="s3">// This used to warn in `getOrInstantiateModuleFromParent` when a disposed</span>
    <span class="s3">// module is still importing other modules.</span>
    <span class="s0">module.hot.active = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">moduleHotState.delete(module);</span>
    <span class="s3">// TODO(alexkirsz) Dependencies: delete the module from outdated deps.</span>
    <span class="s3">// Remove the disposed module from its children's parent list.</span>
    <span class="s3">// It will be added back once the module re-instantiates and imports its</span>
    <span class="s3">// children again.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">childId of module.children){</span>
        <span class="s1">const </span><span class="s0">child = devModuleCache[childId];</span>
        <span class="s1">if </span><span class="s0">(!child) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">idx = child.parents.indexOf(module.id);</span>
        <span class="s1">if </span><span class="s0">(idx &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">child.parents.splice(idx, </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">switch</span><span class="s0">(mode){</span>
        <span class="s1">case </span><span class="s2">'clear'</span><span class="s0">:</span>
            <span class="s1">delete </span><span class="s0">devModuleCache[module.id];</span>
            <span class="s0">moduleHotData.delete(module.id);</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">'replace'</span><span class="s0">:</span>
            <span class="s0">moduleHotData.set(module.id, data);</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">invariant(mode, (mode)=&gt;</span><span class="s2">`invalid mode: </span><span class="s0">${mode}</span><span class="s2">`</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedModuleParents, reportError) {</span>
    <span class="s3">// Update module factories.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[moduleId, factory] of newModuleFactories.entries()){</span>
        <span class="s0">applyModuleFactoryName(factory);</span>
        <span class="s0">moduleFactories.set(moduleId, factory);</span>
    <span class="s0">}</span>
    <span class="s3">// TODO(alexkirsz) Run new runtime entries here.</span>
    <span class="s3">// TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.</span>
    <span class="s3">// Re-instantiate all outdated self-accepted modules.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">{ moduleId, errorHandler } of outdatedSelfAcceptedModules){</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">instantiateModule(moduleId, SourceType.Update, outdatedModuleParents.get(moduleId));</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">errorHandler === </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s1">try </span><span class="s0">{</span>
                    <span class="s0">errorHandler(err, {</span>
                        <span class="s0">moduleId,</span>
                        <span class="s0">module: devModuleCache[moduleId]</span>
                    <span class="s0">});</span>
                <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err2) {</span>
                    <span class="s0">reportError(err2);</span>
                    <span class="s0">reportError(err);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">reportError(err);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">applyUpdate(update) {</span>
    <span class="s1">switch</span><span class="s0">(update.type){</span>
        <span class="s1">case </span><span class="s2">'ChunkListUpdate'</span><span class="s0">:</span>
            <span class="s0">applyChunkListUpdate(update);</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">invariant(update, (update)=&gt;</span><span class="s2">`Unknown update type: </span><span class="s0">${update.type}</span><span class="s2">`</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">applyChunkListUpdate(update) {</span>
    <span class="s1">if </span><span class="s0">(update.merged != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">merged of update.merged){</span>
            <span class="s1">switch</span><span class="s0">(merged.type){</span>
                <span class="s1">case </span><span class="s2">'EcmascriptMergedUpdate'</span><span class="s0">:</span>
                    <span class="s0">applyEcmascriptMergedUpdate(merged);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">default</span><span class="s0">:</span>
                    <span class="s0">invariant(merged, (merged)=&gt;</span><span class="s2">`Unknown merged type: </span><span class="s0">${merged.type}</span><span class="s2">`</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(update.chunks != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, chunkUpdate] of Object.entries(update.chunks)){</span>
            <span class="s1">const </span><span class="s0">chunkUrl = getChunkRelativeUrl(chunkPath);</span>
            <span class="s1">switch</span><span class="s0">(chunkUpdate.type){</span>
                <span class="s1">case </span><span class="s2">'added'</span><span class="s0">:</span>
                    <span class="s0">BACKEND.loadChunkCached(SourceType.Update, chunkUrl);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">case </span><span class="s2">'total'</span><span class="s0">:</span>
                    <span class="s0">DEV_BACKEND.reloadChunk?.(chunkUrl);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">case </span><span class="s2">'deleted'</span><span class="s0">:</span>
                    <span class="s0">DEV_BACKEND.unloadChunk?.(chunkUrl);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">case </span><span class="s2">'partial'</span><span class="s0">:</span>
                    <span class="s0">invariant(chunkUpdate.instruction, (instruction)=&gt;</span><span class="s2">`Unknown partial instruction: </span><span class="s0">${JSON.stringify(instruction)}</span><span class="s2">.`</span><span class="s0">);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">default</span><span class="s0">:</span>
                    <span class="s0">invariant(chunkUpdate, (chunkUpdate)=&gt;</span><span class="s2">`Unknown chunk update type: </span><span class="s0">${chunkUpdate.type}</span><span class="s2">`</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">applyEcmascriptMergedUpdate(update) {</span>
    <span class="s1">const </span><span class="s0">{ entries = {}, chunks = {} } = update;</span>
    <span class="s1">const </span><span class="s0">{ added, modified, chunksAdded, chunksDeleted } = computeChangedModules(entries, chunks);</span>
    <span class="s1">const </span><span class="s0">{ outdatedModules, newModuleFactories } = computeOutdatedModules(added, modified);</span>
    <span class="s1">const </span><span class="s0">{ disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted);</span>
    <span class="s0">applyInternal(outdatedModules, disposedModules, newModuleFactories);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">applyInvalidatedModules(outdatedModules) {</span>
    <span class="s1">if </span><span class="s0">(queuedInvalidatedModules.size &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId)=&gt;{</span>
            <span class="s0">outdatedModules.add(moduleId);</span>
        <span class="s0">});</span>
        <span class="s0">queuedInvalidatedModules.clear();</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">outdatedModules;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">applyInternal(outdatedModules, disposedModules, newModuleFactories) {</span>
    <span class="s0">outdatedModules = applyInvalidatedModules(outdatedModules);</span>
    <span class="s1">const </span><span class="s0">outdatedSelfAcceptedModules = computeOutdatedSelfAcceptedModules(outdatedModules);</span>
    <span class="s1">const </span><span class="s0">{ outdatedModuleParents } = disposePhase(outdatedModules, disposedModules);</span>
    <span class="s3">// we want to continue on error and only throw the error after we tried applying all updates</span>
    <span class="s1">let </span><span class="s0">error;</span>
    <span class="s1">function </span><span class="s0">reportError(err) {</span>
        <span class="s1">if </span><span class="s0">(!error) error = err;</span>
    <span class="s0">}</span>
    <span class="s0">applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedModuleParents, reportError);</span>
    <span class="s1">if </span><span class="s0">(error) {</span>
        <span class="s1">throw </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(queuedInvalidatedModules.size &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">applyInternal(</span><span class="s1">new </span><span class="s0">Set(), [], </span><span class="s1">new </span><span class="s0">Map());</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">computeChangedModules(entries, updates) {</span>
    <span class="s1">const </span><span class="s0">chunksAdded = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">const </span><span class="s0">chunksDeleted = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">const </span><span class="s0">added = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">const </span><span class="s0">modified = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">const </span><span class="s0">deleted = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[chunkPath, mergedChunkUpdate] of Object.entries(updates)){</span>
        <span class="s1">switch</span><span class="s0">(mergedChunkUpdate.type){</span>
            <span class="s1">case </span><span class="s2">'added'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s1">const </span><span class="s0">updateAdded = </span><span class="s1">new </span><span class="s0">Set(mergedChunkUpdate.modules);</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of updateAdded){</span>
                        <span class="s0">added.set(moduleId, entries[moduleId]);</span>
                    <span class="s0">}</span>
                    <span class="s0">chunksAdded.set(chunkPath, updateAdded);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">case </span><span class="s2">'deleted'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s3">// We could also use `mergedChunkUpdate.modules` here.</span>
                    <span class="s1">const </span><span class="s0">updateDeleted = </span><span class="s1">new </span><span class="s0">Set(chunkModulesMap.get(chunkPath));</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of updateDeleted){</span>
                        <span class="s0">deleted.add(moduleId);</span>
                    <span class="s0">}</span>
                    <span class="s0">chunksDeleted.set(chunkPath, updateDeleted);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">case </span><span class="s2">'partial'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s1">const </span><span class="s0">updateAdded = </span><span class="s1">new </span><span class="s0">Set(mergedChunkUpdate.added);</span>
                    <span class="s1">const </span><span class="s0">updateDeleted = </span><span class="s1">new </span><span class="s0">Set(mergedChunkUpdate.deleted);</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of updateAdded){</span>
                        <span class="s0">added.set(moduleId, entries[moduleId]);</span>
                    <span class="s0">}</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of updateDeleted){</span>
                        <span class="s0">deleted.add(moduleId);</span>
                    <span class="s0">}</span>
                    <span class="s0">chunksAdded.set(chunkPath, updateAdded);</span>
                    <span class="s0">chunksDeleted.set(chunkPath, updateDeleted);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">invariant(mergedChunkUpdate, (mergedChunkUpdate)=&gt;</span><span class="s2">`Unknown merged chunk update type: </span><span class="s0">${mergedChunkUpdate.type}</span><span class="s2">`</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// If a module was added from one chunk and deleted from another in the same update,</span>
    <span class="s3">// consider it to be modified, as it means the module was moved from one chunk to another</span>
    <span class="s3">// AND has new code in a single update.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of added.keys()){</span>
        <span class="s1">if </span><span class="s0">(deleted.has(moduleId)) {</span>
            <span class="s0">added.delete(moduleId);</span>
            <span class="s0">deleted.delete(moduleId);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[moduleId, entry] of Object.entries(entries)){</span>
        <span class="s3">// Modules that haven't been added to any chunk but have new code are considered</span>
        <span class="s3">// to be modified.</span>
        <span class="s3">// This needs to be under the previous loop, as we need it to get rid of modules</span>
        <span class="s3">// that were added and deleted in the same update.</span>
        <span class="s1">if </span><span class="s0">(!added.has(moduleId)) {</span>
            <span class="s0">modified.set(moduleId, entry);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">added,</span>
        <span class="s0">deleted,</span>
        <span class="s0">modified,</span>
        <span class="s0">chunksAdded,</span>
        <span class="s0">chunksDeleted</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getAffectedModuleEffects(moduleId) {</span>
    <span class="s1">const </span><span class="s0">outdatedModules = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">queue = [</span>
        <span class="s0">{</span>
            <span class="s0">moduleId,</span>
            <span class="s0">dependencyChain: []</span>
        <span class="s0">}</span>
    <span class="s0">];</span>
    <span class="s1">let </span><span class="s0">nextItem;</span>
    <span class="s1">while</span><span class="s0">(nextItem = queue.shift()){</span>
        <span class="s1">const </span><span class="s0">{ moduleId, dependencyChain } = nextItem;</span>
        <span class="s1">if </span><span class="s0">(moduleId != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(outdatedModules.has(moduleId)) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">outdatedModules.add(moduleId);</span>
        <span class="s0">}</span>
        <span class="s3">// We've arrived at the runtime of the chunk, which means that nothing</span>
        <span class="s3">// else above can accept this update.</span>
        <span class="s1">if </span><span class="s0">(moduleId === undefined) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">'unaccepted'</span><span class="s0">,</span>
                <span class="s0">dependencyChain</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">module = devModuleCache[moduleId];</span>
        <span class="s1">const </span><span class="s0">hotState = moduleHotState.get(module);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s3">// The module is not in the cache. Since this is a &quot;modified&quot; update,</span>
        <span class="s3">// it means that the module was never instantiated before.</span>
        <span class="s0">!module || hotState.selfAccepted &amp;&amp; !hotState.selfInvalidated) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(hotState.selfDeclined) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">'self-declined'</span><span class="s0">,</span>
                <span class="s0">dependencyChain,</span>
                <span class="s0">moduleId</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(runtimeModules.has(moduleId)) {</span>
            <span class="s0">queue.push({</span>
                <span class="s0">moduleId: undefined,</span>
                <span class="s0">dependencyChain: [</span>
                    <span class="s0">...dependencyChain,</span>
                    <span class="s0">moduleId</span>
                <span class="s0">]</span>
            <span class="s0">});</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">parentId of module.parents){</span>
            <span class="s1">const </span><span class="s0">parent = devModuleCache[parentId];</span>
            <span class="s1">if </span><span class="s0">(!parent) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// TODO(alexkirsz) Dependencies: check accepted and declined</span>
            <span class="s3">// dependencies here.</span>
            <span class="s0">queue.push({</span>
                <span class="s0">moduleId: parentId,</span>
                <span class="s0">dependencyChain: [</span>
                    <span class="s0">...dependencyChain,</span>
                    <span class="s0">moduleId</span>
                <span class="s0">]</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">type: </span><span class="s2">'accepted'</span><span class="s0">,</span>
        <span class="s0">moduleId,</span>
        <span class="s0">outdatedModules</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">handleApply(chunkListPath, update) {</span>
    <span class="s1">switch</span><span class="s0">(update.type){</span>
        <span class="s1">case </span><span class="s2">'partial'</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s3">// This indicates that the update is can be applied to the current state of the application.</span>
                <span class="s0">applyUpdate(update.instruction);</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s2">'restart'</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s3">// This indicates that there is no way to apply the update to the</span>
                <span class="s3">// current state of the application, and that the application must be</span>
                <span class="s3">// restarted.</span>
                <span class="s0">DEV_BACKEND.restart();</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s2">'notFound'</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s3">// This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,</span>
                <span class="s3">// or the page itself was deleted.</span>
                <span class="s3">// If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.</span>
                <span class="s3">// If it is a runtime chunk list, we restart the application.</span>
                <span class="s1">if </span><span class="s0">(runtimeChunkLists.has(chunkListPath)) {</span>
                    <span class="s0">DEV_BACKEND.restart();</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">disposeChunkList(chunkListPath);</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`Unknown update type: </span><span class="s0">${update.type}</span><span class="s2">`</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createModuleHot(moduleId, hotData) {</span>
    <span class="s1">const </span><span class="s0">hotState = {</span>
        <span class="s0">selfAccepted: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">selfDeclined: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">selfInvalidated: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">disposeHandlers: []</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">hot = {</span>
        <span class="s3">// TODO(alexkirsz) This is not defined in the HMR API. It was used to</span>
        <span class="s3">// decide whether to warn whenever an HMR-disposed module required other</span>
        <span class="s3">// modules. We might want to remove it.</span>
        <span class="s0">active: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">data: hotData ?? {},</span>
        <span class="s3">// TODO(alexkirsz) Support full (dep, callback, errorHandler) form.</span>
        <span class="s0">accept: (modules, _callback, _errorHandler)=&gt;{</span>
            <span class="s1">if </span><span class="s0">(modules === undefined) {</span>
                <span class="s0">hotState.selfAccepted = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">modules === </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s0">hotState.selfAccepted = modules;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'unsupported `accept` signature'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s0">decline: (dep)=&gt;{</span>
            <span class="s1">if </span><span class="s0">(dep === undefined) {</span>
                <span class="s0">hotState.selfDeclined = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'unsupported `decline` signature'</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s0">dispose: (callback)=&gt;{</span>
            <span class="s0">hotState.disposeHandlers.push(callback);</span>
        <span class="s0">},</span>
        <span class="s0">addDisposeHandler: (callback)=&gt;{</span>
            <span class="s0">hotState.disposeHandlers.push(callback);</span>
        <span class="s0">},</span>
        <span class="s0">removeDisposeHandler: (callback)=&gt;{</span>
            <span class="s1">const </span><span class="s0">idx = hotState.disposeHandlers.indexOf(callback);</span>
            <span class="s1">if </span><span class="s0">(idx &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">hotState.disposeHandlers.splice(idx, </span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s0">invalidate: ()=&gt;{</span>
            <span class="s0">hotState.selfInvalidated = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">queuedInvalidatedModules.add(moduleId);</span>
        <span class="s0">},</span>
        <span class="s3">// NOTE(alexkirsz) This is part of the management API, which we don't</span>
        <span class="s3">// implement, but the Next.js React Refresh runtime uses this to decide</span>
        <span class="s3">// whether to schedule an update.</span>
        <span class="s0">status: ()=&gt;</span><span class="s2">'idle'</span><span class="s0">,</span>
        <span class="s3">// NOTE(alexkirsz) Since we always return &quot;idle&quot; for now, these are no-ops.</span>
        <span class="s0">addStatusHandler: (_handler)=&gt;{},</span>
        <span class="s0">removeStatusHandler: (_handler)=&gt;{},</span>
        <span class="s3">// NOTE(jridgewell) Check returns the list of updated modules, but we don't</span>
        <span class="s3">// want the webpack code paths to ever update (the turbopack paths handle</span>
        <span class="s3">// this already).</span>
        <span class="s0">check: ()=&gt;Promise.resolve(</span><span class="s1">null</span><span class="s0">)</span>
    <span class="s0">};</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">hot,</span>
        <span class="s0">hotState</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Removes a module from a chunk.</span>
 <span class="s3">* Returns `true` if there are no remaining chunks including this module.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">removeModuleFromChunk(moduleId, chunkPath) {</span>
    <span class="s1">const </span><span class="s0">moduleChunks = moduleChunksMap.get(moduleId);</span>
    <span class="s0">moduleChunks.delete(chunkPath);</span>
    <span class="s1">const </span><span class="s0">chunkModules = chunkModulesMap.get(chunkPath);</span>
    <span class="s0">chunkModules.delete(moduleId);</span>
    <span class="s1">const </span><span class="s0">noRemainingModules = chunkModules.size === </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(noRemainingModules) {</span>
        <span class="s0">chunkModulesMap.delete(chunkPath);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">noRemainingChunks = moduleChunks.size === </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(noRemainingChunks) {</span>
        <span class="s0">moduleChunksMap.delete(moduleId);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">noRemainingChunks;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Disposes of a chunk list and its corresponding exclusive chunks.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">disposeChunkList(chunkListPath) {</span>
    <span class="s1">const </span><span class="s0">chunkPaths = chunkListChunksMap.get(chunkListPath);</span>
    <span class="s1">if </span><span class="s0">(chunkPaths == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">chunkListChunksMap.delete(chunkListPath);</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">chunkPath of chunkPaths){</span>
        <span class="s1">const </span><span class="s0">chunkChunkLists = chunkChunkListsMap.get(chunkPath);</span>
        <span class="s0">chunkChunkLists.delete(chunkListPath);</span>
        <span class="s1">if </span><span class="s0">(chunkChunkLists.size === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">chunkChunkListsMap.delete(chunkPath);</span>
            <span class="s0">disposeChunk(chunkPath);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// We must also dispose of the chunk list's chunk itself to ensure it may</span>
    <span class="s3">// be reloaded properly in the future.</span>
    <span class="s1">const </span><span class="s0">chunkListUrl = getChunkRelativeUrl(chunkListPath);</span>
    <span class="s0">DEV_BACKEND.unloadChunk?.(chunkListUrl);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Disposes of a chunk and its corresponding exclusive modules.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@returns </span><span class="s3">Whether the chunk was disposed of.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">disposeChunk(chunkPath) {</span>
    <span class="s1">const </span><span class="s0">chunkUrl = getChunkRelativeUrl(chunkPath);</span>
    <span class="s3">// This should happen whether the chunk has any modules in it or not.</span>
    <span class="s3">// For instance, CSS chunks have no modules in them, but they still need to be unloaded.</span>
    <span class="s0">DEV_BACKEND.unloadChunk?.(chunkUrl);</span>
    <span class="s1">const </span><span class="s0">chunkModules = chunkModulesMap.get(chunkPath);</span>
    <span class="s1">if </span><span class="s0">(chunkModules == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">chunkModules.delete(chunkPath);</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of chunkModules){</span>
        <span class="s1">const </span><span class="s0">moduleChunks = moduleChunksMap.get(moduleId);</span>
        <span class="s0">moduleChunks.delete(chunkPath);</span>
        <span class="s1">const </span><span class="s0">noRemainingChunks = moduleChunks.size === </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(noRemainingChunks) {</span>
            <span class="s0">moduleChunksMap.delete(moduleId);</span>
            <span class="s0">disposeModule(moduleId, </span><span class="s2">'clear'</span><span class="s0">);</span>
            <span class="s0">availableModules.delete(moduleId);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Adds a module to a chunk.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">addModuleToChunk(moduleId, chunkPath) {</span>
    <span class="s1">let </span><span class="s0">moduleChunks = moduleChunksMap.get(moduleId);</span>
    <span class="s1">if </span><span class="s0">(!moduleChunks) {</span>
        <span class="s0">moduleChunks = </span><span class="s1">new </span><span class="s0">Set([</span>
            <span class="s0">chunkPath</span>
        <span class="s0">]);</span>
        <span class="s0">moduleChunksMap.set(moduleId, moduleChunks);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">moduleChunks.add(chunkPath);</span>
    <span class="s0">}</span>
    <span class="s1">let </span><span class="s0">chunkModules = chunkModulesMap.get(chunkPath);</span>
    <span class="s1">if </span><span class="s0">(!chunkModules) {</span>
        <span class="s0">chunkModules = </span><span class="s1">new </span><span class="s0">Set([</span>
            <span class="s0">moduleId</span>
        <span class="s0">]);</span>
        <span class="s0">chunkModulesMap.set(chunkPath, chunkModules);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">chunkModules.add(moduleId);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Marks a chunk list as a runtime chunk list. There can be more than one</span>
 <span class="s3">* runtime chunk list. For instance, integration tests can have multiple chunk</span>
 <span class="s3">* groups loaded at runtime, each with its own chunk list.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">markChunkListAsRuntime(chunkListPath) {</span>
    <span class="s0">runtimeChunkLists.add(chunkListPath);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">registerChunk(registration) {</span>
    <span class="s1">const </span><span class="s0">chunkPath = getPathFromScript(registration[</span><span class="s4">0</span><span class="s0">]);</span>
    <span class="s1">let </span><span class="s0">runtimeParams;</span>
    <span class="s3">// When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length</span>
    <span class="s1">if </span><span class="s0">(registration.length === </span><span class="s4">2</span><span class="s0">) {</span>
        <span class="s0">runtimeParams = registration[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">runtimeParams = undefined;</span>
        <span class="s0">installCompressedModuleFactories(registration, </span><span class="s3">/* offset= */ </span><span class="s4">1</span><span class="s0">, moduleFactories, (id)=&gt;addModuleToChunk(id, chunkPath));</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">BACKEND.registerChunk(chunkPath, runtimeParams);</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Subscribes to chunk list updates from the update server and applies them.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">registerChunkList(chunkList) {</span>
    <span class="s1">const </span><span class="s0">chunkListScript = chunkList.script;</span>
    <span class="s1">const </span><span class="s0">chunkListPath = getPathFromScript(chunkListScript);</span>
    <span class="s3">// The &quot;chunk&quot; is also registered to finish the loading in the backend</span>
    <span class="s0">BACKEND.registerChunk(chunkListPath);</span>
    <span class="s0">globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS.push([</span>
        <span class="s0">chunkListPath,</span>
        <span class="s0">handleApply.bind(</span><span class="s1">null</span><span class="s0">, chunkListPath)</span>
    <span class="s0">]);</span>
    <span class="s3">// Adding chunks to chunk lists and vice versa.</span>
    <span class="s1">const </span><span class="s0">chunkPaths = </span><span class="s1">new </span><span class="s0">Set(chunkList.chunks.map(getChunkPath));</span>
    <span class="s0">chunkListChunksMap.set(chunkListPath, chunkPaths);</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">chunkPath of chunkPaths){</span>
        <span class="s1">let </span><span class="s0">chunkChunkLists = chunkChunkListsMap.get(chunkPath);</span>
        <span class="s1">if </span><span class="s0">(!chunkChunkLists) {</span>
            <span class="s0">chunkChunkLists = </span><span class="s1">new </span><span class="s0">Set([</span>
                <span class="s0">chunkListPath</span>
            <span class="s0">]);</span>
            <span class="s0">chunkChunkListsMap.set(chunkPath, chunkChunkLists);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">chunkChunkLists.add(chunkListPath);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(chunkList.source === </span><span class="s2">'entry'</span><span class="s0">) {</span>
        <span class="s0">markChunkListAsRuntime(chunkListPath);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= [];</span>
<span class="s3">/**</span>
 <span class="s3">* This file contains the runtime code specific to the Turbopack development</span>
 <span class="s3">* ECMAScript DOM runtime.</span>
 <span class="s3">*</span>
 <span class="s3">* It will be appended to the base development runtime code.</span>
 <span class="s3">*/ /* eslint-disable @typescript-eslint/no-unused-vars */ /// &lt;reference path=&quot;../../../browser/runtime/base/runtime-base.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;../../../shared/runtime-types.d.ts&quot; /&gt;</span>
<span class="s1">let </span><span class="s0">BACKEND;</span>
<span class="s3">/**</span>
 <span class="s3">* Maps chunk paths to the corresponding resolver.</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">chunkResolvers = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s0">(()=&gt;{</span>
    <span class="s0">BACKEND = {</span>
        <span class="s0">async registerChunk (chunkPath, params) {</span>
            <span class="s1">const </span><span class="s0">chunkUrl = getChunkRelativeUrl(chunkPath);</span>
            <span class="s1">const </span><span class="s0">resolver = getOrCreateResolver(chunkUrl);</span>
            <span class="s0">resolver.resolve();</span>
            <span class="s1">if </span><span class="s0">(params == </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">otherChunkData of params.otherChunks){</span>
                <span class="s1">const </span><span class="s0">otherChunkPath = getChunkPath(otherChunkData);</span>
                <span class="s1">const </span><span class="s0">otherChunkUrl = getChunkRelativeUrl(otherChunkPath);</span>
                <span class="s3">// Chunk might have started loading, so we want to avoid triggering another load.</span>
                <span class="s0">getOrCreateResolver(otherChunkUrl);</span>
            <span class="s0">}</span>
            <span class="s3">// This waits for chunks to be loaded, but also marks included items as available.</span>
            <span class="s1">await </span><span class="s0">Promise.all(params.otherChunks.map((otherChunkData)=&gt;loadInitialChunk(chunkPath, otherChunkData)));</span>
            <span class="s1">if </span><span class="s0">(params.runtimeModuleIds.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">moduleId of params.runtimeModuleIds){</span>
                    <span class="s0">getOrInstantiateRuntimeModule(chunkPath, moduleId);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s3">/**</span>
     <span class="s3">* Loads the given chunk, and returns a promise that resolves once the chunk</span>
     <span class="s3">* has been loaded.</span>
     <span class="s3">*/ </span><span class="s0">loadChunkCached (sourceType, chunkUrl) {</span>
            <span class="s1">return </span><span class="s0">doLoadChunk(sourceType, chunkUrl);</span>
        <span class="s0">},</span>
        <span class="s0">async loadWebAssembly (_sourceType, _sourceData, wasmChunkPath, _edgeModule, importsObj) {</span>
            <span class="s1">const </span><span class="s0">req = fetchWebAssembly(wasmChunkPath);</span>
            <span class="s1">const </span><span class="s0">{ instance } = </span><span class="s1">await </span><span class="s0">WebAssembly.instantiateStreaming(req, importsObj);</span>
            <span class="s1">return </span><span class="s0">instance.exports;</span>
        <span class="s0">},</span>
        <span class="s0">async loadWebAssemblyModule (_sourceType, _sourceData, wasmChunkPath, _edgeModule) {</span>
            <span class="s1">const </span><span class="s0">req = fetchWebAssembly(wasmChunkPath);</span>
            <span class="s1">return await </span><span class="s0">WebAssembly.compileStreaming(req);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">getOrCreateResolver(chunkUrl) {</span>
        <span class="s1">let </span><span class="s0">resolver = chunkResolvers.get(chunkUrl);</span>
        <span class="s1">if </span><span class="s0">(!resolver) {</span>
            <span class="s1">let </span><span class="s0">resolve;</span>
            <span class="s1">let </span><span class="s0">reject;</span>
            <span class="s1">const </span><span class="s0">promise = </span><span class="s1">new </span><span class="s0">Promise((innerResolve, innerReject)=&gt;{</span>
                <span class="s0">resolve = innerResolve;</span>
                <span class="s0">reject = innerReject;</span>
            <span class="s0">});</span>
            <span class="s0">resolver = {</span>
                <span class="s0">resolved: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">loadingStarted: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">promise,</span>
                <span class="s0">resolve: ()=&gt;{</span>
                    <span class="s0">resolver.resolved = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">resolve();</span>
                <span class="s0">},</span>
                <span class="s0">reject: reject</span>
            <span class="s0">};</span>
            <span class="s0">chunkResolvers.set(chunkUrl, resolver);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">resolver;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
   <span class="s3">* Loads the given chunk, and returns a promise that resolves once the chunk</span>
   <span class="s3">* has been loaded.</span>
   <span class="s3">*/ </span><span class="s1">function </span><span class="s0">doLoadChunk(sourceType, chunkUrl) {</span>
        <span class="s1">const </span><span class="s0">resolver = getOrCreateResolver(chunkUrl);</span>
        <span class="s1">if </span><span class="s0">(resolver.loadingStarted) {</span>
            <span class="s1">return </span><span class="s0">resolver.promise;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(sourceType === SourceType.Runtime) {</span>
            <span class="s3">// We don't need to load chunks references from runtime code, as they're already</span>
            <span class="s3">// present in the DOM.</span>
            <span class="s0">resolver.loadingStarted = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(isCss(chunkUrl)) {</span>
                <span class="s3">// CSS chunks do not register themselves, and as such must be marked as</span>
                <span class="s3">// loaded instantly.</span>
                <span class="s0">resolver.resolve();</span>
            <span class="s0">}</span>
            <span class="s3">// We need to wait for JS chunks to register themselves within `registerChunk`</span>
            <span class="s3">// before we can start instantiating runtime modules, hence the absence of</span>
            <span class="s3">// `resolver.resolve()` in this branch.</span>
            <span class="s1">return </span><span class="s0">resolver.promise;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">importScripts === </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s3">// We're in a web worker</span>
            <span class="s1">if </span><span class="s0">(isCss(chunkUrl)) {</span>
            <span class="s3">// ignore</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(isJs(chunkUrl)) {</span>
                <span class="s0">self.TURBOPACK_NEXT_CHUNK_URLS.push(chunkUrl);</span>
                <span class="s0">importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`can't infer type of chunk from URL </span><span class="s0">${chunkUrl} </span><span class="s2">in worker`</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.</span>
            <span class="s1">const </span><span class="s0">decodedChunkUrl = decodeURI(chunkUrl);</span>
            <span class="s1">if </span><span class="s0">(isCss(chunkUrl)) {</span>
                <span class="s1">const </span><span class="s0">previousLinks = document.querySelectorAll(</span><span class="s2">`link[rel=stylesheet][href=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">&quot;],link[rel=stylesheet][href^=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">?&quot;],link[rel=stylesheet][href=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">&quot;],link[rel=stylesheet][href^=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">?&quot;]`</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(previousLinks.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s3">// CSS chunks do not register themselves, and as such must be marked as</span>
                    <span class="s3">// loaded instantly.</span>
                    <span class="s0">resolver.resolve();</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">const </span><span class="s0">link = document.createElement(</span><span class="s2">'link'</span><span class="s0">);</span>
                    <span class="s0">link.rel = </span><span class="s2">'stylesheet'</span><span class="s0">;</span>
                    <span class="s0">link.href = chunkUrl;</span>
                    <span class="s0">link.onerror = ()=&gt;{</span>
                        <span class="s0">resolver.reject();</span>
                    <span class="s0">};</span>
                    <span class="s0">link.onload = ()=&gt;{</span>
                        <span class="s3">// CSS chunks do not register themselves, and as such must be marked as</span>
                        <span class="s3">// loaded instantly.</span>
                        <span class="s0">resolver.resolve();</span>
                    <span class="s0">};</span>
                    <span class="s3">// Append to the `head` for webpack compatibility.</span>
                    <span class="s0">document.head.appendChild(link);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(isJs(chunkUrl)) {</span>
                <span class="s1">const </span><span class="s0">previousScripts = document.querySelectorAll(</span><span class="s2">`script[src=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">&quot;],script[src^=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">?&quot;],script[src=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">&quot;],script[src^=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">?&quot;]`</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(previousScripts.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s3">// There is this edge where the script already failed loading, but we</span>
                    <span class="s3">// can't detect that. The Promise will never resolve in this case.</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">script of Array.from(previousScripts)){</span>
                        <span class="s0">script.addEventListener(</span><span class="s2">'error'</span><span class="s0">, ()=&gt;{</span>
                            <span class="s0">resolver.reject();</span>
                        <span class="s0">});</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">const </span><span class="s0">script = document.createElement(</span><span class="s2">'script'</span><span class="s0">);</span>
                    <span class="s0">script.src = chunkUrl;</span>
                    <span class="s3">// We'll only mark the chunk as loaded once the script has been executed,</span>
                    <span class="s3">// which happens in `registerChunk`. Hence the absence of `resolve()` in</span>
                    <span class="s3">// this branch.</span>
                    <span class="s0">script.onerror = ()=&gt;{</span>
                        <span class="s0">resolver.reject();</span>
                    <span class="s0">};</span>
                    <span class="s3">// Append to the `head` for webpack compatibility.</span>
                    <span class="s0">document.head.appendChild(script);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`can't infer type of chunk from URL </span><span class="s0">${chunkUrl}</span><span class="s2">`</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">resolver.loadingStarted = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">resolver.promise;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">fetchWebAssembly(wasmChunkPath) {</span>
        <span class="s1">return </span><span class="s0">fetch(getChunkRelativeUrl(wasmChunkPath));</span>
    <span class="s0">}</span>
<span class="s0">})();</span>
<span class="s3">/**</span>
 <span class="s3">* This file contains the runtime code specific to the Turbopack development</span>
 <span class="s3">* ECMAScript DOM runtime.</span>
 <span class="s3">*</span>
 <span class="s3">* It will be appended to the base development runtime code.</span>
 <span class="s3">*/ /* eslint-disable @typescript-eslint/no-unused-vars */ /// &lt;reference path=&quot;../base/runtime-base.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;../base/dev-base.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;./runtime-backend-dom.ts&quot; /&gt;</span>
<span class="s3">/// &lt;reference path=&quot;../../../shared/require-type.d.ts&quot; /&gt;</span>
<span class="s1">let </span><span class="s0">DEV_BACKEND;</span>
<span class="s0">(()=&gt;{</span>
    <span class="s0">DEV_BACKEND = {</span>
        <span class="s0">unloadChunk (chunkUrl) {</span>
            <span class="s0">deleteResolver(chunkUrl);</span>
            <span class="s3">// TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.</span>
            <span class="s1">const </span><span class="s0">decodedChunkUrl = decodeURI(chunkUrl);</span>
            <span class="s1">if </span><span class="s0">(isCss(chunkUrl)) {</span>
                <span class="s1">const </span><span class="s0">links = document.querySelectorAll(</span><span class="s2">`link[href=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">&quot;],link[href^=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">?&quot;],link[href=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">&quot;],link[href^=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">?&quot;]`</span><span class="s0">);</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">link of Array.from(links)){</span>
                    <span class="s0">link.remove();</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(isJs(chunkUrl)) {</span>
                <span class="s3">// Unloading a JS chunk would have no effect, as it lives in the JS</span>
                <span class="s3">// runtime once evaluated.</span>
                <span class="s3">// However, we still want to remove the script tag from the DOM to keep</span>
                <span class="s3">// the HTML somewhat consistent from the user's perspective.</span>
                <span class="s1">const </span><span class="s0">scripts = document.querySelectorAll(</span><span class="s2">`script[src=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">&quot;],script[src^=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">?&quot;],script[src=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">&quot;],script[src^=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">?&quot;]`</span><span class="s0">);</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">script of Array.from(scripts)){</span>
                    <span class="s0">script.remove();</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">`can't infer type of chunk from URL </span><span class="s0">${chunkUrl}</span><span class="s2">`</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s0">reloadChunk (chunkUrl) {</span>
            <span class="s1">return new </span><span class="s0">Promise((resolve, reject)=&gt;{</span>
                <span class="s1">if </span><span class="s0">(!isCss(chunkUrl)) {</span>
                    <span class="s0">reject(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'The DOM backend can only reload CSS chunks'</span><span class="s0">));</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">decodedChunkUrl = decodeURI(chunkUrl);</span>
                <span class="s1">const </span><span class="s0">previousLinks = document.querySelectorAll(</span><span class="s2">`link[rel=stylesheet][href=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">&quot;],link[rel=stylesheet][href^=&quot;</span><span class="s0">${chunkUrl}</span><span class="s2">?&quot;],link[rel=stylesheet][href=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">&quot;],link[rel=stylesheet][href^=&quot;</span><span class="s0">${decodedChunkUrl}</span><span class="s2">?&quot;]`</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(previousLinks.length === </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">reject(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">`No link element found for chunk </span><span class="s0">${chunkUrl}</span><span class="s2">`</span><span class="s0">));</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">link = document.createElement(</span><span class="s2">'link'</span><span class="s0">);</span>
                <span class="s0">link.rel = </span><span class="s2">'stylesheet'</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(navigator.userAgent.includes(</span><span class="s2">'Firefox'</span><span class="s0">)) {</span>
                    <span class="s3">// Firefox won't reload CSS files that were previously loaded on the current page,</span>
                    <span class="s3">// we need to add a query param to make sure CSS is actually reloaded from the server.</span>
                    <span class="s3">//</span>
                    <span class="s3">// I believe this is this issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1037506</span>
                    <span class="s3">//</span>
                    <span class="s3">// Safari has a similar issue, but only if you have a `&lt;link rel=preload ... /&gt;` tag</span>
                    <span class="s3">// pointing to the same URL as the stylesheet: https://bugs.webkit.org/show_bug.cgi?id=187726</span>
                    <span class="s0">link.href = </span><span class="s2">`</span><span class="s0">${chunkUrl}</span><span class="s2">?ts=</span><span class="s0">${Date.now()}</span><span class="s2">`</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">link.href = chunkUrl;</span>
                <span class="s0">}</span>
                <span class="s0">link.onerror = ()=&gt;{</span>
                    <span class="s0">reject();</span>
                <span class="s0">};</span>
                <span class="s0">link.onload = ()=&gt;{</span>
                    <span class="s3">// First load the new CSS, then remove the old ones. This prevents visible</span>
                    <span class="s3">// flickering that would happen in-between removing the previous CSS and</span>
                    <span class="s3">// loading the new one.</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">previousLink of Array.from(previousLinks))previousLink.remove();</span>
                    <span class="s3">// CSS chunks do not register themselves, and as such must be marked as</span>
                    <span class="s3">// loaded instantly.</span>
                    <span class="s0">resolve();</span>
                <span class="s0">};</span>
                <span class="s3">// Make sure to insert the new CSS right after the previous one, so that</span>
                <span class="s3">// its precedence is higher.</span>
                <span class="s0">previousLinks[</span><span class="s4">0</span><span class="s0">].parentElement.insertBefore(link, previousLinks[</span><span class="s4">0</span><span class="s0">].nextSibling);</span>
            <span class="s0">});</span>
        <span class="s0">},</span>
        <span class="s0">restart: ()=&gt;self.location.reload()</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">deleteResolver(chunkUrl) {</span>
        <span class="s0">chunkResolvers.delete(chunkUrl);</span>
    <span class="s0">}</span>
<span class="s0">})();</span>
<span class="s1">function </span><span class="s0">_eval({ code, url, map }) {</span>
    <span class="s0">code += </span><span class="s2">`</span><span class="s7">\n\n</span><span class="s2">//# sourceURL=</span><span class="s0">${encodeURI(location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX_PATH)}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(map) {</span>
        <span class="s0">code += </span><span class="s2">`</span><span class="s7">\n</span><span class="s2">//# sourceMappingURL=data:application/json;charset=utf-8;base64,</span><span class="s0">${btoa(</span><span class="s3">// btoa doesn't handle nonlatin characters, so escape them as \x sequences</span>
        <span class="s3">// See https://stackoverflow.com/a/26603875</span>
        <span class="s0">unescape(encodeURIComponent(map)))}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// eslint-disable-next-line no-eval</span>
    <span class="s1">return </span><span class="s0">eval(code);</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">chunksToRegister = globalThis.TURBOPACK;</span>
<span class="s0">globalThis.TURBOPACK = { push: registerChunk };</span>
<span class="s0">chunksToRegister.forEach(registerChunk);</span>
<span class="s1">const </span><span class="s0">chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS || [];</span>
<span class="s0">globalThis.TURBOPACK_CHUNK_LISTS = { push: registerChunkList };</span>
<span class="s0">chunkListsToRegister.forEach(registerChunkList);</span>
<span class="s0">})();</span>


<span class="s3">//# sourceMappingURL=_cdba956c._.js.map</span></pre>
</body>
</html>