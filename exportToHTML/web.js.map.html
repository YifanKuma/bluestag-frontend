<html>
<head>
<title>web.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
web.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/response-cache/web.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { DetachedPromise } from '../../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import type { ResponseCacheEntry, ResponseGenerator } from './types'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* In the web server, there is currently no incremental cache provided and we</span><span class="s3">\n </span><span class="s1">* always SSR the page.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default class WebResponseCache {</span><span class="s3">\n  </span><span class="s1">pendingResponses: Map&lt;string, Promise&lt;ResponseCacheEntry | null&gt;&gt;</span><span class="s3">\n  </span><span class="s1">previousCacheItem?: {</span><span class="s3">\n    </span><span class="s1">key: string</span><span class="s3">\n    </span><span class="s1">entry: ResponseCacheEntry | null</span><span class="s3">\n    </span><span class="s1">expiresAt: number</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(minimalMode: boolean) {</span><span class="s3">\n    </span><span class="s1">this.pendingResponses = new Map()</span><span class="s3">\n    </span><span class="s1">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span><span class="s3">\n    </span><span class="s1">// because we replace this.minimalMode to true in production bundles.</span><span class="s3">\n    </span><span class="s1">Object.assign(this, { minimalMode })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: any</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// ensure on-demand revalidate doesn't block normal requests</span><span class="s3">\n    </span><span class="s1">const pendingResponseKey = key</span><span class="s3">\n      </span><span class="s1">? `${key}-${context.isOnDemandRevalidate ? '1' : '0'}`</span><span class="s3">\n      </span><span class="s1">: null</span><span class="s3">\n\n    </span><span class="s1">const pendingResponse = pendingResponseKey</span><span class="s3">\n      </span><span class="s1">? this.pendingResponses.get(pendingResponseKey)</span><span class="s3">\n      </span><span class="s1">: null</span><span class="s3">\n    </span><span class="s1">if (pendingResponse) {</span><span class="s3">\n      </span><span class="s1">return pendingResponse</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">promise,</span><span class="s3">\n      </span><span class="s1">resolve: resolver,</span><span class="s3">\n      </span><span class="s1">reject: rejecter,</span><span class="s3">\n    </span><span class="s1">} = new DetachedPromise&lt;ResponseCacheEntry | null&gt;()</span><span class="s3">\n    </span><span class="s1">if (pendingResponseKey) {</span><span class="s3">\n      </span><span class="s1">this.pendingResponses.set(pendingResponseKey, promise)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let hasResolved = false</span><span class="s3">\n    </span><span class="s1">const resolve = (cacheEntry: ResponseCacheEntry | null) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (pendingResponseKey) {</span><span class="s3">\n        </span><span class="s1">// Ensure all reads from the cache get the latest value.</span><span class="s3">\n        </span><span class="s1">this.pendingResponses.set(</span><span class="s3">\n          </span><span class="s1">pendingResponseKey,</span><span class="s3">\n          </span><span class="s1">Promise.resolve(cacheEntry)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!hasResolved) {</span><span class="s3">\n        </span><span class="s1">hasResolved = true</span><span class="s3">\n        </span><span class="s1">resolver(cacheEntry)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// we keep the previous cache entry around to leverage</span><span class="s3">\n    </span><span class="s1">// when the incremental cache is disabled in minimal mode</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">pendingResponseKey &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.minimalMode &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.previousCacheItem?.key === pendingResponseKey &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.previousCacheItem.expiresAt &gt; Date.now()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">resolve(this.previousCacheItem.entry)</span><span class="s3">\n      </span><span class="s1">this.pendingResponses.delete(pendingResponseKey)</span><span class="s3">\n      </span><span class="s1">return promise</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We wait to do any async work until after we've added our promise to</span><span class="s3">\n    </span><span class="s1">// `pendingResponses` to ensure that any any other calls will reuse the</span><span class="s3">\n    </span><span class="s1">// same promise until we've fully finished our work.</span><span class="s3">\n    </span><span class="s1">;(async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const cacheEntry = await responseGenerator({ hasResolved })</span><span class="s3">\n        </span><span class="s1">const resolveValue =</span><span class="s3">\n          </span><span class="s1">cacheEntry === null</span><span class="s3">\n            </span><span class="s1">? null</span><span class="s3">\n            </span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">...cacheEntry,</span><span class="s3">\n                </span><span class="s1">isMiss: true,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// for on-demand revalidate wait to resolve until cache is set</span><span class="s3">\n        </span><span class="s1">if (!context.isOnDemandRevalidate) {</span><span class="s3">\n          </span><span class="s1">resolve(resolveValue)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (key &amp;&amp; cacheEntry &amp;&amp; cacheEntry.cacheControl) {</span><span class="s3">\n          </span><span class="s1">this.previousCacheItem = {</span><span class="s3">\n            </span><span class="s1">key: pendingResponseKey || key,</span><span class="s3">\n            </span><span class="s1">entry: cacheEntry,</span><span class="s3">\n            </span><span class="s1">expiresAt: Date.now() + 1000,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">this.previousCacheItem = undefined</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (context.isOnDemandRevalidate) {</span><span class="s3">\n          </span><span class="s1">resolve(resolveValue)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">// while revalidating in the background we can't reject as</span><span class="s3">\n        </span><span class="s1">// we already resolved the cache entry so log the error here</span><span class="s3">\n        </span><span class="s1">if (hasResolved) {</span><span class="s3">\n          </span><span class="s1">console.error(err)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">rejecter(err as Error)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">if (pendingResponseKey) {</span><span class="s3">\n          </span><span class="s1">this.pendingResponses.delete(pendingResponseKey)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})()</span><span class="s3">\n    </span><span class="s1">return promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;WebResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalMode&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingResponses&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;responseGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingResponseKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;resolver&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;rejecter&quot;</span><span class="s0">,</span><span class="s1">&quot;DetachedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;hasResolved&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheItem&quot;</span><span class="s0">,</span><span class="s1">&quot;expiresAt&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isMiss&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAGA;;;CAGC,GACD;;;eAAqBA;;;iCAPW;AAOjB,MAAMA;IASnBC,YAAYC,WAAoB,CAAE;QAChC,IAAI,CAACC,gBAAgB,GAAG,IAAIC;QAC5B,4EAA4E;QAC5E,qEAAqE;QACrEC,OAAOC,MAAM,CAAC,IAAI,EAAE;YAAEJ;QAAY;IACpC;IAEOK,IACLC,GAAkB,EAClBC,iBAAoC,EACpCC,OAIC,EACmC;YA0ClC;QAzCF,4DAA4D;QAC5D,MAAMC,qBAAqBH,MACvB,GAAGA,IAAI,CAAC,EAAEE,QAAQE,oBAAoB,GAAG,MAAM,KAAK,GACpD;QAEJ,MAAMC,kBAAkBF,qBACpB,IAAI,CAACR,gBAAgB,CAACI,GAAG,CAACI,sBAC1B;QACJ,IAAIE,iBAAiB;YACnB,OAAOA;QACT;QAEA,MAAM,EACJC,OAAO,EACPC,SAASC,QAAQ,EACjBC,QAAQC,QAAQ,EACjB,GAAG,IAAIC,gCAAe;QACvB,IAAIR,oBAAoB;YACtB,IAAI,CAACR,gBAAgB,CAACiB,GAAG,CAACT,oBAAoBG;QAChD;QAEA,IAAIO,cAAc;QAClB,MAAMN,UAAU,CAACO;YACf,IAAIX,oBAAoB;gBACtB,wDAAwD;gBACxD,IAAI,CAACR,gBAAgB,CAACiB,GAAG,CACvBT,oBACAY,QAAQR,OAAO,CAACO;YAEpB;YACA,IAAI,CAACD,aAAa;gBAChBA,cAAc;gBACdL,SAASM;YACX;QACF;QAEA,sDAAsD;QACtD,yDAAyD;QACzD,IACEX,sBACA,IAAI,CAACT,WAAW,IAChB,EAAA,0BAAA,IAAI,CAACsB,iBAAiB,qBAAtB,wBAAwBhB,GAAG,MAAKG,sBAChC,IAAI,CAACa,iBAAiB,CAACC,SAAS,GAAGC,KAAKC,GAAG,IAC3C;YACAZ,QAAQ,IAAI,CAACS,iBAAiB,CAACI,KAAK;YACpC,IAAI,CAACzB,gBAAgB,CAAC0B,MAAM,CAAClB;YAC7B,OAAOG;QACT;QAEA,sEAAsE;QACtE,uEAAuE;QACvE,oDAAoD;;QAClD,CAAA;YACA,IAAI;gBACF,MAAMQ,aAAa,MAAMb,kBAAkB;oBAAEY;gBAAY;gBACzD,MAAMS,eACJR,eAAe,OACX,OACA;oBACE,GAAGA,UAAU;oBACbS,QAAQ;gBACV;gBAEN,8DAA8D;gBAC9D,IAAI,CAACrB,QAAQE,oBAAoB,EAAE;oBACjCG,QAAQe;gBACV;gBAEA,IAAItB,OAAOc,cAAcA,WAAWU,YAAY,EAAE;oBAChD,IAAI,CAACR,iBAAiB,GAAG;wBACvBhB,KAAKG,sBAAsBH;wBAC3BoB,OAAON;wBACPG,WAAWC,KAAKC,GAAG,KAAK;oBAC1B;gBACF,OAAO;oBACL,IAAI,CAACH,iBAAiB,GAAGS;gBAC3B;gBAEA,IAAIvB,QAAQE,oBAAoB,EAAE;oBAChCG,QAAQe;gBACV;YACF,EAAE,OAAOI,KAAK;gBACZ,0DAA0D;gBAC1D,4DAA4D;gBAC5D,IAAIb,aAAa;oBACfc,QAAQC,KAAK,CAACF;gBAChB,OAAO;oBACLhB,SAASgB;gBACX;YACF,SAAU;gBACR,IAAIvB,oBAAoB;oBACtB,IAAI,CAACR,gBAAgB,CAAC0B,MAAM,CAAClB;gBAC/B;YACF;QACF,CAAA;QACA,OAAOG;IACT;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>