<html>
<head>
<title>next-metadata-image-loader.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-metadata-image-loader.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * This loader is responsible for extracting the metadata image info for rendering in html 
 */ </span><span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s4">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s3">default</span><span class="s1">: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">raw: </span><span class="s3">null</span>
<span class="s1">});</span>
<span class="s3">function </span><span class="s1">_export(target, all) {</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">name </span><span class="s3">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s3">default</span><span class="s1">: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">_default;</span>
    <span class="s1">},</span>
    <span class="s1">raw: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">raw;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_fs = require(</span><span class="s2">&quot;fs&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_path = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_loaderutils3 = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;next/dist/compiled/loader-utils3&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_imageoptimizer = require(</span><span class="s2">&quot;../../../server/image-optimizer&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_mimetype = require(</span><span class="s2">&quot;../../../lib/mime-type&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_constants = require(</span><span class="s2">&quot;../../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_normalizepathsep = require(</span><span class="s2">&quot;../../../shared/lib/page-path/normalize-path-sep&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_utils = require(</span><span class="s2">&quot;./utils&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s3">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s3">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">// [NOTE] For turbopack, refer to app_page_loader_tree's write_metadata_item for</span>
<span class="s0">// corresponding features.</span>
<span class="s1">async </span><span class="s3">function </span><span class="s1">nextMetadataImageLoader(content) {</span>
    <span class="s3">const </span><span class="s1">options = </span><span class="s3">this</span><span class="s1">.getOptions();</span>
    <span class="s3">const </span><span class="s1">{ type, segment, pageExtensions, basePath } = options;</span>
    <span class="s3">const </span><span class="s1">{ resourcePath, rootContext: context } = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">{ name: fileNameBase, ext } = _path.default.parse(resourcePath);</span>
    <span class="s3">const </span><span class="s1">useNumericSizes = type === </span><span class="s2">'twitter' </span><span class="s1">|| type === </span><span class="s2">'openGraph'</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s1">extension = ext.slice(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(extension === </span><span class="s2">'jpg'</span><span class="s1">) {</span>
        <span class="s1">extension = </span><span class="s2">'jpeg'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">opts = {</span>
        <span class="s1">context,</span>
        <span class="s1">content</span>
    <span class="s1">};</span>
    <span class="s0">// No hash query for favicon.ico</span>
    <span class="s3">const </span><span class="s1">contentHash = type === </span><span class="s2">'favicon' </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: _loaderutils3.default.interpolateName(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'[contenthash]'</span><span class="s1">, opts);</span>
    <span class="s3">const </span><span class="s1">interpolatedName = _loaderutils3.default.interpolateName(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'[name].[ext]'</span><span class="s1">, opts);</span>
    <span class="s3">const </span><span class="s1">isDynamicResource = pageExtensions.includes(extension);</span>
    <span class="s3">const </span><span class="s1">pageSegment = isDynamicResource ? fileNameBase : interpolatedName;</span>
    <span class="s3">const </span><span class="s1">hashQuery = contentHash ? </span><span class="s2">'?' </span><span class="s1">+ contentHash : </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s1">pathnamePrefix = (</span><span class="s4">0</span><span class="s1">, _normalizepathsep.normalizePathSep)(_path.default.join(basePath, segment));</span>
    <span class="s3">if </span><span class="s1">(isDynamicResource) {</span>
        <span class="s3">const </span><span class="s1">exportedFieldsExcludingDefault = (</span><span class="s3">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils.getLoaderModuleNamedExports)(resourcePath, </span><span class="s3">this</span><span class="s1">)).filter((name)=&gt;name !== </span><span class="s2">'default'</span><span class="s1">);</span>
        <span class="s0">// re-export and spread as `exportedImageData` to avoid non-exported error</span>
        <span class="s3">return </span><span class="s2">`</span><span class="s5">\ 
    </span><span class="s2">import { 
      </span><span class="s1">${exportedFieldsExcludingDefault.map((field)=&gt;</span><span class="s2">`</span><span class="s1">${field} </span><span class="s2">as _</span><span class="s1">${field}</span><span class="s2">`</span><span class="s1">).join(</span><span class="s2">','</span><span class="s1">)}</span>
    <span class="s2">} from </span><span class="s1">${JSON.stringify(</span><span class="s0">// This is an arbitrary resource query to ensure it's a new request, instead</span>
        <span class="s0">// of sharing the same module with next-metadata-route-loader.</span>
        <span class="s0">// Since here we only need export fields such as `size`, `alt` and</span>
        <span class="s0">// `generateImageMetadata`, avoid sharing the same module can make this entry</span>
        <span class="s0">// smaller.</span>
        <span class="s1">resourcePath + </span><span class="s2">'?' </span><span class="s1">+ _constants.WEBPACK_RESOURCE_QUERIES.metadataImageMeta)}</span>
    <span class="s2">import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route' 
 
    const imageModule = { 
      </span><span class="s1">${exportedFieldsExcludingDefault.map((field)=&gt;</span><span class="s2">`</span><span class="s1">${field}</span><span class="s2">: _</span><span class="s1">${field}</span><span class="s2">`</span><span class="s1">).join(</span><span class="s2">','</span><span class="s1">)}</span>
    <span class="s2">} 
 
    export default async function (props) { 
      const { __metadata_id__: _, ...params } = await props.params 
      const imageUrl = fillMetadataSegment(</span><span class="s1">${JSON.stringify(pathnamePrefix)}</span><span class="s2">, params, </span><span class="s1">${JSON.stringify(pageSegment)}</span><span class="s2">) 
 
      const { generateImageMetadata } = imageModule 
 
      function getImageMetadata(imageMetadata, idParam) { 
        const data = { 
          alt: imageMetadata.alt, 
          type: imageMetadata.contentType || 'image/png', 
          url: imageUrl + (idParam ? ('/' + idParam) : '') + </span><span class="s1">${JSON.stringify(hashQuery)}</span><span class="s2">, 
        } 
        const { size } = imageMetadata 
        if (size) { 
          </span><span class="s1">${type === </span><span class="s2">'twitter' </span><span class="s1">|| type === </span><span class="s2">'openGraph' </span><span class="s1">? </span><span class="s2">'data.width = size.width; data.height = size.height;' </span><span class="s1">: </span><span class="s2">'data.sizes = size.width + &quot;x&quot; + size.height;'</span><span class="s1">}</span>
        <span class="s2">} 
        return data 
      } 
 
      if (generateImageMetadata) { 
        const imageMetadataArray = await generateImageMetadata({ params }) 
        return imageMetadataArray.map((imageMetadata, index) =&gt; { 
          const idParam = (imageMetadata.id || index) + '' 
          return getImageMetadata(imageMetadata, idParam) 
        }) 
      } else { 
        return [getImageMetadata(imageModule, '')] 
      } 
    }`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">imageSize = </span><span class="s3">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _imageoptimizer.getImageSize)(content).catch((err)=&gt;err);</span>
    <span class="s3">if </span><span class="s1">(imageSize </span><span class="s3">instanceof </span><span class="s1">Error) {</span>
        <span class="s3">const </span><span class="s1">err = imageSize;</span>
        <span class="s1">err.name = </span><span class="s2">'InvalidImageFormatError'</span><span class="s1">;</span>
        <span class="s3">throw </span><span class="s1">err;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">imageData = {</span>
        <span class="s1">...extension </span><span class="s3">in </span><span class="s1">_mimetype.imageExtMimeTypeMap &amp;&amp; {</span>
            <span class="s1">type: _mimetype.imageExtMimeTypeMap[extension]</span>
        <span class="s1">},</span>
        <span class="s1">...useNumericSizes &amp;&amp; imageSize.width != </span><span class="s3">null </span><span class="s1">&amp;&amp; imageSize.height != </span><span class="s3">null </span><span class="s1">? imageSize : {</span>
            <span class="s1">sizes: </span><span class="s0">// For SVGs, skip sizes and use &quot;any&quot; to let it scale automatically based on viewport,</span>
            <span class="s0">// For the images doesn't provide the size properly, use &quot;any&quot; as well.</span>
            <span class="s0">// If the size is presented, use the actual size for the image.</span>
            <span class="s1">extension !== </span><span class="s2">'svg' </span><span class="s1">&amp;&amp; imageSize.width != </span><span class="s3">null </span><span class="s1">&amp;&amp; imageSize.height != </span><span class="s3">null </span><span class="s1">? </span><span class="s2">`</span><span class="s1">${imageSize.width}</span><span class="s2">x</span><span class="s1">${imageSize.height}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">'any'</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'openGraph' </span><span class="s1">|| type === </span><span class="s2">'twitter'</span><span class="s1">) {</span>
        <span class="s3">const </span><span class="s1">altPath = _path.default.join(_path.default.dirname(resourcePath), fileNameBase + </span><span class="s2">'.alt.txt'</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _fs.existsSync)(altPath)) {</span>
            <span class="s1">imageData.alt = </span><span class="s3">await </span><span class="s1">_fs.promises.readFile(altPath, </span><span class="s2">'utf8'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s2">`</span><span class="s5">\ 
  </span><span class="s2">import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route' 
 
  export default async (props) =&gt; { 
    const imageData = </span><span class="s1">${JSON.stringify(imageData)}</span>
    <span class="s2">const imageUrl = fillMetadataSegment(</span><span class="s1">${JSON.stringify(pathnamePrefix)}</span><span class="s2">, await props.params, </span><span class="s1">${JSON.stringify(pageSegment)}</span><span class="s2">) 
 
    return [{ 
      ...imageData, 
      url: imageUrl + </span><span class="s1">${JSON.stringify(type === </span><span class="s2">'favicon' </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: hashQuery)}</span><span class="s2">, 
    }] 
  }`</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">raw = </span><span class="s3">true</span><span class="s1">;</span>
<span class="s3">const </span><span class="s1">_default = nextMetadataImageLoader;</span>

<span class="s0">//# sourceMappingURL=next-metadata-image-loader.js.map</span></pre>
</body>
</html>