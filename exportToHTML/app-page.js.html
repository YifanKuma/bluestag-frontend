<html>
<head>
<title>app-page.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-page.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;exportAppPage&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">exportAppPage;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_isdynamicusageerror = require(</span><span class="s0">&quot;../helpers/is-dynamic-usage-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ciinfo = require(</span><span class="s0">&quot;../../server/ci-info&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_modulerender = require(</span><span class="s0">&quot;../../server/route-modules/app-page/module.render&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_bailouttocsr = require(</span><span class="s0">&quot;../../shared/lib/lazy-dynamic/bailout-to-csr&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_node = require(</span><span class="s0">&quot;../../server/base-http/node&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_approuterheaders = require(</span><span class="s0">&quot;../../client/components/app-router-headers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_runwithafter = require(</span><span class="s0">&quot;../../server/after/run-with-after&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_resumedatacache = require(</span><span class="s0">&quot;../../server/resume-data-cache/resume-data-cache&quot;</span><span class="s1">);</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">exportAppPage(req, res, page, path, pathname, query, fallbackRouteParams, partialRenderOpts, htmlFilepath, debugOutput, isDynamicError, fileWriter, sharedContext) {</span>
    <span class="s2">const </span><span class="s1">afterRunner = </span><span class="s2">new </span><span class="s1">_runwithafter.AfterRunner();</span>
    <span class="s2">const </span><span class="s1">renderOpts = {</span>
        <span class="s1">...partialRenderOpts,</span>
        <span class="s1">waitUntil: afterRunner.context.waitUntil,</span>
        <span class="s1">onClose: afterRunner.context.onClose,</span>
        <span class="s1">onAfterTaskError: afterRunner.context.onTaskError</span>
    <span class="s1">};</span>
    <span class="s2">let </span><span class="s1">isDefaultNotFound = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s3">// If the page is `/_not-found`, then we should update the page to be `/404`.</span>
    <span class="s3">// UNDERSCORE_NOT_FOUND_ROUTE value used here, however we don't want to import it here as it causes constants to be inlined which we don't want here.</span>
    <span class="s2">if </span><span class="s1">(page === </span><span class="s0">'/_not-found/page'</span><span class="s1">) {</span>
        <span class="s1">isDefaultNotFound = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">pathname = </span><span class="s0">'/404'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _modulerender.lazyRenderAppPage)(</span><span class="s2">new </span><span class="s1">_node.NodeNextRequest(req), </span><span class="s2">new </span><span class="s1">_node.NodeNextResponse(res), pathname, query, fallbackRouteParams, renderOpts, undefined, </span><span class="s2">false</span><span class="s1">, sharedContext);</span>
        <span class="s2">const </span><span class="s1">html = result.toUnchunkedString();</span>
        <span class="s3">// TODO(after): if we abort a prerender because of an error in an after-callback</span>
        <span class="s3">// we should probably communicate that better (and not log the error twice)</span>
        <span class="s2">await </span><span class="s1">afterRunner.executeAfter();</span>
        <span class="s2">const </span><span class="s1">{ metadata } = result;</span>
        <span class="s2">const </span><span class="s1">{ flightData, cacheControl = {</span>
            <span class="s1">revalidate: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">expire: undefined</span>
        <span class="s1">}, postponed, fetchTags, fetchMetrics, segmentData, renderResumeDataCache } = metadata;</span>
        <span class="s3">// Ensure we don't postpone without having PPR enabled.</span>
        <span class="s2">if </span><span class="s1">(postponed &amp;&amp; !renderOpts.experimental.isRoutePPREnabled) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: page postponed without PPR being enabled'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E156&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(cacheControl.revalidate === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(isDynamicError) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Page with dynamic = &quot;error&quot; encountered dynamic data method on </span><span class="s1">${path}</span><span class="s0">.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E388&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ staticBailoutInfo = {} } = metadata;</span>
            <span class="s2">if </span><span class="s1">(debugOutput &amp;&amp; (staticBailoutInfo == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: staticBailoutInfo.description)) {</span>
                <span class="s1">logDynamicUsageWarning({</span>
                    <span class="s1">path,</span>
                    <span class="s1">description: staticBailoutInfo.description,</span>
                    <span class="s1">stack: staticBailoutInfo.stack</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">cacheControl,</span>
                <span class="s1">fetchMetrics</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s3">// If page data isn't available, it means that the page couldn't be rendered</span>
        <span class="s3">// properly so long as we don't have unknown route params. When a route doesn't</span>
        <span class="s3">// have unknown route params, there will not be any flight data.</span>
        <span class="s2">if </span><span class="s1">(!flightData &amp;&amp; (!fallbackRouteParams || fallbackRouteParams.size === </span><span class="s4">0</span><span class="s1">)) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Invariant: failed to get page data for </span><span class="s1">${path}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E194&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(flightData) {</span>
            <span class="s3">// If PPR is enabled, we want to emit a prefetch rsc file for the page</span>
            <span class="s3">// instead of the standard rsc. This is because the standard rsc will</span>
            <span class="s3">// contain the dynamic data. We do this if any routes have PPR enabled so</span>
            <span class="s3">// that the cache read/write is the same.</span>
            <span class="s2">if </span><span class="s1">(renderOpts.experimental.isRoutePPREnabled) {</span>
                <span class="s3">// If PPR is enabled, we should emit the flight data as the prefetch</span>
                <span class="s3">// payload.</span>
                <span class="s3">// TODO: This will eventually be replaced by the per-segment prefetch</span>
                <span class="s3">// output below.</span>
                <span class="s1">fileWriter.append(htmlFilepath.replace(</span><span class="s5">/\.html$/</span><span class="s1">, _constants.RSC_PREFETCH_SUFFIX), flightData);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s3">// Writing the RSC payload to a file if we don't have PPR enabled.</span>
                <span class="s1">fileWriter.append(htmlFilepath.replace(</span><span class="s5">/\.html$/</span><span class="s1">, _constants.RSC_SUFFIX), flightData);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">segmentPaths;</span>
        <span class="s2">if </span><span class="s1">(segmentData) {</span>
            <span class="s3">// Emit the per-segment prefetch data. We emit them as separate files</span>
            <span class="s3">// so that the cache handler has the option to treat each as a</span>
            <span class="s3">// separate entry.</span>
            <span class="s1">segmentPaths = [];</span>
            <span class="s2">const </span><span class="s1">segmentsDir = htmlFilepath.replace(</span><span class="s5">/\.html$/</span><span class="s1">, _constants.RSC_SEGMENTS_DIR_SUFFIX);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[segmentPath, buffer] of segmentData){</span>
                <span class="s1">segmentPaths.push(segmentPath);</span>
                <span class="s2">const </span><span class="s1">segmentDataFilePath = segmentsDir + segmentPath + _constants.RSC_SEGMENT_SUFFIX;</span>
                <span class="s1">fileWriter.append(segmentDataFilePath, buffer);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">headers = {</span>
            <span class="s1">...metadata.headers</span>
        <span class="s1">};</span>
        <span class="s3">// If we're writing the file to disk, we know it's a prerender.</span>
        <span class="s1">headers[_approuterheaders.NEXT_IS_PRERENDER_HEADER] = </span><span class="s0">'1'</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(fetchTags) {</span>
            <span class="s1">headers[_constants.NEXT_CACHE_TAGS_HEADER] = fetchTags;</span>
        <span class="s1">}</span>
        <span class="s3">// Writing static HTML to a file.</span>
        <span class="s1">fileWriter.append(htmlFilepath, html);</span>
        <span class="s2">const </span><span class="s1">isParallelRoute = </span><span class="s5">/\/@\w+/</span><span class="s1">.test(page);</span>
        <span class="s2">const </span><span class="s1">isNonSuccessfulStatusCode = res.statusCode &gt; </span><span class="s4">300</span><span class="s1">;</span>
        <span class="s3">// When PPR is enabled, we don't always send 200 for routes that have been</span>
        <span class="s3">// pregenerated, so we should grab the status code from the mocked</span>
        <span class="s3">// response.</span>
        <span class="s2">let </span><span class="s1">status = renderOpts.experimental.isRoutePPREnabled ? res.statusCode : undefined;</span>
        <span class="s2">if </span><span class="s1">(isDefaultNotFound) {</span>
            <span class="s3">// Override the default /_not-found page status code to 404</span>
            <span class="s1">status = </span><span class="s4">404</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isNonSuccessfulStatusCode &amp;&amp; !isParallelRoute) {</span>
            <span class="s3">// If it's parallel route the status from mock response is 404</span>
            <span class="s1">status = res.statusCode;</span>
        <span class="s1">}</span>
        <span class="s3">// Writing the request metadata to a file.</span>
        <span class="s2">const </span><span class="s1">meta = {</span>
            <span class="s1">status,</span>
            <span class="s1">headers,</span>
            <span class="s1">postponed,</span>
            <span class="s1">segmentPaths</span>
        <span class="s1">};</span>
        <span class="s1">fileWriter.append(htmlFilepath.replace(</span><span class="s5">/\.html$/</span><span class="s1">, _constants.NEXT_META_SUFFIX), JSON.stringify(meta, </span><span class="s2">null</span><span class="s1">, </span><span class="s4">2</span><span class="s1">));</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s3">// Filter the metadata if the environment does not have next support.</span>
            <span class="s1">metadata: _ciinfo.hasNextSupport ? meta : {</span>
                <span class="s1">segmentPaths: meta.segmentPaths</span>
            <span class="s1">},</span>
            <span class="s1">hasEmptyStaticShell: Boolean(postponed) &amp;&amp; html === </span><span class="s0">''</span><span class="s1">,</span>
            <span class="s1">hasPostponed: Boolean(postponed),</span>
            <span class="s1">cacheControl,</span>
            <span class="s1">fetchMetrics,</span>
            <span class="s1">renderResumeDataCache: renderResumeDataCache ? </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _resumedatacache.stringifyResumeDataCache)(renderResumeDataCache) : undefined</span>
        <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, _isdynamicusageerror.isDynamicUsageError)(err)) {</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s3">// We should fail rendering if a client side rendering bailout</span>
        <span class="s3">// occurred at the page level.</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _bailouttocsr.isBailoutToCSRError)(err)) {</span>
            <span class="s2">throw </span><span class="s1">err;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">fetchMetrics;</span>
        <span class="s2">if </span><span class="s1">(debugOutput) {</span>
            <span class="s2">const </span><span class="s1">store = renderOpts.store;</span>
            <span class="s2">const </span><span class="s1">{ dynamicUsageDescription, dynamicUsageStack } = store;</span>
            <span class="s1">fetchMetrics = store.fetchMetrics;</span>
            <span class="s1">logDynamicUsageWarning({</span>
                <span class="s1">path,</span>
                <span class="s1">description: dynamicUsageDescription ?? </span><span class="s0">''</span><span class="s1">,</span>
                <span class="s1">stack: dynamicUsageStack</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">cacheControl: {</span>
                <span class="s1">revalidate: </span><span class="s4">0</span><span class="s1">,</span>
                <span class="s1">expire: undefined</span>
            <span class="s1">},</span>
            <span class="s1">fetchMetrics</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">logDynamicUsageWarning({ path, description, stack }) {</span>
    <span class="s2">const </span><span class="s1">errMessage = Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Static generation failed due to dynamic usage on </span><span class="s1">${path}</span><span class="s0">, reason: </span><span class="s1">${description}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">&quot;E381&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(stack) {</span>
        <span class="s1">errMessage.stack = errMessage.message + stack.substring(stack.indexOf(</span><span class="s0">'</span><span class="s6">\n</span><span class="s0">'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s1">console.warn(errMessage);</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=app-page.js.map</span></pre>
</body>
</html>