<html>
<head>
<title>emnapi-core.d.mts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
emnapi-core.d.mts</font>
</center></td></tr></table>
<pre><span class="s0">/// &lt;reference types=&quot;node&quot; /&gt;</span>

<span class="s2">import </span><span class="s1">type { Context } from </span><span class="s3">'@emnapi/runtime'</span><span class="s1">;</span>
<span class="s2">import </span><span class="s1">type { ReferenceOwnership } from </span><span class="s3">'@emnapi/runtime'</span><span class="s1">;</span>
<span class="s2">import </span><span class="s1">type { Worker as Worker_2 } from </span><span class="s3">'worker_threads'</span><span class="s1">;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type BaseCreateOptions = {</span>
    <span class="s1">filename?: string</span>
    <span class="s1">nodeBinding?: NodeBinding</span>
    <span class="s1">reuseWorker?: ThreadManagerOptionsMain[</span><span class="s3">'reuseWorker'</span><span class="s1">]</span>
    <span class="s1">asyncWorkPoolSize?: number</span>
    <span class="s1">waitThreadStart?: MainThreadBaseOptions[</span><span class="s3">'waitThreadStart'</span><span class="s1">]</span>
    <span class="s1">onCreateWorker?: (info: CreateWorkerInfo) =&gt; any</span>
    <span class="s1">print?: (str: string) =&gt; </span><span class="s2">void</span>
    <span class="s1">printErr?: (str: string) =&gt; </span><span class="s2">void</span>
    <span class="s1">postMessage?: (msg: any) =&gt; any</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">BaseOptions {</span>
    <span class="s1">wasi: WASIInstance;</span>
    <span class="s1">version?: </span><span class="s3">'preview1'</span><span class="s1">;</span>
    <span class="s1">wasm64?: boolean;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ChildThreadOptions </span><span class="s2">extends </span><span class="s1">BaseOptions {</span>
    <span class="s1">childThread: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">postMessage?: (data: any) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">CleanupThreadPayload {</span>
    <span class="s1">tid: number;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">CommandInfo&lt;T </span><span class="s2">extends </span><span class="s1">CommandType&gt; {</span>
    <span class="s1">type: T;</span>
    <span class="s1">payload: CommandPayloadMap[T];</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">CommandPayloadMap {</span>
    <span class="s1">load: LoadPayload;</span>
    <span class="s1">loaded: LoadedPayload;</span>
    <span class="s1">start: StartPayload;</span>
    <span class="s3">'cleanup-thread'</span><span class="s1">: CleanupThreadPayload;</span>
    <span class="s3">'terminate-all-threads'</span><span class="s1">: TerminateAllThreadsPayload;</span>
    <span class="s3">'spawn-thread'</span><span class="s1">: SpawnThreadPayload;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type CommandType = keyof CommandPayloadMap;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">function </span><span class="s1">createInstanceProxy(instance: WebAssembly.Instance, memory?: WebAssembly.Memory | (() =&gt; WebAssembly.Memory)): WebAssembly.Instance;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">function </span><span class="s1">createNapiModule (</span>
<span class="s1">options: CreateOptions</span>
<span class="s1">): NapiModule</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type CreateOptions = BaseCreateOptions &amp; ({</span>
    <span class="s1">context: Context</span>
    <span class="s1">childThread?: boolean</span>
<span class="s1">} | {</span>
    <span class="s1">context?: Context</span>
    <span class="s1">childThread: </span><span class="s2">true</span>
<span class="s1">})</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">CreateWorkerInfo {</span>
    <span class="s1">type: </span><span class="s3">'thread' </span><span class="s1">| </span><span class="s3">'async-work'</span>
    <span class="s1">name: string</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">InitOptions {</span>
    <span class="s1">instance: WebAssembly.Instance</span>
    <span class="s1">module: WebAssembly.Module</span>
    <span class="s1">memory?: WebAssembly.Memory</span>
    <span class="s1">table?: WebAssembly.Table</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s1">declare type InputType = string | URL | Response | BufferSource | WebAssembly.Module;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">InstantiatedSource </span><span class="s2">extends </span><span class="s1">LoadedSource {</span>
    <span class="s1">napiModule: NapiModule;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">function </span><span class="s1">instantiateNapiModule(</span>
<span class="s0">/** Only support `BufferSource` or `WebAssembly.Module` on Node.js */</span>
<span class="s1">wasmInput: InputType | Promise&lt;InputType&gt;, options: InstantiateOptions): Promise&lt;InstantiatedSource&gt;;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">function </span><span class="s1">instantiateNapiModuleSync(wasmInput: BufferSource | WebAssembly.Module, options: InstantiateOptions): InstantiatedSource;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type InstantiateOptions = CreateOptions &amp; LoadOptions;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">function </span><span class="s1">isSharedArrayBuffer(value: any): value is SharedArrayBuffer;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">function </span><span class="s1">isTrapError(e: Error): e is WebAssembly.RuntimeError;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LoadedPayload {</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LoadedSource </span><span class="s2">extends </span><span class="s1">WebAssembly.WebAssemblyInstantiatedSource {</span>
    <span class="s1">usedInstance: WebAssembly.Instance;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">function </span><span class="s1">loadNapiModule(napiModule: NapiModule, </span>
<span class="s0">/** Only support `BufferSource` or `WebAssembly.Module` on Node.js */</span>
<span class="s1">wasmInput: InputType | Promise&lt;InputType&gt;, options?: LoadOptions): Promise&lt;LoadedSource&gt;;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">function </span><span class="s1">loadNapiModuleSync(napiModule: NapiModule, wasmInput: BufferSource | WebAssembly.Module, options?: LoadOptions): LoadedSource;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LoadOptions {</span>
    <span class="s1">wasi?: WASIInstance;</span>
    <span class="s1">overwriteImports?: (importObject: WebAssembly.Imports) =&gt; WebAssembly.Imports;</span>
    <span class="s1">beforeInit?: (source: WebAssembly.WebAssemblyInstantiatedSource) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">getMemory?: (exports: WebAssembly.Exports) =&gt; WebAssembly.Memory;</span>
    <span class="s1">getTable?: (exports: WebAssembly.Exports) =&gt; WebAssembly.Table;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">LoadPayload {</span>
    <span class="s1">wasmModule: WebAssembly.Module;</span>
    <span class="s1">wasmMemory: WebAssembly.Memory;</span>
    <span class="s1">sab?: Int32Array;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MainThreadBaseOptions </span><span class="s2">extends </span><span class="s1">BaseOptions {</span>
    <span class="s1">waitThreadStart?: boolean | number;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type MainThreadOptions = MainThreadOptionsWithThreadManager | MainThreadOptionsCreateThreadManager;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MainThreadOptionsCreateThreadManager </span><span class="s2">extends </span><span class="s1">MainThreadBaseOptions, ThreadManagerOptionsMain {</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MainThreadOptionsWithThreadManager </span><span class="s2">extends </span><span class="s1">MainThreadBaseOptions {</span>
    <span class="s1">threadManager?: ThreadManager | (() =&gt; ThreadManager);</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MessageEventData&lt;T </span><span class="s2">extends </span><span class="s1">CommandType&gt; {</span>
    <span class="s1">__emnapi__: CommandInfo&lt;T&gt;;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">class </span><span class="s1">MessageHandler </span><span class="s2">extends </span><span class="s1">ThreadMessageHandler {</span>
    <span class="s1">napiModule: NapiModule | undefined;</span>
    <span class="s1">constructor(options: MessageHandlerOptions);</span>
    <span class="s1">instantiate(data: LoadPayload): InstantiatedSource | PromiseLike&lt;InstantiatedSource&gt;;</span>
    <span class="s1">handle(e: WorkerMessageEvent): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">MessageHandlerOptions </span><span class="s2">extends </span><span class="s1">ThreadMessageHandlerOptions {</span>
    <span class="s1">onLoad: (data: LoadPayload) =&gt; InstantiatedSource | PromiseLike&lt;InstantiatedSource&gt;;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">NapiModule {</span>
    <span class="s1">imports: {</span>
        <span class="s1">env: any</span>
        <span class="s1">napi: any</span>
        <span class="s1">emnapi: any</span>
    <span class="s1">}</span>
    <span class="s1">exports: any</span>
    <span class="s1">loaded: boolean</span>
    <span class="s1">filename: string</span>
    <span class="s1">childThread: boolean</span>
    <span class="s1">emnapi: {</span>
        <span class="s1">syncMemory&lt;T </span><span class="s2">extends </span><span class="s1">ArrayBuffer | ArrayBufferView&gt; (</span>
        <span class="s1">js_to_wasm: boolean,</span>
        <span class="s1">arrayBufferOrView: T,</span>
        <span class="s1">offset?: number,</span>
        <span class="s1">len?: number</span>
        <span class="s1">): T</span>
        <span class="s1">getMemoryAddress (arrayBufferOrView: ArrayBuffer | ArrayBufferView): PointerInfo</span>
        <span class="s1">addSendListener (worker: any): boolean</span>
    <span class="s1">}</span>

    <span class="s1">init (options: InitOptions): any</span>
    <span class="s1">initWorker (arg: number): </span><span class="s2">void</span>
    <span class="s1">executeAsyncWork (work: number): </span><span class="s2">void</span>
    <span class="s1">postMessage?: (msg: any) =&gt; any</span>

    <span class="s1">waitThreadStart: boolean | number</span>
    <span class="s0">/* Excluded from this release type: PThread */</span><span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">NodeBinding {</span>
    <span class="s1">node: {</span>
        <span class="s1">emitAsyncInit: Function</span>
        <span class="s1">emitAsyncDestroy: Function</span>
        <span class="s1">makeCallback: Function</span>
    <span class="s1">}</span>
    <span class="s1">napi: {</span>
        <span class="s1">asyncInit: Function</span>
        <span class="s1">asyncDestroy: Function</span>
        <span class="s1">makeCallback: Function</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">PointerInfo {</span>
    <span class="s1">address: number</span>
    <span class="s1">ownership: ReferenceOwnership</span>
    <span class="s1">runtimeAllocated: </span><span class="s5">0 </span><span class="s1">| </span><span class="s5">1</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ReuseWorkerOptions {</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s4">@see </span><span class="s0">{</span><span class="s4">@link </span><span class="s0">https://emscripten.org/docs/tools_reference/settings_reference.html#pthread-pool-size | PTHREAD_POOL_SIZE}</span>
     <span class="s0">*/</span>
    <span class="s1">size: number;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s4">@see </span><span class="s0">{</span><span class="s4">@link </span><span class="s0">https://emscripten.org/docs/tools_reference/settings_reference.html#pthread-pool-size-strict | PTHREAD_POOL_SIZE_STRICT}</span>
     <span class="s0">*/</span>
    <span class="s1">strict?: boolean;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">SpawnThreadPayload {</span>
    <span class="s1">startArg: number;</span>
    <span class="s1">errorOrTid: number;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">StartPayload {</span>
    <span class="s1">tid: number;</span>
    <span class="s1">arg: number;</span>
    <span class="s1">sab?: Int32Array;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">StartResult {</span>
    <span class="s1">exitCode: number;</span>
    <span class="s1">instance: WebAssembly.Instance;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">TerminateAllThreadsPayload {</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">class </span><span class="s1">ThreadManager {</span>
    <span class="s1">unusedWorkers: WorkerLike[];</span>
    <span class="s1">runningWorkers: WorkerLike[];</span>
    <span class="s1">pthreads: Record&lt;number, WorkerLike&gt;;</span>
    <span class="s1">get nextWorkerID(): number;</span>
    <span class="s1">wasmModule: WebAssembly.Module | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">wasmMemory: WebAssembly.Memory | </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">private </span><span class="s1">readonly messageEvents;</span>
    <span class="s2">private </span><span class="s1">readonly _childThread;</span>
    <span class="s2">private </span><span class="s1">readonly _onCreateWorker;</span>
    <span class="s2">private </span><span class="s1">readonly _reuseWorker;</span>
    <span class="s2">private </span><span class="s1">readonly _beforeLoad?;</span>
    <span class="s0">/* Excluded from this release type: printErr */</span>
    <span class="s1">constructor(options: ThreadManagerOptions);</span>
    <span class="s1">init(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">initMainThread(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">private </span><span class="s1">preparePool;</span>
    <span class="s1">shouldPreloadWorkers(): boolean;</span>
    <span class="s1">loadWasmModuleToAllWorkers(): Promise&lt;WorkerLike[]&gt;;</span>
    <span class="s1">preloadWorkers(): Promise&lt;WorkerLike[]&gt;;</span>
    <span class="s1">setup(wasmModule: WebAssembly.Module, wasmMemory: WebAssembly.Memory): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">markId(worker: WorkerLike): number;</span>
    <span class="s1">returnWorkerToPool(worker: WorkerLike): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">loadWasmModuleToWorker(worker: WorkerLike, sab?: Int32Array): Promise&lt;WorkerLike&gt;;</span>
    <span class="s1">allocateUnusedWorker(): WorkerLike;</span>
    <span class="s1">getNewWorker(sab?: Int32Array): WorkerLike | undefined;</span>
    <span class="s1">cleanThread(worker: WorkerLike, tid: number, force?: boolean): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">terminateWorker(worker: WorkerLike): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">terminateAllThreads(): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">addMessageEventListener(worker: WorkerLike, onMessage: (e: WorkerMessageEvent) =&gt; </span><span class="s2">void</span><span class="s1">): () =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">fireMessageEvent(worker: WorkerLike, e: WorkerMessageEvent): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type ThreadManagerOptions = ThreadManagerOptionsMain | ThreadManagerOptionsChild;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ThreadManagerOptionsBase {</span>
    <span class="s1">printErr?: (message: string) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ThreadManagerOptionsChild </span><span class="s2">extends </span><span class="s1">ThreadManagerOptionsBase {</span>
    <span class="s1">childThread: </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ThreadManagerOptionsMain </span><span class="s2">extends </span><span class="s1">ThreadManagerOptionsBase {</span>
    <span class="s1">beforeLoad?: (worker: WorkerLike) =&gt; any;</span>
    <span class="s1">reuseWorker?: boolean | number | ReuseWorkerOptions;</span>
    <span class="s1">onCreateWorker: WorkerFactory;</span>
    <span class="s1">childThread?: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">class </span><span class="s1">ThreadMessageHandler {</span>
    <span class="s2">protected </span><span class="s1">instance: WebAssembly.Instance | undefined;</span>
    <span class="s2">private </span><span class="s1">messagesBeforeLoad;</span>
    <span class="s2">protected </span><span class="s1">postMessage: (message: any) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">protected </span><span class="s1">onLoad?: (data: LoadPayload) =&gt; WebAssembly.WebAssemblyInstantiatedSource | PromiseLike&lt;WebAssembly.WebAssemblyInstantiatedSource&gt;;</span>
    <span class="s2">protected </span><span class="s1">onError: (error: Error, type: WorkerMessageType) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">constructor(options?: ThreadMessageHandlerOptions);</span>
    <span class="s0">/** </span><span class="s4">@virtual </span><span class="s0">*/</span>
    <span class="s1">instantiate(data: LoadPayload): WebAssembly.WebAssemblyInstantiatedSource | PromiseLike&lt;WebAssembly.WebAssemblyInstantiatedSource&gt;;</span>
    <span class="s0">/** </span><span class="s4">@virtual </span><span class="s0">*/</span>
    <span class="s1">handle(e: WorkerMessageEvent&lt;MessageEventData&lt;WorkerMessageType&gt;&gt;): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">private </span><span class="s1">_load;</span>
    <span class="s2">private </span><span class="s1">_start;</span>
    <span class="s2">protected </span><span class="s1">_loaded(err: Error | </span><span class="s2">null</span><span class="s1">, source: WebAssembly.WebAssemblyInstantiatedSource | </span><span class="s2">null</span><span class="s1">, payload: LoadPayload): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s2">protected </span><span class="s1">handleAfterLoad&lt;E </span><span class="s2">extends </span><span class="s1">WorkerMessageEvent&gt;(e: E, f: (e: E) =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">ThreadMessageHandlerOptions {</span>
    <span class="s1">onLoad?: (data: LoadPayload) =&gt; WebAssembly.WebAssemblyInstantiatedSource | PromiseLike&lt;WebAssembly.WebAssemblyInstantiatedSource&gt;;</span>
    <span class="s1">onError?: (error: Error, type: WorkerMessageType) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">postMessage?: (message: any) =&gt; </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s1">declare </span><span class="s2">const </span><span class="s1">version: string;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">WASIInstance {</span>
    <span class="s1">readonly wasiImport?: Record&lt;string, any&gt;;</span>
    <span class="s1">initialize(instance: object): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">start(instance: object): number;</span>
    <span class="s1">getImportObject?(): any;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">class </span><span class="s1">WASIThreads {</span>
    <span class="s1">PThread: ThreadManager | undefined;</span>
    <span class="s2">private </span><span class="s1">wasmMemory;</span>
    <span class="s2">private </span><span class="s1">wasmInstance;</span>
    <span class="s2">private </span><span class="s1">readonly threadSpawn;</span>
    <span class="s1">readonly childThread: boolean;</span>
    <span class="s2">private </span><span class="s1">readonly postMessage;</span>
    <span class="s1">readonly wasi: WASIInstance;</span>
    <span class="s1">constructor(options: WASIThreadsOptions);</span>
    <span class="s1">getImportObject(): {</span>
        <span class="s1">wasi: WASIThreadsImports;</span>
    <span class="s1">};</span>
    <span class="s1">setup(wasmInstance: WebAssembly.Instance, wasmModule: WebAssembly.Module, wasmMemory?: WebAssembly.Memory): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s1">preloadWorkers(): Promise&lt;WorkerLike[]&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* It's ok to call this method to a WASI command module.</span>
     <span class="s0">*</span>
     <span class="s0">* in child thread, must call this method instead of {</span><span class="s4">@link </span><span class="s0">WASIThreads.start} even if it's a WASI command module</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s4">@returns </span><span class="s0">A proxied WebAssembly instance if in child thread, other wise the original instance</span>
     <span class="s0">*/</span>
    <span class="s1">initialize(instance: WebAssembly.Instance, module: WebAssembly.Module, memory?: WebAssembly.Memory): WebAssembly.Instance;</span>
    <span class="s0">/**</span>
     <span class="s0">* Equivalent to calling {</span><span class="s4">@link </span><span class="s0">WASIThreads.initialize} and then calling {</span><span class="s4">@link </span><span class="s0">WASIInstance.start}</span>
     <span class="s0">* ```js</span>
     <span class="s0">* this.initialize(instance, module, memory)</span>
     <span class="s0">* this.wasi.start(instance)</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s1">start(instance: WebAssembly.Instance, module: WebAssembly.Module, memory?: WebAssembly.Memory): StartResult;</span>
    <span class="s1">terminateAllThreads(): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">WASIThreadsImports {</span>
    <span class="s3">'thread-spawn'</span><span class="s1">: (startArg: number, errorOrTid?: number) =&gt; number;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type WASIThreadsOptions = MainThreadOptions | ChildThreadOptions;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type WorkerFactory = (ctx: {</span>
    <span class="s1">type: string;</span>
    <span class="s1">name: string;</span>
<span class="s1">}) =&gt; WorkerLike;</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type WorkerLike = (Worker | Worker_2) &amp; {</span>
    <span class="s1">whenLoaded?: Promise&lt;WorkerLike&gt;;</span>
    <span class="s1">loaded?: boolean;</span>
    <span class="s1">__emnapi_tid?: number;</span>
<span class="s1">};</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">interface </span><span class="s1">WorkerMessageEvent&lt;T = any&gt; {</span>
    <span class="s1">data: T;</span>
<span class="s1">}</span>

<span class="s0">/** </span><span class="s4">@public </span><span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type WorkerMessageType = </span><span class="s3">'load' </span><span class="s1">| </span><span class="s3">'start'</span><span class="s1">;</span>

<span class="s2">export </span><span class="s1">{ }</span>
</pre>
</body>
</html>