<html>
<head>
<title>write-entry.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
write-entry.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;write-entry.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/write-entry.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import fs, { type Stats } from 'fs'</span><span class="s3">\n</span><span class="s1">import { Minipass } from 'minipass'</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import { Header } from './header.js'</span><span class="s3">\n</span><span class="s1">import { modeFix } from './mode-fix.js'</span><span class="s3">\n</span><span class="s1">import { normalizeWindowsPath } from './normalize-windows-path.js'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">dealias,</span><span class="s3">\n  </span><span class="s1">LinkCacheKey,</span><span class="s3">\n  </span><span class="s1">TarOptions,</span><span class="s3">\n  </span><span class="s1">TarOptionsWithAliases,</span><span class="s3">\n</span><span class="s1">} from './options.js'</span><span class="s3">\n</span><span class="s1">import { Pax } from './pax.js'</span><span class="s3">\n</span><span class="s1">import { ReadEntry } from './read-entry.js'</span><span class="s3">\n</span><span class="s1">import { stripAbsolutePath } from './strip-absolute-path.js'</span><span class="s3">\n</span><span class="s1">import { stripTrailingSlashes } from './strip-trailing-slashes.js'</span><span class="s3">\n</span><span class="s1">import { EntryTypeName } from './types.js'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">WarnData,</span><span class="s3">\n  </span><span class="s1">Warner,</span><span class="s3">\n  </span><span class="s1">WarnEvent,</span><span class="s3">\n  </span><span class="s1">warnMethod,</span><span class="s3">\n</span><span class="s1">} from './warn-method.js'</span><span class="s3">\n</span><span class="s1">import * as winchars from './winchars.js'</span><span class="s3">\n\n</span><span class="s1">const prefixPath = (path: string, prefix?: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!prefix) {</span><span class="s3">\n    </span><span class="s1">return normalizeWindowsPath(path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">path = normalizeWindowsPath(path).replace(/^</span><span class="s3">\\</span><span class="s1">.(</span><span class="s3">\\</span><span class="s1">/|$)/, '')</span><span class="s3">\n  </span><span class="s1">return stripTrailingSlashes(prefix) + '/' + path</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const maxReadSize = 16 * 1024 * 1024</span><span class="s3">\n\n</span><span class="s1">const PROCESS = Symbol('process')</span><span class="s3">\n</span><span class="s1">const FILE = Symbol('file')</span><span class="s3">\n</span><span class="s1">const DIRECTORY = Symbol('directory')</span><span class="s3">\n</span><span class="s1">const SYMLINK = Symbol('symlink')</span><span class="s3">\n</span><span class="s1">const HARDLINK = Symbol('hardlink')</span><span class="s3">\n</span><span class="s1">const HEADER = Symbol('header')</span><span class="s3">\n</span><span class="s1">const READ = Symbol('read')</span><span class="s3">\n</span><span class="s1">const LSTAT = Symbol('lstat')</span><span class="s3">\n</span><span class="s1">const ONLSTAT = Symbol('onlstat')</span><span class="s3">\n</span><span class="s1">const ONREAD = Symbol('onread')</span><span class="s3">\n</span><span class="s1">const ONREADLINK = Symbol('onreadlink')</span><span class="s3">\n</span><span class="s1">const OPENFILE = Symbol('openfile')</span><span class="s3">\n</span><span class="s1">const ONOPENFILE = Symbol('onopenfile')</span><span class="s3">\n</span><span class="s1">const CLOSE = Symbol('close')</span><span class="s3">\n</span><span class="s1">const MODE = Symbol('mode')</span><span class="s3">\n</span><span class="s1">const AWAITDRAIN = Symbol('awaitDrain')</span><span class="s3">\n</span><span class="s1">const ONDRAIN = Symbol('ondrain')</span><span class="s3">\n</span><span class="s1">const PREFIX = Symbol('prefix')</span><span class="s3">\n\n</span><span class="s1">export class WriteEntry</span><span class="s3">\n  </span><span class="s1">extends Minipass&lt;Buffer, Minipass.ContiguousData, WarnEvent&gt;</span><span class="s3">\n  </span><span class="s1">implements Warner</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n  </span><span class="s1">portable: boolean</span><span class="s3">\n  </span><span class="s1">myuid: number = (process.getuid &amp;&amp; process.getuid()) || 0</span><span class="s3">\n  </span><span class="s1">// until node has builtin pwnam functions, this'll have to do</span><span class="s3">\n  </span><span class="s1">myuser: string = process.env.USER || ''</span><span class="s3">\n  </span><span class="s1">maxReadSize: number</span><span class="s3">\n  </span><span class="s1">linkCache: Exclude&lt;TarOptions['linkCache'], undefined&gt;</span><span class="s3">\n  </span><span class="s1">statCache: Exclude&lt;TarOptions['statCache'], undefined&gt;</span><span class="s3">\n  </span><span class="s1">preservePaths: boolean</span><span class="s3">\n  </span><span class="s1">cwd: string</span><span class="s3">\n  </span><span class="s1">strict: boolean</span><span class="s3">\n  </span><span class="s1">mtime?: Date</span><span class="s3">\n  </span><span class="s1">noPax: boolean</span><span class="s3">\n  </span><span class="s1">noMtime: boolean</span><span class="s3">\n  </span><span class="s1">prefix?: string</span><span class="s3">\n  </span><span class="s1">fd?: number</span><span class="s3">\n\n  </span><span class="s1">blockLen: number = 0</span><span class="s3">\n  </span><span class="s1">blockRemain: number = 0</span><span class="s3">\n  </span><span class="s1">buf?: Buffer</span><span class="s3">\n  </span><span class="s1">pos: number = 0</span><span class="s3">\n  </span><span class="s1">remain: number = 0</span><span class="s3">\n  </span><span class="s1">length: number = 0</span><span class="s3">\n  </span><span class="s1">offset: number = 0</span><span class="s3">\n\n  </span><span class="s1">win32: boolean</span><span class="s3">\n  </span><span class="s1">absolute: string</span><span class="s3">\n\n  </span><span class="s1">header?: Header</span><span class="s3">\n  </span><span class="s1">type?: EntryTypeName | 'Unsupported'</span><span class="s3">\n  </span><span class="s1">linkpath?: string</span><span class="s3">\n  </span><span class="s1">stat?: Stats</span><span class="s3">\n  </span><span class="s1">onWriteEntry?: (entry: WriteEntry) =&gt; any</span><span class="s3">\n\n  </span><span class="s1">#hadError: boolean = false</span><span class="s3">\n\n  </span><span class="s1">constructor(p: string, opt_: TarOptionsWithAliases = {}) {</span><span class="s3">\n    </span><span class="s1">const opt = dealias(opt_)</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.path = normalizeWindowsPath(p)</span><span class="s3">\n    </span><span class="s1">// suppress atime, ctime, uid, gid, uname, gname</span><span class="s3">\n    </span><span class="s1">this.portable = !!opt.portable</span><span class="s3">\n    </span><span class="s1">this.maxReadSize = opt.maxReadSize || maxReadSize</span><span class="s3">\n    </span><span class="s1">this.linkCache = opt.linkCache || new Map()</span><span class="s3">\n    </span><span class="s1">this.statCache = opt.statCache || new Map()</span><span class="s3">\n    </span><span class="s1">this.preservePaths = !!opt.preservePaths</span><span class="s3">\n    </span><span class="s1">this.cwd = normalizeWindowsPath(opt.cwd || process.cwd())</span><span class="s3">\n    </span><span class="s1">this.strict = !!opt.strict</span><span class="s3">\n    </span><span class="s1">this.noPax = !!opt.noPax</span><span class="s3">\n    </span><span class="s1">this.noMtime = !!opt.noMtime</span><span class="s3">\n    </span><span class="s1">this.mtime = opt.mtime</span><span class="s3">\n    </span><span class="s1">this.prefix =</span><span class="s3">\n      </span><span class="s1">opt.prefix ? normalizeWindowsPath(opt.prefix) : undefined</span><span class="s3">\n    </span><span class="s1">this.onWriteEntry = opt.onWriteEntry</span><span class="s3">\n\n    </span><span class="s1">if (typeof opt.onwarn === 'function') {</span><span class="s3">\n      </span><span class="s1">this.on('warn', opt.onwarn)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let pathWarn: string | boolean = false</span><span class="s3">\n    </span><span class="s1">if (!this.preservePaths) {</span><span class="s3">\n      </span><span class="s1">const [root, stripped] = stripAbsolutePath(this.path)</span><span class="s3">\n      </span><span class="s1">if (root &amp;&amp; typeof stripped === 'string') {</span><span class="s3">\n        </span><span class="s1">this.path = stripped</span><span class="s3">\n        </span><span class="s1">pathWarn = root</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.win32 = !!opt.win32 || process.platform === 'win32'</span><span class="s3">\n    </span><span class="s1">if (this.win32) {</span><span class="s3">\n      </span><span class="s1">// force the </span><span class="s3">\\ </span><span class="s1">to / normalization, since we might not *actually*</span><span class="s3">\n      </span><span class="s1">// be on windows, but want </span><span class="s3">\\ </span><span class="s1">to be considered a path separator.</span><span class="s3">\n      </span><span class="s1">this.path = winchars.decode(this.path.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/'))</span><span class="s3">\n      </span><span class="s1">p = p.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.absolute = normalizeWindowsPath(</span><span class="s3">\n      </span><span class="s1">opt.absolute || path.resolve(this.cwd, p),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (this.path === '') {</span><span class="s3">\n      </span><span class="s1">this.path = './'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (pathWarn) {</span><span class="s3">\n      </span><span class="s1">this.warn(</span><span class="s3">\n        </span><span class="s1">'TAR_ENTRY_INFO',</span><span class="s3">\n        </span><span class="s1">`stripping ${pathWarn} from absolute path`,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">entry: this,</span><span class="s3">\n          </span><span class="s1">path: pathWarn + this.path,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const cs = this.statCache.get(this.absolute)</span><span class="s3">\n    </span><span class="s1">if (cs) {</span><span class="s3">\n      </span><span class="s1">this[ONLSTAT](cs)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this[LSTAT]()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">warn(code: string, message: string | Error, data: WarnData = {}) {</span><span class="s3">\n    </span><span class="s1">return warnMethod(this, code, message, data)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">emit(ev: keyof WarnEvent, ...data: any[]) {</span><span class="s3">\n    </span><span class="s1">if (ev === 'error') {</span><span class="s3">\n      </span><span class="s1">this.#hadError = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return super.emit(ev, ...data)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[LSTAT]() {</span><span class="s3">\n    </span><span class="s1">fs.lstat(this.absolute, (er, stat) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">return this.emit('error', er)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this[ONLSTAT](stat)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONLSTAT](stat: Stats) {</span><span class="s3">\n    </span><span class="s1">this.statCache.set(this.absolute, stat)</span><span class="s3">\n    </span><span class="s1">this.stat = stat</span><span class="s3">\n    </span><span class="s1">if (!stat.isFile()) {</span><span class="s3">\n      </span><span class="s1">stat.size = 0</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.type = getType(stat)</span><span class="s3">\n    </span><span class="s1">this.emit('stat', stat)</span><span class="s3">\n    </span><span class="s1">this[PROCESS]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[PROCESS]() {</span><span class="s3">\n    </span><span class="s1">switch (this.type) {</span><span class="s3">\n      </span><span class="s1">case 'File':</span><span class="s3">\n        </span><span class="s1">return this[FILE]()</span><span class="s3">\n      </span><span class="s1">case 'Directory':</span><span class="s3">\n        </span><span class="s1">return this[DIRECTORY]()</span><span class="s3">\n      </span><span class="s1">case 'SymbolicLink':</span><span class="s3">\n        </span><span class="s1">return this[SYMLINK]()</span><span class="s3">\n      </span><span class="s1">// unsupported types are ignored.</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return this.end()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[MODE](mode: number) {</span><span class="s3">\n    </span><span class="s1">return modeFix(mode, this.type === 'Directory', this.portable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[PREFIX](path: string) {</span><span class="s3">\n    </span><span class="s1">return prefixPath(path, this.prefix)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[HEADER]() {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!this.stat) {</span><span class="s3">\n      </span><span class="s1">throw new Error('cannot write header before stat')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n    </span><span class="s1">if (this.type === 'Directory' &amp;&amp; this.portable) {</span><span class="s3">\n      </span><span class="s1">this.noMtime = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.onWriteEntry?.(this)</span><span class="s3">\n    </span><span class="s1">this.header = new Header({</span><span class="s3">\n      </span><span class="s1">path: this[PREFIX](this.path),</span><span class="s3">\n      </span><span class="s1">// only apply the prefix to hard links.</span><span class="s3">\n      </span><span class="s1">linkpath:</span><span class="s3">\n        </span><span class="s1">this.type === 'Link' &amp;&amp; this.linkpath !== undefined ?</span><span class="s3">\n          </span><span class="s1">this[PREFIX](this.linkpath)</span><span class="s3">\n        </span><span class="s1">: this.linkpath,</span><span class="s3">\n      </span><span class="s1">// only the permissions and setuid/setgid/sticky bitflags</span><span class="s3">\n      </span><span class="s1">// not the higher-order bits that specify file type</span><span class="s3">\n      </span><span class="s1">mode: this[MODE](this.stat.mode),</span><span class="s3">\n      </span><span class="s1">uid: this.portable ? undefined : this.stat.uid,</span><span class="s3">\n      </span><span class="s1">gid: this.portable ? undefined : this.stat.gid,</span><span class="s3">\n      </span><span class="s1">size: this.stat.size,</span><span class="s3">\n      </span><span class="s1">mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,</span><span class="s3">\n      </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n      </span><span class="s1">type: this.type === 'Unsupported' ? undefined : this.type,</span><span class="s3">\n      </span><span class="s1">uname:</span><span class="s3">\n        </span><span class="s1">this.portable ? undefined</span><span class="s3">\n        </span><span class="s1">: this.stat.uid === this.myuid ? this.myuser</span><span class="s3">\n        </span><span class="s1">: '',</span><span class="s3">\n      </span><span class="s1">atime: this.portable ? undefined : this.stat.atime,</span><span class="s3">\n      </span><span class="s1">ctime: this.portable ? undefined : this.stat.ctime,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (this.header.encode() &amp;&amp; !this.noPax) {</span><span class="s3">\n      </span><span class="s1">super.write(</span><span class="s3">\n        </span><span class="s1">new Pax({</span><span class="s3">\n          </span><span class="s1">atime: this.portable ? undefined : this.header.atime,</span><span class="s3">\n          </span><span class="s1">ctime: this.portable ? undefined : this.header.ctime,</span><span class="s3">\n          </span><span class="s1">gid: this.portable ? undefined : this.header.gid,</span><span class="s3">\n          </span><span class="s1">mtime:</span><span class="s3">\n            </span><span class="s1">this.noMtime ? undefined : (</span><span class="s3">\n              </span><span class="s1">this.mtime || this.header.mtime</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">path: this[PREFIX](this.path),</span><span class="s3">\n          </span><span class="s1">linkpath:</span><span class="s3">\n            </span><span class="s1">this.type === 'Link' &amp;&amp; this.linkpath !== undefined ?</span><span class="s3">\n              </span><span class="s1">this[PREFIX](this.linkpath)</span><span class="s3">\n            </span><span class="s1">: this.linkpath,</span><span class="s3">\n          </span><span class="s1">size: this.header.size,</span><span class="s3">\n          </span><span class="s1">uid: this.portable ? undefined : this.header.uid,</span><span class="s3">\n          </span><span class="s1">uname: this.portable ? undefined : this.header.uname,</span><span class="s3">\n          </span><span class="s1">dev: this.portable ? undefined : this.stat.dev,</span><span class="s3">\n          </span><span class="s1">ino: this.portable ? undefined : this.stat.ino,</span><span class="s3">\n          </span><span class="s1">nlink: this.portable ? undefined : this.stat.nlink,</span><span class="s3">\n        </span><span class="s1">}).encode(),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const block = this.header?.block</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!block) {</span><span class="s3">\n      </span><span class="s1">throw new Error('failed to encode header')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">super.write(block)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[DIRECTORY]() {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!this.stat) {</span><span class="s3">\n      </span><span class="s1">throw new Error('cannot create directory entry without stat')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">if (this.path.slice(-1) !== '/') {</span><span class="s3">\n      </span><span class="s1">this.path += '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.stat.size = 0</span><span class="s3">\n    </span><span class="s1">this[HEADER]()</span><span class="s3">\n    </span><span class="s1">this.end()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[SYMLINK]() {</span><span class="s3">\n    </span><span class="s1">fs.readlink(this.absolute, (er, linkpath) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">return this.emit('error', er)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this[ONREADLINK](linkpath)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONREADLINK](linkpath: string) {</span><span class="s3">\n    </span><span class="s1">this.linkpath = normalizeWindowsPath(linkpath)</span><span class="s3">\n    </span><span class="s1">this[HEADER]()</span><span class="s3">\n    </span><span class="s1">this.end()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[HARDLINK](linkpath: string) {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!this.stat) {</span><span class="s3">\n      </span><span class="s1">throw new Error('cannot create link entry without stat')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">this.type = 'Link'</span><span class="s3">\n    </span><span class="s1">this.linkpath = normalizeWindowsPath(</span><span class="s3">\n      </span><span class="s1">path.relative(this.cwd, linkpath),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.stat.size = 0</span><span class="s3">\n    </span><span class="s1">this[HEADER]()</span><span class="s3">\n    </span><span class="s1">this.end()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[FILE]() {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!this.stat) {</span><span class="s3">\n      </span><span class="s1">throw new Error('cannot create file entry without stat')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">if (this.stat.nlink &gt; 1) {</span><span class="s3">\n      </span><span class="s1">const linkKey =</span><span class="s3">\n        </span><span class="s1">`${this.stat.dev}:${this.stat.ino}` as LinkCacheKey</span><span class="s3">\n      </span><span class="s1">const linkpath = this.linkCache.get(linkKey)</span><span class="s3">\n      </span><span class="s1">if (linkpath?.indexOf(this.cwd) === 0) {</span><span class="s3">\n        </span><span class="s1">return this[HARDLINK](linkpath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.linkCache.set(linkKey, this.absolute)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[HEADER]()</span><span class="s3">\n    </span><span class="s1">if (this.stat.size === 0) {</span><span class="s3">\n      </span><span class="s1">return this.end()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[OPENFILE]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[OPENFILE]() {</span><span class="s3">\n    </span><span class="s1">fs.open(this.absolute, 'r', (er, fd) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">return this.emit('error', er)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this[ONOPENFILE](fd)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONOPENFILE](fd: number) {</span><span class="s3">\n    </span><span class="s1">this.fd = fd</span><span class="s3">\n    </span><span class="s1">if (this.#hadError) {</span><span class="s3">\n      </span><span class="s1">return this[CLOSE]()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!this.stat) {</span><span class="s3">\n      </span><span class="s1">throw new Error('should stat before calling onopenfile')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n\n    </span><span class="s1">this.blockLen = 512 * Math.ceil(this.stat.size / 512)</span><span class="s3">\n    </span><span class="s1">this.blockRemain = this.blockLen</span><span class="s3">\n    </span><span class="s1">const bufLen = Math.min(this.blockLen, this.maxReadSize)</span><span class="s3">\n    </span><span class="s1">this.buf = Buffer.allocUnsafe(bufLen)</span><span class="s3">\n    </span><span class="s1">this.offset = 0</span><span class="s3">\n    </span><span class="s1">this.pos = 0</span><span class="s3">\n    </span><span class="s1">this.remain = this.stat.size</span><span class="s3">\n    </span><span class="s1">this.length = this.buf.length</span><span class="s3">\n    </span><span class="s1">this[READ]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[READ]() {</span><span class="s3">\n    </span><span class="s1">const { fd, buf, offset, length, pos } = this</span><span class="s3">\n    </span><span class="s1">if (fd === undefined || buf === undefined) {</span><span class="s3">\n      </span><span class="s1">throw new Error('cannot read file without first opening')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fs.read(fd, buf, offset, length, pos, (er, bytesRead) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">// ignoring the error from close(2) is a bad practice, but at</span><span class="s3">\n        </span><span class="s1">// this point we already have an error, don't need another one</span><span class="s3">\n        </span><span class="s1">return this[CLOSE](() =&gt; this.emit('error', er))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this[ONREAD](bytesRead)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n  </span><span class="s1">[CLOSE](</span><span class="s3">\n    </span><span class="s1">cb: (er?: null | Error | NodeJS.ErrnoException) =&gt; any = () =&gt; {},</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">if (this.fd !== undefined) fs.close(this.fd, cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONREAD](bytesRead: number) {</span><span class="s3">\n    </span><span class="s1">if (bytesRead &lt;= 0 &amp;&amp; this.remain &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const er = Object.assign(</span><span class="s3">\n        </span><span class="s1">new Error('encountered unexpected EOF'),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">path: this.absolute,</span><span class="s3">\n          </span><span class="s1">syscall: 'read',</span><span class="s3">\n          </span><span class="s1">code: 'EOF',</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return this[CLOSE](() =&gt; this.emit('error', er))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (bytesRead &gt; this.remain) {</span><span class="s3">\n      </span><span class="s1">const er = Object.assign(</span><span class="s3">\n        </span><span class="s1">new Error('did not encounter expected EOF'),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">path: this.absolute,</span><span class="s3">\n          </span><span class="s1">syscall: 'read',</span><span class="s3">\n          </span><span class="s1">code: 'EOF',</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return this[CLOSE](() =&gt; this.emit('error', er))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!this.buf) {</span><span class="s3">\n      </span><span class="s1">throw new Error('should have created buffer prior to reading')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n    </span><span class="s1">// null out the rest of the buffer, if we could fit the block padding</span><span class="s3">\n    </span><span class="s1">// at the end of this loop, we've incremented bytesRead and this.remain</span><span class="s3">\n    </span><span class="s1">// to be incremented up to the blockRemain level, as if we had expected</span><span class="s3">\n    </span><span class="s1">// to get a null-padded file, and read it until the end.  then we will</span><span class="s3">\n    </span><span class="s1">// decrement both remain and blockRemain by bytesRead, and know that we</span><span class="s3">\n    </span><span class="s1">// reached the expected EOF, without any null buffer to append.</span><span class="s3">\n    </span><span class="s1">if (bytesRead === this.remain) {</span><span class="s3">\n      </span><span class="s1">for (</span><span class="s3">\n        </span><span class="s1">let i = bytesRead;</span><span class="s3">\n        </span><span class="s1">i &lt; this.length &amp;&amp; bytesRead &lt; this.blockRemain;</span><span class="s3">\n        </span><span class="s1">i++</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.buf[i + this.offset] = 0</span><span class="s3">\n        </span><span class="s1">bytesRead++</span><span class="s3">\n        </span><span class="s1">this.remain++</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const chunk =</span><span class="s3">\n      </span><span class="s1">this.offset === 0 &amp;&amp; bytesRead === this.buf.length ?</span><span class="s3">\n        </span><span class="s1">this.buf</span><span class="s3">\n      </span><span class="s1">: this.buf.subarray(this.offset, this.offset + bytesRead)</span><span class="s3">\n\n    </span><span class="s1">const flushed = this.write(chunk)</span><span class="s3">\n    </span><span class="s1">if (!flushed) {</span><span class="s3">\n      </span><span class="s1">this[AWAITDRAIN](() =&gt; this[ONDRAIN]())</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this[ONDRAIN]()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[AWAITDRAIN](cb: () =&gt; any) {</span><span class="s3">\n    </span><span class="s1">this.once('drain', cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">write(buffer: Buffer | string, cb?: () =&gt; void): boolean</span><span class="s3">\n  </span><span class="s1">write(</span><span class="s3">\n    </span><span class="s1">str: Buffer | string,</span><span class="s3">\n    </span><span class="s1">encoding?: BufferEncoding | null,</span><span class="s3">\n    </span><span class="s1">cb?: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">): boolean</span><span class="s3">\n  </span><span class="s1">write(</span><span class="s3">\n    </span><span class="s1">chunk: Buffer | string,</span><span class="s3">\n    </span><span class="s1">encoding?: BufferEncoding | (() =&gt; any) | null,</span><span class="s3">\n    </span><span class="s1">cb?: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start - just junk to comply with NodeJS.WritableStream */</span><span class="s3">\n    </span><span class="s1">if (typeof encoding === 'function') {</span><span class="s3">\n      </span><span class="s1">cb = encoding</span><span class="s3">\n      </span><span class="s1">encoding = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof chunk === 'string') {</span><span class="s3">\n      </span><span class="s1">chunk = Buffer.from(</span><span class="s3">\n        </span><span class="s1">chunk,</span><span class="s3">\n        </span><span class="s1">typeof encoding === 'string' ? encoding : 'utf8',</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n    </span><span class="s1">if (this.blockRemain &lt; chunk.length) {</span><span class="s3">\n      </span><span class="s1">const er = Object.assign(</span><span class="s3">\n        </span><span class="s1">new Error('writing more data than expected'),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">path: this.absolute,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return this.emit('error', er)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.remain -= chunk.length</span><span class="s3">\n    </span><span class="s1">this.blockRemain -= chunk.length</span><span class="s3">\n    </span><span class="s1">this.pos += chunk.length</span><span class="s3">\n    </span><span class="s1">this.offset += chunk.length</span><span class="s3">\n    </span><span class="s1">return super.write(chunk, null, cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONDRAIN]() {</span><span class="s3">\n    </span><span class="s1">if (!this.remain) {</span><span class="s3">\n      </span><span class="s1">if (this.blockRemain) {</span><span class="s3">\n        </span><span class="s1">super.write(Buffer.alloc(this.blockRemain))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this[CLOSE](er =&gt;</span><span class="s3">\n        </span><span class="s1">er ? this.emit('error', er) : this.end(),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!this.buf) {</span><span class="s3">\n      </span><span class="s1">throw new Error('buffer lost somehow in ONDRAIN')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n    </span><span class="s1">if (this.offset &gt;= this.length) {</span><span class="s3">\n      </span><span class="s1">// if we only have a smaller bit left to read, alloc a smaller buffer</span><span class="s3">\n      </span><span class="s1">// otherwise, keep it the same length it was before.</span><span class="s3">\n      </span><span class="s1">this.buf = Buffer.allocUnsafe(</span><span class="s3">\n        </span><span class="s1">Math.min(this.blockRemain, this.buf.length),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">this.offset = 0</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.length = this.buf.length - this.offset</span><span class="s3">\n    </span><span class="s1">this[READ]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class WriteEntrySync extends WriteEntry implements Warner {</span><span class="s3">\n  </span><span class="s1">sync: true = true;</span><span class="s3">\n\n  </span><span class="s1">[LSTAT]() {</span><span class="s3">\n    </span><span class="s1">this[ONLSTAT](fs.lstatSync(this.absolute))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[SYMLINK]() {</span><span class="s3">\n    </span><span class="s1">this[ONREADLINK](fs.readlinkSync(this.absolute))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[OPENFILE]() {</span><span class="s3">\n    </span><span class="s1">this[ONOPENFILE](fs.openSync(this.absolute, 'r'))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[READ]() {</span><span class="s3">\n    </span><span class="s1">let threw = true</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const { fd, buf, offset, length, pos } = this</span><span class="s3">\n      </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n      </span><span class="s1">if (fd === undefined || buf === undefined) {</span><span class="s3">\n        </span><span class="s1">throw new Error('fd and buf must be set in READ method')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n      </span><span class="s1">const bytesRead = fs.readSync(fd, buf, offset, length, pos)</span><span class="s3">\n      </span><span class="s1">this[ONREAD](bytesRead)</span><span class="s3">\n      </span><span class="s1">threw = false</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">// ignoring the error from close(2) is a bad practice, but at</span><span class="s3">\n      </span><span class="s1">// this point we already have an error, don't need another one</span><span class="s3">\n      </span><span class="s1">if (threw) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">this[CLOSE](() =&gt; {})</span><span class="s3">\n        </span><span class="s1">} catch (er) {}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[AWAITDRAIN](cb: () =&gt; any) {</span><span class="s3">\n    </span><span class="s1">cb()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n  </span><span class="s1">[CLOSE](</span><span class="s3">\n    </span><span class="s1">cb: (er?: null | Error | NodeJS.ErrnoException) =&gt; any = () =&gt; {},</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">if (this.fd !== undefined) fs.closeSync(this.fd)</span><span class="s3">\n    </span><span class="s1">cb()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class WriteEntryTar</span><span class="s3">\n  </span><span class="s1">extends Minipass&lt;Buffer, Buffer | string, WarnEvent&gt;</span><span class="s3">\n  </span><span class="s1">implements Warner</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">blockLen: number = 0</span><span class="s3">\n  </span><span class="s1">blockRemain: number = 0</span><span class="s3">\n  </span><span class="s1">buf: number = 0</span><span class="s3">\n  </span><span class="s1">pos: number = 0</span><span class="s3">\n  </span><span class="s1">remain: number = 0</span><span class="s3">\n  </span><span class="s1">length: number = 0</span><span class="s3">\n  </span><span class="s1">preservePaths: boolean</span><span class="s3">\n  </span><span class="s1">portable: boolean</span><span class="s3">\n  </span><span class="s1">strict: boolean</span><span class="s3">\n  </span><span class="s1">noPax: boolean</span><span class="s3">\n  </span><span class="s1">noMtime: boolean</span><span class="s3">\n  </span><span class="s1">readEntry: ReadEntry</span><span class="s3">\n  </span><span class="s1">type: EntryTypeName</span><span class="s3">\n  </span><span class="s1">prefix?: string</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n  </span><span class="s1">mode?: number</span><span class="s3">\n  </span><span class="s1">uid?: number</span><span class="s3">\n  </span><span class="s1">gid?: number</span><span class="s3">\n  </span><span class="s1">uname?: string</span><span class="s3">\n  </span><span class="s1">gname?: string</span><span class="s3">\n  </span><span class="s1">header?: Header</span><span class="s3">\n  </span><span class="s1">mtime?: Date</span><span class="s3">\n  </span><span class="s1">atime?: Date</span><span class="s3">\n  </span><span class="s1">ctime?: Date</span><span class="s3">\n  </span><span class="s1">linkpath?: string</span><span class="s3">\n  </span><span class="s1">size: number</span><span class="s3">\n  </span><span class="s1">onWriteEntry?: (entry: WriteEntry) =&gt; any</span><span class="s3">\n\n  </span><span class="s1">warn(code: string, message: string | Error, data: WarnData = {}) {</span><span class="s3">\n    </span><span class="s1">return warnMethod(this, code, message, data)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">readEntry: ReadEntry,</span><span class="s3">\n    </span><span class="s1">opt_: TarOptionsWithAliases = {},</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const opt = dealias(opt_)</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.preservePaths = !!opt.preservePaths</span><span class="s3">\n    </span><span class="s1">this.portable = !!opt.portable</span><span class="s3">\n    </span><span class="s1">this.strict = !!opt.strict</span><span class="s3">\n    </span><span class="s1">this.noPax = !!opt.noPax</span><span class="s3">\n    </span><span class="s1">this.noMtime = !!opt.noMtime</span><span class="s3">\n    </span><span class="s1">this.onWriteEntry = opt.onWriteEntry</span><span class="s3">\n\n    </span><span class="s1">this.readEntry = readEntry</span><span class="s3">\n    </span><span class="s1">const { type } = readEntry</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (type === 'Unsupported') {</span><span class="s3">\n      </span><span class="s1">throw new Error('writing entry that should be ignored')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">this.type = type</span><span class="s3">\n    </span><span class="s1">if (this.type === 'Directory' &amp;&amp; this.portable) {</span><span class="s3">\n      </span><span class="s1">this.noMtime = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.prefix = opt.prefix</span><span class="s3">\n\n    </span><span class="s1">this.path = normalizeWindowsPath(readEntry.path)</span><span class="s3">\n    </span><span class="s1">this.mode =</span><span class="s3">\n      </span><span class="s1">readEntry.mode !== undefined ?</span><span class="s3">\n        </span><span class="s1">this[MODE](readEntry.mode)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n    </span><span class="s1">this.uid = this.portable ? undefined : readEntry.uid</span><span class="s3">\n    </span><span class="s1">this.gid = this.portable ? undefined : readEntry.gid</span><span class="s3">\n    </span><span class="s1">this.uname = this.portable ? undefined : readEntry.uname</span><span class="s3">\n    </span><span class="s1">this.gname = this.portable ? undefined : readEntry.gname</span><span class="s3">\n    </span><span class="s1">this.size = readEntry.size</span><span class="s3">\n    </span><span class="s1">this.mtime =</span><span class="s3">\n      </span><span class="s1">this.noMtime ? undefined : opt.mtime || readEntry.mtime</span><span class="s3">\n    </span><span class="s1">this.atime = this.portable ? undefined : readEntry.atime</span><span class="s3">\n    </span><span class="s1">this.ctime = this.portable ? undefined : readEntry.ctime</span><span class="s3">\n    </span><span class="s1">this.linkpath =</span><span class="s3">\n      </span><span class="s1">readEntry.linkpath !== undefined ?</span><span class="s3">\n        </span><span class="s1">normalizeWindowsPath(readEntry.linkpath)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">if (typeof opt.onwarn === 'function') {</span><span class="s3">\n      </span><span class="s1">this.on('warn', opt.onwarn)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let pathWarn: false | string = false</span><span class="s3">\n    </span><span class="s1">if (!this.preservePaths) {</span><span class="s3">\n      </span><span class="s1">const [root, stripped] = stripAbsolutePath(this.path)</span><span class="s3">\n      </span><span class="s1">if (root &amp;&amp; typeof stripped === 'string') {</span><span class="s3">\n        </span><span class="s1">this.path = stripped</span><span class="s3">\n        </span><span class="s1">pathWarn = root</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.remain = readEntry.size</span><span class="s3">\n    </span><span class="s1">this.blockRemain = readEntry.startBlockSize</span><span class="s3">\n\n    </span><span class="s1">this.onWriteEntry?.(this as unknown as WriteEntry)</span><span class="s3">\n    </span><span class="s1">this.header = new Header({</span><span class="s3">\n      </span><span class="s1">path: this[PREFIX](this.path),</span><span class="s3">\n      </span><span class="s1">linkpath:</span><span class="s3">\n        </span><span class="s1">this.type === 'Link' &amp;&amp; this.linkpath !== undefined ?</span><span class="s3">\n          </span><span class="s1">this[PREFIX](this.linkpath)</span><span class="s3">\n        </span><span class="s1">: this.linkpath,</span><span class="s3">\n      </span><span class="s1">// only the permissions and setuid/setgid/sticky bitflags</span><span class="s3">\n      </span><span class="s1">// not the higher-order bits that specify file type</span><span class="s3">\n      </span><span class="s1">mode: this.mode,</span><span class="s3">\n      </span><span class="s1">uid: this.portable ? undefined : this.uid,</span><span class="s3">\n      </span><span class="s1">gid: this.portable ? undefined : this.gid,</span><span class="s3">\n      </span><span class="s1">size: this.size,</span><span class="s3">\n      </span><span class="s1">mtime: this.noMtime ? undefined : this.mtime,</span><span class="s3">\n      </span><span class="s1">type: this.type,</span><span class="s3">\n      </span><span class="s1">uname: this.portable ? undefined : this.uname,</span><span class="s3">\n      </span><span class="s1">atime: this.portable ? undefined : this.atime,</span><span class="s3">\n      </span><span class="s1">ctime: this.portable ? undefined : this.ctime,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (pathWarn) {</span><span class="s3">\n      </span><span class="s1">this.warn(</span><span class="s3">\n        </span><span class="s1">'TAR_ENTRY_INFO',</span><span class="s3">\n        </span><span class="s1">`stripping ${pathWarn} from absolute path`,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">entry: this,</span><span class="s3">\n          </span><span class="s1">path: pathWarn + this.path,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.header.encode() &amp;&amp; !this.noPax) {</span><span class="s3">\n      </span><span class="s1">super.write(</span><span class="s3">\n        </span><span class="s1">new Pax({</span><span class="s3">\n          </span><span class="s1">atime: this.portable ? undefined : this.atime,</span><span class="s3">\n          </span><span class="s1">ctime: this.portable ? undefined : this.ctime,</span><span class="s3">\n          </span><span class="s1">gid: this.portable ? undefined : this.gid,</span><span class="s3">\n          </span><span class="s1">mtime: this.noMtime ? undefined : this.mtime,</span><span class="s3">\n          </span><span class="s1">path: this[PREFIX](this.path),</span><span class="s3">\n          </span><span class="s1">linkpath:</span><span class="s3">\n            </span><span class="s1">this.type === 'Link' &amp;&amp; this.linkpath !== undefined ?</span><span class="s3">\n              </span><span class="s1">this[PREFIX](this.linkpath)</span><span class="s3">\n            </span><span class="s1">: this.linkpath,</span><span class="s3">\n          </span><span class="s1">size: this.size,</span><span class="s3">\n          </span><span class="s1">uid: this.portable ? undefined : this.uid,</span><span class="s3">\n          </span><span class="s1">uname: this.portable ? undefined : this.uname,</span><span class="s3">\n          </span><span class="s1">dev: this.portable ? undefined : this.readEntry.dev,</span><span class="s3">\n          </span><span class="s1">ino: this.portable ? undefined : this.readEntry.ino,</span><span class="s3">\n          </span><span class="s1">nlink: this.portable ? undefined : this.readEntry.nlink,</span><span class="s3">\n        </span><span class="s1">}).encode(),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const b = this.header?.block</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!b) throw new Error('failed to encode header')</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">super.write(b)</span><span class="s3">\n    </span><span class="s1">readEntry.pipe(this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[PREFIX](path: string) {</span><span class="s3">\n    </span><span class="s1">return prefixPath(path, this.prefix)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[MODE](mode: number) {</span><span class="s3">\n    </span><span class="s1">return modeFix(mode, this.type === 'Directory', this.portable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">write(buffer: Buffer | string, cb?: () =&gt; void): boolean</span><span class="s3">\n  </span><span class="s1">write(</span><span class="s3">\n    </span><span class="s1">str: Buffer | string,</span><span class="s3">\n    </span><span class="s1">encoding?: BufferEncoding | null,</span><span class="s3">\n    </span><span class="s1">cb?: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">): boolean</span><span class="s3">\n  </span><span class="s1">write(</span><span class="s3">\n    </span><span class="s1">chunk: Buffer | string,</span><span class="s3">\n    </span><span class="s1">encoding?: BufferEncoding | (() =&gt; any) | null,</span><span class="s3">\n    </span><span class="s1">cb?: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start - just junk to comply with NodeJS.WritableStream */</span><span class="s3">\n    </span><span class="s1">if (typeof encoding === 'function') {</span><span class="s3">\n      </span><span class="s1">cb = encoding</span><span class="s3">\n      </span><span class="s1">encoding = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof chunk === 'string') {</span><span class="s3">\n      </span><span class="s1">chunk = Buffer.from(</span><span class="s3">\n        </span><span class="s1">chunk,</span><span class="s3">\n        </span><span class="s1">typeof encoding === 'string' ? encoding : 'utf8',</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">const writeLen = chunk.length</span><span class="s3">\n    </span><span class="s1">if (writeLen &gt; this.blockRemain) {</span><span class="s3">\n      </span><span class="s1">throw new Error('writing more to entry than is appropriate')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.blockRemain -= writeLen</span><span class="s3">\n    </span><span class="s1">return super.write(chunk, cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">end(cb?: () =&gt; void): this</span><span class="s3">\n  </span><span class="s1">end(chunk: Buffer | string, cb?: () =&gt; void): this</span><span class="s3">\n  </span><span class="s1">end(</span><span class="s3">\n    </span><span class="s1">chunk: Buffer | string,</span><span class="s3">\n    </span><span class="s1">encoding?: BufferEncoding,</span><span class="s3">\n    </span><span class="s1">cb?: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">): this</span><span class="s3">\n  </span><span class="s1">end(</span><span class="s3">\n    </span><span class="s1">chunk?: Buffer | string | (() =&gt; void),</span><span class="s3">\n    </span><span class="s1">encoding?: BufferEncoding | (() =&gt; void),</span><span class="s3">\n    </span><span class="s1">cb?: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">): this {</span><span class="s3">\n    </span><span class="s1">if (this.blockRemain) {</span><span class="s3">\n      </span><span class="s1">super.write(Buffer.alloc(this.blockRemain))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start - just junk to comply with NodeJS.WritableStream */</span><span class="s3">\n    </span><span class="s1">if (typeof chunk === 'function') {</span><span class="s3">\n      </span><span class="s1">cb = chunk</span><span class="s3">\n      </span><span class="s1">encoding = undefined</span><span class="s3">\n      </span><span class="s1">chunk = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof encoding === 'function') {</span><span class="s3">\n      </span><span class="s1">cb = encoding</span><span class="s3">\n      </span><span class="s1">encoding = undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof chunk === 'string') {</span><span class="s3">\n      </span><span class="s1">chunk = Buffer.from(chunk, encoding ?? 'utf8')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cb) this.once('finish', cb)</span><span class="s3">\n    </span><span class="s1">chunk ? super.end(chunk, cb) : super.end(cb)</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const getType = (stat: Stats): EntryTypeName | 'Unsupported' =&gt;</span><span class="s3">\n  </span><span class="s1">stat.isFile() ? 'File'</span><span class="s3">\n  </span><span class="s1">: stat.isDirectory() ? 'Directory'</span><span class="s3">\n  </span><span class="s1">: stat.isSymbolicLink() ? 'SymbolicLink'</span><span class="s3">\n  </span><span class="s1">: 'Unsupported'</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>