<html>
<head>
<title>extract-const-value.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extract-const-value.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/build/analysis/extract-const-value.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ArrayExpression,</span><span class="s3">\n  </span><span class="s1">BooleanLiteral,</span><span class="s3">\n  </span><span class="s1">ExportDeclaration,</span><span class="s3">\n  </span><span class="s1">Identifier,</span><span class="s3">\n  </span><span class="s1">KeyValueProperty,</span><span class="s3">\n  </span><span class="s1">Module,</span><span class="s3">\n  </span><span class="s1">Node,</span><span class="s3">\n  </span><span class="s1">NullLiteral,</span><span class="s3">\n  </span><span class="s1">NumericLiteral,</span><span class="s3">\n  </span><span class="s1">ObjectExpression,</span><span class="s3">\n  </span><span class="s1">RegExpLiteral,</span><span class="s3">\n  </span><span class="s1">StringLiteral,</span><span class="s3">\n  </span><span class="s1">TemplateLiteral,</span><span class="s3">\n  </span><span class="s1">TsSatisfiesExpression,</span><span class="s3">\n  </span><span class="s1">VariableDeclaration,</span><span class="s3">\n</span><span class="s1">} from '@swc/core'</span><span class="s3">\n\n</span><span class="s1">export class NoSuchDeclarationError extends Error {}</span><span class="s3">\n\n</span><span class="s1">function isExportDeclaration(node: Node): node is ExportDeclaration {</span><span class="s3">\n  </span><span class="s1">return node.type === 'ExportDeclaration'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isVariableDeclaration(node: Node): node is VariableDeclaration {</span><span class="s3">\n  </span><span class="s1">return node.type === 'VariableDeclaration'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isIdentifier(node: Node): node is Identifier {</span><span class="s3">\n  </span><span class="s1">return node.type === 'Identifier'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isBooleanLiteral(node: Node): node is BooleanLiteral {</span><span class="s3">\n  </span><span class="s1">return node.type === 'BooleanLiteral'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isNullLiteral(node: Node): node is NullLiteral {</span><span class="s3">\n  </span><span class="s1">return node.type === 'NullLiteral'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isStringLiteral(node: Node): node is StringLiteral {</span><span class="s3">\n  </span><span class="s1">return node.type === 'StringLiteral'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isNumericLiteral(node: Node): node is NumericLiteral {</span><span class="s3">\n  </span><span class="s1">return node.type === 'NumericLiteral'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isArrayExpression(node: Node): node is ArrayExpression {</span><span class="s3">\n  </span><span class="s1">return node.type === 'ArrayExpression'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isObjectExpression(node: Node): node is ObjectExpression {</span><span class="s3">\n  </span><span class="s1">return node.type === 'ObjectExpression'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isKeyValueProperty(node: Node): node is KeyValueProperty {</span><span class="s3">\n  </span><span class="s1">return node.type === 'KeyValueProperty'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isRegExpLiteral(node: Node): node is RegExpLiteral {</span><span class="s3">\n  </span><span class="s1">return node.type === 'RegExpLiteral'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isTemplateLiteral(node: Node): node is TemplateLiteral {</span><span class="s3">\n  </span><span class="s1">return node.type === 'TemplateLiteral'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isTsSatisfiesExpression(node: Node): node is TsSatisfiesExpression {</span><span class="s3">\n  </span><span class="s1">return node.type === 'TsSatisfiesExpression'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class UnsupportedValueError extends Error {</span><span class="s3">\n  </span><span class="s1">/** @example `config.runtime[0].value` */</span><span class="s3">\n  </span><span class="s1">path?: string</span><span class="s3">\n\n  </span><span class="s1">constructor(message: string, paths?: string[]) {</span><span class="s3">\n    </span><span class="s1">super(message)</span><span class="s3">\n\n    </span><span class="s1">// Generating </span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot; </span><span class="s1">that looks like </span><span class="s3">\&quot;</span><span class="s1">config.runtime[0].value</span><span class="s3">\&quot;\n    </span><span class="s1">let codePath: string | undefined</span><span class="s3">\n    </span><span class="s1">if (paths) {</span><span class="s3">\n      </span><span class="s1">codePath = ''</span><span class="s3">\n      </span><span class="s1">for (const path of paths) {</span><span class="s3">\n        </span><span class="s1">if (path[0] === '[') {</span><span class="s3">\n          </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;</span><span class="s1">[0]</span><span class="s3">\&quot;\n          </span><span class="s1">codePath += path</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (codePath === '') {</span><span class="s3">\n            </span><span class="s1">codePath = path</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">+ </span><span class="s3">\&quot;</span><span class="s1">.key</span><span class="s3">\&quot;\n            </span><span class="s1">codePath += `.${path}`</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.path = codePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function extractValue(node: Node, path?: string[]): any {</span><span class="s3">\n  </span><span class="s1">if (isNullLiteral(node)) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">} else if (isBooleanLiteral(node)) {</span><span class="s3">\n    </span><span class="s1">// e.g. true / false</span><span class="s3">\n    </span><span class="s1">return node.value</span><span class="s3">\n  </span><span class="s1">} else if (isStringLiteral(node)) {</span><span class="s3">\n    </span><span class="s1">// e.g. </span><span class="s3">\&quot;</span><span class="s1">abc</span><span class="s3">\&quot;\n    </span><span class="s1">return node.value</span><span class="s3">\n  </span><span class="s1">} else if (isNumericLiteral(node)) {</span><span class="s3">\n    </span><span class="s1">// e.g. 123</span><span class="s3">\n    </span><span class="s1">return node.value</span><span class="s3">\n  </span><span class="s1">} else if (isRegExpLiteral(node)) {</span><span class="s3">\n    </span><span class="s1">// e.g. /abc/i</span><span class="s3">\n    </span><span class="s1">return new RegExp(node.pattern, node.flags)</span><span class="s3">\n  </span><span class="s1">} else if (isIdentifier(node)) {</span><span class="s3">\n    </span><span class="s1">switch (node.value) {</span><span class="s3">\n      </span><span class="s1">case 'undefined':</span><span class="s3">\n        </span><span class="s1">return undefined</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new UnsupportedValueError(</span><span class="s3">\n          </span><span class="s1">`Unknown identifier </span><span class="s3">\&quot;</span><span class="s1">${node.value}</span><span class="s3">\&quot;</span><span class="s1">`,</span><span class="s3">\n          </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (isArrayExpression(node)) {</span><span class="s3">\n    </span><span class="s1">// e.g. [1, 2, 3]</span><span class="s3">\n    </span><span class="s1">const arr = []</span><span class="s3">\n    </span><span class="s1">for (let i = 0, len = node.elements.length; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">const elem = node.elements[i]</span><span class="s3">\n      </span><span class="s1">if (elem) {</span><span class="s3">\n        </span><span class="s1">if (elem.spread) {</span><span class="s3">\n          </span><span class="s1">// e.g. [ ...a ]</span><span class="s3">\n          </span><span class="s1">throw new UnsupportedValueError(</span><span class="s3">\n            </span><span class="s1">'Unsupported spread operator in the Array Expression',</span><span class="s3">\n            </span><span class="s1">path</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">arr.push(extractValue(elem.expression, path &amp;&amp; [...path, `[${i}]`]))</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// e.g. [1, , 2]</span><span class="s3">\n        </span><span class="s1">//         ^^</span><span class="s3">\n        </span><span class="s1">arr.push(undefined)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return arr</span><span class="s3">\n  </span><span class="s1">} else if (isObjectExpression(node)) {</span><span class="s3">\n    </span><span class="s1">// e.g. { a: 1, b: 2 }</span><span class="s3">\n    </span><span class="s1">const obj: any = {}</span><span class="s3">\n    </span><span class="s1">for (const prop of node.properties) {</span><span class="s3">\n      </span><span class="s1">if (!isKeyValueProperty(prop)) {</span><span class="s3">\n        </span><span class="s1">// e.g. { ...a }</span><span class="s3">\n        </span><span class="s1">throw new UnsupportedValueError(</span><span class="s3">\n          </span><span class="s1">'Unsupported spread operator in the Object Expression',</span><span class="s3">\n          </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let key</span><span class="s3">\n      </span><span class="s1">if (isIdentifier(prop.key)) {</span><span class="s3">\n        </span><span class="s1">// e.g. { a: 1, b: 2 }</span><span class="s3">\n        </span><span class="s1">key = prop.key.value</span><span class="s3">\n      </span><span class="s1">} else if (isStringLiteral(prop.key)) {</span><span class="s3">\n        </span><span class="s1">// e.g. { </span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">: 1, </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">: 2 }</span><span class="s3">\n        </span><span class="s1">key = prop.key.value</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new UnsupportedValueError(</span><span class="s3">\n          </span><span class="s1">`Unsupported key type </span><span class="s3">\&quot;</span><span class="s1">${prop.key.type}</span><span class="s3">\&quot; </span><span class="s1">in the Object Expression`,</span><span class="s3">\n          </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">obj[key] = extractValue(prop.value, path &amp;&amp; [...path, key])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return obj</span><span class="s3">\n  </span><span class="s1">} else if (isTemplateLiteral(node)) {</span><span class="s3">\n    </span><span class="s1">// e.g. `abc`</span><span class="s3">\n    </span><span class="s1">if (node.expressions.length !== 0) {</span><span class="s3">\n      </span><span class="s1">// TODO: should we add support for `${'e'}d${'g'}'e'`?</span><span class="s3">\n      </span><span class="s1">throw new UnsupportedValueError(</span><span class="s3">\n        </span><span class="s1">'Unsupported template literal with expressions',</span><span class="s3">\n        </span><span class="s1">path</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// When TemplateLiteral has 0 expressions, the length of quasis is always 1.</span><span class="s3">\n    </span><span class="s1">// Because when parsing TemplateLiteral, the parser yields the first quasi,</span><span class="s3">\n    </span><span class="s1">// then the first expression, then the next quasi, then the next expression, etc.,</span><span class="s3">\n    </span><span class="s1">// until the last quasi.</span><span class="s3">\n    </span><span class="s1">// Thus if there is no expression, the parser ends at the frst and also last quasis</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// A </span><span class="s3">\&quot;</span><span class="s1">cooked</span><span class="s3">\&quot; </span><span class="s1">interpretation where backslashes have special meaning, while a</span><span class="s3">\n    </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">raw</span><span class="s3">\&quot; </span><span class="s1">interpretation where backslashes do not have special meaning</span><span class="s3">\n    </span><span class="s1">// https://exploringjs.com/impatient-js/ch_template-literals.html#template-strings-cooked-vs-raw</span><span class="s3">\n    </span><span class="s1">const [{ cooked, raw }] = node.quasis</span><span class="s3">\n\n    </span><span class="s1">return cooked ?? raw</span><span class="s3">\n  </span><span class="s1">} else if (isTsSatisfiesExpression(node)) {</span><span class="s3">\n    </span><span class="s1">return extractValue(node.expression)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new UnsupportedValueError(</span><span class="s3">\n      </span><span class="s1">`Unsupported node type </span><span class="s3">\&quot;</span><span class="s1">${node.type}</span><span class="s3">\&quot;</span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">path</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Extracts the value of an exported const variable named `exportedName`</span><span class="s3">\n </span><span class="s1">* (e.g. </span><span class="s3">\&quot;</span><span class="s1">export const config = { runtime: 'edge' }</span><span class="s3">\&quot;</span><span class="s1">) from swc's AST.</span><span class="s3">\n </span><span class="s1">* The value must be one of (or throws UnsupportedValueError):</span><span class="s3">\n </span><span class="s1">*   - string</span><span class="s3">\n </span><span class="s1">*   - boolean</span><span class="s3">\n </span><span class="s1">*   - number</span><span class="s3">\n </span><span class="s1">*   - null</span><span class="s3">\n </span><span class="s1">*   - undefined</span><span class="s3">\n </span><span class="s1">*   - array containing values listed in this list</span><span class="s3">\n </span><span class="s1">*   - object containing values listed in this list</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Throws NoSuchDeclarationError if the declaration is not found.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function extractExportedConstValue(</span><span class="s3">\n  </span><span class="s1">module: Module,</span><span class="s3">\n  </span><span class="s1">exportedName: string</span><span class="s3">\n</span><span class="s1">): any {</span><span class="s3">\n  </span><span class="s1">for (const moduleItem of module.body) {</span><span class="s3">\n    </span><span class="s1">if (!isExportDeclaration(moduleItem)) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const declaration = moduleItem.declaration</span><span class="s3">\n    </span><span class="s1">if (!isVariableDeclaration(declaration)) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (declaration.kind !== 'const') {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const decl of declaration.declarations) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">isIdentifier(decl.id) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">decl.id.value === exportedName &amp;&amp;</span><span class="s3">\n        </span><span class="s1">decl.init</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return extractValue(decl.init, [exportedName])</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">throw new NoSuchDeclarationError()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;NoSuchDeclarationError&quot;</span><span class="s0">,</span><span class="s1">&quot;UnsupportedValueError&quot;</span><span class="s0">,</span><span class="s1">&quot;extractExportedConstValue&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isBooleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isNullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isNumericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isKeyValueProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isRegExpLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isTemplateLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isTsSatisfiesExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;codePath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;extractValue&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;elements&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;elem&quot;</span><span class="s0">,</span><span class="s1">&quot;spread&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;cooked&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;quasis&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;exportedName&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleItem&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;decl&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>