<html>
<head>
<title>web.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
web.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s3">/**</span>
 <span class="s3">* In the web server, there is currently no incremental cache provided and we</span>
 <span class="s3">* always SSR the page.</span>
 <span class="s3">*/ </span><span class="s0">&quot;default&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">WebResponseCache;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_detachedpromise = require(</span><span class="s0">&quot;../../lib/detached-promise&quot;</span><span class="s1">);</span>
<span class="s2">class </span><span class="s1">WebResponseCache {</span>
    <span class="s1">constructor(minimalMode){</span>
        <span class="s2">this</span><span class="s1">.pendingResponses = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s3">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span>
        <span class="s3">// because we replace this.minimalMode to true in production bundles.</span>
        <span class="s1">Object.assign(</span><span class="s2">this</span><span class="s1">, {</span>
            <span class="s1">minimalMode</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">get(key, responseGenerator, context) {</span>
        <span class="s2">var </span><span class="s1">_this_previousCacheItem;</span>
        <span class="s3">// ensure on-demand revalidate doesn't block normal requests</span>
        <span class="s2">const </span><span class="s1">pendingResponseKey = key ? </span><span class="s0">`</span><span class="s1">${key}</span><span class="s0">-</span><span class="s1">${context.isOnDemandRevalidate ? </span><span class="s0">'1' </span><span class="s1">: </span><span class="s0">'0'</span><span class="s1">}</span><span class="s0">` </span><span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">pendingResponse = pendingResponseKey ? </span><span class="s2">this</span><span class="s1">.pendingResponses.get(pendingResponseKey) : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(pendingResponse) {</span>
            <span class="s2">return </span><span class="s1">pendingResponse;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ promise, resolve: resolver, reject: rejecter } = </span><span class="s2">new </span><span class="s1">_detachedpromise.DetachedPromise();</span>
        <span class="s2">if </span><span class="s1">(pendingResponseKey) {</span>
            <span class="s2">this</span><span class="s1">.pendingResponses.set(pendingResponseKey, promise);</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">hasResolved = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">resolve = (cacheEntry)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(pendingResponseKey) {</span>
                <span class="s3">// Ensure all reads from the cache get the latest value.</span>
                <span class="s2">this</span><span class="s1">.pendingResponses.set(pendingResponseKey, Promise.resolve(cacheEntry));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!hasResolved) {</span>
                <span class="s1">hasResolved = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">resolver(cacheEntry);</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s3">// we keep the previous cache entry around to leverage</span>
        <span class="s3">// when the incremental cache is disabled in minimal mode</span>
        <span class="s2">if </span><span class="s1">(pendingResponseKey &amp;&amp; </span><span class="s2">this</span><span class="s1">.minimalMode &amp;&amp; ((_this_previousCacheItem = </span><span class="s2">this</span><span class="s1">.previousCacheItem) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_previousCacheItem.key) === pendingResponseKey &amp;&amp; </span><span class="s2">this</span><span class="s1">.previousCacheItem.expiresAt &gt; Date.now()) {</span>
            <span class="s1">resolve(</span><span class="s2">this</span><span class="s1">.previousCacheItem.entry);</span>
            <span class="s2">this</span><span class="s1">.pendingResponses.delete(pendingResponseKey);</span>
            <span class="s2">return </span><span class="s1">promise;</span>
        <span class="s1">}</span>
        <span class="s3">// We wait to do any async work until after we've added our promise to</span>
        <span class="s3">// `pendingResponses` to ensure that any any other calls will reuse the</span>
        <span class="s3">// same promise until we've fully finished our work.</span>
        <span class="s1">;</span>
        <span class="s1">(async ()=&gt;{</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">cacheEntry = </span><span class="s2">await </span><span class="s1">responseGenerator({</span>
                    <span class="s1">hasResolved</span>
                <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">resolveValue = cacheEntry === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: {</span>
                    <span class="s1">...cacheEntry,</span>
                    <span class="s1">isMiss: </span><span class="s2">true</span>
                <span class="s1">};</span>
                <span class="s3">// for on-demand revalidate wait to resolve until cache is set</span>
                <span class="s2">if </span><span class="s1">(!context.isOnDemandRevalidate) {</span>
                    <span class="s1">resolve(resolveValue);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(key &amp;&amp; cacheEntry &amp;&amp; cacheEntry.cacheControl) {</span>
                    <span class="s2">this</span><span class="s1">.previousCacheItem = {</span>
                        <span class="s1">key: pendingResponseKey || key,</span>
                        <span class="s1">entry: cacheEntry,</span>
                        <span class="s1">expiresAt: Date.now() + </span><span class="s4">1000</span>
                    <span class="s1">};</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">this</span><span class="s1">.previousCacheItem = undefined;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(context.isOnDemandRevalidate) {</span>
                    <span class="s1">resolve(resolveValue);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s3">// while revalidating in the background we can't reject as</span>
                <span class="s3">// we already resolved the cache entry so log the error here</span>
                <span class="s2">if </span><span class="s1">(hasResolved) {</span>
                    <span class="s1">console.error(err);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">rejecter(err);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(pendingResponseKey) {</span>
                    <span class="s2">this</span><span class="s1">.pendingResponses.delete(pendingResponseKey);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">})();</span>
        <span class="s2">return </span><span class="s1">promise;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=web.js.map</span></pre>
</body>
</html>