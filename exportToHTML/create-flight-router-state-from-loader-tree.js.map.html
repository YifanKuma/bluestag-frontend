<html>
<head>
<title>create-flight-router-state-from-loader-tree.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create-flight-router-state-from-loader-tree.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/create-flight-router-state-from-loader-tree.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { LoaderTree } from '../lib/app-dir-module'</span><span class="s3">\n</span><span class="s1">import { HasLoadingBoundary, type FlightRouterState } from './types'</span><span class="s3">\n</span><span class="s1">import type { GetDynamicParamFromSegment } from './app-render'</span><span class="s3">\n</span><span class="s1">import { addSearchParamsIfPageSegment } from '../../shared/lib/segment'</span><span class="s3">\n\n</span><span class="s1">function createFlightRouterStateFromLoaderTreeImpl(</span><span class="s3">\n  </span><span class="s1">[segment, parallelRoutes, { layout, loading }]: LoaderTree,</span><span class="s3">\n  </span><span class="s1">getDynamicParamFromSegment: GetDynamicParamFromSegment,</span><span class="s3">\n  </span><span class="s1">searchParams: any,</span><span class="s3">\n  </span><span class="s1">includeHasLoadingBoundary: boolean,</span><span class="s3">\n  </span><span class="s1">didFindRootLayout: boolean</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const dynamicParam = getDynamicParamFromSegment(segment)</span><span class="s3">\n  </span><span class="s1">const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment</span><span class="s3">\n\n  </span><span class="s1">const segmentTree: FlightRouterState = [</span><span class="s3">\n    </span><span class="s1">addSearchParamsIfPageSegment(treeSegment, searchParams),</span><span class="s3">\n    </span><span class="s1">{},</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">// Mark the first segment that has a layout as the </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot; </span><span class="s1">layout</span><span class="s3">\n  </span><span class="s1">if (!didFindRootLayout &amp;&amp; typeof layout !== 'undefined') {</span><span class="s3">\n    </span><span class="s1">didFindRootLayout = true</span><span class="s3">\n    </span><span class="s1">segmentTree[4] = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let childHasLoadingBoundary = false</span><span class="s3">\n  </span><span class="s1">const children: FlightRouterState[1] = {}</span><span class="s3">\n  </span><span class="s1">Object.keys(parallelRoutes).forEach((parallelRouteKey) =&gt; {</span><span class="s3">\n    </span><span class="s1">const child = createFlightRouterStateFromLoaderTreeImpl(</span><span class="s3">\n      </span><span class="s1">parallelRoutes[parallelRouteKey],</span><span class="s3">\n      </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n      </span><span class="s1">searchParams,</span><span class="s3">\n      </span><span class="s1">includeHasLoadingBoundary,</span><span class="s3">\n      </span><span class="s1">didFindRootLayout</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">includeHasLoadingBoundary &amp;&amp;</span><span class="s3">\n      </span><span class="s1">child[5] !== HasLoadingBoundary.SubtreeHasNoLoadingBoundary</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">childHasLoadingBoundary = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">children[parallelRouteKey] = child</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">segmentTree[1] = children</span><span class="s3">\n\n  </span><span class="s1">if (includeHasLoadingBoundary) {</span><span class="s3">\n    </span><span class="s1">// During a route tree prefetch, the FlightRouterState includes whether a</span><span class="s3">\n    </span><span class="s1">// tree has a loading boundary. The client uses this to determine if it can</span><span class="s3">\n    </span><span class="s1">// skip the data prefetch request â€” if `hasLoadingBoundary` is `false`, the</span><span class="s3">\n    </span><span class="s1">// data prefetch response will be empty, so there's no reason to request it.</span><span class="s3">\n    </span><span class="s1">// NOTE: It would be better to accumulate this while building the loader</span><span class="s3">\n    </span><span class="s1">// tree so we don't have to keep re-deriving it, but since this won't be</span><span class="s3">\n    </span><span class="s1">// once PPR is enabled everywhere, it's not that important.</span><span class="s3">\n    </span><span class="s1">segmentTree[5] = loading</span><span class="s3">\n      </span><span class="s1">? HasLoadingBoundary.SegmentHasLoadingBoundary</span><span class="s3">\n      </span><span class="s1">: childHasLoadingBoundary</span><span class="s3">\n        </span><span class="s1">? HasLoadingBoundary.SubtreeHasLoadingBoundary</span><span class="s3">\n        </span><span class="s1">: HasLoadingBoundary.SubtreeHasNoLoadingBoundary</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segmentTree</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createFlightRouterStateFromLoaderTree(</span><span class="s3">\n  </span><span class="s1">loaderTree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">getDynamicParamFromSegment: GetDynamicParamFromSegment,</span><span class="s3">\n  </span><span class="s1">searchParams: any</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const includeHasLoadingBoundary = false</span><span class="s3">\n  </span><span class="s1">const didFindRootLayout = false</span><span class="s3">\n  </span><span class="s1">return createFlightRouterStateFromLoaderTreeImpl(</span><span class="s3">\n    </span><span class="s1">loaderTree,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">searchParams,</span><span class="s3">\n    </span><span class="s1">includeHasLoadingBoundary,</span><span class="s3">\n    </span><span class="s1">didFindRootLayout</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createRouteTreePrefetch(</span><span class="s3">\n  </span><span class="s1">loaderTree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">getDynamicParamFromSegment: GetDynamicParamFromSegment</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">// Search params should not be added to page segment's cache key during a</span><span class="s3">\n  </span><span class="s1">// route tree prefetch request, because they do not affect the structure of</span><span class="s3">\n  </span><span class="s1">// the route. The client cache has its own logic to handle search params.</span><span class="s3">\n  </span><span class="s1">const searchParams = {}</span><span class="s3">\n  </span><span class="s1">// During a route tree prefetch, we include `hasLoadingBoundary` in</span><span class="s3">\n  </span><span class="s1">// the response.</span><span class="s3">\n  </span><span class="s1">const includeHasLoadingBoundary = true</span><span class="s3">\n  </span><span class="s1">const didFindRootLayout = false</span><span class="s3">\n  </span><span class="s1">return createFlightRouterStateFromLoaderTreeImpl(</span><span class="s3">\n    </span><span class="s1">loaderTree,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">searchParams,</span><span class="s3">\n    </span><span class="s1">includeHasLoadingBoundary,</span><span class="s3">\n    </span><span class="s1">didFindRootLayout</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createFlightRouterStateFromLoaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouteTreePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;createFlightRouterStateFromLoaderTreeImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;layout&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicParamFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;includeHasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;didFindRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParam&quot;</span><span class="s0">,</span><span class="s1">&quot;treeSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;addSearchParamsIfPageSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;childHasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;HasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;SubtreeHasNoLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentHasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;SubtreeHasLoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderTree&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;IAgEgBA,qCAAqC;eAArCA;;IAgBAC,uBAAuB;eAAvBA;;;uBA/E2C;yBAEd;AAE7C,SAASC,0CACP,CAACC,SAASC,gBAAgB,EAAEC,MAAM,EAAEC,OAAO,EAAE,CAAa,EAC1DC,0BAAsD,EACtDC,YAAiB,EACjBC,yBAAkC,EAClCC,iBAA0B;IAE1B,MAAMC,eAAeJ,2BAA2BJ;IAChD,MAAMS,cAAcD,eAAeA,aAAaC,WAAW,GAAGT;IAE9D,MAAMU,cAAiC;QACrCC,IAAAA,qCAA4B,EAACF,aAAaJ;QAC1C,CAAC;KACF;IAED,gEAAgE;IAChE,IAAI,CAACE,qBAAqB,OAAOL,WAAW,aAAa;QACvDK,oBAAoB;QACpBG,WAAW,CAAC,EAAE,GAAG;IACnB;IAEA,IAAIE,0BAA0B;IAC9B,MAAMC,WAAiC,CAAC;IACxCC,OAAOC,IAAI,CAACd,gBAAgBe,OAAO,CAAC,CAACC;QACnC,MAAMC,QAAQnB,0CACZE,cAAc,CAACgB,iBAAiB,EAChCb,4BACAC,cACAC,2BACAC;QAEF,IACED,6BACAY,KAAK,CAAC,EAAE,KAAKC,yBAAkB,CAACC,2BAA2B,EAC3D;YACAR,0BAA0B;QAC5B;QACAC,QAAQ,CAACI,iBAAiB,GAAGC;IAC/B;IACAR,WAAW,CAAC,EAAE,GAAGG;IAEjB,IAAIP,2BAA2B;QAC7B,yEAAyE;QACzE,2EAA2E;QAC3E,2EAA2E;QAC3E,4EAA4E;QAC5E,wEAAwE;QACxE,wEAAwE;QACxE,2DAA2D;QAC3DI,WAAW,CAAC,EAAE,GAAGP,UACbgB,yBAAkB,CAACE,yBAAyB,GAC5CT,0BACEO,yBAAkB,CAACG,yBAAyB,GAC5CH,yBAAkB,CAACC,2BAA2B;IACtD;IAEA,OAAOV;AACT;AAEO,SAASb,sCACd0B,UAAsB,EACtBnB,0BAAsD,EACtDC,YAAiB;IAEjB,MAAMC,4BAA4B;IAClC,MAAMC,oBAAoB;IAC1B,OAAOR,0CACLwB,YACAnB,4BACAC,cACAC,2BACAC;AAEJ;AAEO,SAAST,wBACdyB,UAAsB,EACtBnB,0BAAsD;IAEtD,yEAAyE;IACzE,2EAA2E;IAC3E,yEAAyE;IACzE,MAAMC,eAAe,CAAC;IACtB,mEAAmE;IACnE,gBAAgB;IAChB,MAAMC,4BAA4B;IAClC,MAAMC,oBAAoB;IAC1B,OAAOR,0CACLwB,YACAnB,4BACAC,cACAC,2BACAC;AAEJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>