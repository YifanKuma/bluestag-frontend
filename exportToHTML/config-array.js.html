<html>
<head>
<title>config-array.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
config-array.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">`ConfigArray` class.</span>
 <span class="s0">*</span>
 <span class="s0">* `ConfigArray` class expresses the full of a configuration. It has the entry</span>
 <span class="s0">* config file, base config files that were extended, loaded parsers, and loaded</span>
 <span class="s0">* plugins.</span>
 <span class="s0">*</span>
 <span class="s0">* `ConfigArray` class provides three properties and two methods.</span>
 <span class="s0">*</span>
 <span class="s0">* - `pluginEnvironments`</span>
 <span class="s0">* - `pluginProcessors`</span>
 <span class="s0">* - `pluginRules`</span>
 <span class="s0">*      The `Map` objects that contain the members of all plugins that this</span>
 <span class="s0">*      config array contains. Those map objects don't have mutation methods.</span>
 <span class="s0">*      Those keys are the member ID such as `pluginId/memberName`.</span>
 <span class="s0">* - `isRoot()`</span>
 <span class="s0">*      If `true` then this configuration has `root:true` property.</span>
 <span class="s0">* - `extractConfig(filePath)`</span>
 <span class="s0">*      Extract the final configuration for a given file. This means merging</span>
 <span class="s0">*      every config array element which that `criteria` property matched. The</span>
 <span class="s0">*      `filePath` argument must be an absolute path.</span>
 <span class="s0">*</span>
 <span class="s0">* `ConfigArrayFactory` provides the loading logic of config files.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s0">*/</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s3">import </span><span class="s2">{ ExtractedConfig } from </span><span class="s4">&quot;./extracted-config.js&quot;</span><span class="s2">;</span>
<span class="s3">import </span><span class="s2">{ IgnorePattern } from </span><span class="s4">&quot;./ignore-pattern.js&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">// Define types for VSCode IntelliSense.</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../../shared/types&quot;).Environment} Environment */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../../shared/types&quot;).GlobalConf} GlobalConf */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../../shared/types&quot;).RuleConf} RuleConf */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../../shared/types&quot;).Rule} Rule */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../../shared/types&quot;).Plugin} Plugin */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../../shared/types&quot;).Processor} Processor */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./config-dependency&quot;).DependentParser} DependentParser */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./config-dependency&quot;).DependentPlugin} DependentPlugin */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;./override-tester&quot;)[&quot;OverrideTester&quot;]} OverrideTester */</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} ConfigArrayElement</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} name The name of this config element.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} filePath The path to the source file of this config element.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{InstanceType&lt;OverrideTester&gt;|null} criteria The tester for the `files` and `excludedFiles` of this config element.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Record&lt;string, boolean&gt;|undefined} env The environment settings.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Record&lt;string, GlobalConf&gt;|undefined} globals The global variable settings.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{IgnorePattern|undefined} ignorePattern The ignore patterns.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{boolean|undefined} noInlineConfig The flag that disables directive comments.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{DependentParser|undefined} parser The parser loader.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Object|undefined} parserOptions The parser options.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Record&lt;string, DependentPlugin&gt;|undefined} plugins The plugin loaders.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string|undefined} processor The processor name to refer plugin's processor.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{boolean|undefined} root The flag to express root.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Record&lt;string, RuleConf&gt;|undefined} rules The rule settings</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Object|undefined} settings The shared settings.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot;} type The element type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} ConfigArrayInternalSlots</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Map&lt;string, ExtractedConfig&gt;} cache The cache to extract configs.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{ReadonlyMap&lt;string, Environment&gt;|null} envMap The map from environment ID to environment definition.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{ReadonlyMap&lt;string, Processor&gt;|null} processorMap The map from processor ID to environment definition.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{ReadonlyMap&lt;string, Rule&gt;|null} ruleMap The map from rule ID to rule definition.</span>
 <span class="s0">*/</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{WeakMap&lt;ConfigArray, ConfigArrayInternalSlots&gt;} */</span>
<span class="s3">const </span><span class="s2">internalSlotsMap = </span><span class="s3">new class extends </span><span class="s2">WeakMap {</span>
    <span class="s2">get(key) {</span>
        <span class="s3">let </span><span class="s2">value = </span><span class="s3">super</span><span class="s2">.get(key);</span>

        <span class="s3">if </span><span class="s2">(!value) {</span>
            <span class="s2">value = {</span>
                <span class="s2">cache: </span><span class="s3">new </span><span class="s2">Map(),</span>
                <span class="s2">envMap: </span><span class="s3">null</span><span class="s2">,</span>
                <span class="s2">processorMap: </span><span class="s3">null</span><span class="s2">,</span>
                <span class="s2">ruleMap: </span><span class="s3">null</span>
            <span class="s2">};</span>
            <span class="s3">super</span><span class="s2">.set(key, value);</span>
        <span class="s2">}</span>

        <span class="s3">return </span><span class="s2">value;</span>
    <span class="s2">}</span>
<span class="s2">}();</span>

<span class="s0">/**</span>
 <span class="s0">* Get the indices which are matched to a given file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayElement[]} elements The elements.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The path to a target file.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number[]} The indices.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">getMatchedIndices(elements, filePath) {</span>
    <span class="s3">const </span><span class="s2">indices = [];</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = elements.length - </span><span class="s5">1</span><span class="s2">; i &gt;= </span><span class="s5">0</span><span class="s2">; --i) {</span>
        <span class="s3">const </span><span class="s2">element = elements[i];</span>

        <span class="s3">if </span><span class="s2">(!element.criteria || (filePath &amp;&amp; element.criteria.test(filePath))) {</span>
            <span class="s2">indices.push(i);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">indices;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check if a value is a non-null object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} x The value to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the value is a non-null object.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">isNonNullObject(x) {</span>
    <span class="s3">return typeof </span><span class="s2">x === </span><span class="s4">&quot;object&quot; </span><span class="s2">&amp;&amp; x !== </span><span class="s3">null</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Merge two objects.</span>
 <span class="s0">*</span>
 <span class="s0">* Assign every property values of `y` to `x` if `x` doesn't have the property.</span>
 <span class="s0">* If `x`'s property value is an object, it does recursive.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} target The destination to merge</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|undefined} source The source to merge.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mergeWithoutOverwrite(target, source) {</span>
    <span class="s3">if </span><span class="s2">(!isNonNullObject(source)) {</span>
        <span class="s3">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">key of Object.keys(source)) {</span>
        <span class="s3">if </span><span class="s2">(key === </span><span class="s4">&quot;__proto__&quot;</span><span class="s2">) {</span>
            <span class="s3">continue</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s3">if </span><span class="s2">(isNonNullObject(target[key])) {</span>
            <span class="s2">mergeWithoutOverwrite(target[key], source[key]);</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(target[key] === </span><span class="s3">void </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s3">if </span><span class="s2">(isNonNullObject(source[key])) {</span>
                <span class="s2">target[key] = Array.isArray(source[key]) ? [] : {};</span>
                <span class="s2">mergeWithoutOverwrite(target[key], source[key]);</span>
            <span class="s2">} </span><span class="s3">else if </span><span class="s2">(source[key] !== </span><span class="s3">void </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s2">target[key] = source[key];</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* The error for plugin conflicts.</span>
 <span class="s0">*/</span>
<span class="s3">class </span><span class="s2">PluginConflictError </span><span class="s3">extends </span><span class="s2">Error {</span>

    <span class="s0">/**</span>
     <span class="s0">* Initialize this error object.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} pluginId The plugin ID.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{{filePath:string, importerName:string}[]} plugins The resolved plugins.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor(pluginId, plugins) {</span>
        <span class="s3">super</span><span class="s2">(</span><span class="s4">`Plugin &quot;</span><span class="s2">${pluginId}</span><span class="s4">&quot; was conflicted between </span><span class="s2">${plugins.map(p =&gt; </span><span class="s4">`&quot;</span><span class="s2">${p.importerName}</span><span class="s4">&quot;`</span><span class="s2">).join(</span><span class="s4">&quot; and &quot;</span><span class="s2">)}</span><span class="s4">.`</span><span class="s2">);</span>
        <span class="s3">this</span><span class="s2">.messageTemplate = </span><span class="s4">&quot;plugin-conflict&quot;</span><span class="s2">;</span>
        <span class="s3">this</span><span class="s2">.messageData = { pluginId, plugins };</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Merge plugins.</span>
 <span class="s0">* `target`'s definition is prior to `source`'s.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Record&lt;string, DependentPlugin&gt;} target The destination to merge</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Record&lt;string, DependentPlugin&gt;|undefined} source The source to merge.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{PluginConflictError} When a plugin was conflicted.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mergePlugins(target, source) {</span>
    <span class="s3">if </span><span class="s2">(!isNonNullObject(source)) {</span>
        <span class="s3">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">key of Object.keys(source)) {</span>
        <span class="s3">if </span><span class="s2">(key === </span><span class="s4">&quot;__proto__&quot;</span><span class="s2">) {</span>
            <span class="s3">continue</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">const </span><span class="s2">targetValue = target[key];</span>
        <span class="s3">const </span><span class="s2">sourceValue = source[key];</span>

        <span class="s0">// Adopt the plugin which was found at first.</span>
        <span class="s3">if </span><span class="s2">(targetValue === </span><span class="s3">void </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s3">if </span><span class="s2">(sourceValue.error) {</span>
                <span class="s3">throw </span><span class="s2">sourceValue.error;</span>
            <span class="s2">}</span>
            <span class="s2">target[key] = sourceValue;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(sourceValue.filePath !== targetValue.filePath) {</span>
            <span class="s3">throw new </span><span class="s2">PluginConflictError(key, [</span>
                <span class="s2">{</span>
                    <span class="s2">filePath: targetValue.filePath,</span>
                    <span class="s2">importerName: targetValue.importerName</span>
                <span class="s2">},</span>
                <span class="s2">{</span>
                    <span class="s2">filePath: sourceValue.filePath,</span>
                    <span class="s2">importerName: sourceValue.importerName</span>
                <span class="s2">}</span>
            <span class="s2">]);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Merge rule configs.</span>
 <span class="s0">* `target`'s definition is prior to `source`'s.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Record&lt;string, Array&gt;} target The destination to merge</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Record&lt;string, RuleConf&gt;|undefined} source The source to merge.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mergeRuleConfigs(target, source) {</span>
    <span class="s3">if </span><span class="s2">(!isNonNullObject(source)) {</span>
        <span class="s3">return</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">key of Object.keys(source)) {</span>
        <span class="s3">if </span><span class="s2">(key === </span><span class="s4">&quot;__proto__&quot;</span><span class="s2">) {</span>
            <span class="s3">continue</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">const </span><span class="s2">targetDef = target[key];</span>
        <span class="s3">const </span><span class="s2">sourceDef = source[key];</span>

        <span class="s0">// Adopt the rule config which was found at first.</span>
        <span class="s3">if </span><span class="s2">(targetDef === </span><span class="s3">void </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s3">if </span><span class="s2">(Array.isArray(sourceDef)) {</span>
                <span class="s2">target[key] = [...sourceDef];</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
                <span class="s2">target[key] = [sourceDef];</span>
            <span class="s2">}</span>

        <span class="s0">/* 
         * If the first found rule config is severity only and the current rule 
         * config has options, merge the severity and the options. 
         */</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span>
            <span class="s2">targetDef.length === </span><span class="s5">1 </span><span class="s2">&amp;&amp;</span>
            <span class="s2">Array.isArray(sourceDef) &amp;&amp;</span>
            <span class="s2">sourceDef.length &gt;= </span><span class="s5">2</span>
        <span class="s2">) {</span>
            <span class="s2">targetDef.push(...sourceDef.slice(</span><span class="s5">1</span><span class="s2">));</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Create the extracted config.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArray} instance The config elements.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number[]} indices The indices to use.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ExtractedConfig} The extracted config.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} When a plugin is conflicted.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">createConfig(instance, indices) {</span>
    <span class="s3">const </span><span class="s2">config = </span><span class="s3">new </span><span class="s2">ExtractedConfig();</span>
    <span class="s3">const </span><span class="s2">ignorePatterns = [];</span>

    <span class="s0">// Merge elements.</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">index of indices) {</span>
        <span class="s3">const </span><span class="s2">element = instance[index];</span>

        <span class="s0">// Adopt the parser which was found at first.</span>
        <span class="s3">if </span><span class="s2">(!config.parser &amp;&amp; element.parser) {</span>
            <span class="s3">if </span><span class="s2">(element.parser.error) {</span>
                <span class="s3">throw </span><span class="s2">element.parser.error;</span>
            <span class="s2">}</span>
            <span class="s2">config.parser = element.parser;</span>
        <span class="s2">}</span>

        <span class="s0">// Adopt the processor which was found at first.</span>
        <span class="s3">if </span><span class="s2">(!config.processor &amp;&amp; element.processor) {</span>
            <span class="s2">config.processor = element.processor;</span>
        <span class="s2">}</span>

        <span class="s0">// Adopt the noInlineConfig which was found at first.</span>
        <span class="s3">if </span><span class="s2">(config.noInlineConfig === </span><span class="s3">void </span><span class="s5">0 </span><span class="s2">&amp;&amp; element.noInlineConfig !== </span><span class="s3">void </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s2">config.noInlineConfig = element.noInlineConfig;</span>
            <span class="s2">config.configNameOfNoInlineConfig = element.name;</span>
        <span class="s2">}</span>

        <span class="s0">// Adopt the reportUnusedDisableDirectives which was found at first.</span>
        <span class="s3">if </span><span class="s2">(config.reportUnusedDisableDirectives === </span><span class="s3">void </span><span class="s5">0 </span><span class="s2">&amp;&amp; element.reportUnusedDisableDirectives !== </span><span class="s3">void </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s2">config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;</span>
        <span class="s2">}</span>

        <span class="s0">// Collect ignorePatterns</span>
        <span class="s3">if </span><span class="s2">(element.ignorePattern) {</span>
            <span class="s2">ignorePatterns.push(element.ignorePattern);</span>
        <span class="s2">}</span>

        <span class="s0">// Merge others.</span>
        <span class="s2">mergeWithoutOverwrite(config.env, element.env);</span>
        <span class="s2">mergeWithoutOverwrite(config.globals, element.globals);</span>
        <span class="s2">mergeWithoutOverwrite(config.parserOptions, element.parserOptions);</span>
        <span class="s2">mergeWithoutOverwrite(config.settings, element.settings);</span>
        <span class="s2">mergePlugins(config.plugins, element.plugins);</span>
        <span class="s2">mergeRuleConfigs(config.rules, element.rules);</span>
    <span class="s2">}</span>

    <span class="s0">// Create the predicate function for ignore patterns.</span>
    <span class="s3">if </span><span class="s2">(ignorePatterns.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">config;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Collect definitions.</span>
 <span class="s0">* </span><span class="s1">@template </span><span class="s0">T, U</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} pluginId The plugin ID for prefix.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Record&lt;string,T&gt;} defs The definitions to collect.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Map&lt;string, U&gt;} map The map to output.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">collect(pluginId, defs, map) {</span>
    <span class="s3">if </span><span class="s2">(defs) {</span>
        <span class="s3">const </span><span class="s2">prefix = pluginId &amp;&amp; </span><span class="s4">`</span><span class="s2">${pluginId}</span><span class="s4">/`</span><span class="s2">;</span>

        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">[key, value] of Object.entries(defs)) {</span>
            <span class="s2">map.set(</span><span class="s4">`</span><span class="s2">${prefix}${key}</span><span class="s4">`</span><span class="s2">, value);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Delete the mutation methods from a given map.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Map&lt;any, any&gt;} map The map object to delete.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">deleteMutationMethods(map) {</span>
    <span class="s2">Object.defineProperties(map, {</span>
        <span class="s2">clear: { configurable: </span><span class="s3">true</span><span class="s2">, value: </span><span class="s3">void </span><span class="s5">0 </span><span class="s2">},</span>
        <span class="s3">delete</span><span class="s2">: { configurable: </span><span class="s3">true</span><span class="s2">, value: </span><span class="s3">void </span><span class="s5">0 </span><span class="s2">},</span>
        <span class="s2">set: { configurable: </span><span class="s3">true</span><span class="s2">, value: </span><span class="s3">void </span><span class="s5">0 </span><span class="s2">}</span>
    <span class="s2">});</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayElement[]} elements The config elements.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArrayInternalSlots} slots The internal slots.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">initPluginMemberMaps(elements, slots) {</span>
    <span class="s3">const </span><span class="s2">processed = </span><span class="s3">new </span><span class="s2">Set();</span>

    <span class="s2">slots.envMap = </span><span class="s3">new </span><span class="s2">Map();</span>
    <span class="s2">slots.processorMap = </span><span class="s3">new </span><span class="s2">Map();</span>
    <span class="s2">slots.ruleMap = </span><span class="s3">new </span><span class="s2">Map();</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">element of elements) {</span>
        <span class="s3">if </span><span class="s2">(!element.plugins) {</span>
            <span class="s3">continue</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">[pluginId, value] of Object.entries(element.plugins)) {</span>
            <span class="s3">const </span><span class="s2">plugin = value.definition;</span>

            <span class="s3">if </span><span class="s2">(!plugin || processed.has(pluginId)) {</span>
                <span class="s3">continue</span><span class="s2">;</span>
            <span class="s2">}</span>
            <span class="s2">processed.add(pluginId);</span>

            <span class="s2">collect(pluginId, plugin.environments, slots.envMap);</span>
            <span class="s2">collect(pluginId, plugin.processors, slots.processorMap);</span>
            <span class="s2">collect(pluginId, plugin.rules, slots.ruleMap);</span>
        <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s2">deleteMutationMethods(slots.envMap);</span>
    <span class="s2">deleteMutationMethods(slots.processorMap);</span>
    <span class="s2">deleteMutationMethods(slots.ruleMap);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArray} instance The config elements.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ConfigArrayInternalSlots} The extracted config.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">ensurePluginMemberMaps(instance) {</span>
    <span class="s3">const </span><span class="s2">slots = internalSlotsMap.get(instance);</span>

    <span class="s3">if </span><span class="s2">(!slots.ruleMap) {</span>
        <span class="s2">initPluginMemberMaps(instance, slots);</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">slots;</span>
<span class="s2">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Public Interface</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* The Config Array.</span>
 <span class="s0">*</span>
 <span class="s0">* `ConfigArray` instance contains all settings, parsers, and plugins.</span>
 <span class="s0">* You need to call `ConfigArray#extractConfig(filePath)` method in order to</span>
 <span class="s0">* extract, merge and get only the config data which is related to an arbitrary</span>
 <span class="s0">* file.</span>
 <span class="s0">* </span><span class="s1">@extends </span><span class="s0">{Array&lt;ConfigArrayElement&gt;}</span>
 <span class="s0">*/</span>
<span class="s3">class </span><span class="s2">ConfigArray </span><span class="s3">extends </span><span class="s2">Array {</span>

    <span class="s0">/**</span>
     <span class="s0">* Get the plugin environments.</span>
     <span class="s0">* The returned map cannot be mutated.</span>
     <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ReadonlyMap&lt;string, Environment&gt;} The plugin environments.</span>
     <span class="s0">*/</span>
    <span class="s2">get pluginEnvironments() {</span>
        <span class="s3">return </span><span class="s2">ensurePluginMemberMaps(</span><span class="s3">this</span><span class="s2">).envMap;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Get the plugin processors.</span>
     <span class="s0">* The returned map cannot be mutated.</span>
     <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ReadonlyMap&lt;string, Processor&gt;} The plugin processors.</span>
     <span class="s0">*/</span>
    <span class="s2">get pluginProcessors() {</span>
        <span class="s3">return </span><span class="s2">ensurePluginMemberMaps(</span><span class="s3">this</span><span class="s2">).processorMap;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Get the plugin rules.</span>
     <span class="s0">* The returned map cannot be mutated.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ReadonlyMap&lt;string, Rule&gt;} The plugin rules.</span>
     <span class="s0">*/</span>
    <span class="s2">get pluginRules() {</span>
        <span class="s3">return </span><span class="s2">ensurePluginMemberMaps(</span><span class="s3">this</span><span class="s2">).ruleMap;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Check if this config has `root` flag.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if this config array is root.</span>
     <span class="s0">*/</span>
    <span class="s2">isRoot() {</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s3">this</span><span class="s2">.length - </span><span class="s5">1</span><span class="s2">; i &gt;= </span><span class="s5">0</span><span class="s2">; --i) {</span>
            <span class="s3">const </span><span class="s2">root = </span><span class="s3">this</span><span class="s2">[i].root;</span>

            <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">root === </span><span class="s4">&quot;boolean&quot;</span><span class="s2">) {</span>
                <span class="s3">return </span><span class="s2">root;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">return false</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Extract the config data which is related to a given file.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The absolute path to the target file.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ExtractedConfig} The extracted config data.</span>
     <span class="s0">*/</span>
    <span class="s2">extractConfig(filePath) {</span>
        <span class="s3">const </span><span class="s2">{ cache } = internalSlotsMap.get(</span><span class="s3">this</span><span class="s2">);</span>
        <span class="s3">const </span><span class="s2">indices = getMatchedIndices(</span><span class="s3">this</span><span class="s2">, filePath);</span>
        <span class="s3">const </span><span class="s2">cacheKey = indices.join(</span><span class="s4">&quot;,&quot;</span><span class="s2">);</span>

        <span class="s3">if </span><span class="s2">(!cache.has(cacheKey)) {</span>
            <span class="s2">cache.set(cacheKey, createConfig(</span><span class="s3">this</span><span class="s2">, indices));</span>
        <span class="s2">}</span>

        <span class="s3">return </span><span class="s2">cache.get(cacheKey);</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Check if a given path is an additional lint target.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} filePath The absolute path to the target file.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the file is an additional lint target.</span>
     <span class="s0">*/</span>
    <span class="s2">isAdditionalTargetPath(filePath) {</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">{ criteria, type } of </span><span class="s3">this</span><span class="s2">) {</span>
            <span class="s3">if </span><span class="s2">(</span>
                <span class="s2">type === </span><span class="s4">&quot;config&quot; </span><span class="s2">&amp;&amp;</span>
                <span class="s2">criteria &amp;&amp;</span>
                <span class="s2">!criteria.endsWithWildcard &amp;&amp;</span>
                <span class="s2">criteria.test(filePath)</span>
            <span class="s2">) {</span>
                <span class="s3">return true</span><span class="s2">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">return false</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Get the used extracted configs.</span>
 <span class="s0">* CLIEngine will use this method to collect used deprecated rules.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ConfigArray} instance The config array object to get.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ExtractedConfig[]} The used extracted configs.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">getUsedExtractedConfigs(instance) {</span>
    <span class="s3">const </span><span class="s2">{ cache } = internalSlotsMap.get(instance);</span>

    <span class="s3">return </span><span class="s2">Array.from(cache.values());</span>
<span class="s2">}</span>


<span class="s3">export </span><span class="s2">{</span>
    <span class="s2">ConfigArray,</span>
    <span class="s2">getUsedExtractedConfigs</span>
<span class="s2">};</span>
</pre>
</body>
</html>