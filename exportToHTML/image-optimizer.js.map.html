<html>
<head>
<title>image-optimizer.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
image-optimizer.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/image-optimizer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { createHash } from 'crypto'</span><span class="s3">\n</span><span class="s1">import { promises } from 'fs'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import { mediaType } from 'next/dist/compiled/@hapi/accept'</span><span class="s3">\n</span><span class="s1">import contentDisposition from 'next/dist/compiled/content-disposition'</span><span class="s3">\n</span><span class="s1">import imageSizeOf from 'next/dist/compiled/image-size'</span><span class="s3">\n</span><span class="s1">import { detector } from 'next/dist/compiled/image-detector/detector.js'</span><span class="s3">\n</span><span class="s1">import isAnimated from 'next/dist/compiled/is-animated'</span><span class="s3">\n</span><span class="s1">import { join } from 'path'</span><span class="s3">\n</span><span class="s1">import nodeUrl, { type UrlWithParsedQuery } from 'url'</span><span class="s3">\n\n</span><span class="s1">import { getImageBlurSvg } from '../shared/lib/image-blur-svg'</span><span class="s3">\n</span><span class="s1">import type { ImageConfigComplete } from '../shared/lib/image-config'</span><span class="s3">\n</span><span class="s1">import { hasLocalMatch } from '../shared/lib/match-local-pattern'</span><span class="s3">\n</span><span class="s1">import { hasRemoteMatch } from '../shared/lib/match-remote-pattern'</span><span class="s3">\n</span><span class="s1">import type { NextConfigComplete } from './config-shared'</span><span class="s3">\n</span><span class="s1">import { createRequestResponseMocks } from './lib/mock-request'</span><span class="s3">\n</span><span class="s1">import type { NextUrlWithParsedQuery } from './request-meta'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">type CachedImageValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './response-cache'</span><span class="s3">\n</span><span class="s1">import { sendEtagResponse } from './send-payload'</span><span class="s3">\n</span><span class="s1">import { getContentType, getExtension } from './serve-static'</span><span class="s3">\n</span><span class="s1">import * as Log from '../build/output/log'</span><span class="s3">\n</span><span class="s1">import isError from '../lib/is-error'</span><span class="s3">\n</span><span class="s1">import { parseUrl } from '../lib/url'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">type XCacheHeader = 'MISS' | 'HIT' | 'STALE'</span><span class="s3">\n\n</span><span class="s1">const AVIF = 'image/avif'</span><span class="s3">\n</span><span class="s1">const WEBP = 'image/webp'</span><span class="s3">\n</span><span class="s1">const PNG = 'image/png'</span><span class="s3">\n</span><span class="s1">const JPEG = 'image/jpeg'</span><span class="s3">\n</span><span class="s1">const JXL = 'image/jxl'</span><span class="s3">\n</span><span class="s1">const JP2 = 'image/jp2'</span><span class="s3">\n</span><span class="s1">const HEIC = 'image/heic'</span><span class="s3">\n</span><span class="s1">const GIF = 'image/gif'</span><span class="s3">\n</span><span class="s1">const SVG = 'image/svg+xml'</span><span class="s3">\n</span><span class="s1">const ICO = 'image/x-icon'</span><span class="s3">\n</span><span class="s1">const ICNS = 'image/x-icns'</span><span class="s3">\n</span><span class="s1">const TIFF = 'image/tiff'</span><span class="s3">\n</span><span class="s1">const BMP = 'image/bmp'</span><span class="s3">\n</span><span class="s1">const PDF = 'application/pdf'</span><span class="s3">\n</span><span class="s1">const CACHE_VERSION = 4</span><span class="s3">\n</span><span class="s1">const ANIMATABLE_TYPES = [WEBP, PNG, GIF]</span><span class="s3">\n</span><span class="s1">const BYPASS_TYPES = [SVG, ICO, ICNS, BMP, JXL, HEIC]</span><span class="s3">\n</span><span class="s1">const BLUR_IMG_SIZE = 8 // should match `next-image-loader`</span><span class="s3">\n</span><span class="s1">const BLUR_QUALITY = 70 // should match `next-image-loader`</span><span class="s3">\n\n</span><span class="s1">let _sharp: typeof import('sharp')</span><span class="s3">\n\n</span><span class="s1">export function getSharp(concurrency: number | null | undefined) {</span><span class="s3">\n  </span><span class="s1">if (_sharp) {</span><span class="s3">\n    </span><span class="s1">return _sharp</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">_sharp = require('sharp') as typeof import('sharp')</span><span class="s3">\n    </span><span class="s1">if (_sharp &amp;&amp; _sharp.concurrency() &gt; 1) {</span><span class="s3">\n      </span><span class="s1">// Reducing concurrency should reduce the memory usage too.</span><span class="s3">\n      </span><span class="s1">// We more aggressively reduce in dev but also reduce in prod.</span><span class="s3">\n      </span><span class="s1">// https://sharp.pixelplumbing.com/api-utility#concurrency</span><span class="s3">\n      </span><span class="s1">const divisor = process.env.NODE_ENV === 'development' ? 4 : 2</span><span class="s3">\n      </span><span class="s1">_sharp.concurrency(</span><span class="s3">\n        </span><span class="s1">concurrency ?? Math.floor(Math.max(_sharp.concurrency() / divisor, 1))</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (e: unknown) {</span><span class="s3">\n    </span><span class="s1">if (isError(e) &amp;&amp; e.code === 'MODULE_NOT_FOUND') {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Module `sharp` not found. Please run `npm install --cpu=wasm32 sharp` to install it.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return _sharp</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface ImageParamsResult {</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">isAbsolute: boolean</span><span class="s3">\n  </span><span class="s1">isStatic: boolean</span><span class="s3">\n  </span><span class="s1">width: number</span><span class="s3">\n  </span><span class="s1">quality: number</span><span class="s3">\n  </span><span class="s1">mimeType: string</span><span class="s3">\n  </span><span class="s1">sizes: number[]</span><span class="s3">\n  </span><span class="s1">minimumCacheTTL: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ImageUpstream {</span><span class="s3">\n  </span><span class="s1">buffer: Buffer</span><span class="s3">\n  </span><span class="s1">contentType: string | null | undefined</span><span class="s3">\n  </span><span class="s1">cacheControl: string | null | undefined</span><span class="s3">\n  </span><span class="s1">etag: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getSupportedMimeType(options: string[], accept = ''): string {</span><span class="s3">\n  </span><span class="s1">const mimeType = mediaType(accept, options)</span><span class="s3">\n  </span><span class="s1">return accept.includes(mimeType) ? mimeType : ''</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getHash(items: (string | number | Buffer)[]) {</span><span class="s3">\n  </span><span class="s1">const hash = createHash('sha256')</span><span class="s3">\n  </span><span class="s1">for (let item of items) {</span><span class="s3">\n    </span><span class="s1">if (typeof item === 'number') hash.update(String(item))</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">hash.update(item)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// See https://en.wikipedia.org/wiki/Base64#URL_applications</span><span class="s3">\n  </span><span class="s1">return hash.digest('base64url')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractEtag(</span><span class="s3">\n  </span><span class="s1">etag: string | null | undefined,</span><span class="s3">\n  </span><span class="s1">imageBuffer: Buffer</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (etag) {</span><span class="s3">\n    </span><span class="s1">// upstream etag needs to be base64url encoded due to weak etag signature</span><span class="s3">\n    </span><span class="s1">// as we store this in the cache-entry file name.</span><span class="s3">\n    </span><span class="s1">return Buffer.from(etag).toString('base64url')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return getImageEtag(imageBuffer)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getImageEtag(image: Buffer) {</span><span class="s3">\n  </span><span class="s1">return getHash([image])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function writeToCacheDir(</span><span class="s3">\n  </span><span class="s1">dir: string,</span><span class="s3">\n  </span><span class="s1">extension: string,</span><span class="s3">\n  </span><span class="s1">maxAge: number,</span><span class="s3">\n  </span><span class="s1">expireAt: number,</span><span class="s3">\n  </span><span class="s1">buffer: Buffer,</span><span class="s3">\n  </span><span class="s1">etag: string,</span><span class="s3">\n  </span><span class="s1">upstreamEtag: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const filename = join(</span><span class="s3">\n    </span><span class="s1">dir,</span><span class="s3">\n    </span><span class="s1">`${maxAge}.${expireAt}.${etag}.${upstreamEtag}.${extension}`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">await promises.rm(dir, { recursive: true, force: true }).catch(() =&gt; {})</span><span class="s3">\n\n  </span><span class="s1">await promises.mkdir(dir, { recursive: true })</span><span class="s3">\n  </span><span class="s1">await promises.writeFile(filename, buffer)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Inspects the first few bytes of a buffer to determine if</span><span class="s3">\n </span><span class="s1">* it matches the </span><span class="s3">\&quot;</span><span class="s1">magic number</span><span class="s3">\&quot; </span><span class="s1">of known file signatures.</span><span class="s3">\n </span><span class="s1">* https://en.wikipedia.org/wiki/List_of_file_signatures</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function detectContentType(</span><span class="s3">\n  </span><span class="s1">buffer: Buffer,</span><span class="s3">\n  </span><span class="s1">skipMetadata: boolean | null | undefined,</span><span class="s3">\n  </span><span class="s1">concurrency?: number | null | undefined</span><span class="s3">\n</span><span class="s1">): Promise&lt;string | null&gt; {</span><span class="s3">\n  </span><span class="s1">if (buffer.byteLength === 0) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0xff, 0xd8, 0xff].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return JPEG</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a].every(</span><span class="s3">\n      </span><span class="s1">(b, i) =&gt; buffer[i] === b</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return PNG</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0x47, 0x49, 0x46, 0x38].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return GIF</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">[0x52, 0x49, 0x46, 0x46, 0, 0, 0, 0, 0x57, 0x45, 0x42, 0x50].every(</span><span class="s3">\n      </span><span class="s1">(b, i) =&gt; !b || buffer[i] === b</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return WEBP</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0x3c, 0x3f, 0x78, 0x6d, 0x6c].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return SVG</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0x3c, 0x73, 0x76, 0x67].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return SVG</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">[0, 0, 0, 0, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66].every(</span><span class="s3">\n      </span><span class="s1">(b, i) =&gt; !b || buffer[i] === b</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return AVIF</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0x00, 0x00, 0x01, 0x00].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return ICO</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0x69, 0x63, 0x6e, 0x73].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return ICNS</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0x49, 0x49, 0x2a, 0x00].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return TIFF</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0x42, 0x4d].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return BMP</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0xff, 0x0a].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return JXL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\n      </span><span class="s1">0x00, 0x00, 0x00, 0x0c, 0x4a, 0x58, 0x4c, 0x20, 0x0d, 0x0a, 0x87, 0x0a,</span><span class="s3">\n    </span><span class="s1">].every((b, i) =&gt; buffer[i] === b)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return JXL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">[0, 0, 0, 0, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63].every(</span><span class="s3">\n      </span><span class="s1">(b, i) =&gt; !b || buffer[i] === b</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return HEIC</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if ([0x25, 0x50, 0x44, 0x46, 0x2d].every((b, i) =&gt; buffer[i] === b)) {</span><span class="s3">\n    </span><span class="s1">return PDF</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\n      </span><span class="s1">0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a,</span><span class="s3">\n    </span><span class="s1">].every((b, i) =&gt; buffer[i] === b)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return JP2</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let format:</span><span class="s3">\n    </span><span class="s1">| import('sharp').Metadata['format']</span><span class="s3">\n    </span><span class="s1">| ReturnType&lt;typeof detector&gt;</span><span class="s3">\n    </span><span class="s1">| undefined</span><span class="s3">\n  </span><span class="s1">format = detector(buffer)</span><span class="s3">\n\n  </span><span class="s1">if (!format &amp;&amp; !skipMetadata) {</span><span class="s3">\n    </span><span class="s1">const sharp = getSharp(concurrency)</span><span class="s3">\n    </span><span class="s1">const meta = await sharp(buffer)</span><span class="s3">\n      </span><span class="s1">.metadata()</span><span class="s3">\n      </span><span class="s1">.catch((_) =&gt; null)</span><span class="s3">\n    </span><span class="s1">format = meta?.format</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">switch (format) {</span><span class="s3">\n    </span><span class="s1">case 'avif':</span><span class="s3">\n      </span><span class="s1">return AVIF</span><span class="s3">\n    </span><span class="s1">case 'webp':</span><span class="s3">\n      </span><span class="s1">return WEBP</span><span class="s3">\n    </span><span class="s1">case 'png':</span><span class="s3">\n      </span><span class="s1">return PNG</span><span class="s3">\n    </span><span class="s1">case 'jpeg':</span><span class="s3">\n    </span><span class="s1">case 'jpg':</span><span class="s3">\n      </span><span class="s1">return JPEG</span><span class="s3">\n    </span><span class="s1">case 'gif':</span><span class="s3">\n      </span><span class="s1">return GIF</span><span class="s3">\n    </span><span class="s1">case 'svg':</span><span class="s3">\n      </span><span class="s1">return SVG</span><span class="s3">\n    </span><span class="s1">case 'jxl':</span><span class="s3">\n    </span><span class="s1">case 'jxl-stream':</span><span class="s3">\n      </span><span class="s1">return JXL</span><span class="s3">\n    </span><span class="s1">case 'jp2':</span><span class="s3">\n      </span><span class="s1">return JP2</span><span class="s3">\n    </span><span class="s1">case 'tiff':</span><span class="s3">\n    </span><span class="s1">case 'tif':</span><span class="s3">\n      </span><span class="s1">return TIFF</span><span class="s3">\n    </span><span class="s1">case 'pdf':</span><span class="s3">\n      </span><span class="s1">return PDF</span><span class="s3">\n    </span><span class="s1">case 'bmp':</span><span class="s3">\n      </span><span class="s1">return BMP</span><span class="s3">\n    </span><span class="s1">case 'ico':</span><span class="s3">\n      </span><span class="s1">return ICO</span><span class="s3">\n    </span><span class="s1">case 'icns':</span><span class="s3">\n      </span><span class="s1">return ICNS</span><span class="s3">\n    </span><span class="s1">case 'dcraw':</span><span class="s3">\n    </span><span class="s1">case 'dz':</span><span class="s3">\n    </span><span class="s1">case 'exr':</span><span class="s3">\n    </span><span class="s1">case 'fits':</span><span class="s3">\n    </span><span class="s1">case 'heif':</span><span class="s3">\n    </span><span class="s1">case 'input':</span><span class="s3">\n    </span><span class="s1">case 'magick':</span><span class="s3">\n    </span><span class="s1">case 'openslide':</span><span class="s3">\n    </span><span class="s1">case 'ppm':</span><span class="s3">\n    </span><span class="s1">case 'rad':</span><span class="s3">\n    </span><span class="s1">case 'raw':</span><span class="s3">\n    </span><span class="s1">case 'v':</span><span class="s3">\n    </span><span class="s1">case 'cur':</span><span class="s3">\n    </span><span class="s1">case 'dds':</span><span class="s3">\n    </span><span class="s1">case 'j2c':</span><span class="s3">\n    </span><span class="s1">case 'ktx':</span><span class="s3">\n    </span><span class="s1">case 'pnm':</span><span class="s3">\n    </span><span class="s1">case 'psd':</span><span class="s3">\n    </span><span class="s1">case 'tga':</span><span class="s3">\n    </span><span class="s1">case undefined:</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class ImageOptimizerCache {</span><span class="s3">\n  </span><span class="s1">private cacheDir: string</span><span class="s3">\n  </span><span class="s1">private nextConfig: NextConfigComplete</span><span class="s3">\n\n  </span><span class="s1">static validateParams(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n    </span><span class="s1">query: UrlWithParsedQuery['query'],</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete,</span><span class="s3">\n    </span><span class="s1">isDev: boolean</span><span class="s3">\n  </span><span class="s1">): ImageParamsResult | { errorMessage: string } {</span><span class="s3">\n    </span><span class="s1">const imageData = nextConfig.images</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">deviceSizes = [],</span><span class="s3">\n      </span><span class="s1">imageSizes = [],</span><span class="s3">\n      </span><span class="s1">domains = [],</span><span class="s3">\n      </span><span class="s1">minimumCacheTTL = 60,</span><span class="s3">\n      </span><span class="s1">formats = ['image/webp'],</span><span class="s3">\n    </span><span class="s1">} = imageData</span><span class="s3">\n    </span><span class="s1">const remotePatterns = nextConfig.images?.remotePatterns || []</span><span class="s3">\n    </span><span class="s1">const localPatterns = nextConfig.images?.localPatterns</span><span class="s3">\n    </span><span class="s1">const qualities = nextConfig.images?.qualities</span><span class="s3">\n    </span><span class="s1">const { url, w, q } = query</span><span class="s3">\n    </span><span class="s1">let href: string</span><span class="s3">\n\n    </span><span class="s1">if (domains.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">Log.warnOnce(</span><span class="s3">\n        </span><span class="s1">'The </span><span class="s3">\&quot;</span><span class="s1">images.domains</span><span class="s3">\&quot; </span><span class="s1">configuration is deprecated. Please use </span><span class="s3">\&quot;</span><span class="s1">images.remotePatterns</span><span class="s3">\&quot; </span><span class="s1">configuration instead.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!url) {</span><span class="s3">\n      </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is required' }</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(url)) {</span><span class="s3">\n      </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter cannot be an array' }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (url.length &gt; 3072) {</span><span class="s3">\n      </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is too long' }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (url.startsWith('//')) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter cannot be a protocol-relative URL (//)',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let isAbsolute: boolean</span><span class="s3">\n\n    </span><span class="s1">if (url.startsWith('/')) {</span><span class="s3">\n      </span><span class="s1">href = url</span><span class="s3">\n      </span><span class="s1">isAbsolute = false</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">/image($|</span><span class="s3">\\</span><span class="s1">/)/.test(</span><span class="s3">\n          </span><span class="s1">decodeURIComponent(parseUrl(url)?.pathname ?? '')</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter cannot be recursive',</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!hasLocalMatch(localPatterns, url)) {</span><span class="s3">\n        </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is not allowed' }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">let hrefParsed: URL</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">hrefParsed = new URL(url)</span><span class="s3">\n        </span><span class="s1">href = hrefParsed.toString()</span><span class="s3">\n        </span><span class="s1">isAbsolute = true</span><span class="s3">\n      </span><span class="s1">} catch (_error) {</span><span class="s3">\n        </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is invalid' }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!['http:', 'https:'].includes(hrefParsed.protocol)) {</span><span class="s3">\n        </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is invalid' }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!hasRemoteMatch(domains, remotePatterns, hrefParsed)) {</span><span class="s3">\n        </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is not allowed' }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!w) {</span><span class="s3">\n      </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">w</span><span class="s3">\&quot; </span><span class="s1">parameter (width) is required' }</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(w)) {</span><span class="s3">\n      </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">w</span><span class="s3">\&quot; </span><span class="s1">parameter (width) cannot be an array' }</span><span class="s3">\n    </span><span class="s1">} else if (!/^[0-9]+$/.test(w)) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">w</span><span class="s3">\&quot; </span><span class="s1">parameter (width) must be an integer greater than 0',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!q) {</span><span class="s3">\n      </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">q</span><span class="s3">\&quot; </span><span class="s1">parameter (quality) is required' }</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(q)) {</span><span class="s3">\n      </span><span class="s1">return { errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">q</span><span class="s3">\&quot; </span><span class="s1">parameter (quality) cannot be an array' }</span><span class="s3">\n    </span><span class="s1">} else if (!/^[0-9]+$/.test(q)) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">errorMessage:</span><span class="s3">\n          </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">q</span><span class="s3">\&quot; </span><span class="s1">parameter (quality) must be an integer between 1 and 100',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const width = parseInt(w, 10)</span><span class="s3">\n\n    </span><span class="s1">if (width &lt;= 0 || isNaN(width)) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">errorMessage: '</span><span class="s3">\&quot;</span><span class="s1">w</span><span class="s3">\&quot; </span><span class="s1">parameter (width) must be an integer greater than 0',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const sizes = [...(deviceSizes || []), ...(imageSizes || [])]</span><span class="s3">\n\n    </span><span class="s1">if (isDev) {</span><span class="s3">\n      </span><span class="s1">sizes.push(BLUR_IMG_SIZE)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const isValidSize =</span><span class="s3">\n      </span><span class="s1">sizes.includes(width) || (isDev &amp;&amp; width &lt;= BLUR_IMG_SIZE)</span><span class="s3">\n\n    </span><span class="s1">if (!isValidSize) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">errorMessage: `</span><span class="s3">\&quot;</span><span class="s1">w</span><span class="s3">\&quot; </span><span class="s1">parameter (width) of ${width} is not allowed`,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const quality = parseInt(q, 10)</span><span class="s3">\n\n    </span><span class="s1">if (isNaN(quality) || quality &lt; 1 || quality &gt; 100) {</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">errorMessage:</span><span class="s3">\n          </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">q</span><span class="s3">\&quot; </span><span class="s1">parameter (quality) must be an integer between 1 and 100',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (qualities) {</span><span class="s3">\n      </span><span class="s1">if (isDev) {</span><span class="s3">\n        </span><span class="s1">qualities.push(BLUR_QUALITY)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!qualities.includes(quality)) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">errorMessage: `</span><span class="s3">\&quot;</span><span class="s1">q</span><span class="s3">\&quot; </span><span class="s1">parameter (quality) of ${q} is not allowed`,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const mimeType = getSupportedMimeType(formats || [], req.headers['accept'])</span><span class="s3">\n\n    </span><span class="s1">const isStatic = url.startsWith(</span><span class="s3">\n      </span><span class="s1">`${nextConfig.basePath || ''}/_next/static/media`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">href,</span><span class="s3">\n      </span><span class="s1">sizes,</span><span class="s3">\n      </span><span class="s1">isAbsolute,</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n      </span><span class="s1">width,</span><span class="s3">\n      </span><span class="s1">quality,</span><span class="s3">\n      </span><span class="s1">mimeType,</span><span class="s3">\n      </span><span class="s1">minimumCacheTTL,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static getCacheKey({</span><span class="s3">\n    </span><span class="s1">href,</span><span class="s3">\n    </span><span class="s1">width,</span><span class="s3">\n    </span><span class="s1">quality,</span><span class="s3">\n    </span><span class="s1">mimeType,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">href: string</span><span class="s3">\n    </span><span class="s1">width: number</span><span class="s3">\n    </span><span class="s1">quality: number</span><span class="s3">\n    </span><span class="s1">mimeType: string</span><span class="s3">\n  </span><span class="s1">}): string {</span><span class="s3">\n    </span><span class="s1">return getHash([CACHE_VERSION, href, width, quality, mimeType])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">distDir,</span><span class="s3">\n    </span><span class="s1">nextConfig,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">distDir: string</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">this.cacheDir = join(distDir, 'cache', 'images')</span><span class="s3">\n    </span><span class="s1">this.nextConfig = nextConfig</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async get(cacheKey: string): Promise&lt;IncrementalResponseCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const cacheDir = join(this.cacheDir, cacheKey)</span><span class="s3">\n      </span><span class="s1">const files = await promises.readdir(cacheDir)</span><span class="s3">\n      </span><span class="s1">const now = Date.now()</span><span class="s3">\n\n      </span><span class="s1">for (const file of files) {</span><span class="s3">\n        </span><span class="s1">const [maxAgeSt, expireAtSt, etag, upstreamEtag, extension] =</span><span class="s3">\n          </span><span class="s1">file.split('.', 5)</span><span class="s3">\n        </span><span class="s1">const buffer = await promises.readFile(join(cacheDir, file))</span><span class="s3">\n        </span><span class="s1">const expireAt = Number(expireAtSt)</span><span class="s3">\n        </span><span class="s1">const maxAge = Number(maxAgeSt)</span><span class="s3">\n\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">value: {</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.IMAGE,</span><span class="s3">\n            </span><span class="s1">etag,</span><span class="s3">\n            </span><span class="s1">buffer,</span><span class="s3">\n            </span><span class="s1">extension,</span><span class="s3">\n            </span><span class="s1">upstreamEtag,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">revalidateAfter:</span><span class="s3">\n            </span><span class="s1">Math.max(maxAge, this.nextConfig.images.minimumCacheTTL) * 1000 +</span><span class="s3">\n            </span><span class="s1">Date.now(),</span><span class="s3">\n          </span><span class="s1">cacheControl: { revalidate: maxAge, expire: undefined },</span><span class="s3">\n          </span><span class="s1">isStale: now &gt; expireAt,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (_) {</span><span class="s3">\n      </span><span class="s1">// failed to read from cache dir, treat as cache miss</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">value: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">cacheControl,</span><span class="s3">\n    </span><span class="s1">}: {</span><span class="s3">\n      </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!this.nextConfig.experimental.isrFlushToDisk) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (value?.kind !== CachedRouteKind.IMAGE) {</span><span class="s3">\n      </span><span class="s1">throw new Error('invariant attempted to set non-image to image-cache')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const revalidate = cacheControl?.revalidate</span><span class="s3">\n\n    </span><span class="s1">if (typeof revalidate !== 'number') {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError('revalidate must be a number for image-cache')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const expireAt =</span><span class="s3">\n      </span><span class="s1">Math.max(revalidate, this.nextConfig.images.minimumCacheTTL) * 1000 +</span><span class="s3">\n      </span><span class="s1">Date.now()</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">await writeToCacheDir(</span><span class="s3">\n        </span><span class="s1">join(this.cacheDir, cacheKey),</span><span class="s3">\n        </span><span class="s1">value.extension,</span><span class="s3">\n        </span><span class="s1">revalidate,</span><span class="s3">\n        </span><span class="s1">expireAt,</span><span class="s3">\n        </span><span class="s1">value.buffer,</span><span class="s3">\n        </span><span class="s1">value.etag,</span><span class="s3">\n        </span><span class="s1">value.upstreamEtag</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">Log.error(`Failed to write image to cache ${cacheKey}`, err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class ImageError extends Error {</span><span class="s3">\n  </span><span class="s1">statusCode: number</span><span class="s3">\n\n  </span><span class="s1">constructor(statusCode: number, message: string) {</span><span class="s3">\n    </span><span class="s1">super(message)</span><span class="s3">\n\n    </span><span class="s1">// ensure an error status is used &gt; 400</span><span class="s3">\n    </span><span class="s1">if (statusCode &gt;= 400) {</span><span class="s3">\n      </span><span class="s1">this.statusCode = statusCode</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.statusCode = 500</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseCacheControl(</span><span class="s3">\n  </span><span class="s1">str: string | null | undefined</span><span class="s3">\n</span><span class="s1">): Map&lt;string, string&gt; {</span><span class="s3">\n  </span><span class="s1">const map = new Map&lt;string, string&gt;()</span><span class="s3">\n  </span><span class="s1">if (!str) {</span><span class="s3">\n    </span><span class="s1">return map</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (let directive of str.split(',')) {</span><span class="s3">\n    </span><span class="s1">let [key, value] = directive.trim().split('=', 2)</span><span class="s3">\n    </span><span class="s1">key = key.toLowerCase()</span><span class="s3">\n    </span><span class="s1">if (value) {</span><span class="s3">\n      </span><span class="s1">value = value.toLowerCase()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">map.set(key, value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return map</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getMaxAge(str: string | null | undefined): number {</span><span class="s3">\n  </span><span class="s1">const map = parseCacheControl(str)</span><span class="s3">\n  </span><span class="s1">if (map) {</span><span class="s3">\n    </span><span class="s1">let age = map.get('s-maxage') || map.get('max-age') || ''</span><span class="s3">\n    </span><span class="s1">if (age.startsWith('</span><span class="s3">\&quot;</span><span class="s1">') &amp;&amp; age.endsWith('</span><span class="s3">\&quot;</span><span class="s1">')) {</span><span class="s3">\n      </span><span class="s1">age = age.slice(1, -1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const n = parseInt(age, 10)</span><span class="s3">\n    </span><span class="s1">if (!isNaN(n)) {</span><span class="s3">\n      </span><span class="s1">return n</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getPreviouslyCachedImageOrNull(</span><span class="s3">\n  </span><span class="s1">upstreamImage: ImageUpstream,</span><span class="s3">\n  </span><span class="s1">previousCacheEntry: IncrementalCacheEntry | null | undefined</span><span class="s3">\n</span><span class="s1">): CachedImageValue | null {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">previousCacheEntry?.value?.kind === 'IMAGE' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// Images that are SVGs, animated or failed the optimization previously end up using upstreamEtag as their etag as well,</span><span class="s3">\n    </span><span class="s1">// in these cases we want to trigger a new </span><span class="s3">\&quot;</span><span class="s1">optimization</span><span class="s3">\&quot; </span><span class="s1">attempt.</span><span class="s3">\n    </span><span class="s1">previousCacheEntry.value.upstreamEtag !== previousCacheEntry.value.etag &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// and the upstream etag is the same as the previous cache entry's</span><span class="s3">\n    </span><span class="s1">upstreamImage.etag === previousCacheEntry.value.upstreamEtag</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return previousCacheEntry.value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function optimizeImage({</span><span class="s3">\n  </span><span class="s1">buffer,</span><span class="s3">\n  </span><span class="s1">contentType,</span><span class="s3">\n  </span><span class="s1">quality,</span><span class="s3">\n  </span><span class="s1">width,</span><span class="s3">\n  </span><span class="s1">height,</span><span class="s3">\n  </span><span class="s1">concurrency,</span><span class="s3">\n  </span><span class="s1">limitInputPixels,</span><span class="s3">\n  </span><span class="s1">sequentialRead,</span><span class="s3">\n  </span><span class="s1">timeoutInSeconds,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">buffer: Buffer</span><span class="s3">\n  </span><span class="s1">contentType: string</span><span class="s3">\n  </span><span class="s1">quality: number</span><span class="s3">\n  </span><span class="s1">width: number</span><span class="s3">\n  </span><span class="s1">height?: number</span><span class="s3">\n  </span><span class="s1">concurrency?: number | null</span><span class="s3">\n  </span><span class="s1">limitInputPixels?: number</span><span class="s3">\n  </span><span class="s1">sequentialRead?: boolean | null</span><span class="s3">\n  </span><span class="s1">timeoutInSeconds?: number</span><span class="s3">\n</span><span class="s1">}): Promise&lt;Buffer&gt; {</span><span class="s3">\n  </span><span class="s1">const sharp = getSharp(concurrency)</span><span class="s3">\n  </span><span class="s1">const transformer = sharp(buffer, {</span><span class="s3">\n    </span><span class="s1">limitInputPixels,</span><span class="s3">\n    </span><span class="s1">sequentialRead: sequentialRead ?? undefined,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.timeout({</span><span class="s3">\n      </span><span class="s1">seconds: timeoutInSeconds ?? 7,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.rotate()</span><span class="s3">\n\n  </span><span class="s1">if (height) {</span><span class="s3">\n    </span><span class="s1">transformer.resize(width, height)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">transformer.resize(width, undefined, {</span><span class="s3">\n      </span><span class="s1">withoutEnlargement: true,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (contentType === AVIF) {</span><span class="s3">\n    </span><span class="s1">transformer.avif({</span><span class="s3">\n      </span><span class="s1">quality: Math.max(quality - 20, 1),</span><span class="s3">\n      </span><span class="s1">effort: 3,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} else if (contentType === WEBP) {</span><span class="s3">\n    </span><span class="s1">transformer.webp({ quality })</span><span class="s3">\n  </span><span class="s1">} else if (contentType === PNG) {</span><span class="s3">\n    </span><span class="s1">transformer.png({ quality })</span><span class="s3">\n  </span><span class="s1">} else if (contentType === JPEG) {</span><span class="s3">\n    </span><span class="s1">transformer.jpeg({ quality, mozjpeg: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const optimizedBuffer = await transformer.toBuffer()</span><span class="s3">\n\n  </span><span class="s1">return optimizedBuffer</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function fetchExternalImage(href: string): Promise&lt;ImageUpstream&gt; {</span><span class="s3">\n  </span><span class="s1">const res = await fetch(href, {</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal.timeout(7_000),</span><span class="s3">\n  </span><span class="s1">}).catch((err) =&gt; err as Error)</span><span class="s3">\n\n  </span><span class="s1">if (res instanceof Error) {</span><span class="s3">\n    </span><span class="s1">const err = res as Error</span><span class="s3">\n    </span><span class="s1">if (err.name === 'TimeoutError') {</span><span class="s3">\n      </span><span class="s1">Log.error('upstream image response timed out for', href)</span><span class="s3">\n      </span><span class="s1">throw new ImageError(</span><span class="s3">\n        </span><span class="s1">504,</span><span class="s3">\n        </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is valid but upstream response timed out'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!res.ok) {</span><span class="s3">\n    </span><span class="s1">Log.error('upstream image response failed for', href, res.status)</span><span class="s3">\n    </span><span class="s1">throw new ImageError(</span><span class="s3">\n      </span><span class="s1">res.status,</span><span class="s3">\n      </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is valid but upstream response is invalid'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const buffer = Buffer.from(await res.arrayBuffer())</span><span class="s3">\n  </span><span class="s1">const contentType = res.headers.get('Content-Type')</span><span class="s3">\n  </span><span class="s1">const cacheControl = res.headers.get('Cache-Control')</span><span class="s3">\n  </span><span class="s1">const etag = extractEtag(res.headers.get('ETag'), buffer)</span><span class="s3">\n  </span><span class="s1">return { buffer, contentType, cacheControl, etag }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function fetchInternalImage(</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">_req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">_res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">handleRequest: (</span><span class="s3">\n    </span><span class="s1">newReq: IncomingMessage,</span><span class="s3">\n    </span><span class="s1">newRes: ServerResponse,</span><span class="s3">\n    </span><span class="s1">newParsedUrl?: NextUrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;ImageUpstream&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const mocked = createRequestResponseMocks({</span><span class="s3">\n      </span><span class="s1">url: href,</span><span class="s3">\n      </span><span class="s1">method: _req.method || 'GET',</span><span class="s3">\n      </span><span class="s1">socket: _req.socket,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">await handleRequest(mocked.req, mocked.res, nodeUrl.parse(href, true))</span><span class="s3">\n    </span><span class="s1">await mocked.res.hasStreamed</span><span class="s3">\n\n    </span><span class="s1">if (!mocked.res.statusCode) {</span><span class="s3">\n      </span><span class="s1">Log.error('image response failed for', href, mocked.res.statusCode)</span><span class="s3">\n      </span><span class="s1">throw new ImageError(</span><span class="s3">\n        </span><span class="s1">mocked.res.statusCode,</span><span class="s3">\n        </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is valid but internal response is invalid'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const buffer = Buffer.concat(mocked.res.buffers)</span><span class="s3">\n    </span><span class="s1">const contentType = mocked.res.getHeader('Content-Type')</span><span class="s3">\n    </span><span class="s1">const cacheControl = mocked.res.getHeader('Cache-Control')</span><span class="s3">\n    </span><span class="s1">const etag = extractEtag(mocked.res.getHeader('ETag'), buffer)</span><span class="s3">\n\n    </span><span class="s1">return { buffer, contentType, cacheControl, etag }</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">Log.error('upstream image response failed for', href, err)</span><span class="s3">\n    </span><span class="s1">throw new ImageError(</span><span class="s3">\n      </span><span class="s1">500,</span><span class="s3">\n      </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is valid but upstream response is invalid'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function imageOptimizer(</span><span class="s3">\n  </span><span class="s1">imageUpstream: ImageUpstream,</span><span class="s3">\n  </span><span class="s1">paramsResult: Pick&lt;</span><span class="s3">\n    </span><span class="s1">ImageParamsResult,</span><span class="s3">\n    </span><span class="s1">'href' | 'width' | 'quality' | 'mimeType'</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">nextConfig: {</span><span class="s3">\n    </span><span class="s1">experimental: Pick&lt;</span><span class="s3">\n      </span><span class="s1">NextConfigComplete['experimental'],</span><span class="s3">\n      </span><span class="s1">| 'imgOptConcurrency'</span><span class="s3">\n      </span><span class="s1">| 'imgOptMaxInputPixels'</span><span class="s3">\n      </span><span class="s1">| 'imgOptSequentialRead'</span><span class="s3">\n      </span><span class="s1">| 'imgOptSkipMetadata'</span><span class="s3">\n      </span><span class="s1">| 'imgOptTimeoutInSeconds'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n    </span><span class="s1">images: Pick&lt;</span><span class="s3">\n      </span><span class="s1">NextConfigComplete['images'],</span><span class="s3">\n      </span><span class="s1">'dangerouslyAllowSVG' | 'minimumCacheTTL'</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">opts: {</span><span class="s3">\n    </span><span class="s1">isDev?: boolean</span><span class="s3">\n    </span><span class="s1">silent?: boolean</span><span class="s3">\n    </span><span class="s1">previousCacheEntry?: IncrementalResponseCacheEntry | null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">): Promise&lt;{</span><span class="s3">\n  </span><span class="s1">buffer: Buffer</span><span class="s3">\n  </span><span class="s1">contentType: string</span><span class="s3">\n  </span><span class="s1">maxAge: number</span><span class="s3">\n  </span><span class="s1">etag: string</span><span class="s3">\n  </span><span class="s1">upstreamEtag: string</span><span class="s3">\n  </span><span class="s1">error?: unknown</span><span class="s3">\n</span><span class="s1">}&gt; {</span><span class="s3">\n  </span><span class="s1">const { href, quality, width, mimeType } = paramsResult</span><span class="s3">\n  </span><span class="s1">const { buffer: upstreamBuffer, etag: upstreamEtag } = imageUpstream</span><span class="s3">\n  </span><span class="s1">const maxAge = Math.max(</span><span class="s3">\n    </span><span class="s1">nextConfig.images.minimumCacheTTL,</span><span class="s3">\n    </span><span class="s1">getMaxAge(imageUpstream.cacheControl)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const upstreamType = await detectContentType(</span><span class="s3">\n    </span><span class="s1">upstreamBuffer,</span><span class="s3">\n    </span><span class="s1">nextConfig.experimental.imgOptSkipMetadata,</span><span class="s3">\n    </span><span class="s1">nextConfig.experimental.imgOptConcurrency</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!upstreamType ||</span><span class="s3">\n    </span><span class="s1">!upstreamType.startsWith('image/') ||</span><span class="s3">\n    </span><span class="s1">upstreamType.includes(',')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!opts.silent) {</span><span class="s3">\n      </span><span class="s1">Log.error(</span><span class="s3">\n        \&quot;</span><span class="s1">The requested resource isn't a valid image for</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">href,</span><span class="s3">\n        </span><span class="s1">'received',</span><span class="s3">\n        </span><span class="s1">upstreamType</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new ImageError(400, </span><span class="s3">\&quot;</span><span class="s1">The requested resource isn't a valid image.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">upstreamType.startsWith('image/svg') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!nextConfig.images.dangerouslyAllowSVG</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!opts.silent) {</span><span class="s3">\n      </span><span class="s1">Log.error(</span><span class="s3">\n        </span><span class="s1">`The requested resource </span><span class="s3">\&quot;</span><span class="s1">${href}</span><span class="s3">\&quot; </span><span class="s1">has type </span><span class="s3">\&quot;</span><span class="s1">${upstreamType}</span><span class="s3">\&quot; </span><span class="s1">but dangerouslyAllowSVG is disabled. Consider adding the </span><span class="s3">\&quot;</span><span class="s1">unoptimized</span><span class="s3">\&quot; </span><span class="s1">property to the &lt;Image&gt;.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new ImageError(</span><span class="s3">\n      </span><span class="s1">400,</span><span class="s3">\n      </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">parameter is valid but image type is not allowed'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (ANIMATABLE_TYPES.includes(upstreamType) &amp;&amp; isAnimated(upstreamBuffer)) {</span><span class="s3">\n    </span><span class="s1">if (!opts.silent) {</span><span class="s3">\n      </span><span class="s1">Log.warnOnce(</span><span class="s3">\n        </span><span class="s1">`The requested resource </span><span class="s3">\&quot;</span><span class="s1">${href}</span><span class="s3">\&quot; </span><span class="s1">is an animated image so it will not be optimized. Consider adding the </span><span class="s3">\&quot;</span><span class="s1">unoptimized</span><span class="s3">\&quot; </span><span class="s1">property to the &lt;Image&gt;.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">buffer: upstreamBuffer,</span><span class="s3">\n      </span><span class="s1">contentType: upstreamType,</span><span class="s3">\n      </span><span class="s1">maxAge,</span><span class="s3">\n      </span><span class="s1">etag: upstreamEtag,</span><span class="s3">\n      </span><span class="s1">upstreamEtag,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (BYPASS_TYPES.includes(upstreamType)) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">buffer: upstreamBuffer,</span><span class="s3">\n      </span><span class="s1">contentType: upstreamType,</span><span class="s3">\n      </span><span class="s1">maxAge,</span><span class="s3">\n      </span><span class="s1">etag: upstreamEtag,</span><span class="s3">\n      </span><span class="s1">upstreamEtag,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let contentType: string</span><span class="s3">\n\n  </span><span class="s1">if (mimeType) {</span><span class="s3">\n    </span><span class="s1">contentType = mimeType</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">getExtension(upstreamType) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">upstreamType !== WEBP &amp;&amp;</span><span class="s3">\n    </span><span class="s1">upstreamType !== AVIF</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">contentType = upstreamType</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">contentType = JPEG</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const previouslyCachedImage = getPreviouslyCachedImageOrNull(</span><span class="s3">\n    </span><span class="s1">imageUpstream,</span><span class="s3">\n    </span><span class="s1">opts.previousCacheEntry</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (previouslyCachedImage) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">buffer: previouslyCachedImage.buffer,</span><span class="s3">\n      </span><span class="s1">contentType,</span><span class="s3">\n      </span><span class="s1">maxAge: opts?.previousCacheEntry?.cacheControl?.revalidate || maxAge,</span><span class="s3">\n      </span><span class="s1">etag: previouslyCachedImage.etag,</span><span class="s3">\n      </span><span class="s1">upstreamEtag: previouslyCachedImage.upstreamEtag,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">let optimizedBuffer = await optimizeImage({</span><span class="s3">\n      </span><span class="s1">buffer: upstreamBuffer,</span><span class="s3">\n      </span><span class="s1">contentType,</span><span class="s3">\n      </span><span class="s1">quality,</span><span class="s3">\n      </span><span class="s1">width,</span><span class="s3">\n      </span><span class="s1">concurrency: nextConfig.experimental.imgOptConcurrency,</span><span class="s3">\n      </span><span class="s1">limitInputPixels: nextConfig.experimental.imgOptMaxInputPixels,</span><span class="s3">\n      </span><span class="s1">sequentialRead: nextConfig.experimental.imgOptSequentialRead,</span><span class="s3">\n      </span><span class="s1">timeoutInSeconds: nextConfig.experimental.imgOptTimeoutInSeconds,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">if (opts.isDev &amp;&amp; width &lt;= BLUR_IMG_SIZE &amp;&amp; quality === BLUR_QUALITY) {</span><span class="s3">\n      </span><span class="s1">// During `next dev`, we don't want to generate blur placeholders with webpack</span><span class="s3">\n      </span><span class="s1">// because it can delay starting the dev server. Instead, `next-image-loader.js`</span><span class="s3">\n      </span><span class="s1">// will inline a special url to lazily generate the blur placeholder at request time.</span><span class="s3">\n      </span><span class="s1">const meta = await getImageSize(optimizedBuffer)</span><span class="s3">\n      </span><span class="s1">const blurOpts = {</span><span class="s3">\n        </span><span class="s1">blurWidth: meta.width,</span><span class="s3">\n        </span><span class="s1">blurHeight: meta.height,</span><span class="s3">\n        </span><span class="s1">blurDataURL: `data:${contentType};base64,${optimizedBuffer.toString(</span><span class="s3">\n          </span><span class="s1">'base64'</span><span class="s3">\n        </span><span class="s1">)}`,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">optimizedBuffer = Buffer.from(unescape(getImageBlurSvg(blurOpts)))</span><span class="s3">\n      </span><span class="s1">contentType = 'image/svg+xml'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">buffer: optimizedBuffer,</span><span class="s3">\n      </span><span class="s1">contentType,</span><span class="s3">\n      </span><span class="s1">maxAge,</span><span class="s3">\n      </span><span class="s1">etag: getImageEtag(optimizedBuffer),</span><span class="s3">\n      </span><span class="s1">upstreamEtag,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">if (upstreamType) {</span><span class="s3">\n      </span><span class="s1">// If we fail to optimize, fallback to the original image</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">buffer: upstreamBuffer,</span><span class="s3">\n        </span><span class="s1">contentType: upstreamType,</span><span class="s3">\n        </span><span class="s1">maxAge: nextConfig.images.minimumCacheTTL,</span><span class="s3">\n        </span><span class="s1">etag: upstreamEtag,</span><span class="s3">\n        </span><span class="s1">upstreamEtag,</span><span class="s3">\n        </span><span class="s1">error,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new ImageError(</span><span class="s3">\n        </span><span class="s1">400,</span><span class="s3">\n        </span><span class="s1">'Unable to optimize image and unable to fallback to upstream image'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getFileNameWithExtension(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">contentType: string | null</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const [urlWithoutQueryParams] = url.split('?', 1)</span><span class="s3">\n  </span><span class="s1">const fileNameWithExtension = urlWithoutQueryParams.split('/').pop()</span><span class="s3">\n  </span><span class="s1">if (!contentType || !fileNameWithExtension) {</span><span class="s3">\n    </span><span class="s1">return 'image.bin'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [fileName] = fileNameWithExtension.split('.', 1)</span><span class="s3">\n  </span><span class="s1">const extension = getExtension(contentType)</span><span class="s3">\n  </span><span class="s1">return `${fileName}.${extension}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function setResponseHeaders(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">etag: string,</span><span class="s3">\n  </span><span class="s1">contentType: string | null,</span><span class="s3">\n  </span><span class="s1">isStatic: boolean,</span><span class="s3">\n  </span><span class="s1">xCache: XCacheHeader,</span><span class="s3">\n  </span><span class="s1">imagesConfig: ImageConfigComplete,</span><span class="s3">\n  </span><span class="s1">maxAge: number,</span><span class="s3">\n  </span><span class="s1">isDev: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">res.setHeader('Vary', 'Accept')</span><span class="s3">\n  </span><span class="s1">res.setHeader(</span><span class="s3">\n    </span><span class="s1">'Cache-Control',</span><span class="s3">\n    </span><span class="s1">isStatic</span><span class="s3">\n      </span><span class="s1">? 'public, max-age=315360000, immutable'</span><span class="s3">\n      </span><span class="s1">: `public, max-age=${isDev ? 0 : maxAge}, must-revalidate`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (sendEtagResponse(req, res, etag)) {</span><span class="s3">\n    </span><span class="s1">// already called res.end() so we're finished</span><span class="s3">\n    </span><span class="s1">return { finished: true }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (contentType) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Content-Type', contentType)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const fileName = getFileNameWithExtension(url, contentType)</span><span class="s3">\n  </span><span class="s1">res.setHeader(</span><span class="s3">\n    </span><span class="s1">'Content-Disposition',</span><span class="s3">\n    </span><span class="s1">contentDisposition(fileName, { type: imagesConfig.contentDispositionType })</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">res.setHeader('Content-Security-Policy', imagesConfig.contentSecurityPolicy)</span><span class="s3">\n  </span><span class="s1">res.setHeader('X-Nextjs-Cache', xCache)</span><span class="s3">\n\n  </span><span class="s1">return { finished: false }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function sendResponse(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">extension: string,</span><span class="s3">\n  </span><span class="s1">buffer: Buffer,</span><span class="s3">\n  </span><span class="s1">etag: string,</span><span class="s3">\n  </span><span class="s1">isStatic: boolean,</span><span class="s3">\n  </span><span class="s1">xCache: XCacheHeader,</span><span class="s3">\n  </span><span class="s1">imagesConfig: ImageConfigComplete,</span><span class="s3">\n  </span><span class="s1">maxAge: number,</span><span class="s3">\n  </span><span class="s1">isDev: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const contentType = getContentType(extension)</span><span class="s3">\n  </span><span class="s1">const result = setResponseHeaders(</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">etag,</span><span class="s3">\n    </span><span class="s1">contentType,</span><span class="s3">\n    </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">xCache,</span><span class="s3">\n    </span><span class="s1">imagesConfig,</span><span class="s3">\n    </span><span class="s1">maxAge,</span><span class="s3">\n    </span><span class="s1">isDev</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (!result.finished) {</span><span class="s3">\n    </span><span class="s1">res.setHeader('Content-Length', Buffer.byteLength(buffer))</span><span class="s3">\n    </span><span class="s1">res.end(buffer)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function getImageSize(buffer: Buffer): Promise&lt;{</span><span class="s3">\n  </span><span class="s1">width?: number</span><span class="s3">\n  </span><span class="s1">height?: number</span><span class="s3">\n</span><span class="s1">}&gt; {</span><span class="s3">\n  </span><span class="s1">const { width, height } = imageSizeOf(buffer)</span><span class="s3">\n  </span><span class="s1">return { width, height }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ImageError&quot;</span><span class="s0">,</span><span class="s1">&quot;ImageOptimizerCache&quot;</span><span class="s0">,</span><span class="s1">&quot;detectContentType&quot;</span><span class="s0">,</span><span class="s1">&quot;extractEtag&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchExternalImage&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchInternalImage&quot;</span><span class="s0">,</span><span class="s1">&quot;getHash&quot;</span><span class="s0">,</span><span class="s1">&quot;getImageEtag&quot;</span><span class="s0">,</span><span class="s1">&quot;getImageSize&quot;</span><span class="s0">,</span><span class="s1">&quot;getMaxAge&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreviouslyCachedImageOrNull&quot;</span><span class="s0">,</span><span class="s1">&quot;getSharp&quot;</span><span class="s0">,</span><span class="s1">&quot;imageOptimizer&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizeImage&quot;</span><span class="s0">,</span><span class="s1">&quot;sendResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;AVIF&quot;</span><span class="s0">,</span><span class="s1">&quot;WEBP&quot;</span><span class="s0">,</span><span class="s1">&quot;PNG&quot;</span><span class="s0">,</span><span class="s1">&quot;JPEG&quot;</span><span class="s0">,</span><span class="s1">&quot;JXL&quot;</span><span class="s0">,</span><span class="s1">&quot;JP2&quot;</span><span class="s0">,</span><span class="s1">&quot;HEIC&quot;</span><span class="s0">,</span><span class="s1">&quot;GIF&quot;</span><span class="s0">,</span><span class="s1">&quot;SVG&quot;</span><span class="s0">,</span><span class="s1">&quot;ICO&quot;</span><span class="s0">,</span><span class="s1">&quot;ICNS&quot;</span><span class="s0">,</span><span class="s1">&quot;TIFF&quot;</span><span class="s0">,</span><span class="s1">&quot;BMP&quot;</span><span class="s0">,</span><span class="s1">&quot;PDF&quot;</span><span class="s0">,</span><span class="s1">&quot;CACHE_VERSION&quot;</span><span class="s0">,</span><span class="s1">&quot;ANIMATABLE_TYPES&quot;</span><span class="s0">,</span><span class="s1">&quot;BYPASS_TYPES&quot;</span><span class="s0">,</span><span class="s1">&quot;BLUR_IMG_SIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;BLUR_QUALITY&quot;</span><span class="s0">,</span><span class="s1">&quot;_sharp&quot;</span><span class="s0">,</span><span class="s1">&quot;concurrency&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;divisor&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;getSupportedMimeType&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;accept&quot;</span><span class="s0">,</span><span class="s1">&quot;mimeType&quot;</span><span class="s0">,</span><span class="s1">&quot;mediaType&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;items&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;createHash&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;etag&quot;</span><span class="s0">,</span><span class="s1">&quot;imageBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;image&quot;</span><span class="s0">,</span><span class="s1">&quot;writeToCacheDir&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;extension&quot;</span><span class="s0">,</span><span class="s1">&quot;maxAge&quot;</span><span class="s0">,</span><span class="s1">&quot;expireAt&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;upstreamEtag&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;rm&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;force&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;writeFile&quot;</span><span class="s0">,</span><span class="s1">&quot;skipMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;byteLength&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;detector&quot;</span><span class="s0">,</span><span class="s1">&quot;sharp&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;validateParams&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;isDev&quot;</span><span class="s0">,</span><span class="s1">&quot;imageData&quot;</span><span class="s0">,</span><span class="s1">&quot;images&quot;</span><span class="s0">,</span><span class="s1">&quot;deviceSizes&quot;</span><span class="s0">,</span><span class="s1">&quot;imageSizes&quot;</span><span class="s0">,</span><span class="s1">&quot;domains&quot;</span><span class="s0">,</span><span class="s1">&quot;minimumCacheTTL&quot;</span><span class="s0">,</span><span class="s1">&quot;formats&quot;</span><span class="s0">,</span><span class="s1">&quot;remotePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;localPatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;qualities&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;w&quot;</span><span class="s0">,</span><span class="s1">&quot;q&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;Log&quot;</span><span class="s0">,</span><span class="s1">&quot;warnOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;errorMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbsolute&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLocalMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;hrefParsed&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;_error&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;hasRemoteMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;width&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;sizes&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidSize&quot;</span><span class="s0">,</span><span class="s1">&quot;quality&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheDir&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;files&quot;</span><span class="s0">,</span><span class="s1">&quot;readdir&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;maxAgeSt&quot;</span><span class="s0">,</span><span class="s1">&quot;expireAtSt&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedRouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;IMAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;isStale&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;isrFlushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;parseCacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;age&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;upstreamImage&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;height&quot;</span><span class="s0">,</span><span class="s1">&quot;limitInputPixels&quot;</span><span class="s0">,</span><span class="s1">&quot;sequentialRead&quot;</span><span class="s0">,</span><span class="s1">&quot;timeoutInSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;transformer&quot;</span><span class="s0">,</span><span class="s1">&quot;timeout&quot;</span><span class="s0">,</span><span class="s1">&quot;seconds&quot;</span><span class="s0">,</span><span class="s1">&quot;rotate&quot;</span><span class="s0">,</span><span class="s1">&quot;resize&quot;</span><span class="s0">,</span><span class="s1">&quot;withoutEnlargement&quot;</span><span class="s0">,</span><span class="s1">&quot;avif&quot;</span><span class="s0">,</span><span class="s1">&quot;effort&quot;</span><span class="s0">,</span><span class="s1">&quot;webp&quot;</span><span class="s0">,</span><span class="s1">&quot;png&quot;</span><span class="s0">,</span><span class="s1">&quot;jpeg&quot;</span><span class="s0">,</span><span class="s1">&quot;mozjpeg&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizedBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;toBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;_req&quot;</span><span class="s0">,</span><span class="s1">&quot;_res&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;mocked&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequestResponseMocks&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;socket&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStreamed&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;buffers&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;imageUpstream&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;upstreamBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;upstreamType&quot;</span><span class="s0">,</span><span class="s1">&quot;imgOptSkipMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;imgOptConcurrency&quot;</span><span class="s0">,</span><span class="s1">&quot;silent&quot;</span><span class="s0">,</span><span class="s1">&quot;dangerouslyAllowSVG&quot;</span><span class="s0">,</span><span class="s1">&quot;isAnimated&quot;</span><span class="s0">,</span><span class="s1">&quot;getExtension&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyCachedImage&quot;</span><span class="s0">,</span><span class="s1">&quot;imgOptMaxInputPixels&quot;</span><span class="s0">,</span><span class="s1">&quot;imgOptSequentialRead&quot;</span><span class="s0">,</span><span class="s1">&quot;imgOptTimeoutInSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;blurOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;blurWidth&quot;</span><span class="s0">,</span><span class="s1">&quot;blurHeight&quot;</span><span class="s0">,</span><span class="s1">&quot;blurDataURL&quot;</span><span class="s0">,</span><span class="s1">&quot;unescape&quot;</span><span class="s0">,</span><span class="s1">&quot;getImageBlurSvg&quot;</span><span class="s0">,</span><span class="s1">&quot;getFileNameWithExtension&quot;</span><span class="s0">,</span><span class="s1">&quot;urlWithoutQueryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fileNameWithExtension&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;fileName&quot;</span><span class="s0">,</span><span class="s1">&quot;setResponseHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;xCache&quot;</span><span class="s0">,</span><span class="s1">&quot;imagesConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;sendEtagResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;contentDisposition&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;contentDispositionType&quot;</span><span class="s0">,</span><span class="s1">&quot;contentSecurityPolicy&quot;</span><span class="s0">,</span><span class="s1">&quot;getContentType&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;imageSizeOf&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>