<html>
<head>
<title>[root-of-the-server]__974941ed._.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
[root-of-the-server]__974941ed._.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span>
  <span class="s1">&quot;version&quot;</span><span class="s0">: </span><span class="s2">3</span><span class="s0">,</span>
  <span class="s1">&quot;sources&quot;</span><span class="s0">: [],</span>
  <span class="s1">&quot;sections&quot;</span><span class="s0">: [</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack-node]/globals.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// @ts-ignore</span><span class="s3">\n</span><span class="s1">process.turbopack = {}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,aAAa;AACb,QAAQ,SAAS,GAAG,CAAC&quot;</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">21</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack-node]/compiled/stacktrace-parser/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;if (typeof __nccwpck_require__ !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">__nccwpck_require__.ab = __dirname + </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">var n = </span><span class="s3">\&quot;</span><span class="s1">&lt;unknown&gt;</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function parse(e) {</span><span class="s3">\n  </span><span class="s1">var r = e.split(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return r.reduce(function (e, r) {</span><span class="s3">\n    </span><span class="s1">var n =</span><span class="s3">\n      </span><span class="s1">parseChrome(r) ||</span><span class="s3">\n      </span><span class="s1">parseWinjs(r) ||</span><span class="s3">\n      </span><span class="s1">parseGecko(r) ||</span><span class="s3">\n      </span><span class="s1">parseNode(r) ||</span><span class="s3">\n      </span><span class="s1">parseJSC(r);</span><span class="s3">\n    </span><span class="s1">if (n) {</span><span class="s3">\n      </span><span class="s1">e.push(n);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return e;</span><span class="s3">\n  </span><span class="s1">}, []);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var a =</span><span class="s3">\n  </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">s*at (.*?) ?</span><span class="s3">\\</span><span class="s1">(((?:file|https?|blob|chrome-extension|native|eval|webpack|&lt;anonymous&gt;|</span><span class="s3">\\</span><span class="s1">/|[a-z]:</span><span class="s3">\\\\</span><span class="s1">|</span><span class="s3">\\\\\\\\</span><span class="s1">).*?)(?::(</span><span class="s3">\\</span><span class="s1">d+))?(?::(</span><span class="s3">\\</span><span class="s1">d+))?</span><span class="s3">\\</span><span class="s1">)?</span><span class="s3">\\</span><span class="s1">s*$/i;</span><span class="s3">\n</span><span class="s1">var l = /</span><span class="s3">\\</span><span class="s1">((</span><span class="s3">\\</span><span class="s1">S*)(?::(</span><span class="s3">\\</span><span class="s1">d+))(?::(</span><span class="s3">\\</span><span class="s1">d+))</span><span class="s3">\\</span><span class="s1">)/;</span><span class="s3">\n</span><span class="s1">function parseChrome(e) {</span><span class="s3">\n  </span><span class="s1">var r = a.exec(e);</span><span class="s3">\n  </span><span class="s1">if (!r) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var u = r[2] &amp;&amp; r[2].indexOf(</span><span class="s3">\&quot;</span><span class="s1">native</span><span class="s3">\&quot;</span><span class="s1">) === 0;</span><span class="s3">\n  </span><span class="s1">var t = r[2] &amp;&amp; r[2].indexOf(</span><span class="s3">\&quot;</span><span class="s1">eval</span><span class="s3">\&quot;</span><span class="s1">) === 0;</span><span class="s3">\n  </span><span class="s1">var i = l.exec(r[2]);</span><span class="s3">\n  </span><span class="s1">if (t &amp;&amp; i != null) {</span><span class="s3">\n    </span><span class="s1">r[2] = i[1];</span><span class="s3">\n    </span><span class="s1">r[3] = i[2];</span><span class="s3">\n    </span><span class="s1">r[4] = i[3];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">file: !u ? r[2] : null,</span><span class="s3">\n    </span><span class="s1">methodName: r[1] || n,</span><span class="s3">\n    </span><span class="s1">arguments: u ? [r[2]] : [],</span><span class="s3">\n    </span><span class="s1">lineNumber: r[3] ? +r[3] : null,</span><span class="s3">\n    </span><span class="s1">column: r[4] ? +r[4] : null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var u =</span><span class="s3">\n  </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">s*at (?:((?:</span><span class="s3">\\</span><span class="s1">[object object</span><span class="s3">\\</span><span class="s1">])?.+) )?</span><span class="s3">\\</span><span class="s1">(?((?:file|ms-appx|https?|webpack|blob):.*?):(</span><span class="s3">\\</span><span class="s1">d+)(?::(</span><span class="s3">\\</span><span class="s1">d+))?</span><span class="s3">\\</span><span class="s1">)?</span><span class="s3">\\</span><span class="s1">s*$/i;</span><span class="s3">\n</span><span class="s1">function parseWinjs(e) {</span><span class="s3">\n  </span><span class="s1">var r = u.exec(e);</span><span class="s3">\n  </span><span class="s1">if (!r) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">file: r[2],</span><span class="s3">\n    </span><span class="s1">methodName: r[1] || n,</span><span class="s3">\n    </span><span class="s1">arguments: [],</span><span class="s3">\n    </span><span class="s1">lineNumber: +r[3],</span><span class="s3">\n    </span><span class="s1">column: r[4] ? +r[4] : null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var t =</span><span class="s3">\n  </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">s*(.*?)(?:</span><span class="s3">\\</span><span class="s1">((.*?)</span><span class="s3">\\</span><span class="s1">))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|</span><span class="s3">\\</span><span class="s1">[native).*?|[^@]*bundle)(?::(</span><span class="s3">\\</span><span class="s1">d+))?(?::(</span><span class="s3">\\</span><span class="s1">d+))?</span><span class="s3">\\</span><span class="s1">s*$/i;</span><span class="s3">\n</span><span class="s1">var i = /(</span><span class="s3">\\</span><span class="s1">S+) line (</span><span class="s3">\\</span><span class="s1">d+)(?: &gt; eval line </span><span class="s3">\\</span><span class="s1">d+)* &gt; eval/i;</span><span class="s3">\n</span><span class="s1">function parseGecko(e) {</span><span class="s3">\n  </span><span class="s1">var r = t.exec(e);</span><span class="s3">\n  </span><span class="s1">if (!r) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var a = r[3] &amp;&amp; r[3].indexOf(</span><span class="s3">\&quot; </span><span class="s1">&gt; eval</span><span class="s3">\&quot;</span><span class="s1">) &gt; -1;</span><span class="s3">\n  </span><span class="s1">var l = i.exec(r[3]);</span><span class="s3">\n  </span><span class="s1">if (a &amp;&amp; l != null) {</span><span class="s3">\n    </span><span class="s1">r[3] = l[1];</span><span class="s3">\n    </span><span class="s1">r[4] = l[2];</span><span class="s3">\n    </span><span class="s1">r[5] = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">file: r[3],</span><span class="s3">\n    </span><span class="s1">methodName: r[1] || n,</span><span class="s3">\n    </span><span class="s1">arguments: r[2] ? r[2].split(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) : [],</span><span class="s3">\n    </span><span class="s1">lineNumber: r[4] ? +r[4] : null,</span><span class="s3">\n    </span><span class="s1">column: r[5] ? +r[5] : null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var s = /^</span><span class="s3">\\</span><span class="s1">s*(?:([^@]*)(?:</span><span class="s3">\\</span><span class="s1">((.*?)</span><span class="s3">\\</span><span class="s1">))?@)?(</span><span class="s3">\\</span><span class="s1">S.*?):(</span><span class="s3">\\</span><span class="s1">d+)(?::(</span><span class="s3">\\</span><span class="s1">d+))?</span><span class="s3">\\</span><span class="s1">s*$/i;</span><span class="s3">\n</span><span class="s1">function parseJSC(e) {</span><span class="s3">\n  </span><span class="s1">var r = s.exec(e);</span><span class="s3">\n  </span><span class="s1">if (!r) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">file: r[3],</span><span class="s3">\n    </span><span class="s1">methodName: r[1] || n,</span><span class="s3">\n    </span><span class="s1">arguments: [],</span><span class="s3">\n    </span><span class="s1">lineNumber: +r[4],</span><span class="s3">\n    </span><span class="s1">column: r[5] ? +r[5] : null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var o =</span><span class="s3">\n  </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">s*at (?:((?:</span><span class="s3">\\</span><span class="s1">[object object</span><span class="s3">\\</span><span class="s1">])?[^</span><span class="s3">\\\\</span><span class="s1">/]+(?: </span><span class="s3">\\</span><span class="s1">[as </span><span class="s3">\\</span><span class="s1">S+</span><span class="s3">\\</span><span class="s1">])?) )?</span><span class="s3">\\</span><span class="s1">(?(.*?):(</span><span class="s3">\\</span><span class="s1">d+)(?::(</span><span class="s3">\\</span><span class="s1">d+))?</span><span class="s3">\\</span><span class="s1">)?</span><span class="s3">\\</span><span class="s1">s*$/i;</span><span class="s3">\n</span><span class="s1">function parseNode(e) {</span><span class="s3">\n  </span><span class="s1">var r = o.exec(e);</span><span class="s3">\n  </span><span class="s1">if (!r) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">file: r[2],</span><span class="s3">\n    </span><span class="s1">methodName: r[1] || n,</span><span class="s3">\n    </span><span class="s1">arguments: [],</span><span class="s3">\n    </span><span class="s1">lineNumber: +r[3],</span><span class="s3">\n    </span><span class="s1">column: r[4] ? +r[4] : null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">130</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack-node]/ipc/error.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// merged from next.js</span><span class="s3">\n</span><span class="s1">// https://github.com/vercel/next.js/blob/e657741b9908cf0044aaef959c0c4defb19ed6d8/packages/next/src/lib/is-error.ts</span><span class="s3">\n</span><span class="s1">// https://github.com/vercel/next.js/blob/e657741b9908cf0044aaef959c0c4defb19ed6d8/packages/next/src/shared/lib/is-plain-object.ts</span><span class="s3">\n\n</span><span class="s1">export default function isError(err: unknown): err is Error {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof err === 'object' &amp;&amp; err !== null &amp;&amp; 'name' in err &amp;&amp; 'message' in err</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getProperError(err: unknown): Error {</span><span class="s3">\n  </span><span class="s1">if (isError(err)) {</span><span class="s3">\n    </span><span class="s1">return err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">// Provide a better error message for cases where `throw undefined`</span><span class="s3">\n    </span><span class="s1">// is called in development</span><span class="s3">\n    </span><span class="s1">if (typeof err === 'undefined') {</span><span class="s3">\n      </span><span class="s1">return new Error('`undefined` was thrown instead of a real error')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (err === null) {</span><span class="s3">\n      </span><span class="s1">return new Error('`null` was thrown instead of a real error')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new Error(isPlainObject(err) ? JSON.stringify(err) : err + '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getObjectClassLabel(value: any): string {</span><span class="s3">\n  </span><span class="s1">return Object.prototype.toString.call(value)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isPlainObject(value: any): boolean {</span><span class="s3">\n  </span><span class="s1">if (getObjectClassLabel(value) !== '[object Object]') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const prototype = Object.getPrototypeOf(value)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* this used to be previously:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* `return prototype === null || prototype === Object.prototype`</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* It was changed to the current implementation since it's resilient to serialization.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">return prototype === null || prototype.hasOwnProperty('isPrototypeOf')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,sBAAsB;AACtB,oHAAoH;AACpH,kIAAkI;;;;;;;AAEnH,SAAS,QAAQ,GAAY;IAC1C,OACE,OAAO,QAAQ,YAAY,QAAQ,QAAQ,UAAU,OAAO,aAAa;AAE7E;AAEO,SAAS,eAAe,GAAY;IACzC,IAAI,QAAQ,MAAM;QAChB,OAAO;IACT;IAEA,wCAA4C;QAC1C,mEAAmE;QACnE,2BAA2B;QAC3B,IAAI,OAAO,QAAQ,aAAa;YAC9B,OAAO,IAAI,MAAM;QACnB;QAEA,IAAI,QAAQ,MAAM;YAChB,OAAO,IAAI,MAAM;QACnB;IACF;IAEA,OAAO,IAAI,MAAM,cAAc,OAAO,KAAK,SAAS,CAAC,OAAO,MAAM;AACpE;AAEA,SAAS,oBAAoB,KAAU;IACrC,OAAO,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC;AACxC;AAEA,SAAS,cAAc,KAAU;IAC/B,IAAI,oBAAoB,WAAW,mBAAmB;QACpD,OAAO;IACT;IAEA,MAAM,YAAY,OAAO,cAAc,CAAC;IAExC;;;;;;;;GAQC,GACD,OAAO,cAAc,QAAQ,UAAU,cAAc,CAAC;AACxD&quot;</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">180</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack-node]/ipc/index.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { createConnection } from 'node:net'</span><span class="s3">\n</span><span class="s1">import { Writable } from 'node:stream'</span><span class="s3">\n</span><span class="s1">import type { StackFrame } from '../compiled/stacktrace-parser'</span><span class="s3">\n</span><span class="s1">import { parse as parseStackTrace } from '../compiled/stacktrace-parser'</span><span class="s3">\n</span><span class="s1">import { getProperError } from './error'</span><span class="s3">\n\n</span><span class="s1">export type StructuredError = {</span><span class="s3">\n  </span><span class="s1">name: string</span><span class="s3">\n  </span><span class="s1">message: string</span><span class="s3">\n  </span><span class="s1">stack: StackFrame[]</span><span class="s3">\n  </span><span class="s1">cause: StructuredError | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function structuredError(e: unknown): StructuredError {</span><span class="s3">\n  </span><span class="s1">e = getProperError(e)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: e.name,</span><span class="s3">\n    </span><span class="s1">message: e.message,</span><span class="s3">\n    </span><span class="s1">stack: typeof e.stack === 'string' ? parseStackTrace(e.stack) : [],</span><span class="s3">\n    </span><span class="s1">cause: e.cause ? structuredError(getProperError(e.cause)) : undefined,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type State =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'waiting'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'packet'</span><span class="s3">\n      </span><span class="s1">length: number</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type Ipc&lt;TIncoming, TOutgoing&gt; = {</span><span class="s3">\n  </span><span class="s1">recv(): Promise&lt;TIncoming&gt;</span><span class="s3">\n  </span><span class="s1">send(message: TOutgoing): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">sendError(error: Error | string): Promise&lt;never&gt;</span><span class="s3">\n  </span><span class="s1">sendReady(): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createIpc&lt;TIncoming, TOutgoing&gt;(</span><span class="s3">\n  </span><span class="s1">port: number</span><span class="s3">\n</span><span class="s1">): Ipc&lt;TIncoming, TOutgoing&gt; {</span><span class="s3">\n  </span><span class="s1">const socket = createConnection({</span><span class="s3">\n    </span><span class="s1">port,</span><span class="s3">\n    </span><span class="s1">host: '127.0.0.1',</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A writable stream that writes to the socket.</span><span class="s3">\n   </span><span class="s1">* We don't write directly to the socket because we need to</span><span class="s3">\n   </span><span class="s1">* handle backpressure and wait for the socket to be drained</span><span class="s3">\n   </span><span class="s1">* before writing more data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const socketWritable = new Writable({</span><span class="s3">\n    </span><span class="s1">write(chunk, _enc, cb) {</span><span class="s3">\n      </span><span class="s1">if (socket.write(chunk)) {</span><span class="s3">\n        </span><span class="s1">cb()</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">socket.once('drain', cb)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">final(cb) {</span><span class="s3">\n      </span><span class="s1">socket.end(cb)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const packetQueue: Buffer[] = []</span><span class="s3">\n  </span><span class="s1">const recvPromiseResolveQueue: Array&lt;(message: TIncoming) =&gt; void&gt; = []</span><span class="s3">\n\n  </span><span class="s1">function pushPacket(packet: Buffer) {</span><span class="s3">\n    </span><span class="s1">const recvPromiseResolve = recvPromiseResolveQueue.shift()</span><span class="s3">\n    </span><span class="s1">if (recvPromiseResolve != null) {</span><span class="s3">\n      </span><span class="s1">recvPromiseResolve(JSON.parse(packet.toString('utf8')) as TIncoming)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">packetQueue.push(packet)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let state: State = { type: 'waiting' }</span><span class="s3">\n  </span><span class="s1">let buffer: Buffer = Buffer.alloc(0)</span><span class="s3">\n  </span><span class="s1">socket.once('connect', () =&gt; {</span><span class="s3">\n    </span><span class="s1">socket.on('data', (chunk) =&gt; {</span><span class="s3">\n      </span><span class="s1">buffer = Buffer.concat([buffer, chunk])</span><span class="s3">\n\n      </span><span class="s1">loop: while (true) {</span><span class="s3">\n        </span><span class="s1">switch (state.type) {</span><span class="s3">\n          </span><span class="s1">case 'waiting': {</span><span class="s3">\n            </span><span class="s1">if (buffer.length &gt;= 4) {</span><span class="s3">\n              </span><span class="s1">const length = buffer.readUInt32BE(0)</span><span class="s3">\n              </span><span class="s1">buffer = buffer.subarray(4)</span><span class="s3">\n              </span><span class="s1">state = { type: 'packet', length }</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">break loop</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case 'packet': {</span><span class="s3">\n            </span><span class="s1">if (buffer.length &gt;= state.length) {</span><span class="s3">\n              </span><span class="s1">const packet = buffer.subarray(0, state.length)</span><span class="s3">\n              </span><span class="s1">buffer = buffer.subarray(state.length)</span><span class="s3">\n              </span><span class="s1">state = { type: 'waiting' }</span><span class="s3">\n              </span><span class="s1">pushPacket(packet)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">break loop</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">invariant(state, (state) =&gt; `Unknown state type: ${state?.type}`)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">// When the socket is closed, this process is no longer needed.</span><span class="s3">\n  </span><span class="s1">// This might happen e. g. when parent process is killed or</span><span class="s3">\n  </span><span class="s1">// node.js pool is garbage collected.</span><span class="s3">\n  </span><span class="s1">socket.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">process.exit(0)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// TODO(lukesandberg): some of the messages being sent are very large and contain lots</span><span class="s3">\n  </span><span class="s1">//  of redundant information.  Consider adding gzip compression to our stream.</span><span class="s3">\n  </span><span class="s1">function doSend(message: string): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Reserve 4 bytes for our length prefix, we will over-write after encoding.</span><span class="s3">\n      </span><span class="s1">const packet = Buffer.from('0000' + message, 'utf8')</span><span class="s3">\n      </span><span class="s1">packet.writeUInt32BE(packet.length - 4, 0)</span><span class="s3">\n      </span><span class="s1">socketWritable.write(packet, (err) =&gt; {</span><span class="s3">\n        </span><span class="s1">process.stderr.write(`TURBOPACK_OUTPUT_D</span><span class="s3">\\</span><span class="s1">n`)</span><span class="s3">\n        </span><span class="s1">process.stdout.write(`TURBOPACK_OUTPUT_D</span><span class="s3">\\</span><span class="s1">n`)</span><span class="s3">\n        </span><span class="s1">if (err != null) {</span><span class="s3">\n          </span><span class="s1">reject(err)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">resolve()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function send(message: any): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return doSend(JSON.stringify(message))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function sendReady(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return doSend('')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">async recv() {</span><span class="s3">\n      </span><span class="s1">const packet = packetQueue.shift()</span><span class="s3">\n      </span><span class="s1">if (packet != null) {</span><span class="s3">\n        </span><span class="s1">return JSON.parse(packet.toString('utf8')) as TIncoming</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const result = await new Promise&lt;TIncoming&gt;((resolve) =&gt; {</span><span class="s3">\n        </span><span class="s1">recvPromiseResolveQueue.push((result) =&gt; {</span><span class="s3">\n          </span><span class="s1">resolve(result)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">return result</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">send(message: TOutgoing) {</span><span class="s3">\n      </span><span class="s1">return send(message)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">sendReady,</span><span class="s3">\n\n    </span><span class="s1">async sendError(error: Error): Promise&lt;never&gt; {</span><span class="s3">\n      </span><span class="s1">let failed = false</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">await send({</span><span class="s3">\n          </span><span class="s1">type: 'error',</span><span class="s3">\n          </span><span class="s1">...structuredError(error),</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">// There's nothing we can do about errors that happen after this point, we can't tell anyone</span><span class="s3">\n        </span><span class="s1">// about them.</span><span class="s3">\n        </span><span class="s1">console.error('failed to send error back to rust:', err)</span><span class="s3">\n        </span><span class="s1">failed = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">await new Promise&lt;void&gt;((res) =&gt; socket.end(() =&gt; res()))</span><span class="s3">\n      </span><span class="s1">process.exit(failed ? 1 : 0)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const PORT = process.argv[2]</span><span class="s3">\n\n</span><span class="s1">export const IPC = createIpc&lt;unknown, unknown&gt;(parseInt(PORT, 10))</span><span class="s3">\n\n</span><span class="s1">process.on('uncaughtException', (err) =&gt; {</span><span class="s3">\n  </span><span class="s1">IPC.sendError(err)</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">const improveConsole = (name: string, stream: string, addStack: boolean) =&gt; {</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">const original = console[name]</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">const stdio = process[stream]</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">console[name] = (...args: any[]) =&gt; {</span><span class="s3">\n    </span><span class="s1">stdio.write(`TURBOPACK_OUTPUT_B</span><span class="s3">\\</span><span class="s1">n`)</span><span class="s3">\n    </span><span class="s1">original(...args)</span><span class="s3">\n    </span><span class="s1">if (addStack) {</span><span class="s3">\n      </span><span class="s1">const stack = new Error().stack?.replace(/^.+</span><span class="s3">\\</span><span class="s1">n.+</span><span class="s3">\\</span><span class="s1">n/, '') + '</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n      </span><span class="s1">stdio.write('TURBOPACK_OUTPUT_S</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n      </span><span class="s1">stdio.write(stack)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stdio.write('TURBOPACK_OUTPUT_E</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">improveConsole('error', 'stderr', true)</span><span class="s3">\n</span><span class="s1">improveConsole('warn', 'stderr', true)</span><span class="s3">\n</span><span class="s1">improveConsole('count', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('trace', 'stderr', false)</span><span class="s3">\n</span><span class="s1">improveConsole('log', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('group', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('groupCollapsed', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('table', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('debug', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('info', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('dir', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('dirxml', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('timeEnd', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('timeLog', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('timeStamp', 'stdout', true)</span><span class="s3">\n</span><span class="s1">improveConsole('assert', 'stderr', true)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility function to ensure all variants of an enum are handled.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function invariant(never: never, computeMessage: (arg: any) =&gt; string): never {</span><span class="s3">\n  </span><span class="s1">throw new Error(`Invariant: ${computeMessage(never)}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AACA;AAEA;AACA;;;;;AASO,SAAS,gBAAgB,CAAU;IACxC,IAAI,IAAA,qIAAc,EAAC;IAEnB,OAAO;QACL,MAAM,EAAE,IAAI;QACZ,SAAS,EAAE,OAAO;QAClB,OAAO,OAAO,EAAE,KAAK,KAAK,WAAW,IAAA,yJAAe,EAAC,EAAE,KAAK,IAAI,EAAE;QAClE,OAAO,EAAE,KAAK,GAAG,gBAAgB,IAAA,qIAAc,EAAC,EAAE,KAAK,KAAK;IAC9D;AACF;AAkBA,SAAS,UACP,IAAY;IAEZ,MAAM,SAAS,IAAA,mIAAgB,EAAC;QAC9B;QACA,MAAM;IACR;IAEA;;;;;GAKC,GACD,MAAM,iBAAiB,IAAI,iIAAQ,CAAC;QAClC,OAAM,KAAK,EAAE,IAAI,EAAE,EAAE;YACnB,IAAI,OAAO,KAAK,CAAC,QAAQ;gBACvB;YACF,OAAO;gBACL,OAAO,IAAI,CAAC,SAAS;YACvB;QACF;QACA,OAAM,EAAE;YACN,OAAO,GAAG,CAAC;QACb;IACF;IAEA,MAAM,cAAwB,EAAE;IAChC,MAAM,0BAA+D,EAAE;IAEvE,SAAS,WAAW,MAAc;QAChC,MAAM,qBAAqB,wBAAwB,KAAK;QACxD,IAAI,sBAAsB,MAAM;YAC9B,mBAAmB,KAAK,KAAK,CAAC,OAAO,QAAQ,CAAC;QAChD,OAAO;YACL,YAAY,IAAI,CAAC;QACnB;IACF;IAEA,IAAI,QAAe;QAAE,MAAM;IAAU;IACrC,IAAI,SAAiB,OAAO,KAAK,CAAC;IAClC,OAAO,IAAI,CAAC,WAAW;QACrB,OAAO,EAAE,CAAC,QAAQ,CAAC;YACjB,SAAS,OAAO,MAAM,CAAC;gBAAC;gBAAQ;aAAM;YAEtC,MAAM,MAAO,KAAM;gBACjB,OAAQ,MAAM,IAAI;oBAChB,KAAK;wBAAW;4BACd,IAAI,OAAO,MAAM,IAAI,GAAG;gCACtB,MAAM,SAAS,OAAO,YAAY,CAAC;gCACnC,SAAS,OAAO,QAAQ,CAAC;gCACzB,QAAQ;oCAAE,MAAM;oCAAU;gCAAO;4BACnC,OAAO;gCACL,MAAM;4BACR;4BACA;wBACF;oBACA,KAAK;wBAAU;4BACb,IAAI,OAAO,MAAM,IAAI,MAAM,MAAM,EAAE;gCACjC,MAAM,SAAS,OAAO,QAAQ,CAAC,GAAG,MAAM,MAAM;gCAC9C,SAAS,OAAO,QAAQ,CAAC,MAAM,MAAM;gCACrC,QAAQ;oCAAE,MAAM;gCAAU;gCAC1B,WAAW;4BACb,OAAO;gCACL,MAAM;4BACR;4BACA;wBACF;oBACA;wBACE,UAAU,OAAO,CAAC,QAAU,CAAC,oBAAoB,EAAE,OAAO,MAAM;gBACpE;YACF;QACF;IACF;IACA,+DAA+D;IAC/D,2DAA2D;IAC3D,qCAAqC;IACrC,OAAO,IAAI,CAAC,SAAS;QACnB,QAAQ,IAAI,CAAC;IACf;IAEA,sFAAsF;IACtF,8EAA8E;IAC9E,SAAS,OAAO,OAAe;QAC7B,OAAO,IAAI,QAAQ,CAAC,SAAS;YAC3B,4EAA4E;YAC5E,MAAM,SAAS,OAAO,IAAI,CAAC,SAAS,SAAS;YAC7C,OAAO,aAAa,CAAC,OAAO,MAAM,GAAG,GAAG;YACxC,eAAe,KAAK,CAAC,QAAQ,CAAC;gBAC5B,QAAQ,MAAM,CAAC,KAAK,CAAC,CAAC,oBAAoB,CAAC;gBAC3C,QAAQ,MAAM,CAAC,KAAK,CAAC,CAAC,oBAAoB,CAAC;gBAC3C,IAAI,OAAO,MAAM;oBACf,OAAO;gBACT,OAAO;oBACL;gBACF;YACF;QACF;IACF;IAEA,SAAS,KAAK,OAAY;QACxB,OAAO,OAAO,KAAK,SAAS,CAAC;IAC/B;IACA,SAAS;QACP,OAAO,OAAO;IAChB;IAEA,OAAO;QACL,MAAM;YACJ,MAAM,SAAS,YAAY,KAAK;YAChC,IAAI,UAAU,MAAM;gBAClB,OAAO,KAAK,KAAK,CAAC,OAAO,QAAQ,CAAC;YACpC;YAEA,MAAM,SAAS,MAAM,IAAI,QAAmB,CAAC;gBAC3C,wBAAwB,IAAI,CAAC,CAAC;oBAC5B,QAAQ;gBACV;YACF;YAEA,OAAO;QACT;QAEA,MAAK,OAAkB;YACrB,OAAO,KAAK;QACd;QAEA;QAEA,MAAM,WAAU,KAAY;YAC1B,IAAI,SAAS;YACb,IAAI;gBACF,MAAM,KAAK;oBACT,MAAM;oBACN,GAAG,gBAAgB,MAAM;gBAC3B;YACF,EAAE,OAAO,KAAK;gBACZ,4FAA4F;gBAC5F,cAAc;gBACd,QAAQ,KAAK,CAAC,sCAAsC;gBACpD,SAAS;YACX;YACA,MAAM,IAAI,QAAc,CAAC,MAAQ,OAAO,GAAG,CAAC,IAAM;YAClD,QAAQ,IAAI,CAAC,SAAS,IAAI;QAC5B;IACF;AACF;AAEA,MAAM,OAAO,QAAQ,IAAI,CAAC,EAAE;AAErB,MAAM,MAAM,UAA4B,SAAS,MAAM;AAE9D,QAAQ,EAAE,CAAC,qBAAqB,CAAC;IAC/B,IAAI,SAAS,CAAC;AAChB;AAEA,MAAM,iBAAiB,CAAC,MAAc,QAAgB;IACpD,aAAa;IACb,MAAM,WAAW,OAAO,CAAC,KAAK;IAC9B,aAAa;IACb,MAAM,QAAQ,OAAO,CAAC,OAAO;IAC7B,aAAa;IACb,OAAO,CAAC,KAAK,GAAG,CAAC,GAAG;QAClB,MAAM,KAAK,CAAC,CAAC,oBAAoB,CAAC;QAClC,YAAY;QACZ,IAAI,UAAU;YACZ,MAAM,QAAQ,IAAI,QAAQ,KAAK,EAAE,QAAQ,aAAa,MAAM;YAC5D,MAAM,KAAK,CAAC;YACZ,MAAM,KAAK,CAAC;QACd;QACA,MAAM,KAAK,CAAC;IACd;AACF;AAEA,eAAe,SAAS,UAAU;AAClC,eAAe,QAAQ,UAAU;AACjC,eAAe,SAAS,UAAU;AAClC,eAAe,SAAS,UAAU;AAClC,eAAe,OAAO,UAAU;AAChC,eAAe,SAAS,UAAU;AAClC,eAAe,kBAAkB,UAAU;AAC3C,eAAe,SAAS,UAAU;AAClC,eAAe,SAAS,UAAU;AAClC,eAAe,QAAQ,UAAU;AACjC,eAAe,OAAO,UAAU;AAChC,eAAe,UAAU,UAAU;AACnC,eAAe,WAAW,UAAU;AACpC,eAAe,WAAW,UAAU;AACpC,eAAe,aAAa,UAAU;AACtC,eAAe,UAAU,UAAU;AAEnC;;CAEC,GACD,SAAS,UAAU,KAAY,EAAE,cAAoC;IACnE,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,eAAe,QAAQ;AACvD&quot;</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">393</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack-node]/ipc/evaluate.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { IPC } from './index'</span><span class="s3">\n</span><span class="s1">import type { Ipc as GenericIpc } from './index'</span><span class="s3">\n\n</span><span class="s1">type IpcIncomingMessage =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'evaluate'</span><span class="s3">\n      </span><span class="s1">args: string[]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'result'</span><span class="s3">\n      </span><span class="s1">id: number</span><span class="s3">\n      </span><span class="s1">error: string | null</span><span class="s3">\n      </span><span class="s1">data: any | null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type IpcOutgoingMessage =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'end'</span><span class="s3">\n      </span><span class="s1">data: string | undefined</span><span class="s3">\n      </span><span class="s1">duration: number</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'info'</span><span class="s3">\n      </span><span class="s1">data: any</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">type: 'request'</span><span class="s3">\n      </span><span class="s1">id: number</span><span class="s3">\n      </span><span class="s1">data: any</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type Ipc&lt;IM, RM&gt; = {</span><span class="s3">\n  </span><span class="s1">sendInfo(message: IM): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">sendRequest(message: RM): Promise&lt;unknown&gt;</span><span class="s3">\n  </span><span class="s1">sendError(error: Error): Promise&lt;never&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const ipc = IPC as GenericIpc&lt;IpcIncomingMessage, IpcOutgoingMessage&gt;</span><span class="s3">\n\n</span><span class="s1">const queue: string[][] = []</span><span class="s3">\n\n</span><span class="s1">export const run = async (</span><span class="s3">\n  </span><span class="s1">moduleFactory: () =&gt; Promise&lt;{</span><span class="s3">\n    </span><span class="s1">init?: () =&gt; Promise&lt;void&gt;</span><span class="s3">\n    </span><span class="s1">default: (ipc: Ipc&lt;any, any&gt;, ...deserializedArgs: any[]) =&gt; any</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">let nextId = 1</span><span class="s3">\n  </span><span class="s1">const requests = new Map()</span><span class="s3">\n  </span><span class="s1">const internalIpc = {</span><span class="s3">\n    </span><span class="s1">sendInfo: (message: any) =&gt;</span><span class="s3">\n      </span><span class="s1">ipc.send({</span><span class="s3">\n        </span><span class="s1">type: 'info',</span><span class="s3">\n        </span><span class="s1">data: message,</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">sendRequest: (message: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">const id = nextId++</span><span class="s3">\n      </span><span class="s1">let resolve, reject</span><span class="s3">\n      </span><span class="s1">const promise = new Promise((res, rej) =&gt; {</span><span class="s3">\n        </span><span class="s1">resolve = res</span><span class="s3">\n        </span><span class="s1">reject = rej</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">requests.set(id, { resolve, reject })</span><span class="s3">\n      </span><span class="s1">return ipc</span><span class="s3">\n        </span><span class="s1">.send({ type: 'request', id, data: message })</span><span class="s3">\n        </span><span class="s1">.then(() =&gt; promise)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">sendError: (error: Error) =&gt; {</span><span class="s3">\n      </span><span class="s1">return ipc.sendError(error)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Initialize module and send ready message</span><span class="s3">\n  </span><span class="s1">let getValue: (ipc: Ipc&lt;any, any&gt;, ...deserializedArgs: any[]) =&gt; any</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const module = await moduleFactory()</span><span class="s3">\n    </span><span class="s1">if (typeof module.init === 'function') {</span><span class="s3">\n      </span><span class="s1">await module.init()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getValue = module.default</span><span class="s3">\n    </span><span class="s1">await ipc.sendReady()</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">await ipc.sendReady()</span><span class="s3">\n    </span><span class="s1">await ipc.sendError(err as Error)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Queue handling</span><span class="s3">\n  </span><span class="s1">let isRunning = false</span><span class="s3">\n  </span><span class="s1">const run = async () =&gt; {</span><span class="s3">\n    </span><span class="s1">while (queue.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const args = queue.shift()!</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const value = await getValue(internalIpc, ...args)</span><span class="s3">\n        </span><span class="s1">await ipc.send({</span><span class="s3">\n          </span><span class="s1">type: 'end',</span><span class="s3">\n          </span><span class="s1">data:</span><span class="s3">\n            </span><span class="s1">value === undefined ? undefined : JSON.stringify(value, null, 2),</span><span class="s3">\n          </span><span class="s1">duration: 0,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">await ipc.sendError(e as Error)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isRunning = false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Communication handling</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">const msg = await ipc.recv()</span><span class="s3">\n\n    </span><span class="s1">switch (msg.type) {</span><span class="s3">\n      </span><span class="s1">case 'evaluate': {</span><span class="s3">\n        </span><span class="s1">queue.push(msg.args)</span><span class="s3">\n        </span><span class="s1">if (!isRunning) {</span><span class="s3">\n          </span><span class="s1">isRunning = true</span><span class="s3">\n          </span><span class="s1">run()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'result': {</span><span class="s3">\n        </span><span class="s1">const request = requests.get(msg.id)</span><span class="s3">\n        </span><span class="s1">if (request) {</span><span class="s3">\n          </span><span class="s1">requests.delete(msg.id)</span><span class="s3">\n          </span><span class="s1">if (msg.error) {</span><span class="s3">\n            </span><span class="s1">request.reject(new Error(msg.error))</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">request.resolve(msg.data)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">console.error('unexpected message type', (msg as any).type)</span><span class="s3">\n        </span><span class="s1">process.exit(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type { IpcIncomingMessage, IpcOutgoingMessage }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAoCA,MAAM,MAAM,0HAAG;AAEf,MAAM,QAAoB,EAAE;AAErB,MAAM,MAAM,OACjB;IAKA,IAAI,SAAS;IACb,MAAM,WAAW,IAAI;IACrB,MAAM,cAAc;QAClB,UAAU,CAAC,UACT,IAAI,IAAI,CAAC;gBACP,MAAM;gBACN,MAAM;YACR;QACF,aAAa,CAAC;YACZ,MAAM,KAAK;YACX,IAAI,SAAS;YACb,MAAM,UAAU,IAAI,QAAQ,CAAC,KAAK;gBAChC,UAAU;gBACV,SAAS;YACX;YACA,SAAS,GAAG,CAAC,IAAI;gBAAE;gBAAS;YAAO;YACnC,OAAO,IACJ,IAAI,CAAC;gBAAE,MAAM;gBAAW;gBAAI,MAAM;YAAQ,GAC1C,IAAI,CAAC,IAAM;QAChB;QACA,WAAW,CAAC;YACV,OAAO,IAAI,SAAS,CAAC;QACvB;IACF;IAEA,2CAA2C;IAC3C,IAAI;IACJ,IAAI;QACF,MAAM,SAAS,MAAM;QACrB,IAAI,OAAO,OAAO,IAAI,KAAK,YAAY;YACrC,MAAM,OAAO,IAAI;QACnB;QACA,WAAW,OAAO,OAAO;QACzB,MAAM,IAAI,SAAS;IACrB,EAAE,OAAO,KAAK;QACZ,MAAM,IAAI,SAAS;QACnB,MAAM,IAAI,SAAS,CAAC;IACtB;IAEA,iBAAiB;IACjB,IAAI,YAAY;IAChB,MAAM,MAAM;QACV,MAAO,MAAM,MAAM,GAAG,EAAG;YACvB,MAAM,OAAO,MAAM,KAAK;YACxB,IAAI;gBACF,MAAM,QAAQ,MAAM,SAAS,gBAAgB;gBAC7C,MAAM,IAAI,IAAI,CAAC;oBACb,MAAM;oBACN,MACE,UAAU,YAAY,YAAY,KAAK,SAAS,CAAC,OAAO,MAAM;oBAChE,UAAU;gBACZ;YACF,EAAE,OAAO,GAAG;gBACV,MAAM,IAAI,SAAS,CAAC;YACtB;QACF;QACA,YAAY;IACd;IAEA,yBAAyB;IACzB,MAAO,KAAM;QACX,MAAM,MAAM,MAAM,IAAI,IAAI;QAE1B,OAAQ,IAAI,IAAI;YACd,KAAK;gBAAY;oBACf,MAAM,IAAI,CAAC,IAAI,IAAI;oBACnB,IAAI,CAAC,WAAW;wBACd,YAAY;wBACZ;oBACF;oBACA;gBACF;YACA,KAAK;gBAAU;oBACb,MAAM,UAAU,SAAS,GAAG,CAAC,IAAI,EAAE;oBACnC,IAAI,SAAS;wBACX,SAAS,MAAM,CAAC,IAAI,EAAE;wBACtB,IAAI,IAAI,KAAK,EAAE;4BACb,QAAQ,MAAM,CAAC,IAAI,MAAM,IAAI,KAAK;wBACpC,OAAO;4BACL,QAAQ,OAAO,CAAC,IAAI,IAAI;wBAC1B;oBACF;oBACA;gBACF;YACA;gBAAS;oBACP,QAAQ,KAAK,CAAC,2BAA2B,AAAC,IAAY,IAAI;oBAC1D,QAAQ,IAAI,CAAC;gBACf;QACF;IACF;AACF&quot;</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">499</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;turbopack:///[turbopack-node]/ipc/evaluate.ts/evaluate.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { run } from 'RUNTIME'; run(() =&gt; import('INNER'))&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;AAAA;;AAA+B,IAAA,6HAAG,EAAC&quot;</span><span class="s0">}}]</span>
<span class="s0">}</span></pre>
</body>
</html>