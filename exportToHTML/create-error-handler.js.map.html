<html>
<head>
<title>create-error-handler.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create-error-handler.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/create-error-handler.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { ErrorInfo } from 'react'</span><span class="s3">\n\n</span><span class="s1">import stringHash from 'next/dist/compiled/string-hash'</span><span class="s3">\n</span><span class="s1">import { formatServerError } from '../../lib/format-server-error'</span><span class="s3">\n</span><span class="s1">import { SpanStatusCode, getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { isAbortError } from '../pipe-readable'</span><span class="s3">\n</span><span class="s1">import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { isDynamicServerError } from '../../client/components/hooks-server-context'</span><span class="s3">\n</span><span class="s1">import { isNextRouterError } from '../../client/components/is-next-router-error'</span><span class="s3">\n</span><span class="s1">import { isPrerenderInterruptedError } from './dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import { getProperError } from '../../lib/is-error'</span><span class="s3">\n</span><span class="s1">import { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'</span><span class="s3">\n</span><span class="s1">import { isReactLargeShellError } from './react-large-shell-error'</span><span class="s3">\n\n</span><span class="s1">declare global {</span><span class="s3">\n  </span><span class="s1">var __next_log_error__: undefined | ((err: unknown) =&gt; void)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RSCErrorHandler = (err: unknown) =&gt; string | undefined</span><span class="s3">\n</span><span class="s1">type SSRErrorHandler = (</span><span class="s3">\n  </span><span class="s1">err: unknown,</span><span class="s3">\n  </span><span class="s1">errorInfo?: ErrorInfo</span><span class="s3">\n</span><span class="s1">) =&gt; string | undefined</span><span class="s3">\n\n</span><span class="s1">export type DigestedError = Error &amp; { digest: string }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a digest for well-known Next.js errors, otherwise `undefined`. If a</span><span class="s3">\n </span><span class="s1">* digest is returned this also means that the error does not need to be</span><span class="s3">\n </span><span class="s1">* reported.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getDigestForWellKnownError(error: unknown): string | undefined {</span><span class="s3">\n  </span><span class="s1">// If we're bailing out to CSR, we don't need to log the error.</span><span class="s3">\n  </span><span class="s1">if (isBailoutToCSRError(error)) return error.digest</span><span class="s3">\n\n  </span><span class="s1">// If this is a navigation error, we don't need to log the error.</span><span class="s3">\n  </span><span class="s1">if (isNextRouterError(error)) return error.digest</span><span class="s3">\n\n  </span><span class="s1">// If this error occurs, we know that we should be stopping the static</span><span class="s3">\n  </span><span class="s1">// render. This is only thrown in static generation when PPR is not enabled,</span><span class="s3">\n  </span><span class="s1">// which causes the whole page to be marked as dynamic. We don't need to</span><span class="s3">\n  </span><span class="s1">// tell the user about this error, as it's not actionable.</span><span class="s3">\n  </span><span class="s1">if (isDynamicServerError(error)) return error.digest</span><span class="s3">\n\n  </span><span class="s1">// If this is a prerender interrupted error, we don't need to log the error.</span><span class="s3">\n  </span><span class="s1">if (isPrerenderInterruptedError(error)) return error.digest</span><span class="s3">\n\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createFlightReactServerErrorHandler(</span><span class="s3">\n  </span><span class="s1">shouldFormatError: boolean,</span><span class="s3">\n  </span><span class="s1">onReactServerRenderError: (err: DigestedError) =&gt; void</span><span class="s3">\n</span><span class="s1">): RSCErrorHandler {</span><span class="s3">\n  </span><span class="s1">return (thrownValue: unknown) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (typeof thrownValue === 'string') {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span><span class="s3">\n      </span><span class="s1">return stringHash(thrownValue).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response was closed, we don't need to log the error.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(thrownValue)) return</span><span class="s3">\n\n    </span><span class="s1">const digest = getDigestForWellKnownError(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">if (digest) {</span><span class="s3">\n      </span><span class="s1">return digest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isReactLargeShellError(thrownValue)) {</span><span class="s3">\n      </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n      </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const err = getProperError(thrownValue) as DigestedError</span><span class="s3">\n\n    </span><span class="s1">// If the error already has a digest, respect the original digest,</span><span class="s3">\n    </span><span class="s1">// so it won't get re-generated into another new error.</span><span class="s3">\n    </span><span class="s1">if (!err.digest) {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span><span class="s3">\n      </span><span class="s1">err.digest = stringHash(err.message + err.stack || '').toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Format server errors in development to add more helpful error messages</span><span class="s3">\n    </span><span class="s1">if (shouldFormatError) {</span><span class="s3">\n      </span><span class="s1">formatServerError(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Record exception in an active span, if available.</span><span class="s3">\n    </span><span class="s1">const span = getTracer().getActiveScopeSpan()</span><span class="s3">\n    </span><span class="s1">if (span) {</span><span class="s3">\n      </span><span class="s1">span.recordException(err)</span><span class="s3">\n      </span><span class="s1">span.setAttribute('error.type', err.name)</span><span class="s3">\n      </span><span class="s1">span.setStatus({</span><span class="s3">\n        </span><span class="s1">code: SpanStatusCode.ERROR,</span><span class="s3">\n        </span><span class="s1">message: err.message,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">onReactServerRenderError(err)</span><span class="s3">\n\n    </span><span class="s1">return createDigestWithErrorCode(thrownValue, err.digest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createHTMLReactServerErrorHandler(</span><span class="s3">\n  </span><span class="s1">shouldFormatError: boolean,</span><span class="s3">\n  </span><span class="s1">isNextExport: boolean,</span><span class="s3">\n  </span><span class="s1">reactServerErrors: Map&lt;string, DigestedError&gt;,</span><span class="s3">\n  </span><span class="s1">silenceLogger: boolean,</span><span class="s3">\n  </span><span class="s1">onReactServerRenderError: undefined | ((err: DigestedError) =&gt; void)</span><span class="s3">\n</span><span class="s1">): RSCErrorHandler {</span><span class="s3">\n  </span><span class="s1">return (thrownValue: unknown) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (typeof thrownValue === 'string') {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span><span class="s3">\n      </span><span class="s1">return stringHash(thrownValue).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response was closed, we don't need to log the error.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(thrownValue)) return</span><span class="s3">\n\n    </span><span class="s1">const digest = getDigestForWellKnownError(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">if (digest) {</span><span class="s3">\n      </span><span class="s1">return digest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isReactLargeShellError(thrownValue)) {</span><span class="s3">\n      </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n      </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const err = getProperError(thrownValue) as DigestedError</span><span class="s3">\n\n    </span><span class="s1">// If the error already has a digest, respect the original digest,</span><span class="s3">\n    </span><span class="s1">// so it won't get re-generated into another new error.</span><span class="s3">\n    </span><span class="s1">if (!err.digest) {</span><span class="s3">\n      </span><span class="s1">// TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.</span><span class="s3">\n      </span><span class="s1">err.digest = stringHash(err.message + (err.stack || '')).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @TODO by putting this here and not at the top it is possible that</span><span class="s3">\n    </span><span class="s1">// we don't error the build in places we actually expect to</span><span class="s3">\n    </span><span class="s1">if (!reactServerErrors.has(err.digest)) {</span><span class="s3">\n      </span><span class="s1">reactServerErrors.set(err.digest, err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Format server errors in development to add more helpful error messages</span><span class="s3">\n    </span><span class="s1">if (shouldFormatError) {</span><span class="s3">\n      </span><span class="s1">formatServerError(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Don't log the suppressed error during export</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!(</span><span class="s3">\n        </span><span class="s1">isNextExport &amp;&amp;</span><span class="s3">\n        </span><span class="s1">err?.message?.includes(</span><span class="s3">\n          </span><span class="s1">'The specific message is omitted in production builds to avoid leaking sensitive details.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Record exception in an active span, if available.</span><span class="s3">\n      </span><span class="s1">const span = getTracer().getActiveScopeSpan()</span><span class="s3">\n      </span><span class="s1">if (span) {</span><span class="s3">\n        </span><span class="s1">span.recordException(err)</span><span class="s3">\n        </span><span class="s1">span.setAttribute('error.type', err.name)</span><span class="s3">\n        </span><span class="s1">span.setStatus({</span><span class="s3">\n          </span><span class="s1">code: SpanStatusCode.ERROR,</span><span class="s3">\n          </span><span class="s1">message: err.message,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!silenceLogger) {</span><span class="s3">\n        </span><span class="s1">onReactServerRenderError?.(err)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return createDigestWithErrorCode(thrownValue, err.digest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createHTMLErrorHandler(</span><span class="s3">\n  </span><span class="s1">shouldFormatError: boolean,</span><span class="s3">\n  </span><span class="s1">isNextExport: boolean,</span><span class="s3">\n  </span><span class="s1">reactServerErrors: Map&lt;string, DigestedError&gt;,</span><span class="s3">\n  </span><span class="s1">allCapturedErrors: Array&lt;unknown&gt;,</span><span class="s3">\n  </span><span class="s1">silenceLogger: boolean,</span><span class="s3">\n  </span><span class="s1">onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) =&gt; void</span><span class="s3">\n</span><span class="s1">): SSRErrorHandler {</span><span class="s3">\n  </span><span class="s1">return (thrownValue: unknown, errorInfo?: ErrorInfo) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (isReactLargeShellError(thrownValue)) {</span><span class="s3">\n      </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n      </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let isSSRError = true</span><span class="s3">\n\n    </span><span class="s1">allCapturedErrors.push(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">// If the response was closed, we don't need to log the error.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(thrownValue)) return</span><span class="s3">\n\n    </span><span class="s1">const digest = getDigestForWellKnownError(thrownValue)</span><span class="s3">\n\n    </span><span class="s1">if (digest) {</span><span class="s3">\n      </span><span class="s1">return digest</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const err = getProperError(thrownValue) as DigestedError</span><span class="s3">\n    </span><span class="s1">// If the error already has a digest, respect the original digest,</span><span class="s3">\n    </span><span class="s1">// so it won't get re-generated into another new error.</span><span class="s3">\n    </span><span class="s1">if (err.digest) {</span><span class="s3">\n      </span><span class="s1">if (reactServerErrors.has(err.digest)) {</span><span class="s3">\n        </span><span class="s1">// This error is likely an obfuscated error from react-server.</span><span class="s3">\n        </span><span class="s1">// We recover the original error here.</span><span class="s3">\n        </span><span class="s1">thrownValue = reactServerErrors.get(err.digest)</span><span class="s3">\n        </span><span class="s1">isSSRError = false</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// The error is not from react-server but has a digest</span><span class="s3">\n        </span><span class="s1">// from other means so we don't need to produce a new one</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">err.digest = stringHash(</span><span class="s3">\n        </span><span class="s1">err.message + (errorInfo?.componentStack || err.stack || '')</span><span class="s3">\n      </span><span class="s1">).toString()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Format server errors in development to add more helpful error messages</span><span class="s3">\n    </span><span class="s1">if (shouldFormatError) {</span><span class="s3">\n      </span><span class="s1">formatServerError(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Don't log the suppressed error during export</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!(</span><span class="s3">\n        </span><span class="s1">isNextExport &amp;&amp;</span><span class="s3">\n        </span><span class="s1">err?.message?.includes(</span><span class="s3">\n          </span><span class="s1">'The specific message is omitted in production builds to avoid leaking sensitive details.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Record exception in an active span, if available.</span><span class="s3">\n      </span><span class="s1">const span = getTracer().getActiveScopeSpan()</span><span class="s3">\n      </span><span class="s1">if (span) {</span><span class="s3">\n        </span><span class="s1">span.recordException(err)</span><span class="s3">\n        </span><span class="s1">span.setAttribute('error.type', err.name)</span><span class="s3">\n        </span><span class="s1">span.setStatus({</span><span class="s3">\n          </span><span class="s1">code: SpanStatusCode.ERROR,</span><span class="s3">\n          </span><span class="s1">message: err.message,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!silenceLogger &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// HTML errors contain RSC errors as well, filter them out before reporting</span><span class="s3">\n        </span><span class="s1">isSSRError</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">onHTMLRenderSSRError(err, errorInfo)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return createDigestWithErrorCode(thrownValue, err.digest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isUserLandError(err: any): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">!isAbortError(err) &amp;&amp; !isBailoutToCSRError(err) &amp;&amp; !isNextRouterError(err)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createFlightReactServerErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;createHTMLErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;createHTMLReactServerErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;getDigestForWellKnownError&quot;</span><span class="s0">,</span><span class="s1">&quot;isUserLandError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;isBailoutToCSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrerenderInterruptedError&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldFormatError&quot;</span><span class="s0">,</span><span class="s1">&quot;onReactServerRenderError&quot;</span><span class="s0">,</span><span class="s1">&quot;thrownValue&quot;</span><span class="s0">,</span><span class="s1">&quot;stringHash&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbortError&quot;</span><span class="s0">,</span><span class="s1">&quot;isReactLargeShellError&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;getProperError&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;formatServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;span&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;getActiveScopeSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;recordException&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;setStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;SpanStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;createDigestWithErrorCode&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextExport&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;silenceLogger&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;allCapturedErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;onHTMLRenderSSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;isSSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;componentStack&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>