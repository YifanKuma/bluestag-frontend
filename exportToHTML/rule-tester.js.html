<html>
<head>
<title>rule-tester.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
.s7 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rule-tester.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Mocha/Jest test wrapper</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Ilya Volodin</span>
 <span class="s0">*/</span>
<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">/* globals describe, it -- Mocha globals */</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">assert = require(</span><span class="s3">&quot;node:assert&quot;</span><span class="s2">),</span>
	<span class="s2">util = require(</span><span class="s3">&quot;node:util&quot;</span><span class="s2">),</span>
	<span class="s2">path = require(</span><span class="s3">&quot;node:path&quot;</span><span class="s2">),</span>
	<span class="s2">equal = require(</span><span class="s3">&quot;fast-deep-equal&quot;</span><span class="s2">),</span>
	<span class="s2">Traverser = require(</span><span class="s3">&quot;../shared/traverser&quot;</span><span class="s2">),</span>
	<span class="s2">{ Config } = require(</span><span class="s3">&quot;../config/config&quot;</span><span class="s2">),</span>
	<span class="s2">{ Linter, SourceCodeFixer } = require(</span><span class="s3">&quot;../linter&quot;</span><span class="s2">),</span>
	<span class="s2">{ interpolate, getPlaceholderMatcher } = require(</span><span class="s3">&quot;../linter/interpolate&quot;</span><span class="s2">),</span>
	<span class="s2">stringify = require(</span><span class="s3">&quot;json-stable-stringify-without-jsonify&quot;</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">{ FlatConfigArray } = require(</span><span class="s3">&quot;../config/flat-config-array&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">{</span>
	<span class="s2">defaultConfig,</span>
	<span class="s2">defaultRuleTesterConfig,</span>
<span class="s2">} = require(</span><span class="s3">&quot;../config/default-config&quot;</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">ajv = require(</span><span class="s3">&quot;../shared/ajv&quot;</span><span class="s2">)({ strictDefaults: </span><span class="s4">true </span><span class="s2">});</span>

<span class="s4">const </span><span class="s2">parserSymbol = Symbol.for(</span><span class="s3">&quot;eslint.RuleTester.parser&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">{ ConfigArraySymbol } = require(</span><span class="s3">&quot;@eslint/config-array&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">{ isSerializable } = require(</span><span class="s3">&quot;../shared/serialization&quot;</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">jslang = require(</span><span class="s3">&quot;../languages/js&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">{ SourceCode } = require(</span><span class="s3">&quot;../languages/js/source-code&quot;</span><span class="s2">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Typedefs</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@import </span><span class="s0">{ LanguageOptions, RuleDefinition } from &quot;@eslint/core&quot; */</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../types&quot;).Linter.Parser} Parser */</span>

<span class="s0">/**</span>
 <span class="s0">* A test case that is expected to pass lint.</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} ValidTestCase</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} [name] Name for the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} code Code for the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{any[]} [options] Options for the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} [before] Function to execute before testing the case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} [after] Function to execute after testing the case regardless of its result.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{LanguageOptions} [languageOptions] The language options to use in the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{{ [name: string]: any }} [settings] Settings for the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{boolean} [only] Run only this test case or the subset of test cases with this property.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* A test case that is expected to fail lint.</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} InvalidTestCase</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} [name] Name for the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} code Code for the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{number | Array&lt;TestCaseError | string | RegExp&gt;} errors Expected errors.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{any[]} [options] Options for the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} [before] Function to execute before testing the case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} [after] Function to execute after testing the case regardless of its result.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{{ [name: string]: any }} [settings] Settings for the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{LanguageOptions} [languageOptions] The language options to use in the test case.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{boolean} [only] Run only this test case or the subset of test cases with this property.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* A description of a reported error used in a rule tester test.</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} TestCaseError</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string | RegExp} [message] Message.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} [messageId] Message ID.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} [type] The type of the reported AST node.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{{ [name: string]: string }} [data] The data used to fill the message template.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{number} [line] The 1-based line number of the reported start location.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{number} [column] The 1-based column number of the reported start location.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{number} [endLine] The 1-based line number of the reported end location.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{number} [endColumn] The 1-based column number of the reported end location.</span>
 <span class="s0">*/</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Private Members</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/* 
 * testerDefaultConfig must not be modified as it allows to reset the tester to 
 * the initial default configuration 
 */</span>
<span class="s4">const </span><span class="s2">testerDefaultConfig = { rules: {} };</span>

<span class="s0">/* 
 * RuleTester uses this config as its default. This can be overwritten via 
 * setDefaultConfig(). 
 */</span>
<span class="s4">let </span><span class="s2">sharedDefaultConfig = { rules: {} };</span>

<span class="s0">/* 
 * List every parameters possible on a test case that are not related to eslint 
 * configuration 
 */</span>
<span class="s4">const </span><span class="s2">RuleTesterParameters = [</span>
	<span class="s3">&quot;name&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;code&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;filename&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;options&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;before&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;after&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;errors&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;output&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;only&quot;</span><span class="s2">,</span>
<span class="s2">];</span>

<span class="s0">/* 
 * All allowed property names in error objects. 
 */</span>
<span class="s4">const </span><span class="s2">errorObjectParameters = </span><span class="s4">new </span><span class="s2">Set([</span>
	<span class="s3">&quot;message&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;messageId&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;data&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;type&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;line&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;column&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;endLine&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;endColumn&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;suggestions&quot;</span><span class="s2">,</span>
<span class="s2">]);</span>
<span class="s4">const </span><span class="s2">friendlyErrorObjectParameterList = </span><span class="s3">`[</span><span class="s2">${[...errorObjectParameters].map(key =&gt; </span><span class="s3">`'</span><span class="s2">${key}</span><span class="s3">'`</span><span class="s2">).join(</span><span class="s3">&quot;, &quot;</span><span class="s2">)}</span><span class="s3">]`</span><span class="s2">;</span>

<span class="s0">/* 
 * All allowed property names in suggestion objects. 
 */</span>
<span class="s4">const </span><span class="s2">suggestionObjectParameters = </span><span class="s4">new </span><span class="s2">Set([</span>
	<span class="s3">&quot;desc&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;messageId&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;data&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;output&quot;</span><span class="s2">,</span>
<span class="s2">]);</span>
<span class="s4">const </span><span class="s2">friendlySuggestionObjectParameterList = </span><span class="s3">`[</span><span class="s2">${[...suggestionObjectParameters].map(key =&gt; </span><span class="s3">`'</span><span class="s2">${key}</span><span class="s3">'`</span><span class="s2">).join(</span><span class="s3">&quot;, &quot;</span><span class="s2">)}</span><span class="s3">]`</span><span class="s2">;</span>

<span class="s0">/* 
 * Ignored test case properties when checking for test case duplicates. 
 */</span>
<span class="s4">const </span><span class="s2">duplicationIgnoredParameters = </span><span class="s4">new </span><span class="s2">Set([</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s3">&quot;output&quot;</span><span class="s2">]);</span>

<span class="s4">const </span><span class="s2">forbiddenMethods = [</span>
	<span class="s3">&quot;applyInlineConfig&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;applyLanguageOptions&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;finalize&quot;</span><span class="s2">,</span>
<span class="s2">];</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{Map&lt;string,WeakSet&gt;} */</span>
<span class="s4">const </span><span class="s2">forbiddenMethodCalls = </span><span class="s4">new </span><span class="s2">Map(</span>
	<span class="s2">forbiddenMethods.map(methodName =&gt; [methodName, </span><span class="s4">new </span><span class="s2">WeakSet()]),</span>
<span class="s2">);</span>

<span class="s4">const </span><span class="s2">hasOwnProperty = Function.call.bind(Object.hasOwnProperty);</span>

<span class="s0">/**</span>
 <span class="s0">* Clones a given value deeply.</span>
 <span class="s0">* Note: This ignores `parent` property.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} x A value to clone.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{any} A cloned value.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">cloneDeeplyExcludesParent(x) {</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">x === </span><span class="s3">&quot;object&quot; </span><span class="s2">&amp;&amp; x !== </span><span class="s4">null</span><span class="s2">) {</span>
		<span class="s4">if </span><span class="s2">(Array.isArray(x)) {</span>
			<span class="s4">return </span><span class="s2">x.map(cloneDeeplyExcludesParent);</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">retv = {};</span>

		<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">key </span><span class="s4">in </span><span class="s2">x) {</span>
			<span class="s4">if </span><span class="s2">(key !== </span><span class="s3">&quot;parent&quot; </span><span class="s2">&amp;&amp; hasOwnProperty(x, key)) {</span>
				<span class="s2">retv[key] = cloneDeeplyExcludesParent(x[key]);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">retv;</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">x;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Freezes a given value deeply.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} x A value to freeze.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Set&lt;Object&gt;} seenObjects Objects already seen during the traversal.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">freezeDeeply(x, seenObjects = </span><span class="s4">new </span><span class="s2">Set()) {</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">x === </span><span class="s3">&quot;object&quot; </span><span class="s2">&amp;&amp; x !== </span><span class="s4">null</span><span class="s2">) {</span>
		<span class="s4">if </span><span class="s2">(seenObjects.has(x)) {</span>
			<span class="s4">return</span><span class="s2">; </span><span class="s0">// skip to avoid infinite recursion</span>
		<span class="s2">}</span>
		<span class="s2">seenObjects.add(x);</span>

		<span class="s4">if </span><span class="s2">(Array.isArray(x)) {</span>
			<span class="s2">x.forEach(element =&gt; {</span>
				<span class="s2">freezeDeeply(element, seenObjects);</span>
			<span class="s2">});</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">key </span><span class="s4">in </span><span class="s2">x) {</span>
				<span class="s4">if </span><span class="s2">(key !== </span><span class="s3">&quot;parent&quot; </span><span class="s2">&amp;&amp; hasOwnProperty(x, key)) {</span>
					<span class="s2">freezeDeeply(x[key], seenObjects);</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
		<span class="s2">Object.freeze(x);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Replace control characters by `\u00xx` form.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} text The text to sanitize.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The sanitized text.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">sanitize(text) {</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">text !== </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
	<span class="s2">}</span>
	<span class="s4">return </span><span class="s2">text.replace(</span>
		<span class="s5">/[\u0000-\u0009\u000b-\u001a]/gu</span><span class="s2">, </span><span class="s0">// eslint-disable-line no-control-regex -- Escaping controls</span>
		<span class="s2">c =&gt; </span><span class="s3">`</span><span class="s6">\\</span><span class="s3">u</span><span class="s2">${c.codePointAt(</span><span class="s7">0</span><span class="s2">).toString(</span><span class="s7">16</span><span class="s2">).padStart(</span><span class="s7">4</span><span class="s2">, </span><span class="s3">&quot;0&quot;</span><span class="s2">)}</span><span class="s3">`</span><span class="s2">,</span>
	<span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Define `start`/`end` properties as throwing error.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} objName Object name used for error messages.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to define.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">defineStartEndAsError(objName, node) {</span>
	<span class="s2">Object.defineProperties(node, {</span>
		<span class="s2">start: {</span>
			<span class="s2">get() {</span>
				<span class="s4">throw new </span><span class="s2">Error(</span>
					<span class="s3">`Use </span><span class="s2">${objName}</span><span class="s3">.range[0] instead of </span><span class="s2">${objName}</span><span class="s3">.start`</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">},</span>
			<span class="s2">configurable: </span><span class="s4">true</span><span class="s2">,</span>
			<span class="s2">enumerable: </span><span class="s4">false</span><span class="s2">,</span>
		<span class="s2">},</span>
		<span class="s2">end: {</span>
			<span class="s2">get() {</span>
				<span class="s4">throw new </span><span class="s2">Error(</span>
					<span class="s3">`Use </span><span class="s2">${objName}</span><span class="s3">.range[1] instead of </span><span class="s2">${objName}</span><span class="s3">.end`</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">},</span>
			<span class="s2">configurable: </span><span class="s4">true</span><span class="s2">,</span>
			<span class="s2">enumerable: </span><span class="s4">false</span><span class="s2">,</span>
		<span class="s2">},</span>
	<span class="s2">});</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Define `start`/`end` properties of all nodes of the given AST as throwing error.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} ast The root node to errorize `start`/`end` properties.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} [visitorKeys] Visitor keys to be used for traversing the given ast.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">defineStartEndAsErrorInTree(ast, visitorKeys) {</span>
	<span class="s2">Traverser.traverse(ast, {</span>
		<span class="s2">visitorKeys,</span>
		<span class="s2">enter: defineStartEndAsError.bind(</span><span class="s4">null</span><span class="s2">, </span><span class="s3">&quot;node&quot;</span><span class="s2">),</span>
	<span class="s2">});</span>
	<span class="s2">ast.tokens.forEach(defineStartEndAsError.bind(</span><span class="s4">null</span><span class="s2">, </span><span class="s3">&quot;token&quot;</span><span class="s2">));</span>
	<span class="s2">ast.comments.forEach(defineStartEndAsError.bind(</span><span class="s4">null</span><span class="s2">, </span><span class="s3">&quot;token&quot;</span><span class="s2">));</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.</span>
 <span class="s0">* In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Parser} parser Parser object.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Parser} Wrapped parser object.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">wrapParser(parser) {</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">parser.parseForESLint === </span><span class="s3">&quot;function&quot;</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">[parserSymbol]: parser,</span>
			<span class="s2">parseForESLint(...args) {</span>
				<span class="s4">const </span><span class="s2">ret = parser.parseForESLint(...args);</span>

				<span class="s2">defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);</span>
				<span class="s4">return </span><span class="s2">ret;</span>
			<span class="s2">},</span>
		<span class="s2">};</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">{</span>
		<span class="s2">[parserSymbol]: parser,</span>
		<span class="s2">parse(...args) {</span>
			<span class="s4">const </span><span class="s2">ast = parser.parse(...args);</span>

			<span class="s2">defineStartEndAsErrorInTree(ast);</span>
			<span class="s4">return </span><span class="s2">ast;</span>
		<span class="s2">},</span>
	<span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Function to replace forbidden `SourceCode` methods. Allows just one call per method.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method to forbid.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} prototype The prototype with the original method to call.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Function} The function that throws the error.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">throwForbiddenMethodError(methodName, prototype) {</span>
	<span class="s4">const </span><span class="s2">original = prototype[methodName];</span>

	<span class="s4">return function </span><span class="s2">(...args) {</span>
		<span class="s4">const </span><span class="s2">called = forbiddenMethodCalls.get(methodName);</span>

		<span class="s0">/* eslint-disable no-invalid-this -- needed to operate as a method. */</span>
		<span class="s4">if </span><span class="s2">(!called.has(</span><span class="s4">this</span><span class="s2">)) {</span>
			<span class="s2">called.add(</span><span class="s4">this</span><span class="s2">);</span>

			<span class="s4">return </span><span class="s2">original.apply(</span><span class="s4">this</span><span class="s2">, args);</span>
		<span class="s2">}</span>
		<span class="s0">/* eslint-enable no-invalid-this -- not needed past this point */</span>

		<span class="s4">throw new </span><span class="s2">Error(</span>
			<span class="s3">`</span><span class="s6">\`</span><span class="s3">SourceCode#</span><span class="s2">${methodName}</span><span class="s3">()</span><span class="s6">\` </span><span class="s3">cannot be called inside a rule.`</span><span class="s2">,</span>
		<span class="s2">);</span>
	<span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Extracts names of {{ placeholders }} from the reported message.</span>
 <span class="s0">* </span><span class="s1">@param   </span><span class="s0">{string} message Reported message</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string[]} Array of placeholder names</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getMessagePlaceholders(message) {</span>
	<span class="s4">const </span><span class="s2">matcher = getPlaceholderMatcher();</span>

	<span class="s4">return </span><span class="s2">Array.from(message.matchAll(matcher), ([, name]) =&gt; name.trim());</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the placeholders in the reported messages but</span>
 <span class="s0">* only includes the placeholders available in the raw message and not in the provided data.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} message The reported message</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} raw The raw message specified in the rule meta.messages</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{undefined|Record&lt;unknown, unknown&gt;} data The passed</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string[]} Missing placeholder names</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getUnsubstitutedMessagePlaceholders(message, raw, data = {}) {</span>
	<span class="s4">const </span><span class="s2">unsubstituted = getMessagePlaceholders(message);</span>

	<span class="s4">if </span><span class="s2">(unsubstituted.length === </span><span class="s7">0</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">[];</span>
	<span class="s2">}</span>

	<span class="s0">// Remove false positives by only counting placeholders in the raw message, which were not provided in the data matcher or added with a data property</span>
	<span class="s4">const </span><span class="s2">known = getMessagePlaceholders(raw);</span>
	<span class="s4">const </span><span class="s2">provided = Object.keys(data);</span>

	<span class="s4">return </span><span class="s2">unsubstituted.filter(</span>
		<span class="s2">name =&gt; known.includes(name) &amp;&amp; !provided.includes(name),</span>
	<span class="s2">);</span>
<span class="s2">}</span>

<span class="s4">const </span><span class="s2">metaSchemaDescription = </span><span class="s3">`</span>
<span class="s6">\t</span><span class="s3">- If the rule has options, set </span><span class="s6">\`</span><span class="s3">meta.schema</span><span class="s6">\` </span><span class="s3">to an array or non-empty object to enable options validation. 
</span><span class="s6">\t</span><span class="s3">- If the rule doesn't have options, omit </span><span class="s6">\`</span><span class="s3">meta.schema</span><span class="s6">\` </span><span class="s3">to enforce that no options can be passed to the rule. 
</span><span class="s6">\t</span><span class="s3">- You can also set </span><span class="s6">\`</span><span class="s3">meta.schema</span><span class="s6">\` </span><span class="s3">to </span><span class="s6">\`</span><span class="s3">false</span><span class="s6">\` </span><span class="s3">to opt-out of options validation (not recommended). 
 
</span><span class="s6">\t</span><span class="s3">https://eslint.org/docs/latest/extend/custom-rules#options-schemas 
`</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Public Interface</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">// default separators for testing</span>
<span class="s4">const </span><span class="s2">DESCRIBE = Symbol(</span><span class="s3">&quot;describe&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">IT = Symbol(</span><span class="s3">&quot;it&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">IT_ONLY = Symbol(</span><span class="s3">&quot;itOnly&quot;</span><span class="s2">);</span>

<span class="s0">/**</span>
 <span class="s0">* This is `it` default handler if `it` don't exist.</span>
 <span class="s0">* </span><span class="s1">@this </span><span class="s0">{Mocha}</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} text The description of the test case.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} method The logic of the test case.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} Any error upon execution of `method`.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{any} Returned value of `method`.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">itDefaultHandler(text, method) {</span>
	<span class="s4">try </span><span class="s2">{</span>
		<span class="s4">return </span><span class="s2">method.call(</span><span class="s4">this</span><span class="s2">);</span>
	<span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {</span>
		<span class="s4">if </span><span class="s2">(err </span><span class="s4">instanceof </span><span class="s2">assert.AssertionError) {</span>
			<span class="s2">err.message += </span><span class="s3">` (</span><span class="s2">${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)}</span><span class="s3">)`</span><span class="s2">;</span>
		<span class="s2">}</span>
		<span class="s4">throw </span><span class="s2">err;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* This is `describe` default handler if `describe` don't exist.</span>
 <span class="s0">* </span><span class="s1">@this </span><span class="s0">{Mocha}</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} text The description of the test case.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} method The logic of the test case.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{any} Returned value of `method`.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">describeDefaultHandler(text, method) {</span>
	<span class="s4">return </span><span class="s2">method.call(</span><span class="s4">this</span><span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Mocha test wrapper.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">RuleTester {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance of RuleTester.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} [testerConfig] Optional, extra configuration for the tester</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(testerConfig = {}) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* The configuration to use for this tester. Combination of the tester</span>
		 <span class="s0">* configuration and the default configuration.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Object}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.testerConfig = [</span>
			<span class="s2">sharedDefaultConfig,</span>
			<span class="s2">testerConfig,</span>
			<span class="s2">{ rules: { </span><span class="s3">&quot;rule-tester/validate-ast&quot;</span><span class="s2">: </span><span class="s3">&quot;error&quot; </span><span class="s2">} },</span>
		<span class="s2">];</span>

		<span class="s4">this</span><span class="s2">.linter = </span><span class="s4">new </span><span class="s2">Linter({ configType: </span><span class="s3">&quot;flat&quot; </span><span class="s2">});</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Set the configuration to use for all future tests</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} config the configuration to use.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If non-object config.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s4">static </span><span class="s2">setDefaultConfig(config) {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">config !== </span><span class="s3">&quot;object&quot; </span><span class="s2">|| config === </span><span class="s4">null</span><span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">&quot;RuleTester.setDefaultConfig: config must be an object&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s2">sharedDefaultConfig = config;</span>

		<span class="s0">// Make sure the rules object exists since it is assumed to exist later</span>
		<span class="s2">sharedDefaultConfig.rules = sharedDefaultConfig.rules || {};</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Get the current configuration used for all tests</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} the current configuration</span>
	 <span class="s0">*/</span>
	<span class="s4">static </span><span class="s2">getDefaultConfig() {</span>
		<span class="s4">return </span><span class="s2">sharedDefaultConfig;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Reset the configuration to the initial configuration of the tester removing</span>
	 <span class="s0">* any changes made until now.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s4">static </span><span class="s2">resetDefaultConfig() {</span>
		<span class="s2">sharedDefaultConfig = {</span>
			<span class="s2">rules: {</span>
				<span class="s2">...testerDefaultConfig.rules,</span>
			<span class="s2">},</span>
		<span class="s2">};</span>
	<span class="s2">}</span>

	<span class="s0">/* 
     * If people use `mocha test.js --watch` command, `describe` and `it` function 
     * instances are different for each execution. So `describe` and `it` should get fresh instance 
     * always. 
     */</span>
	<span class="s4">static </span><span class="s2">get describe() {</span>
		<span class="s4">return </span><span class="s2">(</span>
			<span class="s4">this</span><span class="s2">[DESCRIBE] ||</span>
			<span class="s2">(</span><span class="s4">typeof </span><span class="s2">describe === </span><span class="s3">&quot;function&quot; </span><span class="s2">? describe : describeDefaultHandler)</span>
		<span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s4">static </span><span class="s2">set describe(value) {</span>
		<span class="s4">this</span><span class="s2">[DESCRIBE] = value;</span>
	<span class="s2">}</span>

	<span class="s4">static </span><span class="s2">get it() {</span>
		<span class="s4">return this</span><span class="s2">[IT] || (</span><span class="s4">typeof </span><span class="s2">it === </span><span class="s3">&quot;function&quot; </span><span class="s2">? it : itDefaultHandler);</span>
	<span class="s2">}</span>

	<span class="s4">static </span><span class="s2">set it(value) {</span>
		<span class="s4">this</span><span class="s2">[IT] = value;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Adds the `only` property to a test to run it in isolation.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string | ValidTestCase | InvalidTestCase} item A single test to run by itself.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ValidTestCase | InvalidTestCase} The test with `only` set.</span>
	 <span class="s0">*/</span>
	<span class="s4">static </span><span class="s2">only(item) {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">item === </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
			<span class="s4">return </span><span class="s2">{ code: item, only: </span><span class="s4">true </span><span class="s2">};</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">{ ...item, only: </span><span class="s4">true </span><span class="s2">};</span>
	<span class="s2">}</span>

	<span class="s4">static </span><span class="s2">get itOnly() {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof this</span><span class="s2">[IT_ONLY] === </span><span class="s3">&quot;function&quot;</span><span class="s2">) {</span>
			<span class="s4">return this</span><span class="s2">[IT_ONLY];</span>
		<span class="s2">}</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s4">typeof this</span><span class="s2">[IT] === </span><span class="s3">&quot;function&quot; </span><span class="s2">&amp;&amp;</span>
			<span class="s4">typeof this</span><span class="s2">[IT].only === </span><span class="s3">&quot;function&quot;</span>
		<span class="s2">) {</span>
			<span class="s4">return </span><span class="s2">Function.bind.call(</span><span class="s4">this</span><span class="s2">[IT].only, </span><span class="s4">this</span><span class="s2">[IT]);</span>
		<span class="s2">}</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">it === </span><span class="s3">&quot;function&quot; </span><span class="s2">&amp;&amp; </span><span class="s4">typeof </span><span class="s2">it.only === </span><span class="s3">&quot;function&quot;</span><span class="s2">) {</span>
			<span class="s4">return </span><span class="s2">Function.bind.call(it.only, it);</span>
		<span class="s2">}</span>

		<span class="s4">if </span><span class="s2">(</span>
			<span class="s4">typeof this</span><span class="s2">[DESCRIBE] === </span><span class="s3">&quot;function&quot; </span><span class="s2">||</span>
			<span class="s4">typeof this</span><span class="s2">[IT] === </span><span class="s3">&quot;function&quot;</span>
		<span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">Error(</span>
				<span class="s3">&quot;Set `RuleTester.itOnly` to use `only` with a custom test framework.</span><span class="s6">\n</span><span class="s3">&quot; </span><span class="s2">+</span>
					<span class="s3">&quot;See https://eslint.org/docs/latest/integrate/nodejs-api#customizing-ruletester for more.&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">it === </span><span class="s3">&quot;function&quot;</span><span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">Error(</span>
				<span class="s3">&quot;The current test framework does not support exclusive tests with `only`.&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s4">throw new </span><span class="s2">Error(</span>
			<span class="s3">&quot;To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.&quot;</span><span class="s2">,</span>
		<span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s4">static </span><span class="s2">set itOnly(value) {</span>
		<span class="s4">this</span><span class="s2">[IT_ONLY] = value;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Adds a new rule test to execute.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} ruleName The name of the rule to run.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RuleDefinition} rule The rule to test.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{{</span>
	 <span class="s0">*   valid: (ValidTestCase | string)[],</span>
	 <span class="s0">*   invalid: InvalidTestCase[]</span>
	 <span class="s0">* }} test The collection of tests to run.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError|Error} If `rule` is not an object with a `create` method,</span>
	 <span class="s0">* or if non-object `test`, or if a required scenario of the given type is missing.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">run(ruleName, rule, test) {</span>
		<span class="s4">const </span><span class="s2">testerConfig = </span><span class="s4">this</span><span class="s2">.testerConfig,</span>
			<span class="s2">requiredScenarios = [</span><span class="s3">&quot;valid&quot;</span><span class="s2">, </span><span class="s3">&quot;invalid&quot;</span><span class="s2">],</span>
			<span class="s2">scenarioErrors = [],</span>
			<span class="s2">linter = </span><span class="s4">this</span><span class="s2">.linter,</span>
			<span class="s2">ruleId = </span><span class="s3">`rule-to-test/</span><span class="s2">${ruleName}</span><span class="s3">`</span><span class="s2">;</span>

		<span class="s4">const </span><span class="s2">seenValidTestCases = </span><span class="s4">new </span><span class="s2">Set();</span>
		<span class="s4">const </span><span class="s2">seenInvalidTestCases = </span><span class="s4">new </span><span class="s2">Set();</span>

		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">!rule ||</span>
			<span class="s4">typeof </span><span class="s2">rule !== </span><span class="s3">&quot;object&quot; </span><span class="s2">||</span>
			<span class="s4">typeof </span><span class="s2">rule.create !== </span><span class="s3">&quot;function&quot;</span>
		<span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">&quot;Rule must be an object with a `create` method&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">if </span><span class="s2">(!test || </span><span class="s4">typeof </span><span class="s2">test !== </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">`Test Scenarios for rule </span><span class="s2">${ruleName} </span><span class="s3">: Could not find test scenario object`</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s2">requiredScenarios.forEach(scenarioType =&gt; {</span>
			<span class="s4">if </span><span class="s2">(!test[scenarioType]) {</span>
				<span class="s2">scenarioErrors.push(</span>
					<span class="s3">`Could not find any </span><span class="s2">${scenarioType} </span><span class="s3">test scenarios`</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">});</span>

		<span class="s4">if </span><span class="s2">(scenarioErrors.length &gt; </span><span class="s7">0</span><span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">Error(</span>
				<span class="s2">[</span><span class="s3">`Test Scenarios for rule </span><span class="s2">${ruleName} </span><span class="s3">is invalid:`</span><span class="s2">]</span>
					<span class="s2">.concat(scenarioErrors)</span>
					<span class="s2">.join(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">baseConfig = [</span>
			<span class="s2">{</span>
				<span class="s2">plugins: {</span>
					<span class="s0">// copy root plugin over</span>
					<span class="s3">&quot;@&quot;</span><span class="s2">: {</span>
						<span class="s0">/* 
                         * Parsers are wrapped to detect more errors, so this needs 
                         * to be a new object for each call to run(), otherwise the 
                         * parsers will be wrapped multiple times. 
                         */</span>
						<span class="s2">parsers: {</span>
							<span class="s2">...defaultConfig[</span><span class="s7">0</span><span class="s2">].plugins[</span><span class="s3">&quot;@&quot;</span><span class="s2">].parsers,</span>
						<span class="s2">},</span>

						<span class="s0">/* 
                         * The rules key on the default plugin is a proxy to lazy-load 
                         * just the rules that are needed. So, don't create a new object 
                         * here, just use the default one to keep that performance 
                         * enhancement. 
                         */</span>
						<span class="s2">rules: defaultConfig[</span><span class="s7">0</span><span class="s2">].plugins[</span><span class="s3">&quot;@&quot;</span><span class="s2">].rules,</span>
						<span class="s2">languages: defaultConfig[</span><span class="s7">0</span><span class="s2">].plugins[</span><span class="s3">&quot;@&quot;</span><span class="s2">].languages,</span>
					<span class="s2">},</span>
					<span class="s3">&quot;rule-to-test&quot;</span><span class="s2">: {</span>
						<span class="s2">rules: {</span>
							<span class="s2">[ruleName]: Object.assign({}, rule, {</span>
								<span class="s0">// Create a wrapper rule that freezes the `context` properties.</span>
								<span class="s2">create(context) {</span>
									<span class="s2">freezeDeeply(context.options);</span>
									<span class="s2">freezeDeeply(context.settings);</span>
									<span class="s2">freezeDeeply(context.parserOptions);</span>

									<span class="s0">// freezeDeeply(context.languageOptions);</span>

									<span class="s4">return </span><span class="s2">rule.create(context);</span>
								<span class="s2">},</span>
							<span class="s2">}),</span>
						<span class="s2">},</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
				<span class="s2">language: defaultConfig[</span><span class="s7">0</span><span class="s2">].language,</span>
			<span class="s2">},</span>
			<span class="s2">...defaultRuleTesterConfig,</span>
		<span class="s2">];</span>

		<span class="s0">/**</span>
		 <span class="s0">* Runs a hook on the given item when it's assigned to the given property</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|Object} item Item to run the hook on</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} prop The property having the hook assigned to</span>
		 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the property is not a function or that function throws an error</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">runHook(item, prop) {</span>
			<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">item === </span><span class="s3">&quot;object&quot; </span><span class="s2">&amp;&amp; hasOwnProperty(item, prop)) {</span>
				<span class="s2">assert.strictEqual(</span>
					<span class="s4">typeof </span><span class="s2">item[prop],</span>
					<span class="s3">&quot;function&quot;</span><span class="s2">,</span>
					<span class="s3">`Optional test case property '</span><span class="s2">${prop}</span><span class="s3">' must be a function`</span><span class="s2">,</span>
				<span class="s2">);</span>
				<span class="s2">item[prop]();</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Run the rule for the given item</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|Object} item Item to run the rule against</span>
		 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If an invalid schema.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} Eslint run result</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">runRuleForItem(item) {</span>
			<span class="s4">const </span><span class="s2">flatConfigArrayOptions = {</span>
				<span class="s2">baseConfig,</span>
			<span class="s2">};</span>

			<span class="s4">if </span><span class="s2">(item.filename) {</span>
				<span class="s2">flatConfigArrayOptions.basePath =</span>
					<span class="s2">path.parse(item.filename).root || </span><span class="s4">void </span><span class="s7">0</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">configs = </span><span class="s4">new </span><span class="s2">FlatConfigArray(</span>
				<span class="s2">testerConfig,</span>
				<span class="s2">flatConfigArrayOptions,</span>
			<span class="s2">);</span>

			<span class="s0">/* 
             * Modify the returned config so that the parser is wrapped to catch 
             * access of the start/end properties. This method is called just 
             * once per code snippet being tested, so each test case gets a clean 
             * parser. 
             */</span>
			<span class="s2">configs[ConfigArraySymbol.finalizeConfig] = </span><span class="s4">function </span><span class="s2">(...args) {</span>
				<span class="s0">// can't do super here :(</span>
				<span class="s4">const </span><span class="s2">proto = Object.getPrototypeOf(</span><span class="s4">this</span><span class="s2">);</span>
				<span class="s4">const </span><span class="s2">calculatedConfig = proto[</span>
					<span class="s2">ConfigArraySymbol.finalizeConfig</span>
				<span class="s2">].apply(</span><span class="s4">this</span><span class="s2">, args);</span>

				<span class="s0">// wrap the parser to catch start/end property access</span>
				<span class="s4">if </span><span class="s2">(calculatedConfig.language === jslang) {</span>
					<span class="s2">calculatedConfig.languageOptions.parser = wrapParser(</span>
						<span class="s2">calculatedConfig.languageOptions.parser,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s4">return </span><span class="s2">calculatedConfig;</span>
			<span class="s2">};</span>

			<span class="s4">let </span><span class="s2">code, filename, output, beforeAST, afterAST;</span>

			<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">item === </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
				<span class="s2">code = item;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">code = item.code;</span>

				<span class="s0">/* 
                 * Assumes everything on the item is a config except for the 
                 * parameters used by this tester 
                 */</span>
				<span class="s4">const </span><span class="s2">itemConfig = { ...item };</span>

				<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">parameter of RuleTesterParameters) {</span>
					<span class="s4">delete </span><span class="s2">itemConfig[parameter];</span>
				<span class="s2">}</span>

				<span class="s0">/* 
                 * Create the config object from the tester config and this item 
                 * specific configurations. 
                 */</span>
				<span class="s2">configs.push(itemConfig);</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(hasOwnProperty(item, </span><span class="s3">&quot;only&quot;</span><span class="s2">)) {</span>
				<span class="s2">assert.ok(</span>
					<span class="s4">typeof </span><span class="s2">item.only === </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
					<span class="s3">&quot;Optional test case property 'only' must be a boolean&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
			<span class="s4">if </span><span class="s2">(hasOwnProperty(item, </span><span class="s3">&quot;filename&quot;</span><span class="s2">)) {</span>
				<span class="s2">assert.ok(</span>
					<span class="s4">typeof </span><span class="s2">item.filename === </span><span class="s3">&quot;string&quot;</span><span class="s2">,</span>
					<span class="s3">&quot;Optional test case property 'filename' must be a string&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
				<span class="s2">filename = item.filename;</span>
			<span class="s2">}</span>

			<span class="s4">let </span><span class="s2">ruleConfig = </span><span class="s7">1</span><span class="s2">;</span>

			<span class="s4">if </span><span class="s2">(hasOwnProperty(item, </span><span class="s3">&quot;options&quot;</span><span class="s2">)) {</span>
				<span class="s2">assert(Array.isArray(item.options), </span><span class="s3">&quot;options must be an array&quot;</span><span class="s2">);</span>
				<span class="s2">ruleConfig = [</span><span class="s7">1</span><span class="s2">, ...item.options];</span>
			<span class="s2">}</span>

			<span class="s2">configs.push({</span>
				<span class="s2">rules: {</span>
					<span class="s2">[ruleId]: ruleConfig,</span>
				<span class="s2">},</span>
			<span class="s2">});</span>

			<span class="s4">let </span><span class="s2">schema;</span>

			<span class="s4">try </span><span class="s2">{</span>
				<span class="s2">schema = Config.getRuleOptionsSchema(rule);</span>
			<span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {</span>
				<span class="s2">err.message += metaSchemaDescription;</span>
				<span class="s4">throw </span><span class="s2">err;</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * Check and throw an error if the schema is an empty object (`schema:{}`), because such schema 
             * doesn't validate or enforce anything and is therefore considered a possible error. If the intent 
             * was to skip options validation, `schema:false` should be set instead (explicit opt-out). 
             * 
             * For this purpose, a schema object is considered empty if it doesn't have any own enumerable string-keyed 
             * properties. While `ajv.compile()` does use enumerable properties from the prototype chain as well, 
             * it caches compiled schemas by serializing only own enumerable properties, so it's generally not a good idea 
             * to use inherited properties in schemas because schemas that differ only in inherited properties would end up 
             * having the same cache entry that would be correct for only one of them. 
             * 
             * At this point, `schema` can only be an object or `null`. 
             */</span>
			<span class="s4">if </span><span class="s2">(schema &amp;&amp; Object.keys(schema).length === </span><span class="s7">0</span><span class="s2">) {</span>
				<span class="s4">throw new </span><span class="s2">Error(</span>
					<span class="s3">`</span><span class="s6">\`</span><span class="s3">schema: {}</span><span class="s6">\` </span><span class="s3">is a no-op</span><span class="s2">${metaSchemaDescription}</span><span class="s3">`</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * Setup AST getters. 
             * The goal is to check whether or not AST was modified when 
             * running the rule under test. 
             */</span>
			<span class="s2">configs.push({</span>
				<span class="s2">plugins: {</span>
					<span class="s3">&quot;rule-tester&quot;</span><span class="s2">: {</span>
						<span class="s2">rules: {</span>
							<span class="s3">&quot;validate-ast&quot;</span><span class="s2">: {</span>
								<span class="s2">create() {</span>
									<span class="s4">return </span><span class="s2">{</span>
										<span class="s2">Program(node) {</span>
											<span class="s2">beforeAST =</span>
												<span class="s2">cloneDeeplyExcludesParent(node);</span>
										<span class="s2">},</span>
										<span class="s3">&quot;Program:exit&quot;</span><span class="s2">(node) {</span>
											<span class="s2">afterAST = node;</span>
										<span class="s2">},</span>
									<span class="s2">};</span>
								<span class="s2">},</span>
							<span class="s2">},</span>
						<span class="s2">},</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
			<span class="s2">});</span>

			<span class="s4">if </span><span class="s2">(schema) {</span>
				<span class="s2">ajv.validateSchema(schema);</span>

				<span class="s4">if </span><span class="s2">(ajv.errors) {</span>
					<span class="s4">const </span><span class="s2">errors = ajv.errors</span>
						<span class="s2">.map(error =&gt; {</span>
							<span class="s4">const </span><span class="s2">field =</span>
								<span class="s2">error.dataPath[</span><span class="s7">0</span><span class="s2">] === </span><span class="s3">&quot;.&quot;</span>
									<span class="s2">? error.dataPath.slice(</span><span class="s7">1</span><span class="s2">)</span>
									<span class="s2">: error.dataPath;</span>

							<span class="s4">return </span><span class="s3">`</span><span class="s6">\t</span><span class="s2">${field}</span><span class="s3">: </span><span class="s2">${error.message}</span><span class="s3">`</span><span class="s2">;</span>
						<span class="s2">})</span>
						<span class="s2">.join(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">);</span>

					<span class="s4">throw new </span><span class="s2">Error([</span>
						<span class="s3">`Schema for rule </span><span class="s2">${ruleName} </span><span class="s3">is invalid:`</span><span class="s2">,</span>
						<span class="s2">errors,</span>
					<span class="s2">]);</span>
				<span class="s2">}</span>

				<span class="s0">/* 
                 * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a &quot;meta-schema&quot;), 
                 * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling 
                 * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result, 
                 * the schema is compiled here separately from checking for `validateSchema` errors. 
                 */</span>
				<span class="s4">try </span><span class="s2">{</span>
					<span class="s2">ajv.compile(schema);</span>
				<span class="s2">} </span><span class="s4">catch </span><span class="s2">(err) {</span>
					<span class="s4">throw new </span><span class="s2">Error(</span>
						<span class="s3">`Schema for rule </span><span class="s2">${ruleName} </span><span class="s3">is invalid: </span><span class="s2">${err.message}</span><span class="s3">`</span><span class="s2">,</span>
						<span class="s2">{</span>
							<span class="s2">cause: err,</span>
						<span class="s2">},</span>
					<span class="s2">);</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s0">// check for validation errors</span>
			<span class="s4">try </span><span class="s2">{</span>
				<span class="s2">configs.normalizeSync();</span>
				<span class="s2">configs.getConfig(</span><span class="s3">&quot;test.js&quot;</span><span class="s2">);</span>
			<span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
				<span class="s2">error.message = </span><span class="s3">`ESLint configuration in rule-tester is invalid: </span><span class="s2">${error.message}</span><span class="s3">`</span><span class="s2">;</span>
				<span class="s4">throw </span><span class="s2">error;</span>
			<span class="s2">}</span>

			<span class="s0">// Verify the code.</span>
			<span class="s4">const </span><span class="s2">{ applyLanguageOptions, applyInlineConfig, finalize } =</span>
				<span class="s2">SourceCode.prototype;</span>
			<span class="s4">let </span><span class="s2">messages;</span>

			<span class="s4">try </span><span class="s2">{</span>
				<span class="s2">forbiddenMethods.forEach(methodName =&gt; {</span>
					<span class="s2">SourceCode.prototype[methodName] =</span>
						<span class="s2">throwForbiddenMethodError(</span>
							<span class="s2">methodName,</span>
							<span class="s2">SourceCode.prototype,</span>
						<span class="s2">);</span>
				<span class="s2">});</span>

				<span class="s2">messages = linter.verify(code, configs, filename);</span>
			<span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
				<span class="s2">SourceCode.prototype.applyInlineConfig = applyInlineConfig;</span>
				<span class="s2">SourceCode.prototype.applyLanguageOptions =</span>
					<span class="s2">applyLanguageOptions;</span>
				<span class="s2">SourceCode.prototype.finalize = finalize;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">fatalErrorMessage = messages.find(m =&gt; m.fatal);</span>

			<span class="s2">assert(</span>
				<span class="s2">!fatalErrorMessage,</span>
				<span class="s3">`A fatal parsing error occurred: </span><span class="s2">${fatalErrorMessage &amp;&amp; fatalErrorMessage.message}</span><span class="s3">`</span><span class="s2">,</span>
			<span class="s2">);</span>

			<span class="s0">// Verify if autofix makes a syntax error or not.</span>
			<span class="s4">if </span><span class="s2">(messages.some(m =&gt; m.fix)) {</span>
				<span class="s2">output = SourceCodeFixer.applyFixes(code, messages).output;</span>
				<span class="s4">const </span><span class="s2">errorMessageInFix = linter</span>
					<span class="s2">.verify(output, configs, filename)</span>
					<span class="s2">.find(m =&gt; m.fatal);</span>

				<span class="s2">assert(</span>
					<span class="s2">!errorMessageInFix,</span>
					<span class="s2">[</span>
						<span class="s3">&quot;A fatal parsing error occurred in autofix.&quot;</span><span class="s2">,</span>
						<span class="s3">`Error: </span><span class="s2">${errorMessageInFix &amp;&amp; errorMessageInFix.message}</span><span class="s3">`</span><span class="s2">,</span>
						<span class="s3">&quot;Autofix output:&quot;</span><span class="s2">,</span>
						<span class="s2">output,</span>
					<span class="s2">].join(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
				<span class="s2">);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">output = code;</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">{</span>
				<span class="s2">messages,</span>
				<span class="s2">output,</span>
				<span class="s2">beforeAST,</span>
				<span class="s2">afterAST: cloneDeeplyExcludesParent(afterAST),</span>
				<span class="s2">configs,</span>
				<span class="s2">filename,</span>
			<span class="s2">};</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check if the AST was changed</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} beforeAST AST node before running</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} afterAST AST node after running</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">assertASTDidntChange(beforeAST, afterAST) {</span>
			<span class="s4">if </span><span class="s2">(!equal(beforeAST, afterAST)) {</span>
				<span class="s2">assert.fail(</span><span class="s3">&quot;Rule should not modify AST.&quot;</span><span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check if this test case is a duplicate of one we have seen before.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|Object} item test case object</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Set&lt;string&gt;} seenTestCases set of serialized test cases we have seen so far (managed by this function)</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkDuplicateTestCase(item, seenTestCases) {</span>
			<span class="s4">if </span><span class="s2">(!isSerializable(item)) {</span>
				<span class="s0">/* 
                 * If we can't serialize a test case (because it contains a function, RegExp, etc), skip the check. 
                 * This might happen with properties like: options, plugins, settings, languageOptions.parser, languageOptions.parserOptions. 
                 */</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">normalizedItem =</span>
				<span class="s4">typeof </span><span class="s2">item === </span><span class="s3">&quot;string&quot; </span><span class="s2">? { code: item } : item;</span>
			<span class="s4">const </span><span class="s2">serializedTestCase = stringify(normalizedItem, {</span>
				<span class="s2">replacer(key, value) {</span>
					<span class="s0">// &quot;this&quot; is the currently stringified object --&gt; only ignore top-level properties</span>
					<span class="s4">return </span><span class="s2">normalizedItem !== </span><span class="s4">this </span><span class="s2">||</span>
						<span class="s2">!duplicationIgnoredParameters.has(key)</span>
						<span class="s2">? value</span>
						<span class="s2">: </span><span class="s4">void </span><span class="s7">0</span><span class="s2">;</span>
				<span class="s2">},</span>
			<span class="s2">});</span>

			<span class="s2">assert(</span>
				<span class="s2">!seenTestCases.has(serializedTestCase),</span>
				<span class="s3">&quot;detected duplicate test case&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
			<span class="s2">seenTestCases.add(serializedTestCase);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check if the template is valid or not</span>
		 <span class="s0">* all valid cases go through this</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|Object} item Item to run the rule against</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">testValidTemplate(item) {</span>
			<span class="s4">const </span><span class="s2">code = </span><span class="s4">typeof </span><span class="s2">item === </span><span class="s3">&quot;object&quot; </span><span class="s2">? item.code : item;</span>

			<span class="s2">assert.ok(</span>
				<span class="s4">typeof </span><span class="s2">code === </span><span class="s3">&quot;string&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;Test case must specify a string value for 'code'&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
			<span class="s4">if </span><span class="s2">(item.name) {</span>
				<span class="s2">assert.ok(</span>
					<span class="s4">typeof </span><span class="s2">item.name === </span><span class="s3">&quot;string&quot;</span><span class="s2">,</span>
					<span class="s3">&quot;Optional test case property 'name' must be a string&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s2">checkDuplicateTestCase(item, seenValidTestCases);</span>

			<span class="s4">const </span><span class="s2">result = runRuleForItem(item);</span>
			<span class="s4">const </span><span class="s2">messages = result.messages;</span>

			<span class="s2">assert.strictEqual(</span>
				<span class="s2">messages.length,</span>
				<span class="s7">0</span><span class="s2">,</span>
				<span class="s2">util.format(</span>
					<span class="s3">&quot;Should have no errors but had %d: %s&quot;</span><span class="s2">,</span>
					<span class="s2">messages.length,</span>
					<span class="s2">util.inspect(messages),</span>
				<span class="s2">),</span>
			<span class="s2">);</span>

			<span class="s2">assertASTDidntChange(result.beforeAST, result.afterAST);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Asserts that the message matches its expected value. If the expected</span>
		 <span class="s0">* value is a regular expression, it is checked against the actual</span>
		 <span class="s0">* value.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} actual Actual value</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|RegExp} expected Expected value</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">assertMessageMatches(actual, expected) {</span>
			<span class="s4">if </span><span class="s2">(expected </span><span class="s4">instanceof </span><span class="s2">RegExp) {</span>
				<span class="s0">// assert.js doesn't have a built-in RegExp match function</span>
				<span class="s2">assert.ok(</span>
					<span class="s2">expected.test(actual),</span>
					<span class="s3">`Expected '</span><span class="s2">${actual}</span><span class="s3">' to match </span><span class="s2">${expected}</span><span class="s3">`</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">assert.strictEqual(actual, expected);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check if the template is invalid or not</span>
		 <span class="s0">* all invalid cases go through this.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|Object} item Item to run the rule against</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">testInvalidTemplate(item) {</span>
			<span class="s2">assert.ok(</span>
				<span class="s4">typeof </span><span class="s2">item.code === </span><span class="s3">&quot;string&quot;</span><span class="s2">,</span>
				<span class="s3">&quot;Test case must specify a string value for 'code'&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
			<span class="s4">if </span><span class="s2">(item.name) {</span>
				<span class="s2">assert.ok(</span>
					<span class="s4">typeof </span><span class="s2">item.name === </span><span class="s3">&quot;string&quot;</span><span class="s2">,</span>
					<span class="s3">&quot;Optional test case property 'name' must be a string&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
			<span class="s2">assert.ok(</span>
				<span class="s2">item.errors || item.errors === </span><span class="s7">0</span><span class="s2">,</span>
				<span class="s3">`Did not specify errors for an invalid test of </span><span class="s2">${ruleName}</span><span class="s3">`</span><span class="s2">,</span>
			<span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(Array.isArray(item.errors) &amp;&amp; item.errors.length === </span><span class="s7">0</span><span class="s2">) {</span>
				<span class="s2">assert.fail(</span><span class="s3">&quot;Invalid cases must have at least one error&quot;</span><span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s2">checkDuplicateTestCase(item, seenInvalidTestCases);</span>

			<span class="s4">const </span><span class="s2">ruleHasMetaMessages =</span>
				<span class="s2">hasOwnProperty(rule, </span><span class="s3">&quot;meta&quot;</span><span class="s2">) &amp;&amp;</span>
				<span class="s2">hasOwnProperty(rule.meta, </span><span class="s3">&quot;messages&quot;</span><span class="s2">);</span>
			<span class="s4">const </span><span class="s2">friendlyIDList = ruleHasMetaMessages</span>
				<span class="s2">? </span><span class="s3">`[</span><span class="s2">${Object.keys(rule.meta.messages)</span>
						<span class="s2">.map(key =&gt; </span><span class="s3">`'</span><span class="s2">${key}</span><span class="s3">'`</span><span class="s2">)</span>
						<span class="s2">.join(</span><span class="s3">&quot;, &quot;</span><span class="s2">)}</span><span class="s3">]`</span>
				<span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>

			<span class="s4">const </span><span class="s2">result = runRuleForItem(item);</span>
			<span class="s4">const </span><span class="s2">messages = result.messages;</span>

			<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">message of messages) {</span>
				<span class="s4">if </span><span class="s2">(hasOwnProperty(message, </span><span class="s3">&quot;suggestions&quot;</span><span class="s2">)) {</span>
					<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{Map&lt;string, number&gt;} */</span>
					<span class="s4">const </span><span class="s2">seenMessageIndices = </span><span class="s4">new </span><span class="s2">Map();</span>

					<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s7">0</span><span class="s2">; i &lt; message.suggestions.length; i += </span><span class="s7">1</span><span class="s2">) {</span>
						<span class="s4">const </span><span class="s2">suggestionMessage = message.suggestions[i].desc;</span>
						<span class="s4">const </span><span class="s2">previous =</span>
							<span class="s2">seenMessageIndices.get(suggestionMessage);</span>

						<span class="s2">assert.ok(</span>
							<span class="s2">!seenMessageIndices.has(suggestionMessage),</span>
							<span class="s3">`Suggestion message '</span><span class="s2">${suggestionMessage}</span><span class="s3">' reported from suggestion </span><span class="s2">${i} </span><span class="s3">was previously reported by suggestion </span><span class="s2">${previous}</span><span class="s3">. Suggestion messages should be unique within an error.`</span><span class="s2">,</span>
						<span class="s2">);</span>
						<span class="s2">seenMessageIndices.set(suggestionMessage, i);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">item.errors === </span><span class="s3">&quot;number&quot;</span><span class="s2">) {</span>
				<span class="s4">if </span><span class="s2">(item.errors === </span><span class="s7">0</span><span class="s2">) {</span>
					<span class="s2">assert.fail(</span>
						<span class="s3">&quot;Invalid cases must have 'error' value greater than 0&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s2">assert.strictEqual(</span>
					<span class="s2">messages.length,</span>
					<span class="s2">item.errors,</span>
					<span class="s2">util.format(</span>
						<span class="s3">&quot;Should have %d error%s but had %d: %s&quot;</span><span class="s2">,</span>
						<span class="s2">item.errors,</span>
						<span class="s2">item.errors === </span><span class="s7">1 </span><span class="s2">? </span><span class="s3">&quot;&quot; </span><span class="s2">: </span><span class="s3">&quot;s&quot;</span><span class="s2">,</span>
						<span class="s2">messages.length,</span>
						<span class="s2">util.inspect(messages),</span>
					<span class="s2">),</span>
				<span class="s2">);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">assert.strictEqual(</span>
					<span class="s2">messages.length,</span>
					<span class="s2">item.errors.length,</span>
					<span class="s2">util.format(</span>
						<span class="s3">&quot;Should have %d error%s but had %d: %s&quot;</span><span class="s2">,</span>
						<span class="s2">item.errors.length,</span>
						<span class="s2">item.errors.length === </span><span class="s7">1 </span><span class="s2">? </span><span class="s3">&quot;&quot; </span><span class="s2">: </span><span class="s3">&quot;s&quot;</span><span class="s2">,</span>
						<span class="s2">messages.length,</span>
						<span class="s2">util.inspect(messages),</span>
					<span class="s2">),</span>
				<span class="s2">);</span>

				<span class="s4">const </span><span class="s2">hasMessageOfThisRule = messages.some(</span>
					<span class="s2">m =&gt; m.ruleId === ruleId,</span>
				<span class="s2">);</span>

				<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s7">0</span><span class="s2">, l = item.errors.length; i &lt; l; i++) {</span>
					<span class="s4">const </span><span class="s2">error = item.errors[i];</span>
					<span class="s4">const </span><span class="s2">message = messages[i];</span>

					<span class="s2">assert(</span>
						<span class="s2">hasMessageOfThisRule,</span>
						<span class="s3">&quot;Error rule name should be the same as the name of the rule being tested&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>

					<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">error === </span><span class="s3">&quot;string&quot; </span><span class="s2">|| error </span><span class="s4">instanceof </span><span class="s2">RegExp) {</span>
						<span class="s0">// Just an error message.</span>
						<span class="s2">assertMessageMatches(message.message, error);</span>
						<span class="s2">assert.ok(</span>
							<span class="s2">message.suggestions === </span><span class="s4">void </span><span class="s7">0</span><span class="s2">,</span>
							<span class="s3">`Error at index </span><span class="s2">${i} </span><span class="s3">has suggestions. Please convert the test error into an object and specify 'suggestions' property on it to test suggestions.`</span><span class="s2">,</span>
						<span class="s2">);</span>
					<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">error === </span><span class="s3">&quot;object&quot; </span><span class="s2">&amp;&amp; error !== </span><span class="s4">null</span><span class="s2">) {</span>
						<span class="s0">/* 
                         * Error object. 
                         * This may have a message, messageId, data, node type, line, and/or 
                         * column. 
                         */</span>

						<span class="s2">Object.keys(error).forEach(propertyName =&gt; {</span>
							<span class="s2">assert.ok(</span>
								<span class="s2">errorObjectParameters.has(propertyName),</span>
								<span class="s3">`Invalid error property name '</span><span class="s2">${propertyName}</span><span class="s3">'. Expected one of </span><span class="s2">${friendlyErrorObjectParameterList}</span><span class="s3">.`</span><span class="s2">,</span>
							<span class="s2">);</span>
						<span class="s2">});</span>

						<span class="s4">if </span><span class="s2">(hasOwnProperty(error, </span><span class="s3">&quot;message&quot;</span><span class="s2">)) {</span>
							<span class="s2">assert.ok(</span>
								<span class="s2">!hasOwnProperty(error, </span><span class="s3">&quot;messageId&quot;</span><span class="s2">),</span>
								<span class="s3">&quot;Error should not specify both 'message' and a 'messageId'.&quot;</span><span class="s2">,</span>
							<span class="s2">);</span>
							<span class="s2">assert.ok(</span>
								<span class="s2">!hasOwnProperty(error, </span><span class="s3">&quot;data&quot;</span><span class="s2">),</span>
								<span class="s3">&quot;Error should not specify both 'data' and 'message'.&quot;</span><span class="s2">,</span>
							<span class="s2">);</span>
							<span class="s2">assertMessageMatches(</span>
								<span class="s2">message.message,</span>
								<span class="s2">error.message,</span>
							<span class="s2">);</span>
						<span class="s2">} </span><span class="s4">else if </span><span class="s2">(hasOwnProperty(error, </span><span class="s3">&quot;messageId&quot;</span><span class="s2">)) {</span>
							<span class="s2">assert.ok(</span>
								<span class="s2">ruleHasMetaMessages,</span>
								<span class="s3">&quot;Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.&quot;</span><span class="s2">,</span>
							<span class="s2">);</span>
							<span class="s4">if </span><span class="s2">(</span>
								<span class="s2">!hasOwnProperty(</span>
									<span class="s2">rule.meta.messages,</span>
									<span class="s2">error.messageId,</span>
								<span class="s2">)</span>
							<span class="s2">) {</span>
								<span class="s2">assert(</span>
									<span class="s4">false</span><span class="s2">,</span>
									<span class="s3">`Invalid messageId '</span><span class="s2">${error.messageId}</span><span class="s3">'. Expected one of </span><span class="s2">${friendlyIDList}</span><span class="s3">.`</span><span class="s2">,</span>
								<span class="s2">);</span>
							<span class="s2">}</span>
							<span class="s2">assert.strictEqual(</span>
								<span class="s2">message.messageId,</span>
								<span class="s2">error.messageId,</span>
								<span class="s3">`messageId '</span><span class="s2">${message.messageId}</span><span class="s3">' does not match expected messageId '</span><span class="s2">${error.messageId}</span><span class="s3">'.`</span><span class="s2">,</span>
							<span class="s2">);</span>

							<span class="s4">const </span><span class="s2">unsubstitutedPlaceholders =</span>
								<span class="s2">getUnsubstitutedMessagePlaceholders(</span>
									<span class="s2">message.message,</span>
									<span class="s2">rule.meta.messages[message.messageId],</span>
									<span class="s2">error.data,</span>
								<span class="s2">);</span>

							<span class="s2">assert.ok(</span>
								<span class="s2">unsubstitutedPlaceholders.length === </span><span class="s7">0</span><span class="s2">,</span>
								<span class="s3">`The reported message has </span><span class="s2">${unsubstitutedPlaceholders.length &gt; </span><span class="s7">1 </span><span class="s2">? </span><span class="s3">`unsubstituted placeholders: </span><span class="s2">${unsubstitutedPlaceholders.map(name =&gt; </span><span class="s3">`'</span><span class="s2">${name}</span><span class="s3">'`</span><span class="s2">).join(</span><span class="s3">&quot;, &quot;</span><span class="s2">)}</span><span class="s3">` </span><span class="s2">: </span><span class="s3">`an unsubstituted placeholder '</span><span class="s2">${unsubstitutedPlaceholders[</span><span class="s7">0</span><span class="s2">]}</span><span class="s3">'`</span><span class="s2">}</span><span class="s3">. Please provide the missing </span><span class="s2">${unsubstitutedPlaceholders.length &gt; </span><span class="s7">1 </span><span class="s2">? </span><span class="s3">&quot;values&quot; </span><span class="s2">: </span><span class="s3">&quot;value&quot;</span><span class="s2">} </span><span class="s3">via the 'data' property in the context.report() call.`</span><span class="s2">,</span>
							<span class="s2">);</span>

							<span class="s4">if </span><span class="s2">(hasOwnProperty(error, </span><span class="s3">&quot;data&quot;</span><span class="s2">)) {</span>
								<span class="s0">/* 
                                 *  if data was provided, then directly compare the returned message to a synthetic 
                                 *  interpolated message using the same message ID and data provided in the test. 
                                 *  See https://github.com/eslint/eslint/issues/9890 for context. 
                                 */</span>
								<span class="s4">const </span><span class="s2">unformattedOriginalMessage =</span>
									<span class="s2">rule.meta.messages[error.messageId];</span>
								<span class="s4">const </span><span class="s2">rehydratedMessage = interpolate(</span>
									<span class="s2">unformattedOriginalMessage,</span>
									<span class="s2">error.data,</span>
								<span class="s2">);</span>

								<span class="s2">assert.strictEqual(</span>
									<span class="s2">message.message,</span>
									<span class="s2">rehydratedMessage,</span>
									<span class="s3">`Hydrated message &quot;</span><span class="s2">${rehydratedMessage}</span><span class="s3">&quot; does not match &quot;</span><span class="s2">${message.message}</span><span class="s3">&quot;`</span><span class="s2">,</span>
								<span class="s2">);</span>
							<span class="s2">}</span>
						<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
							<span class="s2">assert.fail(</span>
								<span class="s3">&quot;Test error must specify either a 'messageId' or 'message'.&quot;</span><span class="s2">,</span>
							<span class="s2">);</span>
						<span class="s2">}</span>

						<span class="s4">if </span><span class="s2">(error.type) {</span>
							<span class="s2">assert.strictEqual(</span>
								<span class="s2">message.nodeType,</span>
								<span class="s2">error.type,</span>
								<span class="s3">`Error type should be </span><span class="s2">${error.type}</span><span class="s3">, found </span><span class="s2">${message.nodeType}</span><span class="s3">`</span><span class="s2">,</span>
							<span class="s2">);</span>
						<span class="s2">}</span>

						<span class="s4">const </span><span class="s2">actualLocation = {};</span>
						<span class="s4">const </span><span class="s2">expectedLocation = {};</span>

						<span class="s4">if </span><span class="s2">(hasOwnProperty(error, </span><span class="s3">&quot;line&quot;</span><span class="s2">)) {</span>
							<span class="s2">actualLocation.line = message.line;</span>
							<span class="s2">expectedLocation.line = error.line;</span>
						<span class="s2">}</span>

						<span class="s4">if </span><span class="s2">(hasOwnProperty(error, </span><span class="s3">&quot;column&quot;</span><span class="s2">)) {</span>
							<span class="s2">actualLocation.column = message.column;</span>
							<span class="s2">expectedLocation.column = error.column;</span>
						<span class="s2">}</span>

						<span class="s4">if </span><span class="s2">(hasOwnProperty(error, </span><span class="s3">&quot;endLine&quot;</span><span class="s2">)) {</span>
							<span class="s2">actualLocation.endLine = message.endLine;</span>
							<span class="s2">expectedLocation.endLine = error.endLine;</span>
						<span class="s2">}</span>

						<span class="s4">if </span><span class="s2">(hasOwnProperty(error, </span><span class="s3">&quot;endColumn&quot;</span><span class="s2">)) {</span>
							<span class="s2">actualLocation.endColumn = message.endColumn;</span>
							<span class="s2">expectedLocation.endColumn = error.endColumn;</span>
						<span class="s2">}</span>

						<span class="s4">if </span><span class="s2">(Object.keys(expectedLocation).length &gt; </span><span class="s7">0</span><span class="s2">) {</span>
							<span class="s2">assert.deepStrictEqual(</span>
								<span class="s2">actualLocation,</span>
								<span class="s2">expectedLocation,</span>
								<span class="s3">&quot;Actual error location does not match expected error location.&quot;</span><span class="s2">,</span>
							<span class="s2">);</span>
						<span class="s2">}</span>

						<span class="s2">assert.ok(</span>
							<span class="s2">!message.suggestions ||</span>
								<span class="s2">hasOwnProperty(error, </span><span class="s3">&quot;suggestions&quot;</span><span class="s2">),</span>
							<span class="s3">`Error at index </span><span class="s2">${i} </span><span class="s3">has suggestions. Please specify 'suggestions' property on the test error object.`</span><span class="s2">,</span>
						<span class="s2">);</span>
						<span class="s4">if </span><span class="s2">(hasOwnProperty(error, </span><span class="s3">&quot;suggestions&quot;</span><span class="s2">)) {</span>
							<span class="s0">// Support asserting there are no suggestions</span>
							<span class="s4">const </span><span class="s2">expectsSuggestions = Array.isArray(</span>
								<span class="s2">error.suggestions,</span>
							<span class="s2">)</span>
								<span class="s2">? error.suggestions.length &gt; </span><span class="s7">0</span>
								<span class="s2">: Boolean(error.suggestions);</span>
							<span class="s4">const </span><span class="s2">hasSuggestions =</span>
								<span class="s2">message.suggestions !== </span><span class="s4">void </span><span class="s7">0</span><span class="s2">;</span>

							<span class="s4">if </span><span class="s2">(!hasSuggestions &amp;&amp; expectsSuggestions) {</span>
								<span class="s2">assert.ok(</span>
									<span class="s2">!error.suggestions,</span>
									<span class="s3">`Error should have suggestions on error with message: &quot;</span><span class="s2">${message.message}</span><span class="s3">&quot;`</span><span class="s2">,</span>
								<span class="s2">);</span>
							<span class="s2">} </span><span class="s4">else if </span><span class="s2">(hasSuggestions) {</span>
								<span class="s2">assert.ok(</span>
									<span class="s2">expectsSuggestions,</span>
									<span class="s3">`Error should have no suggestions on error with message: &quot;</span><span class="s2">${message.message}</span><span class="s3">&quot;`</span><span class="s2">,</span>
								<span class="s2">);</span>
								<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">error.suggestions === </span><span class="s3">&quot;number&quot;</span><span class="s2">) {</span>
									<span class="s2">assert.strictEqual(</span>
										<span class="s2">message.suggestions.length,</span>
										<span class="s2">error.suggestions,</span>
										<span class="s3">`Error should have </span><span class="s2">${error.suggestions} </span><span class="s3">suggestions. Instead found </span><span class="s2">${message.suggestions.length} </span><span class="s3">suggestions`</span><span class="s2">,</span>
									<span class="s2">);</span>
								<span class="s2">} </span><span class="s4">else if </span><span class="s2">(Array.isArray(error.suggestions)) {</span>
									<span class="s2">assert.strictEqual(</span>
										<span class="s2">message.suggestions.length,</span>
										<span class="s2">error.suggestions.length,</span>
										<span class="s3">`Error should have </span><span class="s2">${error.suggestions.length} </span><span class="s3">suggestions. Instead found </span><span class="s2">${message.suggestions.length} </span><span class="s3">suggestions`</span><span class="s2">,</span>
									<span class="s2">);</span>

									<span class="s2">error.suggestions.forEach(</span>
										<span class="s2">(expectedSuggestion, index) =&gt; {</span>
											<span class="s2">assert.ok(</span>
												<span class="s4">typeof </span><span class="s2">expectedSuggestion ===</span>
													<span class="s3">&quot;object&quot; </span><span class="s2">&amp;&amp;</span>
													<span class="s2">expectedSuggestion !== </span><span class="s4">null</span><span class="s2">,</span>
												<span class="s3">&quot;Test suggestion in 'suggestions' array must be an object.&quot;</span><span class="s2">,</span>
											<span class="s2">);</span>
											<span class="s2">Object.keys(</span>
												<span class="s2">expectedSuggestion,</span>
											<span class="s2">).forEach(propertyName =&gt; {</span>
												<span class="s2">assert.ok(</span>
													<span class="s2">suggestionObjectParameters.has(</span>
														<span class="s2">propertyName,</span>
													<span class="s2">),</span>
													<span class="s3">`Invalid suggestion property name '</span><span class="s2">${propertyName}</span><span class="s3">'. Expected one of </span><span class="s2">${friendlySuggestionObjectParameterList}</span><span class="s3">.`</span><span class="s2">,</span>
												<span class="s2">);</span>
											<span class="s2">});</span>

											<span class="s4">const </span><span class="s2">actualSuggestion =</span>
												<span class="s2">message.suggestions[index];</span>
											<span class="s4">const </span><span class="s2">suggestionPrefix = </span><span class="s3">`Error Suggestion at index </span><span class="s2">${index}</span><span class="s3">:`</span><span class="s2">;</span>

											<span class="s4">if </span><span class="s2">(</span>
												<span class="s2">hasOwnProperty(</span>
													<span class="s2">expectedSuggestion,</span>
													<span class="s3">&quot;desc&quot;</span><span class="s2">,</span>
												<span class="s2">)</span>
											<span class="s2">) {</span>
												<span class="s2">assert.ok(</span>
													<span class="s2">!hasOwnProperty(</span>
														<span class="s2">expectedSuggestion,</span>
														<span class="s3">&quot;data&quot;</span><span class="s2">,</span>
													<span class="s2">),</span>
													<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">Test should not specify both 'desc' and 'data'.`</span><span class="s2">,</span>
												<span class="s2">);</span>
												<span class="s2">assert.ok(</span>
													<span class="s2">!hasOwnProperty(</span>
														<span class="s2">expectedSuggestion,</span>
														<span class="s3">&quot;messageId&quot;</span><span class="s2">,</span>
													<span class="s2">),</span>
													<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">Test should not specify both 'desc' and 'messageId'.`</span><span class="s2">,</span>
												<span class="s2">);</span>
												<span class="s2">assert.strictEqual(</span>
													<span class="s2">actualSuggestion.desc,</span>
													<span class="s2">expectedSuggestion.desc,</span>
													<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">desc should be &quot;</span><span class="s2">${expectedSuggestion.desc}</span><span class="s3">&quot; but got &quot;</span><span class="s2">${actualSuggestion.desc}</span><span class="s3">&quot; instead.`</span><span class="s2">,</span>
												<span class="s2">);</span>
											<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
												<span class="s2">hasOwnProperty(</span>
													<span class="s2">expectedSuggestion,</span>
													<span class="s3">&quot;messageId&quot;</span><span class="s2">,</span>
												<span class="s2">)</span>
											<span class="s2">) {</span>
												<span class="s2">assert.ok(</span>
													<span class="s2">ruleHasMetaMessages,</span>
													<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`</span><span class="s2">,</span>
												<span class="s2">);</span>
												<span class="s2">assert.ok(</span>
													<span class="s2">hasOwnProperty(</span>
														<span class="s2">rule.meta.messages,</span>
														<span class="s2">expectedSuggestion.messageId,</span>
													<span class="s2">),</span>
													<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">Test has invalid messageId '</span><span class="s2">${expectedSuggestion.messageId}</span><span class="s3">', the rule under test allows only one of </span><span class="s2">${friendlyIDList}</span><span class="s3">.`</span><span class="s2">,</span>
												<span class="s2">);</span>
												<span class="s2">assert.strictEqual(</span>
													<span class="s2">actualSuggestion.messageId,</span>
													<span class="s2">expectedSuggestion.messageId,</span>
													<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">messageId should be '</span><span class="s2">${expectedSuggestion.messageId}</span><span class="s3">' but got '</span><span class="s2">${actualSuggestion.messageId}</span><span class="s3">' instead.`</span><span class="s2">,</span>
												<span class="s2">);</span>

												<span class="s4">const </span><span class="s2">unsubstitutedPlaceholders =</span>
													<span class="s2">getUnsubstitutedMessagePlaceholders(</span>
														<span class="s2">actualSuggestion.desc,</span>
														<span class="s2">rule.meta.messages[</span>
															<span class="s2">expectedSuggestion</span>
																<span class="s2">.messageId</span>
														<span class="s2">],</span>
														<span class="s2">expectedSuggestion.data,</span>
													<span class="s2">);</span>

												<span class="s2">assert.ok(</span>
													<span class="s2">unsubstitutedPlaceholders.length ===</span>
														<span class="s7">0</span><span class="s2">,</span>
													<span class="s3">`The message of the suggestion has </span><span class="s2">${unsubstitutedPlaceholders.length &gt; </span><span class="s7">1 </span><span class="s2">? </span><span class="s3">`unsubstituted placeholders: </span><span class="s2">${unsubstitutedPlaceholders.map(name =&gt; </span><span class="s3">`'</span><span class="s2">${name}</span><span class="s3">'`</span><span class="s2">).join(</span><span class="s3">&quot;, &quot;</span><span class="s2">)}</span><span class="s3">` </span><span class="s2">: </span><span class="s3">`an unsubstituted placeholder '</span><span class="s2">${unsubstitutedPlaceholders[</span><span class="s7">0</span><span class="s2">]}</span><span class="s3">'`</span><span class="s2">}</span><span class="s3">. Please provide the missing </span><span class="s2">${unsubstitutedPlaceholders.length &gt; </span><span class="s7">1 </span><span class="s2">? </span><span class="s3">&quot;values&quot; </span><span class="s2">: </span><span class="s3">&quot;value&quot;</span><span class="s2">} </span><span class="s3">via the 'data' property for the suggestion in the context.report() call.`</span><span class="s2">,</span>
												<span class="s2">);</span>

												<span class="s4">if </span><span class="s2">(</span>
													<span class="s2">hasOwnProperty(</span>
														<span class="s2">expectedSuggestion,</span>
														<span class="s3">&quot;data&quot;</span><span class="s2">,</span>
													<span class="s2">)</span>
												<span class="s2">) {</span>
													<span class="s4">const </span><span class="s2">unformattedMetaMessage =</span>
														<span class="s2">rule.meta.messages[</span>
															<span class="s2">expectedSuggestion</span>
																<span class="s2">.messageId</span>
														<span class="s2">];</span>
													<span class="s4">const </span><span class="s2">rehydratedDesc =</span>
														<span class="s2">interpolate(</span>
															<span class="s2">unformattedMetaMessage,</span>
															<span class="s2">expectedSuggestion.data,</span>
														<span class="s2">);</span>

													<span class="s2">assert.strictEqual(</span>
														<span class="s2">actualSuggestion.desc,</span>
														<span class="s2">rehydratedDesc,</span>
														<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">Hydrated test desc &quot;</span><span class="s2">${rehydratedDesc}</span><span class="s3">&quot; does not match received desc &quot;</span><span class="s2">${actualSuggestion.desc}</span><span class="s3">&quot;.`</span><span class="s2">,</span>
													<span class="s2">);</span>
												<span class="s2">}</span>
											<span class="s2">} </span><span class="s4">else if </span><span class="s2">(</span>
												<span class="s2">hasOwnProperty(</span>
													<span class="s2">expectedSuggestion,</span>
													<span class="s3">&quot;data&quot;</span><span class="s2">,</span>
												<span class="s2">)</span>
											<span class="s2">) {</span>
												<span class="s2">assert.fail(</span>
													<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">Test must specify 'messageId' if 'data' is used.`</span><span class="s2">,</span>
												<span class="s2">);</span>
											<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
												<span class="s2">assert.fail(</span>
													<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">Test must specify either 'messageId' or 'desc'.`</span><span class="s2">,</span>
												<span class="s2">);</span>
											<span class="s2">}</span>

											<span class="s2">assert.ok(</span>
												<span class="s2">hasOwnProperty(</span>
													<span class="s2">expectedSuggestion,</span>
													<span class="s3">&quot;output&quot;</span><span class="s2">,</span>
												<span class="s2">),</span>
												<span class="s3">`</span><span class="s2">${suggestionPrefix} </span><span class="s3">The &quot;output&quot; property is required.`</span><span class="s2">,</span>
											<span class="s2">);</span>
											<span class="s4">const </span><span class="s2">codeWithAppliedSuggestion =</span>
												<span class="s2">SourceCodeFixer.applyFixes(</span>
													<span class="s2">item.code,</span>
													<span class="s2">[actualSuggestion],</span>
												<span class="s2">).output;</span>

											<span class="s0">// Verify if suggestion fix makes a syntax error or not.</span>
											<span class="s4">const </span><span class="s2">errorMessageInSuggestion =</span>
												<span class="s2">linter</span>
													<span class="s2">.verify(</span>
														<span class="s2">codeWithAppliedSuggestion,</span>
														<span class="s2">result.configs,</span>
														<span class="s2">result.filename,</span>
													<span class="s2">)</span>
													<span class="s2">.find(m =&gt; m.fatal);</span>

											<span class="s2">assert(</span>
												<span class="s2">!errorMessageInSuggestion,</span>
												<span class="s2">[</span>
													<span class="s3">&quot;A fatal parsing error occurred in suggestion fix.&quot;</span><span class="s2">,</span>
													<span class="s3">`Error: </span><span class="s2">${errorMessageInSuggestion &amp;&amp; errorMessageInSuggestion.message}</span><span class="s3">`</span><span class="s2">,</span>
													<span class="s3">&quot;Suggestion output:&quot;</span><span class="s2">,</span>
													<span class="s2">codeWithAppliedSuggestion,</span>
												<span class="s2">].join(</span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
											<span class="s2">);</span>

											<span class="s2">assert.strictEqual(</span>
												<span class="s2">codeWithAppliedSuggestion,</span>
												<span class="s2">expectedSuggestion.output,</span>
												<span class="s3">`Expected the applied suggestion fix to match the test suggestion output for suggestion at index: </span><span class="s2">${index} </span><span class="s3">on error with message: &quot;</span><span class="s2">${message.message}</span><span class="s3">&quot;`</span><span class="s2">,</span>
											<span class="s2">);</span>
											<span class="s2">assert.notStrictEqual(</span>
												<span class="s2">expectedSuggestion.output,</span>
												<span class="s2">item.code,</span>
												<span class="s3">`The output of a suggestion should differ from the original source code for suggestion at index: </span><span class="s2">${index} </span><span class="s3">on error with message: &quot;</span><span class="s2">${message.message}</span><span class="s3">&quot;`</span><span class="s2">,</span>
											<span class="s2">);</span>
										<span class="s2">},</span>
									<span class="s2">);</span>
								<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
									<span class="s2">assert.fail(</span>
										<span class="s3">&quot;Test error object property 'suggestions' should be an array or a number&quot;</span><span class="s2">,</span>
									<span class="s2">);</span>
								<span class="s2">}</span>
							<span class="s2">}</span>
						<span class="s2">}</span>
					<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
						<span class="s0">// Message was an unexpected type</span>
						<span class="s2">assert.fail(</span>
							<span class="s3">`Error should be a string, object, or RegExp, but found (</span><span class="s2">${util.inspect(message)}</span><span class="s3">)`</span><span class="s2">,</span>
						<span class="s2">);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(hasOwnProperty(item, </span><span class="s3">&quot;output&quot;</span><span class="s2">)) {</span>
				<span class="s4">if </span><span class="s2">(item.output === </span><span class="s4">null</span><span class="s2">) {</span>
					<span class="s2">assert.strictEqual(</span>
						<span class="s2">result.output,</span>
						<span class="s2">item.code,</span>
						<span class="s3">&quot;Expected no autofixes to be suggested&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s2">assert.strictEqual(</span>
						<span class="s2">result.output,</span>
						<span class="s2">item.output,</span>
						<span class="s3">&quot;Output is incorrect.&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>
					<span class="s2">assert.notStrictEqual(</span>
						<span class="s2">item.code,</span>
						<span class="s2">item.output,</span>
						<span class="s3">&quot;Test property 'output' matches 'code'. If no autofix is expected, then omit the 'output' property or set it to null.&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">assert.strictEqual(</span>
					<span class="s2">result.output,</span>
					<span class="s2">item.code,</span>
					<span class="s3">&quot;The rule fixed the code. Please add 'output' property.&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s2">assertASTDidntChange(result.beforeAST, result.afterAST);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * This creates a mocha test suite and pipes all supplied info through 
         * one of the templates above. 
         * The test suites for valid/invalid are created conditionally as 
         * test runners (eg. vitest) fail for empty test suites. 
         */</span>
		<span class="s4">this</span><span class="s2">.constructor.describe(ruleName, () =&gt; {</span>
			<span class="s4">if </span><span class="s2">(test.valid.length &gt; </span><span class="s7">0</span><span class="s2">) {</span>
				<span class="s4">this</span><span class="s2">.constructor.describe(</span><span class="s3">&quot;valid&quot;</span><span class="s2">, () =&gt; {</span>
					<span class="s2">test.valid.forEach(valid =&gt; {</span>
						<span class="s4">this</span><span class="s2">.constructor[valid.only ? </span><span class="s3">&quot;itOnly&quot; </span><span class="s2">: </span><span class="s3">&quot;it&quot;</span><span class="s2">](</span>
							<span class="s2">sanitize(</span>
								<span class="s4">typeof </span><span class="s2">valid === </span><span class="s3">&quot;object&quot;</span>
									<span class="s2">? valid.name || valid.code</span>
									<span class="s2">: valid,</span>
							<span class="s2">),</span>
							<span class="s2">() =&gt; {</span>
								<span class="s4">try </span><span class="s2">{</span>
									<span class="s2">runHook(valid, </span><span class="s3">&quot;before&quot;</span><span class="s2">);</span>
									<span class="s2">testValidTemplate(valid);</span>
								<span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
									<span class="s2">runHook(valid, </span><span class="s3">&quot;after&quot;</span><span class="s2">);</span>
								<span class="s2">}</span>
							<span class="s2">},</span>
						<span class="s2">);</span>
					<span class="s2">});</span>
				<span class="s2">});</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(test.invalid.length &gt; </span><span class="s7">0</span><span class="s2">) {</span>
				<span class="s4">this</span><span class="s2">.constructor.describe(</span><span class="s3">&quot;invalid&quot;</span><span class="s2">, () =&gt; {</span>
					<span class="s2">test.invalid.forEach(invalid =&gt; {</span>
						<span class="s4">this</span><span class="s2">.constructor[invalid.only ? </span><span class="s3">&quot;itOnly&quot; </span><span class="s2">: </span><span class="s3">&quot;it&quot;</span><span class="s2">](</span>
							<span class="s2">sanitize(invalid.name || invalid.code),</span>
							<span class="s2">() =&gt; {</span>
								<span class="s4">try </span><span class="s2">{</span>
									<span class="s2">runHook(invalid, </span><span class="s3">&quot;before&quot;</span><span class="s2">);</span>
									<span class="s2">testInvalidTemplate(invalid);</span>
								<span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
									<span class="s2">runHook(invalid, </span><span class="s3">&quot;after&quot;</span><span class="s2">);</span>
								<span class="s2">}</span>
							<span class="s2">},</span>
						<span class="s2">);</span>
					<span class="s2">});</span>
				<span class="s2">});</span>
			<span class="s2">}</span>
		<span class="s2">});</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s2">RuleTester[DESCRIBE] = RuleTester[IT] = RuleTester[IT_ONLY] = </span><span class="s4">null</span><span class="s2">;</span>

<span class="s2">module.exports = RuleTester;</span>
</pre>
</body>
</html>