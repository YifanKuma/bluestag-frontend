<html>
<head>
<title>[root-of-the-server]__974941ed._.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #0037a6;}
.s5 { color: #264eff;}
.s6 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
[root-of-the-server]__974941ed._.js</font>
</center></td></tr></table>
<pre><span class="s0">module.exports = [</span>
<span class="s1">&quot;[turbopack-node]/globals.ts [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s2">// @ts-ignore</span>
<span class="s0">process.turbopack = {};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[externals]/node:net [external] (node:net, cjs)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s3">const </span><span class="s0">mod = __turbopack_context__.x(</span><span class="s1">&quot;node:net&quot;</span><span class="s0">, () =&gt; require(</span><span class="s1">&quot;node:net&quot;</span><span class="s0">));</span>

<span class="s0">module.exports = mod;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[externals]/node:stream [external] (node:stream, cjs)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>

<span class="s3">const </span><span class="s0">mod = __turbopack_context__.x(</span><span class="s1">&quot;node:stream&quot;</span><span class="s0">, () =&gt; require(</span><span class="s1">&quot;node:stream&quot;</span><span class="s0">));</span>

<span class="s0">module.exports = mod;</span>
<span class="s0">}),</span>
<span class="s1">&quot;[turbopack-node]/compiled/stacktrace-parser/index.js [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">__turbopack_context__.s([</span>
    <span class="s1">&quot;parse&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;parse</span>
<span class="s0">]);</span>
<span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">__nccwpck_require__ !== </span><span class="s1">&quot;undefined&quot;</span><span class="s0">) __nccwpck_require__.ab = (</span><span class="s1">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s1">&quot;/ROOT/compiled/stacktrace-parser&quot;</span><span class="s0">) + </span><span class="s1">&quot;/&quot;</span><span class="s0">;</span>
<span class="s3">var </span><span class="s0">n = </span><span class="s1">&quot;&lt;unknown&gt;&quot;</span><span class="s0">;</span>
<span class="s3">function </span><span class="s0">parse(e) {</span>
    <span class="s3">var </span><span class="s0">r = e.split(</span><span class="s1">&quot;</span><span class="s4">\n</span><span class="s1">&quot;</span><span class="s0">);</span>
    <span class="s3">return </span><span class="s0">r.reduce(</span><span class="s3">function</span><span class="s0">(e, r) {</span>
        <span class="s3">var </span><span class="s0">n = parseChrome(r) || parseWinjs(r) || parseGecko(r) || parseNode(r) || parseJSC(r);</span>
        <span class="s3">if </span><span class="s0">(n) {</span>
            <span class="s0">e.push(n);</span>
        <span class="s0">}</span>
        <span class="s3">return </span><span class="s0">e;</span>
    <span class="s0">}, []);</span>
<span class="s0">}</span>
<span class="s3">var </span><span class="s0">a = </span><span class="s5">/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|&lt;anonymous&gt;|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i</span><span class="s0">;</span>
<span class="s3">var </span><span class="s0">l = </span><span class="s5">/\((\S*)(?::(\d+))(?::(\d+))\)/</span><span class="s0">;</span>
<span class="s3">function </span><span class="s0">parseChrome(e) {</span>
    <span class="s3">var </span><span class="s0">r = a.exec(e);</span>
    <span class="s3">if </span><span class="s0">(!r) {</span>
        <span class="s3">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">var </span><span class="s0">u = r[</span><span class="s6">2</span><span class="s0">] &amp;&amp; r[</span><span class="s6">2</span><span class="s0">].indexOf(</span><span class="s1">&quot;native&quot;</span><span class="s0">) === </span><span class="s6">0</span><span class="s0">;</span>
    <span class="s3">var </span><span class="s0">t = r[</span><span class="s6">2</span><span class="s0">] &amp;&amp; r[</span><span class="s6">2</span><span class="s0">].indexOf(</span><span class="s1">&quot;eval&quot;</span><span class="s0">) === </span><span class="s6">0</span><span class="s0">;</span>
    <span class="s3">var </span><span class="s0">i = l.exec(r[</span><span class="s6">2</span><span class="s0">]);</span>
    <span class="s3">if </span><span class="s0">(t &amp;&amp; i != </span><span class="s3">null</span><span class="s0">) {</span>
        <span class="s0">r[</span><span class="s6">2</span><span class="s0">] = i[</span><span class="s6">1</span><span class="s0">];</span>
        <span class="s0">r[</span><span class="s6">3</span><span class="s0">] = i[</span><span class="s6">2</span><span class="s0">];</span>
        <span class="s0">r[</span><span class="s6">4</span><span class="s0">] = i[</span><span class="s6">3</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">{</span>
        <span class="s0">file: !u ? r[</span><span class="s6">2</span><span class="s0">] : </span><span class="s3">null</span><span class="s0">,</span>
        <span class="s0">methodName: r[</span><span class="s6">1</span><span class="s0">] || n,</span>
        <span class="s0">arguments: u ? [</span>
            <span class="s0">r[</span><span class="s6">2</span><span class="s0">]</span>
        <span class="s0">] : [],</span>
        <span class="s0">lineNumber: r[</span><span class="s6">3</span><span class="s0">] ? +r[</span><span class="s6">3</span><span class="s0">] : </span><span class="s3">null</span><span class="s0">,</span>
        <span class="s0">column: r[</span><span class="s6">4</span><span class="s0">] ? +r[</span><span class="s6">4</span><span class="s0">] : </span><span class="s3">null</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">var </span><span class="s0">u = </span><span class="s5">/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i</span><span class="s0">;</span>
<span class="s3">function </span><span class="s0">parseWinjs(e) {</span>
    <span class="s3">var </span><span class="s0">r = u.exec(e);</span>
    <span class="s3">if </span><span class="s0">(!r) {</span>
        <span class="s3">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">{</span>
        <span class="s0">file: r[</span><span class="s6">2</span><span class="s0">],</span>
        <span class="s0">methodName: r[</span><span class="s6">1</span><span class="s0">] || n,</span>
        <span class="s0">arguments: [],</span>
        <span class="s0">lineNumber: +r[</span><span class="s6">3</span><span class="s0">],</span>
        <span class="s0">column: r[</span><span class="s6">4</span><span class="s0">] ? +r[</span><span class="s6">4</span><span class="s0">] : </span><span class="s3">null</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">var </span><span class="s0">t = </span><span class="s5">/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i</span><span class="s0">;</span>
<span class="s3">var </span><span class="s0">i = </span><span class="s5">/(\S+) line (\d+)(?: &gt; eval line \d+)* &gt; eval/i</span><span class="s0">;</span>
<span class="s3">function </span><span class="s0">parseGecko(e) {</span>
    <span class="s3">var </span><span class="s0">r = t.exec(e);</span>
    <span class="s3">if </span><span class="s0">(!r) {</span>
        <span class="s3">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">var </span><span class="s0">a = r[</span><span class="s6">3</span><span class="s0">] &amp;&amp; r[</span><span class="s6">3</span><span class="s0">].indexOf(</span><span class="s1">&quot; &gt; eval&quot;</span><span class="s0">) &gt; -</span><span class="s6">1</span><span class="s0">;</span>
    <span class="s3">var </span><span class="s0">l = i.exec(r[</span><span class="s6">3</span><span class="s0">]);</span>
    <span class="s3">if </span><span class="s0">(a &amp;&amp; l != </span><span class="s3">null</span><span class="s0">) {</span>
        <span class="s0">r[</span><span class="s6">3</span><span class="s0">] = l[</span><span class="s6">1</span><span class="s0">];</span>
        <span class="s0">r[</span><span class="s6">4</span><span class="s0">] = l[</span><span class="s6">2</span><span class="s0">];</span>
        <span class="s0">r[</span><span class="s6">5</span><span class="s0">] = </span><span class="s3">null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">{</span>
        <span class="s0">file: r[</span><span class="s6">3</span><span class="s0">],</span>
        <span class="s0">methodName: r[</span><span class="s6">1</span><span class="s0">] || n,</span>
        <span class="s0">arguments: r[</span><span class="s6">2</span><span class="s0">] ? r[</span><span class="s6">2</span><span class="s0">].split(</span><span class="s1">&quot;,&quot;</span><span class="s0">) : [],</span>
        <span class="s0">lineNumber: r[</span><span class="s6">4</span><span class="s0">] ? +r[</span><span class="s6">4</span><span class="s0">] : </span><span class="s3">null</span><span class="s0">,</span>
        <span class="s0">column: r[</span><span class="s6">5</span><span class="s0">] ? +r[</span><span class="s6">5</span><span class="s0">] : </span><span class="s3">null</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">var </span><span class="s0">s = </span><span class="s5">/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i</span><span class="s0">;</span>
<span class="s3">function </span><span class="s0">parseJSC(e) {</span>
    <span class="s3">var </span><span class="s0">r = s.exec(e);</span>
    <span class="s3">if </span><span class="s0">(!r) {</span>
        <span class="s3">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">{</span>
        <span class="s0">file: r[</span><span class="s6">3</span><span class="s0">],</span>
        <span class="s0">methodName: r[</span><span class="s6">1</span><span class="s0">] || n,</span>
        <span class="s0">arguments: [],</span>
        <span class="s0">lineNumber: +r[</span><span class="s6">4</span><span class="s0">],</span>
        <span class="s0">column: r[</span><span class="s6">5</span><span class="s0">] ? +r[</span><span class="s6">5</span><span class="s0">] : </span><span class="s3">null</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">var </span><span class="s0">o = </span><span class="s5">/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i</span><span class="s0">;</span>
<span class="s3">function </span><span class="s0">parseNode(e) {</span>
    <span class="s3">var </span><span class="s0">r = o.exec(e);</span>
    <span class="s3">if </span><span class="s0">(!r) {</span>
        <span class="s3">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">{</span>
        <span class="s0">file: r[</span><span class="s6">2</span><span class="s0">],</span>
        <span class="s0">methodName: r[</span><span class="s6">1</span><span class="s0">] || n,</span>
        <span class="s0">arguments: [],</span>
        <span class="s0">lineNumber: +r[</span><span class="s6">3</span><span class="s0">],</span>
        <span class="s0">column: r[</span><span class="s6">4</span><span class="s0">] ? +r[</span><span class="s6">4</span><span class="s0">] : </span><span class="s3">null</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">}),</span>
<span class="s1">&quot;[turbopack-node]/ipc/error.ts [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s2">// merged from next.js</span>
<span class="s2">// https://github.com/vercel/next.js/blob/e657741b9908cf0044aaef959c0c4defb19ed6d8/packages/next/src/lib/is-error.ts</span>
<span class="s2">// https://github.com/vercel/next.js/blob/e657741b9908cf0044aaef959c0c4defb19ed6d8/packages/next/src/shared/lib/is-plain-object.ts</span>
<span class="s0">__turbopack_context__.s([</span>
    <span class="s1">&quot;default&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;isError,</span>
    <span class="s1">&quot;getProperError&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;getProperError</span>
<span class="s0">]);</span>
<span class="s3">function </span><span class="s0">isError(err) {</span>
    <span class="s3">return typeof </span><span class="s0">err === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; err !== </span><span class="s3">null </span><span class="s0">&amp;&amp; </span><span class="s1">'name' </span><span class="s3">in </span><span class="s0">err &amp;&amp; </span><span class="s1">'message' </span><span class="s3">in </span><span class="s0">err;</span>
<span class="s0">}</span>
<span class="s3">function </span><span class="s0">getProperError(err) {</span>
    <span class="s3">if </span><span class="s0">(isError(err)) {</span>
        <span class="s3">return </span><span class="s0">err;</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s1">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s6">1</span><span class="s0">) {</span>
        <span class="s2">// Provide a better error message for cases where `throw undefined`</span>
        <span class="s2">// is called in development</span>
        <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">err === </span><span class="s1">'undefined'</span><span class="s0">) {</span>
            <span class="s3">return new </span><span class="s0">Error(</span><span class="s1">'`undefined` was thrown instead of a real error'</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s3">if </span><span class="s0">(err === </span><span class="s3">null</span><span class="s0">) {</span>
            <span class="s3">return new </span><span class="s0">Error(</span><span class="s1">'`null` was thrown instead of a real error'</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">return new </span><span class="s0">Error(isPlainObject(err) ? JSON.stringify(err) : err + </span><span class="s1">''</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s3">function </span><span class="s0">getObjectClassLabel(value) {</span>
    <span class="s3">return </span><span class="s0">Object.prototype.toString.call(value);</span>
<span class="s0">}</span>
<span class="s3">function </span><span class="s0">isPlainObject(value) {</span>
    <span class="s3">if </span><span class="s0">(getObjectClassLabel(value) !== </span><span class="s1">'[object Object]'</span><span class="s0">) {</span>
        <span class="s3">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">const </span><span class="s0">prototype = Object.getPrototypeOf(value);</span>
    <span class="s2">/**</span>
   <span class="s2">* this used to be previously:</span>
   <span class="s2">*</span>
   <span class="s2">* `return prototype === null || prototype === Object.prototype`</span>
   <span class="s2">*</span>
   <span class="s2">* but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.</span>
   <span class="s2">*</span>
   <span class="s2">* It was changed to the current implementation since it's resilient to serialization.</span>
   <span class="s2">*/ </span><span class="s3">return </span><span class="s0">prototype === </span><span class="s3">null </span><span class="s0">|| prototype.hasOwnProperty(</span><span class="s1">'isPrototypeOf'</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s0">}),</span>
<span class="s1">&quot;[turbopack-node]/ipc/index.ts [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">__turbopack_context__.s([</span>
    <span class="s1">&quot;IPC&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;IPC,</span>
    <span class="s1">&quot;structuredError&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;structuredError</span>
<span class="s0">]);</span>
<span class="s3">var </span><span class="s0">__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$net__$5b$external$5d$__$28$node$3a$net$2c$__cjs$29$__ = __turbopack_context__.i(</span><span class="s1">&quot;[externals]/node:net [external] (node:net, cjs)&quot;</span><span class="s0">);</span>
<span class="s3">var </span><span class="s0">__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i(</span><span class="s1">&quot;[externals]/node:stream [external] (node:stream, cjs)&quot;</span><span class="s0">);</span>
<span class="s3">var </span><span class="s0">__TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$compiled$2f$stacktrace$2d$parser$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i(</span><span class="s1">&quot;[turbopack-node]/compiled/stacktrace-parser/index.js [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">var </span><span class="s0">__TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$ipc$2f$error$2e$ts__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i(</span><span class="s1">&quot;[turbopack-node]/ipc/error.ts [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">;</span>
<span class="s0">;</span>
<span class="s0">;</span>
<span class="s0">;</span>
<span class="s3">function </span><span class="s0">structuredError(e) {</span>
    <span class="s0">e = (</span><span class="s6">0</span><span class="s0">, __TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$ipc$2f$error$2e$ts__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;getProperError&quot;</span><span class="s0">])(e);</span>
    <span class="s3">return </span><span class="s0">{</span>
        <span class="s0">name: e.name,</span>
        <span class="s0">message: e.message,</span>
        <span class="s0">stack: </span><span class="s3">typeof </span><span class="s0">e.stack === </span><span class="s1">'string' </span><span class="s0">? (</span><span class="s6">0</span><span class="s0">, __TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$compiled$2f$stacktrace$2d$parser$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;parse&quot;</span><span class="s0">])(e.stack) : [],</span>
        <span class="s0">cause: e.cause ? structuredError((</span><span class="s6">0</span><span class="s0">, __TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$ipc$2f$error$2e$ts__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;getProperError&quot;</span><span class="s0">])(e.cause)) : undefined</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">function </span><span class="s0">createIpc(port) {</span>
    <span class="s3">const </span><span class="s0">socket = (</span><span class="s6">0</span><span class="s0">, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$net__$5b$external$5d$__$28$node$3a$net$2c$__cjs$29$__[</span><span class="s1">&quot;createConnection&quot;</span><span class="s0">])({</span>
        <span class="s0">port,</span>
        <span class="s0">host: </span><span class="s1">'127.0.0.1'</span>
    <span class="s0">});</span>
    <span class="s2">/**</span>
   <span class="s2">* A writable stream that writes to the socket.</span>
   <span class="s2">* We don't write directly to the socket because we need to</span>
   <span class="s2">* handle backpressure and wait for the socket to be drained</span>
   <span class="s2">* before writing more data.</span>
   <span class="s2">*/ </span><span class="s3">const </span><span class="s0">socketWritable = </span><span class="s3">new </span><span class="s0">__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__[</span><span class="s1">&quot;Writable&quot;</span><span class="s0">]({</span>
        <span class="s0">write (chunk, _enc, cb) {</span>
            <span class="s3">if </span><span class="s0">(socket.write(chunk)) {</span>
                <span class="s0">cb();</span>
            <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
                <span class="s0">socket.once(</span><span class="s1">'drain'</span><span class="s0">, cb);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s0">final (cb) {</span>
            <span class="s0">socket.end(cb);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s3">const </span><span class="s0">packetQueue = [];</span>
    <span class="s3">const </span><span class="s0">recvPromiseResolveQueue = [];</span>
    <span class="s3">function </span><span class="s0">pushPacket(packet) {</span>
        <span class="s3">const </span><span class="s0">recvPromiseResolve = recvPromiseResolveQueue.shift();</span>
        <span class="s3">if </span><span class="s0">(recvPromiseResolve != </span><span class="s3">null</span><span class="s0">) {</span>
            <span class="s0">recvPromiseResolve(JSON.parse(packet.toString(</span><span class="s1">'utf8'</span><span class="s0">)));</span>
        <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
            <span class="s0">packetQueue.push(packet);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">let </span><span class="s0">state = {</span>
        <span class="s0">type: </span><span class="s1">'waiting'</span>
    <span class="s0">};</span>
    <span class="s3">let </span><span class="s0">buffer = Buffer.alloc(</span><span class="s6">0</span><span class="s0">);</span>
    <span class="s0">socket.once(</span><span class="s1">'connect'</span><span class="s0">, ()=&gt;{</span>
        <span class="s0">socket.on(</span><span class="s1">'data'</span><span class="s0">, (chunk)=&gt;{</span>
            <span class="s0">buffer = Buffer.concat([</span>
                <span class="s0">buffer,</span>
                <span class="s0">chunk</span>
            <span class="s0">]);</span>
            <span class="s0">loop: </span><span class="s3">while</span><span class="s0">(</span><span class="s3">true</span><span class="s0">){</span>
                <span class="s3">switch</span><span class="s0">(state.type){</span>
                    <span class="s3">case </span><span class="s1">'waiting'</span><span class="s0">:</span>
                        <span class="s0">{</span>
                            <span class="s3">if </span><span class="s0">(buffer.length &gt;= </span><span class="s6">4</span><span class="s0">) {</span>
                                <span class="s3">const </span><span class="s0">length = buffer.readUInt32BE(</span><span class="s6">0</span><span class="s0">);</span>
                                <span class="s0">buffer = buffer.subarray(</span><span class="s6">4</span><span class="s0">);</span>
                                <span class="s0">state = {</span>
                                    <span class="s0">type: </span><span class="s1">'packet'</span><span class="s0">,</span>
                                    <span class="s0">length</span>
                                <span class="s0">};</span>
                            <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
                                <span class="s3">break </span><span class="s0">loop;</span>
                            <span class="s0">}</span>
                            <span class="s3">break</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s3">case </span><span class="s1">'packet'</span><span class="s0">:</span>
                        <span class="s0">{</span>
                            <span class="s3">if </span><span class="s0">(buffer.length &gt;= state.length) {</span>
                                <span class="s3">const </span><span class="s0">packet = buffer.subarray(</span><span class="s6">0</span><span class="s0">, state.length);</span>
                                <span class="s0">buffer = buffer.subarray(state.length);</span>
                                <span class="s0">state = {</span>
                                    <span class="s0">type: </span><span class="s1">'waiting'</span>
                                <span class="s0">};</span>
                                <span class="s0">pushPacket(packet);</span>
                            <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
                                <span class="s3">break </span><span class="s0">loop;</span>
                            <span class="s0">}</span>
                            <span class="s3">break</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s3">default</span><span class="s0">:</span>
                        <span class="s0">invariant(state, (state)=&gt;</span><span class="s1">`Unknown state type: </span><span class="s0">${state?.type}</span><span class="s1">`</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s2">// When the socket is closed, this process is no longer needed.</span>
    <span class="s2">// This might happen e. g. when parent process is killed or</span>
    <span class="s2">// node.js pool is garbage collected.</span>
    <span class="s0">socket.once(</span><span class="s1">'close'</span><span class="s0">, ()=&gt;{</span>
        <span class="s0">process.exit(</span><span class="s6">0</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s2">// TODO(lukesandberg): some of the messages being sent are very large and contain lots</span>
    <span class="s2">//  of redundant information.  Consider adding gzip compression to our stream.</span>
    <span class="s3">function </span><span class="s0">doSend(message) {</span>
        <span class="s3">return new </span><span class="s0">Promise((resolve, reject)=&gt;{</span>
            <span class="s2">// Reserve 4 bytes for our length prefix, we will over-write after encoding.</span>
            <span class="s3">const </span><span class="s0">packet = Buffer.from(</span><span class="s1">'0000' </span><span class="s0">+ message, </span><span class="s1">'utf8'</span><span class="s0">);</span>
            <span class="s0">packet.writeUInt32BE(packet.length - </span><span class="s6">4</span><span class="s0">, </span><span class="s6">0</span><span class="s0">);</span>
            <span class="s0">socketWritable.write(packet, (err)=&gt;{</span>
                <span class="s0">process.stderr.write(</span><span class="s1">`TURBOPACK_OUTPUT_D</span><span class="s4">\n</span><span class="s1">`</span><span class="s0">);</span>
                <span class="s0">process.stdout.write(</span><span class="s1">`TURBOPACK_OUTPUT_D</span><span class="s4">\n</span><span class="s1">`</span><span class="s0">);</span>
                <span class="s3">if </span><span class="s0">(err != </span><span class="s3">null</span><span class="s0">) {</span>
                    <span class="s0">reject(err);</span>
                <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
                    <span class="s0">resolve();</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">function </span><span class="s0">send(message) {</span>
        <span class="s3">return </span><span class="s0">doSend(JSON.stringify(message));</span>
    <span class="s0">}</span>
    <span class="s3">function </span><span class="s0">sendReady() {</span>
        <span class="s3">return </span><span class="s0">doSend(</span><span class="s1">''</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">{</span>
        <span class="s0">async recv () {</span>
            <span class="s3">const </span><span class="s0">packet = packetQueue.shift();</span>
            <span class="s3">if </span><span class="s0">(packet != </span><span class="s3">null</span><span class="s0">) {</span>
                <span class="s3">return </span><span class="s0">JSON.parse(packet.toString(</span><span class="s1">'utf8'</span><span class="s0">));</span>
            <span class="s0">}</span>
            <span class="s3">const </span><span class="s0">result = </span><span class="s3">await new </span><span class="s0">Promise((resolve)=&gt;{</span>
                <span class="s0">recvPromiseResolveQueue.push((result)=&gt;{</span>
                    <span class="s0">resolve(result);</span>
                <span class="s0">});</span>
            <span class="s0">});</span>
            <span class="s3">return </span><span class="s0">result;</span>
        <span class="s0">},</span>
        <span class="s0">send (message) {</span>
            <span class="s3">return </span><span class="s0">send(message);</span>
        <span class="s0">},</span>
        <span class="s0">sendReady,</span>
        <span class="s0">async sendError (error) {</span>
            <span class="s3">let </span><span class="s0">failed = </span><span class="s3">false</span><span class="s0">;</span>
            <span class="s3">try </span><span class="s0">{</span>
                <span class="s3">await </span><span class="s0">send({</span>
                    <span class="s0">type: </span><span class="s1">'error'</span><span class="s0">,</span>
                    <span class="s0">...structuredError(error)</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
                <span class="s2">// There's nothing we can do about errors that happen after this point, we can't tell anyone</span>
                <span class="s2">// about them.</span>
                <span class="s0">console.error(</span><span class="s1">'failed to send error back to rust:'</span><span class="s0">, err);</span>
                <span class="s0">failed = </span><span class="s3">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">await new </span><span class="s0">Promise((res)=&gt;socket.end(()=&gt;res()));</span>
            <span class="s0">process.exit(failed ? </span><span class="s6">1 </span><span class="s0">: </span><span class="s6">0</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s3">const </span><span class="s0">PORT = process.argv[</span><span class="s6">2</span><span class="s0">];</span>
<span class="s3">const </span><span class="s0">IPC = createIpc(parseInt(PORT, </span><span class="s6">10</span><span class="s0">));</span>
<span class="s0">process.on(</span><span class="s1">'uncaughtException'</span><span class="s0">, (err)=&gt;{</span>
    <span class="s0">IPC.sendError(err);</span>
<span class="s0">});</span>
<span class="s3">const </span><span class="s0">improveConsole = (name, stream, addStack)=&gt;{</span>
    <span class="s2">// @ts-ignore</span>
    <span class="s3">const </span><span class="s0">original = console[name];</span>
    <span class="s2">// @ts-ignore</span>
    <span class="s3">const </span><span class="s0">stdio = process[stream];</span>
    <span class="s2">// @ts-ignore</span>
    <span class="s0">console[name] = (...args)=&gt;{</span>
        <span class="s0">stdio.write(</span><span class="s1">`TURBOPACK_OUTPUT_B</span><span class="s4">\n</span><span class="s1">`</span><span class="s0">);</span>
        <span class="s0">original(...args);</span>
        <span class="s3">if </span><span class="s0">(addStack) {</span>
            <span class="s3">const </span><span class="s0">stack = </span><span class="s3">new </span><span class="s0">Error().stack?.replace(</span><span class="s5">/^.+\n.+\n/</span><span class="s0">, </span><span class="s1">''</span><span class="s0">) + </span><span class="s1">'</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">;</span>
            <span class="s0">stdio.write(</span><span class="s1">'TURBOPACK_OUTPUT_S</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">);</span>
            <span class="s0">stdio.write(stack);</span>
        <span class="s0">}</span>
        <span class="s0">stdio.write(</span><span class="s1">'TURBOPACK_OUTPUT_E</span><span class="s4">\n</span><span class="s1">'</span><span class="s0">);</span>
    <span class="s0">};</span>
<span class="s0">};</span>
<span class="s0">improveConsole(</span><span class="s1">'error'</span><span class="s0">, </span><span class="s1">'stderr'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'warn'</span><span class="s0">, </span><span class="s1">'stderr'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'count'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'trace'</span><span class="s0">, </span><span class="s1">'stderr'</span><span class="s0">, </span><span class="s3">false</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'log'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'group'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'groupCollapsed'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'table'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'debug'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'info'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'dir'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'dirxml'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'timeEnd'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'timeLog'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'timeStamp'</span><span class="s0">, </span><span class="s1">'stdout'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s0">improveConsole(</span><span class="s1">'assert'</span><span class="s0">, </span><span class="s1">'stderr'</span><span class="s0">, </span><span class="s3">true</span><span class="s0">);</span>
<span class="s2">/**</span>
 <span class="s2">* Utility function to ensure all variants of an enum are handled.</span>
 <span class="s2">*/ </span><span class="s3">function </span><span class="s0">invariant(never, computeMessage) {</span>
    <span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">`Invariant: </span><span class="s0">${computeMessage(never)}</span><span class="s1">`</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s0">}),</span>
<span class="s1">&quot;[turbopack-node]/ipc/evaluate.ts [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">__turbopack_context__.s([</span>
    <span class="s1">&quot;run&quot;</span><span class="s0">,</span>
    <span class="s0">()=&gt;run</span>
<span class="s0">]);</span>
<span class="s3">var </span><span class="s0">__TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$ipc$2f$index$2e$ts__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i(</span><span class="s1">&quot;[turbopack-node]/ipc/index.ts [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">;</span>
<span class="s3">const </span><span class="s0">ipc = __TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$ipc$2f$index$2e$ts__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;IPC&quot;</span><span class="s0">];</span>
<span class="s3">const </span><span class="s0">queue = [];</span>
<span class="s3">const </span><span class="s0">run = async (moduleFactory)=&gt;{</span>
    <span class="s3">let </span><span class="s0">nextId = </span><span class="s6">1</span><span class="s0">;</span>
    <span class="s3">const </span><span class="s0">requests = </span><span class="s3">new </span><span class="s0">Map();</span>
    <span class="s3">const </span><span class="s0">internalIpc = {</span>
        <span class="s0">sendInfo: (message)=&gt;ipc.send({</span>
                <span class="s0">type: </span><span class="s1">'info'</span><span class="s0">,</span>
                <span class="s0">data: message</span>
            <span class="s0">}),</span>
        <span class="s0">sendRequest: (message)=&gt;{</span>
            <span class="s3">const </span><span class="s0">id = nextId++;</span>
            <span class="s3">let </span><span class="s0">resolve, reject;</span>
            <span class="s3">const </span><span class="s0">promise = </span><span class="s3">new </span><span class="s0">Promise((res, rej)=&gt;{</span>
                <span class="s0">resolve = res;</span>
                <span class="s0">reject = rej;</span>
            <span class="s0">});</span>
            <span class="s0">requests.set(id, {</span>
                <span class="s0">resolve,</span>
                <span class="s0">reject</span>
            <span class="s0">});</span>
            <span class="s3">return </span><span class="s0">ipc.send({</span>
                <span class="s0">type: </span><span class="s1">'request'</span><span class="s0">,</span>
                <span class="s0">id,</span>
                <span class="s0">data: message</span>
            <span class="s0">}).then(()=&gt;promise);</span>
        <span class="s0">},</span>
        <span class="s0">sendError: (error)=&gt;{</span>
            <span class="s3">return </span><span class="s0">ipc.sendError(error);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s2">// Initialize module and send ready message</span>
    <span class="s3">let </span><span class="s0">getValue;</span>
    <span class="s3">try </span><span class="s0">{</span>
        <span class="s3">const </span><span class="s0">module = </span><span class="s3">await </span><span class="s0">moduleFactory();</span>
        <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">module.init === </span><span class="s1">'function'</span><span class="s0">) {</span>
            <span class="s3">await </span><span class="s0">module.init();</span>
        <span class="s0">}</span>
        <span class="s0">getValue = module.default;</span>
        <span class="s3">await </span><span class="s0">ipc.sendReady();</span>
    <span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
        <span class="s3">await </span><span class="s0">ipc.sendReady();</span>
        <span class="s3">await </span><span class="s0">ipc.sendError(err);</span>
    <span class="s0">}</span>
    <span class="s2">// Queue handling</span>
    <span class="s3">let </span><span class="s0">isRunning = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s3">const </span><span class="s0">run = async ()=&gt;{</span>
        <span class="s3">while</span><span class="s0">(queue.length &gt; </span><span class="s6">0</span><span class="s0">){</span>
            <span class="s3">const </span><span class="s0">args = queue.shift();</span>
            <span class="s3">try </span><span class="s0">{</span>
                <span class="s3">const </span><span class="s0">value = </span><span class="s3">await </span><span class="s0">getValue(internalIpc, ...args);</span>
                <span class="s3">await </span><span class="s0">ipc.send({</span>
                    <span class="s0">type: </span><span class="s1">'end'</span><span class="s0">,</span>
                    <span class="s0">data: value === undefined ? undefined : JSON.stringify(value, </span><span class="s3">null</span><span class="s0">, </span><span class="s6">2</span><span class="s0">),</span>
                    <span class="s0">duration: </span><span class="s6">0</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s3">catch </span><span class="s0">(e) {</span>
                <span class="s3">await </span><span class="s0">ipc.sendError(e);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">isRunning = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s0">};</span>
    <span class="s2">// Communication handling</span>
    <span class="s3">while</span><span class="s0">(</span><span class="s3">true</span><span class="s0">){</span>
        <span class="s3">const </span><span class="s0">msg = </span><span class="s3">await </span><span class="s0">ipc.recv();</span>
        <span class="s3">switch</span><span class="s0">(msg.type){</span>
            <span class="s3">case </span><span class="s1">'evaluate'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s0">queue.push(msg.args);</span>
                    <span class="s3">if </span><span class="s0">(!isRunning) {</span>
                        <span class="s0">isRunning = </span><span class="s3">true</span><span class="s0">;</span>
                        <span class="s0">run();</span>
                    <span class="s0">}</span>
                    <span class="s3">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s3">case </span><span class="s1">'result'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s3">const </span><span class="s0">request = requests.get(msg.id);</span>
                    <span class="s3">if </span><span class="s0">(request) {</span>
                        <span class="s0">requests.delete(msg.id);</span>
                        <span class="s3">if </span><span class="s0">(msg.error) {</span>
                            <span class="s0">request.reject(</span><span class="s3">new </span><span class="s0">Error(msg.error));</span>
                        <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
                            <span class="s0">request.resolve(msg.data);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s3">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s3">default</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s0">console.error(</span><span class="s1">'unexpected message type'</span><span class="s0">, msg.type);</span>
                    <span class="s0">process.exit(</span><span class="s6">1</span><span class="s0">);</span>
                <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s0">}),</span>
<span class="s1">&quot;[turbopack-node]/ipc/evaluate.ts/evaluate.js { INNER =&gt; </span><span class="s4">\&quot;</span><span class="s1">[turbopack-node]/transforms/postcss.ts { CONFIG =&gt; </span><span class="s4">\\\&quot;</span><span class="s1">[project]/postcss.config.mjs [postcss] (ecmascript)</span><span class="s4">\\\&quot; </span><span class="s1">} [postcss] (ecmascript)</span><span class="s4">\&quot;</span><span class="s1">, RUNTIME =&gt; </span><span class="s4">\&quot;</span><span class="s1">[turbopack-node]/ipc/evaluate.ts [postcss] (ecmascript)</span><span class="s4">\&quot; </span><span class="s1">} [postcss] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__) =&gt; {</span>
<span class="s1">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">__turbopack_context__.s([]);</span>
<span class="s3">var </span><span class="s0">__TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$ipc$2f$evaluate$2e$ts__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i(</span><span class="s1">&quot;[turbopack-node]/ipc/evaluate.ts [postcss] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">;</span>
<span class="s0">(</span><span class="s6">0</span><span class="s0">, __TURBOPACK__imported__module__$5b$turbopack$2d$node$5d2f$ipc$2f$evaluate$2e$ts__$5b$postcss$5d$__$28$ecmascript$29$__[</span><span class="s1">&quot;run&quot;</span><span class="s0">])(()=&gt;__turbopack_context__.A(</span><span class="s1">'[turbopack-node]/transforms/postcss.ts { CONFIG =&gt; &quot;[project]/postcss.config.mjs [postcss] (ecmascript)&quot; } [postcss] (ecmascript, async loader)'</span><span class="s0">));</span>
<span class="s0">}),</span>
<span class="s0">];</span>

<span class="s2">//# sourceMappingURL=%5Broot-of-the-server%5D__974941ed._.js.map</span></pre>
</body>
</html>