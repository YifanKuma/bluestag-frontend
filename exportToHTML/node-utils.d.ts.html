<html>
<head>
<title>node-utils.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node-utils.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">* as ts from </span><span class="s2">'typescript'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { TSESTree, TSNode } from </span><span class="s2">'./ts-estree'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ AST_NODE_TYPES, AST_TOKEN_TYPES } from </span><span class="s2">'./ts-estree'</span><span class="s1">;</span>
<span class="s1">declare </span><span class="s0">const </span><span class="s1">SyntaxKind: </span><span class="s0">typeof </span><span class="s1">ts.SyntaxKind;</span>
<span class="s1">type LogicalOperatorKind = ts.SyntaxKind.AmpersandAmpersandToken | ts.SyntaxKind.BarBarToken | ts.SyntaxKind.QuestionQuestionToken;</span>
<span class="s0">interface </span><span class="s1">TokenToText </span><span class="s0">extends </span><span class="s1">TSESTree.PunctuatorTokenToText, TSESTree.BinaryOperatorToText {</span>
    <span class="s1">[SyntaxKind.ImportKeyword]: </span><span class="s2">'import'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.KeyOfKeyword]: </span><span class="s2">'keyof'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.NewKeyword]: </span><span class="s2">'new'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.ReadonlyKeyword]: </span><span class="s2">'readonly'</span><span class="s1">;</span>
    <span class="s1">[SyntaxKind.UniqueKeyword]: </span><span class="s2">'unique'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">type AssignmentOperatorKind = keyof TSESTree.AssignmentOperatorToText;</span>
<span class="s1">type BinaryOperatorKind = keyof TSESTree.BinaryOperatorToText;</span>
<span class="s1">type DeclarationKind = TSESTree.VariableDeclaration[</span><span class="s2">'kind'</span><span class="s1">];</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if the given ts.Token is a logical operator</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isLogicalOperator(operator: ts.BinaryOperatorToken): operator is ts.Token&lt;LogicalOperatorKind&gt;;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isESTreeBinaryOperator(operator: ts.BinaryOperatorToken): operator is ts.Token&lt;BinaryOperatorKind&gt;;</span>
<span class="s1">type TokenForTokenKind&lt;T </span><span class="s0">extends </span><span class="s1">ts.SyntaxKind&gt; = T </span><span class="s0">extends </span><span class="s1">keyof TokenToText ? TokenToText[T] : string | undefined;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns the string form of the given TSToken SyntaxKind</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getTextForTokenKind&lt;T </span><span class="s0">extends </span><span class="s1">ts.SyntaxKind&gt;(kind: T): TokenForTokenKind&lt;T&gt;;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if the given ts.Node is a valid ESTree class member</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isESTreeClassMember(node: ts.Node): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Checks if a ts.Node has a modifier</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">hasModifier(modifierKind: ts.KeywordSyntaxKind, node: ts.Node): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Get last last modifier in ast</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">returns last modifier if present or null</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getLastModifier(node: ts.Node): ts.Modifier | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if the given ts.Token is a comma</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isComma(token: ts.Node): token is ts.Token&lt;ts.SyntaxKind.CommaToken&gt;;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if the given ts.Node is a comment</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isComment(node: ts.Node): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns the binary expression type of the given ts.Token</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getBinaryExpressionType(operator: ts.BinaryOperatorToken): {</span>
    <span class="s1">operator: TokenForTokenKind&lt;AssignmentOperatorKind&gt;;</span>
    <span class="s1">type: AST_NODE_TYPES.AssignmentExpression;</span>
<span class="s1">} | {</span>
    <span class="s1">operator: TokenForTokenKind&lt;BinaryOperatorKind&gt;;</span>
    <span class="s1">type: AST_NODE_TYPES.BinaryExpression;</span>
<span class="s1">} | {</span>
    <span class="s1">operator: TokenForTokenKind&lt;LogicalOperatorKind&gt;;</span>
    <span class="s1">type: AST_NODE_TYPES.LogicalExpression;</span>
<span class="s1">};</span>
<span class="s3">/**</span>
 <span class="s3">* Returns line and column data for the given positions</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getLineAndCharacterFor(pos: number, ast: ts.SourceFile): TSESTree.Position;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns line and column data for the given start and end positions,</span>
 <span class="s3">* for the given AST</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getLocFor(range: TSESTree.Range, ast: ts.SourceFile): TSESTree.SourceLocation;</span>
<span class="s3">/**</span>
 <span class="s3">* Check whatever node can contain directive</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">canContainDirective(node: ts.Block | ts.ClassStaticBlockDeclaration | ts.ModuleBlock | ts.SourceFile): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns range for the given ts.Node</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getRange(node: Pick&lt;ts.Node, </span><span class="s2">'getEnd' </span><span class="s1">| </span><span class="s2">'getStart'</span><span class="s1">&gt;, ast: ts.SourceFile): [number, number];</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if a given ts.Node is a JSX token</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isJSXToken(node: ts.Node): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns the declaration kind of the given ts.Node</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getDeclarationKind(node: ts.VariableDeclarationList): DeclarationKind;</span>
<span class="s3">/**</span>
 <span class="s3">* Gets a ts.Node's accessibility level</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getTSNodeAccessibility(node: ts.Node): </span><span class="s2">'private' </span><span class="s1">| </span><span class="s2">'protected' </span><span class="s1">| </span><span class="s2">'public' </span><span class="s1">| undefined;</span>
<span class="s3">/**</span>
 <span class="s3">* Finds the next token based on the previous one and its parent</span>
 <span class="s3">* Had to copy this from TS instead of using TS's version because theirs doesn't pass the ast to getChildren</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">findNextToken(previousToken: ts.TextRange, parent: ts.Node, ast: ts.SourceFile): ts.Node | undefined;</span>
<span class="s3">/**</span>
 <span class="s3">* Find the first matching ancestor based on the given predicate function.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">node The current ts.Node</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">predicate The predicate function to apply to each checked ancestor</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">a matching parent ts.Node</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">findFirstMatchingAncestor(node: ts.Node, predicate: (node: ts.Node) =&gt; boolean): ts.Node | undefined;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if a given ts.Node has a JSX token within its hierarchy</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">hasJSXAncestor(node: ts.Node): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Unescape the text content of string literals, e.g. &amp;amp; -&gt; &amp;</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">text The escaped string literal text.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The unescaped string literal text.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">unescapeStringLiteralText(text: string): string;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if a given ts.Node is a computed property</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isComputedProperty(node: ts.Node): node is ts.ComputedPropertyName;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if a given ts.Node is optional (has QuestionToken)</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">node ts.Node to be checked</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isOptional(node: {</span>
    <span class="s1">questionToken?: ts.QuestionToken;</span>
<span class="s1">}): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true if the node is an optional chain node</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isChainExpression(node: TSESTree.Node): node is TSESTree.ChainExpression;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns true of the child of property access expression is an optional chain</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isChildUnwrappableOptionalChain(node: ts.CallExpression | ts.ElementAccessExpression | ts.NonNullExpression | ts.PropertyAccessExpression, child: TSESTree.Node): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Returns the type of a given ts.Token</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getTokenType(token: ts.Identifier | ts.Token&lt;ts.SyntaxKind&gt;): Exclude&lt;AST_TOKEN_TYPES, AST_TOKEN_TYPES.Block | AST_TOKEN_TYPES.Line&gt;;</span>
<span class="s3">/**</span>
 <span class="s3">* Extends and formats a given ts.Token, for a given AST</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">convertToken(token: ts.Token&lt;ts.TokenSyntaxKind&gt;, ast: ts.SourceFile): TSESTree.Token;</span>
<span class="s3">/**</span>
 <span class="s3">* Converts all tokens for the given AST</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">ast the AST object</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">the converted Tokens</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">convertTokens(ast: ts.SourceFile): TSESTree.Token[];</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">TSError </span><span class="s0">extends </span><span class="s1">Error {</span>
    <span class="s1">readonly fileName: string;</span>
    <span class="s1">readonly location: {</span>
        <span class="s1">end: {</span>
            <span class="s1">column: number;</span>
            <span class="s1">line: number;</span>
            <span class="s1">offset: number;</span>
        <span class="s1">};</span>
        <span class="s1">start: {</span>
            <span class="s1">column: number;</span>
            <span class="s1">line: number;</span>
            <span class="s1">offset: number;</span>
        <span class="s1">};</span>
    <span class="s1">};</span>
    <span class="s1">constructor(message: string, fileName: string, location: {</span>
        <span class="s1">end: {</span>
            <span class="s1">column: number;</span>
            <span class="s1">line: number;</span>
            <span class="s1">offset: number;</span>
        <span class="s1">};</span>
        <span class="s1">start: {</span>
            <span class="s1">column: number;</span>
            <span class="s1">line: number;</span>
            <span class="s1">offset: number;</span>
        <span class="s1">};</span>
    <span class="s1">});</span>
    <span class="s1">get index(): number;</span>
    <span class="s1">get lineNumber(): number;</span>
    <span class="s1">get column(): number;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createError(message: string, ast: ts.SourceFile, startIndex: number, endIndex?: number): TSError;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">nodeHasIllegalDecorators(node: ts.Node): node is {</span>
    <span class="s1">illegalDecorators: ts.Node[];</span>
<span class="s1">} &amp; ts.Node;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">nodeHasTokens(n: ts.Node, ast: ts.SourceFile): boolean;</span>
<span class="s3">/**</span>
 <span class="s3">* Like `forEach`, but suitable for use with numbers and strings (which may be falsy).</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">firstDefined&lt;T, U&gt;(array: readonly T[] | undefined, callback: (element: T, index: number) =&gt; U | undefined): U | undefined;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">identifierIsThisKeyword(id: ts.Identifier): boolean;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isThisIdentifier(node: ts.Node | undefined): node is ts.Identifier;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isThisInTypeQuery(node: ts.Node): boolean;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">nodeIsPresent(node: ts.Node | undefined): node is ts.Node;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getContainingFunction(node: ts.Node): ts.SignatureDeclaration | undefined;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">nodeCanBeDecorated(node: TSNode): boolean;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isValidAssignmentTarget(node: ts.Node): boolean;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getNamespaceModifiers(node: ts.ModuleDeclaration): ts.Modifier[] | undefined;</span>
<span class="s0">export </span><span class="s1">{};</span>
</pre>
</body>
</html>