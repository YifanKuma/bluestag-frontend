<html>
<head>
<title>ppr-navigations.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ppr-navigations.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/ppr-navigations.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">CacheNode,</span><span class="s3">\n  </span><span class="s1">ChildSegmentMap,</span><span class="s3">\n  </span><span class="s1">HeadData,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n  </span><span class="s1">ReadyCacheNode,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import type { FetchServerResponseResult } from './fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'</span><span class="s3">\n</span><span class="s1">import { DYNAMIC_STALETIME_MS } from './prefetch-cache-utils'</span><span class="s3">\n\n</span><span class="s1">// This is yet another tree type that is used to track pending promises that</span><span class="s3">\n</span><span class="s1">// need to be fulfilled once the dynamic data is received. The terminal nodes of</span><span class="s3">\n</span><span class="s1">// this tree represent the new Cache Node trees that were created during this</span><span class="s3">\n</span><span class="s1">// request. We can't use the Cache Node tree or Route State tree directly</span><span class="s3">\n</span><span class="s1">// because those include reused nodes, too. This tree is discarded as soon as</span><span class="s3">\n</span><span class="s1">// the navigation response is received.</span><span class="s3">\n</span><span class="s1">type SPANavigationTask = {</span><span class="s3">\n  </span><span class="s1">// The router state that corresponds to the tree that this Task represents.</span><span class="s3">\n  </span><span class="s1">route: FlightRouterState</span><span class="s3">\n  </span><span class="s1">// The CacheNode that corresponds to the tree that this Task represents. If</span><span class="s3">\n  </span><span class="s1">// `children` is null (i.e. if this is a terminal task node), then `node`</span><span class="s3">\n  </span><span class="s1">// represents a brand new Cache Node tree, which way or may not need to be</span><span class="s3">\n  </span><span class="s1">// filled with dynamic data from the server.</span><span class="s3">\n  </span><span class="s1">node: CacheNode | null</span><span class="s3">\n  </span><span class="s1">// The tree sent to the server during the dynamic request. This is the</span><span class="s3">\n  </span><span class="s1">// same as `route`, except with the `refetch` marker set on dynamic segments.</span><span class="s3">\n  </span><span class="s1">// If all the segments are static, then this will be null, and no server</span><span class="s3">\n  </span><span class="s1">// request is required.</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree: FlightRouterState | null</span><span class="s3">\n  </span><span class="s1">children: Map&lt;string, SPANavigationTask&gt; | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// A special type used to bail out and trigger a full-page navigation.</span><span class="s3">\n</span><span class="s1">type MPANavigationTask = {</span><span class="s3">\n  </span><span class="s1">// MPA tasks are distinguised from SPA tasks by having a null `route`.</span><span class="s3">\n  </span><span class="s1">route: null</span><span class="s3">\n  </span><span class="s1">node: null</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree: null</span><span class="s3">\n  </span><span class="s1">children: null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const MPA_NAVIGATION_TASK: MPANavigationTask = {</span><span class="s3">\n  </span><span class="s1">route: null,</span><span class="s3">\n  </span><span class="s1">node: null,</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree: null,</span><span class="s3">\n  </span><span class="s1">children: null,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type Task = SPANavigationTask | MPANavigationTask</span><span class="s3">\n\n</span><span class="s1">// Creates a new Cache Node tree (i.e. copy-on-write) that represents the</span><span class="s3">\n</span><span class="s1">// optimistic result of a navigation, using both the current Cache Node tree and</span><span class="s3">\n</span><span class="s1">// data that was prefetched prior to navigation.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// At the moment we call this function, we haven't yet received the navigation</span><span class="s3">\n</span><span class="s1">// response from the server. It could send back something completely different</span><span class="s3">\n</span><span class="s1">// from the tree that was prefetched — due to rewrites, default routes, parallel</span><span class="s3">\n</span><span class="s1">// routes, etc.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// But in most cases, it will return the same tree that we prefetched, just with</span><span class="s3">\n</span><span class="s1">// the dynamic holes filled in. So we optimistically assume this will happen,</span><span class="s3">\n</span><span class="s1">// and accept that the real result could be arbitrarily different.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// We'll reuse anything that was already in the previous tree, since that's what</span><span class="s3">\n</span><span class="s1">// the server does.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// New segments (ones that don't appear in the old tree) are assigned an</span><span class="s3">\n</span><span class="s1">// unresolved promise. The data for these promises will be fulfilled later, when</span><span class="s3">\n</span><span class="s1">// the navigation response is received.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The tree can be rendered immediately after it is created (that's why this is</span><span class="s3">\n</span><span class="s1">// a synchronous function). Any new trees that do not have prefetch data will</span><span class="s3">\n</span><span class="s1">// suspend during rendering, until the dynamic data streams in.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Returns a Task object, which contains both the updated Cache Node and a path</span><span class="s3">\n</span><span class="s1">// to the pending subtrees that need to be resolved by the navigation response.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// A return value of `null` means there were no changes, and the previous tree</span><span class="s3">\n</span><span class="s1">// can be reused without initiating a server request.</span><span class="s3">\n</span><span class="s1">export function startPPRNavigation(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">oldCacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">oldRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">newRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">isSamePageNavigation: boolean,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): Task | null {</span><span class="s3">\n  </span><span class="s1">const segmentPath: Array&lt;FlightSegmentPath&gt; = []</span><span class="s3">\n  </span><span class="s1">return updateCacheNodeOnNavigation(</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n    </span><span class="s1">oldCacheNode,</span><span class="s3">\n    </span><span class="s1">oldRouterState,</span><span class="s3">\n    </span><span class="s1">newRouterState,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">prefetchData,</span><span class="s3">\n    </span><span class="s1">prefetchHead,</span><span class="s3">\n    </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n    </span><span class="s1">isSamePageNavigation,</span><span class="s3">\n    </span><span class="s1">segmentPath,</span><span class="s3">\n    </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function updateCacheNodeOnNavigation(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">oldCacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">oldRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">newRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">didFindRootLayout: boolean,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">isSamePageNavigation: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): Task | null {</span><span class="s3">\n  </span><span class="s1">// Diff the old and new trees to reuse the shared layouts.</span><span class="s3">\n  </span><span class="s1">const oldRouterStateChildren = oldRouterState[1]</span><span class="s3">\n  </span><span class="s1">const newRouterStateChildren = newRouterState[1]</span><span class="s3">\n  </span><span class="s1">const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null</span><span class="s3">\n\n  </span><span class="s1">if (!didFindRootLayout) {</span><span class="s3">\n    </span><span class="s1">// We're currently traversing the part of the tree that was also part of</span><span class="s3">\n    </span><span class="s1">// the previous route. If we discover a root layout, then we don't need to</span><span class="s3">\n    </span><span class="s1">// trigger an MPA navigation. See beginRenderingNewRouteTree for context.</span><span class="s3">\n    </span><span class="s1">const isRootLayout = newRouterState[4] === true</span><span class="s3">\n    </span><span class="s1">if (isRootLayout) {</span><span class="s3">\n      </span><span class="s1">// Found a matching root layout.</span><span class="s3">\n      </span><span class="s1">didFindRootLayout = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const oldParallelRoutes = oldCacheNode.parallelRoutes</span><span class="s3">\n\n  </span><span class="s1">// Clone the current set of segment children, even if they aren't active in</span><span class="s3">\n  </span><span class="s1">// the new tree.</span><span class="s3">\n  </span><span class="s1">// TODO: We currently retain all the inactive segments indefinitely, until</span><span class="s3">\n  </span><span class="s1">// there's an explicit refresh, or a parent layout is lazily refreshed. We</span><span class="s3">\n  </span><span class="s1">// rely on this for popstate navigations, which update the Router State Tree</span><span class="s3">\n  </span><span class="s1">// but do not eagerly perform a data fetch, because they expect the segment</span><span class="s3">\n  </span><span class="s1">// data to already be in the Cache Node tree. For highly static sites that</span><span class="s3">\n  </span><span class="s1">// are mostly read-only, this may happen only rarely, causing memory to</span><span class="s3">\n  </span><span class="s1">// leak. We should figure out a better model for the lifetime of inactive</span><span class="s3">\n  </span><span class="s1">// segments, so we can maintain instant back/forward navigations without</span><span class="s3">\n  </span><span class="s1">// leaking memory indefinitely.</span><span class="s3">\n  </span><span class="s1">const prefetchParallelRoutes = new Map(oldParallelRoutes)</span><span class="s3">\n\n  </span><span class="s1">// As we diff the trees, we may sometimes modify (copy-on-write, not mutate)</span><span class="s3">\n  </span><span class="s1">// the Route Tree that was returned by the server — for example, in the case</span><span class="s3">\n  </span><span class="s1">// of default parallel routes, we preserve the currently active segment. To</span><span class="s3">\n  </span><span class="s1">// avoid mutating the original tree, we clone the router state children along</span><span class="s3">\n  </span><span class="s1">// the return path.</span><span class="s3">\n  </span><span class="s1">let patchedRouterStateChildren: {</span><span class="s3">\n    </span><span class="s1">[parallelRouteKey: string]: FlightRouterState</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n  </span><span class="s1">let taskChildren = null</span><span class="s3">\n\n  </span><span class="s1">// Most navigations require a request to fetch additional data from the</span><span class="s3">\n  </span><span class="s1">// server, either because the data was not already prefetched, or because the</span><span class="s3">\n  </span><span class="s1">// target route contains dynamic data that cannot be prefetched.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// However, if the target route is fully static, and it's already completely</span><span class="s3">\n  </span><span class="s1">// loaded into the segment cache, then we can skip the server request.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This starts off as `false`, and is set to `true` if any of the child</span><span class="s3">\n  </span><span class="s1">// routes requires a dynamic request.</span><span class="s3">\n  </span><span class="s1">let needsDynamicRequest = false</span><span class="s3">\n  </span><span class="s1">// As we traverse the children, we'll construct a FlightRouterState that can</span><span class="s3">\n  </span><span class="s1">// be sent to the server to request the dynamic data. If it turns out that</span><span class="s3">\n  </span><span class="s1">// nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the</span><span class="s3">\n  </span><span class="s1">// end), then this will be discarded.</span><span class="s3">\n  </span><span class="s1">// TODO: We can probably optimize the format of this data structure to only</span><span class="s3">\n  </span><span class="s1">// include paths that are dynamic. Instead of reusing the</span><span class="s3">\n  </span><span class="s1">// FlightRouterState type.</span><span class="s3">\n  </span><span class="s1">let dynamicRequestTreeChildren: {</span><span class="s3">\n    </span><span class="s1">[parallelRouteKey: string]: FlightRouterState</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n\n  </span><span class="s1">for (let parallelRouteKey in newRouterStateChildren) {</span><span class="s3">\n    </span><span class="s1">const newRouterStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">newRouterStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const oldRouterStateChild: FlightRouterState | void =</span><span class="s3">\n      </span><span class="s1">oldRouterStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">const prefetchDataChild: CacheNodeSeedData | void | null =</span><span class="s3">\n      </span><span class="s1">prefetchDataChildren !== null</span><span class="s3">\n        </span><span class="s1">? prefetchDataChildren[parallelRouteKey]</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n\n    </span><span class="s1">const newSegmentChild = newRouterStateChild[0]</span><span class="s3">\n    </span><span class="s1">const newSegmentPathChild = segmentPath.concat([</span><span class="s3">\n      </span><span class="s1">parallelRouteKey,</span><span class="s3">\n      </span><span class="s1">newSegmentChild,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)</span><span class="s3">\n\n    </span><span class="s1">const oldSegmentChild =</span><span class="s3">\n      </span><span class="s1">oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined</span><span class="s3">\n\n    </span><span class="s1">const oldCacheNodeChild =</span><span class="s3">\n      </span><span class="s1">oldSegmentMapChild !== undefined</span><span class="s3">\n        </span><span class="s1">? oldSegmentMapChild.get(newSegmentKeyChild)</span><span class="s3">\n        </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">let taskChild: Task | null</span><span class="s3">\n    </span><span class="s1">if (newSegmentChild === DEFAULT_SEGMENT_KEY) {</span><span class="s3">\n      </span><span class="s1">// This is another kind of leaf segment — a default route.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Default routes have special behavior. When there's no matching segment</span><span class="s3">\n      </span><span class="s1">// for a parallel route, Next.js preserves the currently active segment</span><span class="s3">\n      </span><span class="s1">// during a client navigation — but not for initial render. The server</span><span class="s3">\n      </span><span class="s1">// leaves it to the client to account for this. So we need to handle</span><span class="s3">\n      </span><span class="s1">// it here.</span><span class="s3">\n      </span><span class="s1">if (oldRouterStateChild !== undefined) {</span><span class="s3">\n        </span><span class="s1">// Reuse the existing Router State for this segment. We spawn a </span><span class="s3">\&quot;</span><span class="s1">task</span><span class="s3">\&quot;\n        </span><span class="s1">// just to keep track of the updated router state; unlike most, it's</span><span class="s3">\n        </span><span class="s1">// already fulfilled and won't be affected by the dynamic response.</span><span class="s3">\n        </span><span class="s1">taskChild = spawnReusedTask(oldRouterStateChild)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// There's no currently active segment. Switch to the </span><span class="s3">\&quot;</span><span class="s1">create</span><span class="s3">\&quot; </span><span class="s1">path.</span><span class="s3">\n        </span><span class="s1">taskChild = beginRenderingNewRouteTree(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n          </span><span class="s1">newRouterStateChild,</span><span class="s3">\n          </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n          </span><span class="s1">didFindRootLayout,</span><span class="s3">\n          </span><span class="s1">prefetchDataChild !== undefined ? prefetchDataChild : null,</span><span class="s3">\n          </span><span class="s1">prefetchHead,</span><span class="s3">\n          </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n          </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n          </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">isSamePageNavigation &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Check if this is a page segment.</span><span class="s3">\n      </span><span class="s1">// TODO: We're not consistent about how we do this check. Some places</span><span class="s3">\n      </span><span class="s1">// check if the segment starts with PAGE_SEGMENT_KEY, but most seem to</span><span class="s3">\n      </span><span class="s1">// check if there any any children, which is why I'm doing it here. We</span><span class="s3">\n      </span><span class="s1">// should probably encode an empty children set as `null` though. Either</span><span class="s3">\n      </span><span class="s1">// way, we should update all the checks to be consistent.</span><span class="s3">\n      </span><span class="s1">Object.keys(newRouterStateChild[1]).length === 0</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// We special case navigations to the exact same URL as the current</span><span class="s3">\n      </span><span class="s1">// location. It's a common UI pattern for apps to refresh when you click a</span><span class="s3">\n      </span><span class="s1">// link to the current page. So when this happens, we refresh the dynamic</span><span class="s3">\n      </span><span class="s1">// data in the page segments.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Note that this does not apply if the any part of the hash or search</span><span class="s3">\n      </span><span class="s1">// query has changed. This might feel a bit weird but it makes more sense</span><span class="s3">\n      </span><span class="s1">// when you consider that the way to trigger this behavior is to click</span><span class="s3">\n      </span><span class="s1">// the same link multiple times.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// TODO: We should probably refresh the *entire* route when this case</span><span class="s3">\n      </span><span class="s1">// occurs, not just the page segments. Essentially treating it the same as</span><span class="s3">\n      </span><span class="s1">// a refresh() triggered by an action, which is the more explicit way of</span><span class="s3">\n      </span><span class="s1">// modeling the UI pattern described above.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Also note that this only refreshes the dynamic data, not static/</span><span class="s3">\n      </span><span class="s1">// cached data. If the page segment is fully static and prefetched, the</span><span class="s3">\n      </span><span class="s1">// request is skipped. (This is also how refresh() works.)</span><span class="s3">\n      </span><span class="s1">taskChild = beginRenderingNewRouteTree(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n        </span><span class="s1">newRouterStateChild,</span><span class="s3">\n        </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n        </span><span class="s1">didFindRootLayout,</span><span class="s3">\n        </span><span class="s1">prefetchDataChild !== undefined ? prefetchDataChild : null,</span><span class="s3">\n        </span><span class="s1">prefetchHead,</span><span class="s3">\n        </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n        </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n        </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">oldRouterStateChild !== undefined &amp;&amp;</span><span class="s3">\n      </span><span class="s1">oldSegmentChild !== undefined &amp;&amp;</span><span class="s3">\n      </span><span class="s1">matchSegment(newSegmentChild, oldSegmentChild)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">oldCacheNodeChild !== undefined &amp;&amp;</span><span class="s3">\n        </span><span class="s1">oldRouterStateChild !== undefined</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// This segment exists in both the old and new trees. Recursively update</span><span class="s3">\n        </span><span class="s1">// the children.</span><span class="s3">\n        </span><span class="s1">taskChild = updateCacheNodeOnNavigation(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n          </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n          </span><span class="s1">newRouterStateChild,</span><span class="s3">\n          </span><span class="s1">didFindRootLayout,</span><span class="s3">\n          </span><span class="s1">prefetchDataChild,</span><span class="s3">\n          </span><span class="s1">prefetchHead,</span><span class="s3">\n          </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n          </span><span class="s1">isSamePageNavigation,</span><span class="s3">\n          </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n          </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// There's no existing Cache Node for this segment. Switch to the</span><span class="s3">\n        </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">create</span><span class="s3">\&quot; </span><span class="s1">path.</span><span class="s3">\n        </span><span class="s1">taskChild = beginRenderingNewRouteTree(</span><span class="s3">\n          </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n          </span><span class="s1">newRouterStateChild,</span><span class="s3">\n          </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n          </span><span class="s1">didFindRootLayout,</span><span class="s3">\n          </span><span class="s1">prefetchDataChild !== undefined ? prefetchDataChild : null,</span><span class="s3">\n          </span><span class="s1">prefetchHead,</span><span class="s3">\n          </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n          </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n          </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This is a new tree. Switch to the </span><span class="s3">\&quot;</span><span class="s1">create</span><span class="s3">\&quot; </span><span class="s1">path.</span><span class="s3">\n      </span><span class="s1">taskChild = beginRenderingNewRouteTree(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">oldRouterStateChild,</span><span class="s3">\n        </span><span class="s1">newRouterStateChild,</span><span class="s3">\n        </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n        </span><span class="s1">didFindRootLayout,</span><span class="s3">\n        </span><span class="s1">prefetchDataChild !== undefined ? prefetchDataChild : null,</span><span class="s3">\n        </span><span class="s1">prefetchHead,</span><span class="s3">\n        </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n        </span><span class="s1">newSegmentPathChild,</span><span class="s3">\n        </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (taskChild !== null) {</span><span class="s3">\n      </span><span class="s1">// Recursively propagate up the child tasks.</span><span class="s3">\n\n      </span><span class="s1">if (taskChild.route === null) {</span><span class="s3">\n        </span><span class="s1">// One of the child tasks discovered a change to the root layout.</span><span class="s3">\n        </span><span class="s1">// Immediately unwind from this recursive traversal.</span><span class="s3">\n        </span><span class="s1">return MPA_NAVIGATION_TASK</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (taskChildren === null) {</span><span class="s3">\n        </span><span class="s1">taskChildren = new Map()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">taskChildren.set(parallelRouteKey, taskChild)</span><span class="s3">\n      </span><span class="s1">const newCacheNodeChild = taskChild.node</span><span class="s3">\n      </span><span class="s1">if (newCacheNodeChild !== null) {</span><span class="s3">\n        </span><span class="s1">const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)</span><span class="s3">\n        </span><span class="s1">newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)</span><span class="s3">\n        </span><span class="s1">prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// The child tree's route state may be different from the prefetched</span><span class="s3">\n      </span><span class="s1">// route sent by the server. We need to clone it as we traverse back up</span><span class="s3">\n      </span><span class="s1">// the tree.</span><span class="s3">\n      </span><span class="s1">const taskChildRoute = taskChild.route</span><span class="s3">\n      </span><span class="s1">patchedRouterStateChildren[parallelRouteKey] = taskChildRoute</span><span class="s3">\n\n      </span><span class="s1">const dynamicRequestTreeChild = taskChild.dynamicRequestTree</span><span class="s3">\n      </span><span class="s1">if (dynamicRequestTreeChild !== null) {</span><span class="s3">\n        </span><span class="s1">// Something in the child tree is dynamic.</span><span class="s3">\n        </span><span class="s1">needsDynamicRequest = true</span><span class="s3">\n        </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// The child didn't change. We can use the prefetched router state.</span><span class="s3">\n      </span><span class="s1">patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild</span><span class="s3">\n      </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (taskChildren === null) {</span><span class="s3">\n    </span><span class="s1">// No new tasks were spawned.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const newCacheNode: ReadyCacheNode = {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">rsc: oldCacheNode.rsc,</span><span class="s3">\n    </span><span class="s1">// We intentionally aren't updating the prefetchRsc field, since this node</span><span class="s3">\n    </span><span class="s1">// is already part of the current tree, because it would be weird for</span><span class="s3">\n    </span><span class="s1">// prefetch data to be newer than the final data. It probably won't ever be</span><span class="s3">\n    </span><span class="s1">// observable anyway, but it could happen if the segment is unmounted then</span><span class="s3">\n    </span><span class="s1">// mounted again, because LayoutRouter will momentarily switch to rendering</span><span class="s3">\n    </span><span class="s1">// prefetchRsc, via useDeferredValue.</span><span class="s3">\n    </span><span class="s1">prefetchRsc: oldCacheNode.prefetchRsc,</span><span class="s3">\n    </span><span class="s1">head: oldCacheNode.head,</span><span class="s3">\n    </span><span class="s1">prefetchHead: oldCacheNode.prefetchHead,</span><span class="s3">\n    </span><span class="s1">loading: oldCacheNode.loading,</span><span class="s3">\n\n    </span><span class="s1">// Everything is cloned except for the children, which we computed above.</span><span class="s3">\n    </span><span class="s1">parallelRoutes: prefetchParallelRoutes,</span><span class="s3">\n\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// Return a cloned copy of the router state with updated children.</span><span class="s3">\n    </span><span class="s1">route: patchRouterStateWithNewChildren(</span><span class="s3">\n      </span><span class="s1">newRouterState,</span><span class="s3">\n      </span><span class="s1">patchedRouterStateChildren</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">node: newCacheNode,</span><span class="s3">\n    </span><span class="s1">dynamicRequestTree: needsDynamicRequest</span><span class="s3">\n      </span><span class="s1">? patchRouterStateWithNewChildren(</span><span class="s3">\n          </span><span class="s1">newRouterState,</span><span class="s3">\n          </span><span class="s1">dynamicRequestTreeChildren</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n    </span><span class="s1">children: taskChildren,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function beginRenderingNewRouteTree(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">oldRouterState: FlightRouterState | void,</span><span class="s3">\n  </span><span class="s1">newRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">existingCacheNode: CacheNode | void,</span><span class="s3">\n  </span><span class="s1">didFindRootLayout: boolean,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">possiblyPartialPrefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): Task {</span><span class="s3">\n  </span><span class="s1">if (!didFindRootLayout) {</span><span class="s3">\n    </span><span class="s1">// The route tree changed before we reached a layout. (The highest-level</span><span class="s3">\n    </span><span class="s1">// layout in a route tree is referred to as the </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot; </span><span class="s1">layout.) This could</span><span class="s3">\n    </span><span class="s1">// mean that we're navigating between two different root layouts. When this</span><span class="s3">\n    </span><span class="s1">// happens, we perform a full-page (MPA-style) navigation.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// However, the algorithm for deciding where to start rendering a route</span><span class="s3">\n    </span><span class="s1">// (i.e. the one performed in order to reach this function) is stricter</span><span class="s3">\n    </span><span class="s1">// than the one used to detect a change in the root layout. So just because</span><span class="s3">\n    </span><span class="s1">// we're re-rendering a segment outside of the root layout does not mean we</span><span class="s3">\n    </span><span class="s1">// should trigger a full-page navigation.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Specifically, we handle dynamic parameters differently: two segments are</span><span class="s3">\n    </span><span class="s1">// considered the same even if their parameter values are different.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Refer to isNavigatingToNewRootLayout for details.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// Note that we only have to perform this extra traversal if we didn't</span><span class="s3">\n    </span><span class="s1">// already discover a root layout in the part of the tree that is unchanged.</span><span class="s3">\n    </span><span class="s1">// In the common case, this branch is skipped completely.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">oldRouterState === undefined ||</span><span class="s3">\n      </span><span class="s1">isNavigatingToNewRootLayout(oldRouterState, newRouterState)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// The root layout changed. Perform a full-page navigation.</span><span class="s3">\n      </span><span class="s1">return MPA_NAVIGATION_TASK</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return createCacheNodeOnNavigation(</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n    </span><span class="s1">newRouterState,</span><span class="s3">\n    </span><span class="s1">existingCacheNode,</span><span class="s3">\n    </span><span class="s1">prefetchData,</span><span class="s3">\n    </span><span class="s1">possiblyPartialPrefetchHead,</span><span class="s3">\n    </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n    </span><span class="s1">segmentPath,</span><span class="s3">\n    </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createCacheNodeOnNavigation(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">existingCacheNode: CacheNode | void,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">possiblyPartialPrefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): SPANavigationTask {</span><span class="s3">\n  </span><span class="s1">// Same traversal as updateCacheNodeNavigation, but we switch to this path</span><span class="s3">\n  </span><span class="s1">// once we reach the part of the tree that was not in the previous route. We</span><span class="s3">\n  </span><span class="s1">// don't need to diff against the old tree, we just need to create a new one.</span><span class="s3">\n\n  </span><span class="s1">// The head is assigned to every leaf segment delivered by the server. Based</span><span class="s3">\n  </span><span class="s1">// on corresponding logic in fill-lazy-items-till-leaf-with-head.ts</span><span class="s3">\n  </span><span class="s1">const routerStateChildren = routerState[1]</span><span class="s3">\n  </span><span class="s1">const isLeafSegment = Object.keys(routerStateChildren).length === 0</span><span class="s3">\n\n  </span><span class="s1">// Even we're rendering inside the </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">part of the target tree, we may have</span><span class="s3">\n  </span><span class="s1">// a locally cached segment that we can reuse. This may come from either 1)</span><span class="s3">\n  </span><span class="s1">// the CacheNode tree, which lives in React state and is populated by previous</span><span class="s3">\n  </span><span class="s1">// navigations; or 2) the prefetch cache, which is a separate cache that is</span><span class="s3">\n  </span><span class="s1">// populated by prefetches.</span><span class="s3">\n  </span><span class="s1">let rsc: React.ReactNode</span><span class="s3">\n  </span><span class="s1">let loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n  </span><span class="s1">let head: HeadData | null</span><span class="s3">\n  </span><span class="s1">let cacheNodeNavigatedAt: number</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">existingCacheNode !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using</span><span class="s3">\n    </span><span class="s1">// the experimental.staleTimes.dynamic config. When set, we'll avoid</span><span class="s3">\n    </span><span class="s1">// refetching dynamic data if it was fetched within the given threshold.</span><span class="s3">\n    </span><span class="s1">existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS &gt; navigatedAt</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// We have an existing CacheNode for this segment, and it's not stale. We</span><span class="s3">\n    </span><span class="s1">// should reuse it rather than request a new one.</span><span class="s3">\n    </span><span class="s1">rsc = existingCacheNode.rsc</span><span class="s3">\n    </span><span class="s1">loading = existingCacheNode.loading</span><span class="s3">\n    </span><span class="s1">head = existingCacheNode.head</span><span class="s3">\n\n    </span><span class="s1">// Don't update the navigatedAt timestamp, since we're reusing stale data.</span><span class="s3">\n    </span><span class="s1">cacheNodeNavigatedAt = existingCacheNode.navigatedAt</span><span class="s3">\n  </span><span class="s1">} else if (prefetchData !== null) {</span><span class="s3">\n    </span><span class="s1">// There's no existing CacheNode for this segment, but we do have prefetch</span><span class="s3">\n    </span><span class="s1">// data. If the prefetch data is fully static (i.e. does not contain any</span><span class="s3">\n    </span><span class="s1">// dynamic holes), we don't need to request it from the server.</span><span class="s3">\n    </span><span class="s1">rsc = prefetchData[1]</span><span class="s3">\n    </span><span class="s1">loading = prefetchData[3]</span><span class="s3">\n    </span><span class="s1">head = isLeafSegment ? possiblyPartialPrefetchHead : null</span><span class="s3">\n    </span><span class="s1">// Even though we're accessing the data from the prefetch cache, this is</span><span class="s3">\n    </span><span class="s1">// conceptually a new segment, not a reused one. So we should update the</span><span class="s3">\n    </span><span class="s1">// navigatedAt timestamp.</span><span class="s3">\n    </span><span class="s1">cacheNodeNavigatedAt = navigatedAt</span><span class="s3">\n    </span><span class="s1">const isPrefetchRscPartial = prefetchData[4]</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// Check if the segment data is partial</span><span class="s3">\n      </span><span class="s1">isPrefetchRscPartial ||</span><span class="s3">\n      </span><span class="s1">// Check if the head is partial (only relevant if this is a leaf segment)</span><span class="s3">\n      </span><span class="s1">(isPrefetchHeadPartial &amp;&amp; isLeafSegment)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// We only have partial data from this segment. Like missing segments, we</span><span class="s3">\n      </span><span class="s1">// must request the full data from the server.</span><span class="s3">\n      </span><span class="s1">return spawnPendingTask(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">routerState,</span><span class="s3">\n        </span><span class="s1">prefetchData,</span><span class="s3">\n        </span><span class="s1">possiblyPartialPrefetchHead,</span><span class="s3">\n        </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n        </span><span class="s1">segmentPath,</span><span class="s3">\n        </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// The prefetch data is fully static, so we can omit it from the</span><span class="s3">\n      </span><span class="s1">// navigation request.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// There's no prefetch for this segment. Everything from this point will be</span><span class="s3">\n    </span><span class="s1">// requested from the server, even if there are static children below it.</span><span class="s3">\n    </span><span class="s1">// Create a terminal task node that will later be fulfilled by</span><span class="s3">\n    </span><span class="s1">// server response.</span><span class="s3">\n    </span><span class="s1">return spawnPendingTask(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">routerState,</span><span class="s3">\n      </span><span class="s1">null,</span><span class="s3">\n      </span><span class="s1">possiblyPartialPrefetchHead,</span><span class="s3">\n      </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n      </span><span class="s1">segmentPath,</span><span class="s3">\n      </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We already have a full segment we can render, so we don't need to request a</span><span class="s3">\n  </span><span class="s1">// new one from the server. Keep traversing down the tree until we reach</span><span class="s3">\n  </span><span class="s1">// something that requires a dynamic request.</span><span class="s3">\n  </span><span class="s1">const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null</span><span class="s3">\n  </span><span class="s1">const taskChildren = new Map()</span><span class="s3">\n  </span><span class="s1">const existingCacheNodeChildren =</span><span class="s3">\n    </span><span class="s1">existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null</span><span class="s3">\n  </span><span class="s1">const cacheNodeChildren = new Map(existingCacheNodeChildren)</span><span class="s3">\n  </span><span class="s1">let dynamicRequestTreeChildren: {</span><span class="s3">\n    </span><span class="s1">[parallelRouteKey: string]: FlightRouterState</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n  </span><span class="s1">let needsDynamicRequest = false</span><span class="s3">\n  </span><span class="s1">if (isLeafSegment) {</span><span class="s3">\n    </span><span class="s1">// The segment path of every leaf segment (i.e. page) is collected into</span><span class="s3">\n    </span><span class="s1">// a result array. This is used by the LayoutRouter to scroll to ensure that</span><span class="s3">\n    </span><span class="s1">// new pages are visible after a navigation.</span><span class="s3">\n    </span><span class="s1">// TODO: We should use a string to represent the segment path instead of</span><span class="s3">\n    </span><span class="s1">// an array. We already use a string representation for the path when</span><span class="s3">\n    </span><span class="s1">// accessing the Segment Cache, so we can use the same one.</span><span class="s3">\n    </span><span class="s1">scrollableSegmentsResult.push(segmentPath)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (let parallelRouteKey in routerStateChildren) {</span><span class="s3">\n      </span><span class="s1">const routerStateChild: FlightRouterState =</span><span class="s3">\n        </span><span class="s1">routerStateChildren[parallelRouteKey]</span><span class="s3">\n      </span><span class="s1">const prefetchDataChild: CacheNodeSeedData | void | null =</span><span class="s3">\n        </span><span class="s1">prefetchDataChildren !== null</span><span class="s3">\n          </span><span class="s1">? prefetchDataChildren[parallelRouteKey]</span><span class="s3">\n          </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">const existingSegmentMapChild =</span><span class="s3">\n        </span><span class="s1">existingCacheNodeChildren !== null</span><span class="s3">\n          </span><span class="s1">? existingCacheNodeChildren.get(parallelRouteKey)</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n      </span><span class="s1">const segmentChild = routerStateChild[0]</span><span class="s3">\n      </span><span class="s1">const segmentPathChild = segmentPath.concat([</span><span class="s3">\n        </span><span class="s1">parallelRouteKey,</span><span class="s3">\n        </span><span class="s1">segmentChild,</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n      </span><span class="s1">const segmentKeyChild = createRouterCacheKey(segmentChild)</span><span class="s3">\n\n      </span><span class="s1">const existingCacheNodeChild =</span><span class="s3">\n        </span><span class="s1">existingSegmentMapChild !== undefined</span><span class="s3">\n          </span><span class="s1">? existingSegmentMapChild.get(segmentKeyChild)</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n\n      </span><span class="s1">const taskChild = createCacheNodeOnNavigation(</span><span class="s3">\n        </span><span class="s1">navigatedAt,</span><span class="s3">\n        </span><span class="s1">routerStateChild,</span><span class="s3">\n        </span><span class="s1">existingCacheNodeChild,</span><span class="s3">\n        </span><span class="s1">prefetchDataChild,</span><span class="s3">\n        </span><span class="s1">possiblyPartialPrefetchHead,</span><span class="s3">\n        </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n        </span><span class="s1">segmentPathChild,</span><span class="s3">\n        </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">taskChildren.set(parallelRouteKey, taskChild)</span><span class="s3">\n      </span><span class="s1">const dynamicRequestTreeChild = taskChild.dynamicRequestTree</span><span class="s3">\n      </span><span class="s1">if (dynamicRequestTreeChild !== null) {</span><span class="s3">\n        </span><span class="s1">// Something in the child tree is dynamic.</span><span class="s3">\n        </span><span class="s1">needsDynamicRequest = true</span><span class="s3">\n        </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const newCacheNodeChild = taskChild.node</span><span class="s3">\n      </span><span class="s1">if (newCacheNodeChild !== null) {</span><span class="s3">\n        </span><span class="s1">const newSegmentMapChild: ChildSegmentMap = new Map()</span><span class="s3">\n        </span><span class="s1">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)</span><span class="s3">\n        </span><span class="s1">cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// Since we're inside a new route tree, unlike the</span><span class="s3">\n    </span><span class="s1">// `updateCacheNodeOnNavigation` path, the router state on the children</span><span class="s3">\n    </span><span class="s1">// tasks is always the same as the router state we pass in. So we don't need</span><span class="s3">\n    </span><span class="s1">// to clone/modify it.</span><span class="s3">\n    </span><span class="s1">route: routerState,</span><span class="s3">\n    </span><span class="s1">node: {</span><span class="s3">\n      </span><span class="s1">lazyData: null,</span><span class="s3">\n      </span><span class="s1">// Since this segment is already full, we don't need to use the</span><span class="s3">\n      </span><span class="s1">// `prefetchRsc` field.</span><span class="s3">\n      </span><span class="s1">rsc,</span><span class="s3">\n      </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n      </span><span class="s1">head,</span><span class="s3">\n      </span><span class="s1">prefetchHead: null,</span><span class="s3">\n      </span><span class="s1">loading,</span><span class="s3">\n      </span><span class="s1">parallelRoutes: cacheNodeChildren,</span><span class="s3">\n      </span><span class="s1">navigatedAt: cacheNodeNavigatedAt,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">dynamicRequestTree: needsDynamicRequest</span><span class="s3">\n      </span><span class="s1">? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n    </span><span class="s1">children: taskChildren,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function patchRouterStateWithNewChildren(</span><span class="s3">\n  </span><span class="s1">baseRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">newChildren: { [parallelRouteKey: string]: FlightRouterState }</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const clone: FlightRouterState = [baseRouterState[0], newChildren]</span><span class="s3">\n  </span><span class="s1">// Based on equivalent logic in apply-router-state-patch-to-tree, but should</span><span class="s3">\n  </span><span class="s1">// confirm whether we need to copy all of these fields. Not sure the server</span><span class="s3">\n  </span><span class="s1">// ever sends, e.g. the refetch marker.</span><span class="s3">\n  </span><span class="s1">if (2 in baseRouterState) {</span><span class="s3">\n    </span><span class="s1">clone[2] = baseRouterState[2]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (3 in baseRouterState) {</span><span class="s3">\n    </span><span class="s1">clone[3] = baseRouterState[3]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (4 in baseRouterState) {</span><span class="s3">\n    </span><span class="s1">clone[4] = baseRouterState[4]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clone</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function spawnPendingTask(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): SPANavigationTask {</span><span class="s3">\n  </span><span class="s1">// Create a task that will later be fulfilled by data from the server.</span><span class="s3">\n\n  </span><span class="s1">// Clone the prefetched route tree and the `refetch` marker to it. We'll send</span><span class="s3">\n  </span><span class="s1">// this to the server so it knows where to start rendering.</span><span class="s3">\n  </span><span class="s1">const dynamicRequestTree = patchRouterStateWithNewChildren(</span><span class="s3">\n    </span><span class="s1">routerState,</span><span class="s3">\n    </span><span class="s1">routerState[1]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">dynamicRequestTree[3] = 'refetch'</span><span class="s3">\n\n  </span><span class="s1">const newTask: Task = {</span><span class="s3">\n    </span><span class="s1">route: routerState,</span><span class="s3">\n\n    </span><span class="s1">// Corresponds to the part of the route that will be rendered on the server.</span><span class="s3">\n    </span><span class="s1">node: createPendingCacheNode(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">routerState,</span><span class="s3">\n      </span><span class="s1">prefetchData,</span><span class="s3">\n      </span><span class="s1">prefetchHead,</span><span class="s3">\n      </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n      </span><span class="s1">segmentPath,</span><span class="s3">\n      </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">// Because this is non-null, and it gets propagated up through the parent</span><span class="s3">\n    </span><span class="s1">// tasks, the root task will know that it needs to perform a server request.</span><span class="s3">\n    </span><span class="s1">dynamicRequestTree,</span><span class="s3">\n    </span><span class="s1">children: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newTask</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function spawnReusedTask(reusedRouterState: FlightRouterState): Task {</span><span class="s3">\n  </span><span class="s1">// Create a task that reuses an existing segment, e.g. when reusing</span><span class="s3">\n  </span><span class="s1">// the current active segment in place of a default route.</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">route: reusedRouterState,</span><span class="s3">\n    </span><span class="s1">node: null,</span><span class="s3">\n    </span><span class="s1">dynamicRequestTree: null,</span><span class="s3">\n    </span><span class="s1">children: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Writes a dynamic server response into the tree created by</span><span class="s3">\n</span><span class="s1">// updateCacheNodeOnNavigation. All pending promises that were spawned by the</span><span class="s3">\n</span><span class="s1">// navigation will be resolved, either with dynamic data from the server, or</span><span class="s3">\n</span><span class="s1">// `null` to indicate that the data is missing.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// A `null` value will trigger a lazy fetch during render, which will then patch</span><span class="s3">\n</span><span class="s1">// up the tree using the same mechanism as the non-PPR implementation</span><span class="s3">\n</span><span class="s1">// (serverPatchReducer).</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Usually, the server will respond with exactly the subset of data that we're</span><span class="s3">\n</span><span class="s1">// waiting for — everything below the nearest shared layout. But technically,</span><span class="s3">\n</span><span class="s1">// the server can return anything it wants.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// This does _not_ create a new tree; it modifies the existing one in place.</span><span class="s3">\n</span><span class="s1">// Which means it must follow the Suspense rules of cache safety.</span><span class="s3">\n</span><span class="s1">export function listenForDynamicRequest(</span><span class="s3">\n  </span><span class="s1">task: SPANavigationTask,</span><span class="s3">\n  </span><span class="s1">responsePromise: Promise&lt;FetchServerResponseResult&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">responsePromise.then(</span><span class="s3">\n    </span><span class="s1">({ flightData }: FetchServerResponseResult) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (typeof flightData === 'string') {</span><span class="s3">\n        </span><span class="s1">// Happens when navigating to page in `pages` from `app`. We shouldn't</span><span class="s3">\n        </span><span class="s1">// get here because should have already handled this during</span><span class="s3">\n        </span><span class="s1">// the prefetch.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const normalizedFlightData of flightData) {</span><span class="s3">\n        </span><span class="s1">const {</span><span class="s3">\n          </span><span class="s1">segmentPath,</span><span class="s3">\n          </span><span class="s1">tree: serverRouterState,</span><span class="s3">\n          </span><span class="s1">seedData: dynamicData,</span><span class="s3">\n          </span><span class="s1">head: dynamicHead,</span><span class="s3">\n        </span><span class="s1">} = normalizedFlightData</span><span class="s3">\n\n        </span><span class="s1">if (!dynamicData) {</span><span class="s3">\n          </span><span class="s1">// This shouldn't happen. PPR should always send back a response.</span><span class="s3">\n          </span><span class="s1">// However, `FlightDataPath` is a shared type and the pre-PPR handling of</span><span class="s3">\n          </span><span class="s1">// this might return null.</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">writeDynamicDataIntoPendingTask(</span><span class="s3">\n          </span><span class="s1">task,</span><span class="s3">\n          </span><span class="s1">segmentPath,</span><span class="s3">\n          </span><span class="s1">serverRouterState,</span><span class="s3">\n          </span><span class="s1">dynamicData,</span><span class="s3">\n          </span><span class="s1">dynamicHead</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Now that we've exhausted all the data we received from the server, if</span><span class="s3">\n      </span><span class="s1">// there are any remaining pending tasks in the tree, abort them now.</span><span class="s3">\n      </span><span class="s1">// If there's any missing data, it will trigger a lazy fetch.</span><span class="s3">\n      </span><span class="s1">abortTask(task, null)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">(error: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">// This will trigger an error during render</span><span class="s3">\n      </span><span class="s1">abortTask(task, error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function writeDynamicDataIntoPendingTask(</span><span class="s3">\n  </span><span class="s1">rootTask: SPANavigationTask,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">serverRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">dynamicData: CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">dynamicHead: HeadData</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// The data sent by the server represents only a subtree of the app. We need</span><span class="s3">\n  </span><span class="s1">// to find the part of the task tree that matches the server response, and</span><span class="s3">\n  </span><span class="s1">// fulfill it using the dynamic data.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// segmentPath represents the parent path of subtree. It's a repeating pattern</span><span class="s3">\n  </span><span class="s1">// of parallel route key and segment:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   [string, Segment, string, Segment, string, Segment, ...]</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Iterate through the path and finish any tasks that match this payload.</span><span class="s3">\n  </span><span class="s1">let task = rootTask</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; segmentPath.length; i += 2) {</span><span class="s3">\n    </span><span class="s1">const parallelRouteKey: string = segmentPath[i]</span><span class="s3">\n    </span><span class="s1">const segment: Segment = segmentPath[i + 1]</span><span class="s3">\n    </span><span class="s1">const taskChildren = task.children</span><span class="s3">\n    </span><span class="s1">if (taskChildren !== null) {</span><span class="s3">\n      </span><span class="s1">const taskChild = taskChildren.get(parallelRouteKey)</span><span class="s3">\n      </span><span class="s1">if (taskChild !== undefined) {</span><span class="s3">\n        </span><span class="s1">const taskSegment = taskChild.route[0]</span><span class="s3">\n        </span><span class="s1">if (matchSegment(segment, taskSegment)) {</span><span class="s3">\n          </span><span class="s1">// Found a match for this task. Keep traversing down the task tree.</span><span class="s3">\n          </span><span class="s1">task = taskChild</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We didn't find a child task that matches the server data. Exit. We won't</span><span class="s3">\n    </span><span class="s1">// abort the task, though, because a different FlightDataPath may be able to</span><span class="s3">\n    </span><span class="s1">// fulfill it (see loop in listenForDynamicRequest). We only abort tasks</span><span class="s3">\n    </span><span class="s1">// once we've run out of data.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">finishTaskUsingDynamicDataPayload(</span><span class="s3">\n    </span><span class="s1">task,</span><span class="s3">\n    </span><span class="s1">serverRouterState,</span><span class="s3">\n    </span><span class="s1">dynamicData,</span><span class="s3">\n    </span><span class="s1">dynamicHead</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function finishTaskUsingDynamicDataPayload(</span><span class="s3">\n  </span><span class="s1">task: SPANavigationTask,</span><span class="s3">\n  </span><span class="s1">serverRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">dynamicData: CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">dynamicHead: HeadData</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (task.dynamicRequestTree === null) {</span><span class="s3">\n    </span><span class="s1">// Everything in this subtree is already complete. Bail out.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// dynamicData may represent a larger subtree than the task. Before we can</span><span class="s3">\n  </span><span class="s1">// finish the task, we need to line them up.</span><span class="s3">\n  </span><span class="s1">const taskChildren = task.children</span><span class="s3">\n  </span><span class="s1">const taskNode = task.node</span><span class="s3">\n  </span><span class="s1">if (taskChildren === null) {</span><span class="s3">\n    </span><span class="s1">// We've reached the leaf node of the pending task. The server data tree</span><span class="s3">\n    </span><span class="s1">// lines up the pending Cache Node tree. We can now switch to the</span><span class="s3">\n    </span><span class="s1">// normal algorithm.</span><span class="s3">\n    </span><span class="s1">if (taskNode !== null) {</span><span class="s3">\n      </span><span class="s1">finishPendingCacheNode(</span><span class="s3">\n        </span><span class="s1">taskNode,</span><span class="s3">\n        </span><span class="s1">task.route,</span><span class="s3">\n        </span><span class="s1">serverRouterState,</span><span class="s3">\n        </span><span class="s1">dynamicData,</span><span class="s3">\n        </span><span class="s1">dynamicHead</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Set this to null to indicate that this task is now complete.</span><span class="s3">\n      </span><span class="s1">task.dynamicRequestTree = null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// The server returned more data than we need to finish the task. Skip over</span><span class="s3">\n  </span><span class="s1">// the extra segments until we reach the leaf task node.</span><span class="s3">\n  </span><span class="s1">const serverChildren = serverRouterState[1]</span><span class="s3">\n  </span><span class="s1">const dynamicDataChildren = dynamicData[2]</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRouteKey in serverRouterState) {</span><span class="s3">\n    </span><span class="s1">const serverRouterStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">serverChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const dynamicDataChild: CacheNodeSeedData | null | void =</span><span class="s3">\n      </span><span class="s1">dynamicDataChildren[parallelRouteKey]</span><span class="s3">\n\n    </span><span class="s1">const taskChild = taskChildren.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">if (taskChild !== undefined) {</span><span class="s3">\n      </span><span class="s1">const taskSegment = taskChild.route[0]</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">matchSegment(serverRouterStateChild[0], taskSegment) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">dynamicDataChild !== null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">dynamicDataChild !== undefined</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// Found a match for this task. Keep traversing down the task tree.</span><span class="s3">\n        </span><span class="s1">return finishTaskUsingDynamicDataPayload(</span><span class="s3">\n          </span><span class="s1">taskChild,</span><span class="s3">\n          </span><span class="s1">serverRouterStateChild,</span><span class="s3">\n          </span><span class="s1">dynamicDataChild,</span><span class="s3">\n          </span><span class="s1">dynamicHead</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We didn't find a child task that matches the server data. We won't abort</span><span class="s3">\n    </span><span class="s1">// the task, though, because a different FlightDataPath may be able to</span><span class="s3">\n    </span><span class="s1">// fulfill it (see loop in listenForDynamicRequest). We only abort tasks</span><span class="s3">\n    </span><span class="s1">// once we've run out of data.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPendingCacheNode(</span><span class="s3">\n  </span><span class="s1">navigatedAt: number,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">prefetchData: CacheNodeSeedData | null,</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null,</span><span class="s3">\n  </span><span class="s1">isPrefetchHeadPartial: boolean,</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">scrollableSegmentsResult: Array&lt;FlightSegmentPath&gt;</span><span class="s3">\n</span><span class="s1">): ReadyCacheNode {</span><span class="s3">\n  </span><span class="s1">const routerStateChildren = routerState[1]</span><span class="s3">\n  </span><span class="s1">const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null</span><span class="s3">\n\n  </span><span class="s1">const parallelRoutes = new Map()</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in routerStateChildren) {</span><span class="s3">\n    </span><span class="s1">const routerStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">routerStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const prefetchDataChild: CacheNodeSeedData | null | void =</span><span class="s3">\n      </span><span class="s1">prefetchDataChildren !== null</span><span class="s3">\n        </span><span class="s1">? prefetchDataChildren[parallelRouteKey]</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n\n    </span><span class="s1">const segmentChild = routerStateChild[0]</span><span class="s3">\n    </span><span class="s1">const segmentPathChild = segmentPath.concat([</span><span class="s3">\n      </span><span class="s1">parallelRouteKey,</span><span class="s3">\n      </span><span class="s1">segmentChild,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">const segmentKeyChild = createRouterCacheKey(segmentChild)</span><span class="s3">\n\n    </span><span class="s1">const newCacheNodeChild = createPendingCacheNode(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">routerStateChild,</span><span class="s3">\n      </span><span class="s1">prefetchDataChild === undefined ? null : prefetchDataChild,</span><span class="s3">\n      </span><span class="s1">prefetchHead,</span><span class="s3">\n      </span><span class="s1">isPrefetchHeadPartial,</span><span class="s3">\n      </span><span class="s1">segmentPathChild,</span><span class="s3">\n      </span><span class="s1">scrollableSegmentsResult</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const newSegmentMapChild: ChildSegmentMap = new Map()</span><span class="s3">\n    </span><span class="s1">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)</span><span class="s3">\n    </span><span class="s1">parallelRoutes.set(parallelRouteKey, newSegmentMapChild)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// The head is assigned to every leaf segment delivered by the server. Based</span><span class="s3">\n  </span><span class="s1">// on corresponding logic in fill-lazy-items-till-leaf-with-head.ts</span><span class="s3">\n  </span><span class="s1">const isLeafSegment = parallelRoutes.size === 0</span><span class="s3">\n\n  </span><span class="s1">if (isLeafSegment) {</span><span class="s3">\n    </span><span class="s1">// The segment path of every leaf segment (i.e. page) is collected into</span><span class="s3">\n    </span><span class="s1">// a result array. This is used by the LayoutRouter to scroll to ensure that</span><span class="s3">\n    </span><span class="s1">// new pages are visible after a navigation.</span><span class="s3">\n    </span><span class="s1">// TODO: We should use a string to represent the segment path instead of</span><span class="s3">\n    </span><span class="s1">// an array. We already use a string representation for the path when</span><span class="s3">\n    </span><span class="s1">// accessing the Segment Cache, so we can use the same one.</span><span class="s3">\n    </span><span class="s1">scrollableSegmentsResult.push(segmentPath)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null</span><span class="s3">\n  </span><span class="s1">const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">parallelRoutes: parallelRoutes,</span><span class="s3">\n\n    </span><span class="s1">prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,</span><span class="s3">\n    </span><span class="s1">prefetchHead: isLeafSegment ? prefetchHead : [null, null],</span><span class="s3">\n\n    </span><span class="s1">// TODO: Technically, a loading boundary could contain dynamic data. We must</span><span class="s3">\n    </span><span class="s1">// have separate `loading` and `prefetchLoading` fields to handle this, like</span><span class="s3">\n    </span><span class="s1">// we do for the segment data and head.</span><span class="s3">\n    </span><span class="s1">loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,</span><span class="s3">\n\n    </span><span class="s1">// Create a deferred promise. This will be fulfilled once the dynamic</span><span class="s3">\n    </span><span class="s1">// response is received from the server.</span><span class="s3">\n    </span><span class="s1">rsc: createDeferredRsc() as React.ReactNode,</span><span class="s3">\n    </span><span class="s1">head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,</span><span class="s3">\n\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function finishPendingCacheNode(</span><span class="s3">\n  </span><span class="s1">cacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">taskState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">serverState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">dynamicData: CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">dynamicHead: HeadData</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// Writes a dynamic response into an existing Cache Node tree. This does _not_</span><span class="s3">\n  </span><span class="s1">// create a new tree, it updates the existing tree in-place. So it must follow</span><span class="s3">\n  </span><span class="s1">// the Suspense rules of cache safety — it can resolve pending promises, but</span><span class="s3">\n  </span><span class="s1">// it cannot overwrite existing data. It can add segments to the tree (because</span><span class="s3">\n  </span><span class="s1">// a missing segment will cause the layout router to suspend).</span><span class="s3">\n  </span><span class="s1">// but it cannot delete them.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// We must resolve every promise in the tree, or else it will suspend</span><span class="s3">\n  </span><span class="s1">// indefinitely. If we did not receive data for a segment, we will resolve its</span><span class="s3">\n  </span><span class="s1">// data promise to `null` to trigger a lazy fetch during render.</span><span class="s3">\n  </span><span class="s1">const taskStateChildren = taskState[1]</span><span class="s3">\n  </span><span class="s1">const serverStateChildren = serverState[1]</span><span class="s3">\n  </span><span class="s1">const dataChildren = dynamicData[2]</span><span class="s3">\n\n  </span><span class="s1">// The router state that we traverse the tree with (taskState) is the same one</span><span class="s3">\n  </span><span class="s1">// that we used to construct the pending Cache Node tree. That way we're sure</span><span class="s3">\n  </span><span class="s1">// to resolve all the pending promises.</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = cacheNode.parallelRoutes</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in taskStateChildren) {</span><span class="s3">\n    </span><span class="s1">const taskStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">taskStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const serverStateChild: FlightRouterState | void =</span><span class="s3">\n      </span><span class="s1">serverStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const dataChild: CacheNodeSeedData | null | void =</span><span class="s3">\n      </span><span class="s1">dataChildren[parallelRouteKey]</span><span class="s3">\n\n    </span><span class="s1">const segmentMapChild = parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">const taskSegmentChild = taskStateChild[0]</span><span class="s3">\n    </span><span class="s1">const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)</span><span class="s3">\n\n    </span><span class="s1">const cacheNodeChild =</span><span class="s3">\n      </span><span class="s1">segmentMapChild !== undefined</span><span class="s3">\n        </span><span class="s1">? segmentMapChild.get(taskSegmentKeyChild)</span><span class="s3">\n        </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">if (cacheNodeChild !== undefined) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">serverStateChild !== undefined &amp;&amp;</span><span class="s3">\n        </span><span class="s1">matchSegment(taskSegmentChild, serverStateChild[0])</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (dataChild !== undefined &amp;&amp; dataChild !== null) {</span><span class="s3">\n          </span><span class="s1">// This is the happy path. Recursively update all the children.</span><span class="s3">\n          </span><span class="s1">finishPendingCacheNode(</span><span class="s3">\n            </span><span class="s1">cacheNodeChild,</span><span class="s3">\n            </span><span class="s1">taskStateChild,</span><span class="s3">\n            </span><span class="s1">serverStateChild,</span><span class="s3">\n            </span><span class="s1">dataChild,</span><span class="s3">\n            </span><span class="s1">dynamicHead</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// The server never returned data for this segment. Trigger a lazy</span><span class="s3">\n          </span><span class="s1">// fetch during render. This shouldn't happen because the Route Tree</span><span class="s3">\n          </span><span class="s1">// and the Seed Data tree sent by the server should always be the same</span><span class="s3">\n          </span><span class="s1">// shape when part of the same server response.</span><span class="s3">\n          </span><span class="s1">abortPendingCacheNode(taskStateChild, cacheNodeChild, null)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// The server never returned data for this segment. Trigger a lazy</span><span class="s3">\n        </span><span class="s1">// fetch during render.</span><span class="s3">\n        </span><span class="s1">abortPendingCacheNode(taskStateChild, cacheNodeChild, null)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// The server response matches what was expected to receive, but there's</span><span class="s3">\n      </span><span class="s1">// no matching Cache Node in the task tree. This is a bug in the</span><span class="s3">\n      </span><span class="s1">// implementation because we should have created a node for every</span><span class="s3">\n      </span><span class="s1">// segment in the tree that's associated with this task.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Use the dynamic data from the server to fulfill the deferred RSC promise</span><span class="s3">\n  </span><span class="s1">// on the Cache Node.</span><span class="s3">\n  </span><span class="s1">const rsc = cacheNode.rsc</span><span class="s3">\n  </span><span class="s1">const dynamicSegmentData = dynamicData[1]</span><span class="s3">\n  </span><span class="s1">if (rsc === null) {</span><span class="s3">\n    </span><span class="s1">// This is a lazy cache node. We can overwrite it. This is only safe</span><span class="s3">\n    </span><span class="s1">// because we know that the LayoutRouter suspends if `rsc` is `null`.</span><span class="s3">\n    </span><span class="s1">cacheNode.rsc = dynamicSegmentData</span><span class="s3">\n  </span><span class="s1">} else if (isDeferredRsc(rsc)) {</span><span class="s3">\n    </span><span class="s1">// This is a deferred RSC promise. We can fulfill it with the data we just</span><span class="s3">\n    </span><span class="s1">// received from the server. If it was already resolved by a different</span><span class="s3">\n    </span><span class="s1">// navigation, then this does nothing because we can't overwrite data.</span><span class="s3">\n    </span><span class="s1">rsc.resolve(dynamicSegmentData)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// This is not a deferred RSC promise, nor is it empty, so it must have</span><span class="s3">\n    </span><span class="s1">// been populated by a different navigation. We must not overwrite it.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if this is a leaf segment. If so, it will have a `head` property with</span><span class="s3">\n  </span><span class="s1">// a pending promise that needs to be resolved with the dynamic head from</span><span class="s3">\n  </span><span class="s1">// the server.</span><span class="s3">\n  </span><span class="s1">const head = cacheNode.head</span><span class="s3">\n  </span><span class="s1">if (isDeferredRsc(head)) {</span><span class="s3">\n    </span><span class="s1">head.resolve(dynamicHead)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function abortTask(task: SPANavigationTask, error: any): void {</span><span class="s3">\n  </span><span class="s1">const cacheNode = task.node</span><span class="s3">\n  </span><span class="s1">if (cacheNode === null) {</span><span class="s3">\n    </span><span class="s1">// This indicates the task is already complete.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const taskChildren = task.children</span><span class="s3">\n  </span><span class="s1">if (taskChildren === null) {</span><span class="s3">\n    </span><span class="s1">// Reached the leaf task node. This is the root of a pending cache</span><span class="s3">\n    </span><span class="s1">// node tree.</span><span class="s3">\n    </span><span class="s1">abortPendingCacheNode(task.route, cacheNode, error)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// This is an intermediate task node. Keep traversing until we reach a</span><span class="s3">\n    </span><span class="s1">// task node with no children. That will be the root of the cache node tree</span><span class="s3">\n    </span><span class="s1">// that needs to be resolved.</span><span class="s3">\n    </span><span class="s1">for (const taskChild of taskChildren.values()) {</span><span class="s3">\n      </span><span class="s1">abortTask(taskChild, error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Set this to null to indicate that this task is now complete.</span><span class="s3">\n  </span><span class="s1">task.dynamicRequestTree = null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function abortPendingCacheNode(</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">cacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">error: any</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// For every pending segment in the tree, resolve its `rsc` promise to `null`</span><span class="s3">\n  </span><span class="s1">// to trigger a lazy fetch during render.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Or, if an error object is provided, it will error instead.</span><span class="s3">\n  </span><span class="s1">const routerStateChildren = routerState[1]</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = cacheNode.parallelRoutes</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in routerStateChildren) {</span><span class="s3">\n    </span><span class="s1">const routerStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">routerStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const segmentMapChild = parallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">if (segmentMapChild === undefined) {</span><span class="s3">\n      </span><span class="s1">// This shouldn't happen because we're traversing the same tree that was</span><span class="s3">\n      </span><span class="s1">// used to construct the cache nodes in the first place.</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const segmentChild = routerStateChild[0]</span><span class="s3">\n    </span><span class="s1">const segmentKeyChild = createRouterCacheKey(segmentChild)</span><span class="s3">\n    </span><span class="s1">const cacheNodeChild = segmentMapChild.get(segmentKeyChild)</span><span class="s3">\n    </span><span class="s1">if (cacheNodeChild !== undefined) {</span><span class="s3">\n      </span><span class="s1">abortPendingCacheNode(routerStateChild, cacheNodeChild, error)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This shouldn't happen because we're traversing the same tree that was</span><span class="s3">\n      </span><span class="s1">// used to construct the cache nodes in the first place.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const rsc = cacheNode.rsc</span><span class="s3">\n  </span><span class="s1">if (isDeferredRsc(rsc)) {</span><span class="s3">\n    </span><span class="s1">if (error === null) {</span><span class="s3">\n      </span><span class="s1">// This will trigger a lazy fetch during render.</span><span class="s3">\n      </span><span class="s1">rsc.resolve(null)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This will trigger an error during rendering.</span><span class="s3">\n      </span><span class="s1">rsc.reject(error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if this is a leaf segment. If so, it will have a `head` property with</span><span class="s3">\n  </span><span class="s1">// a pending promise that needs to be resolved. If an error was provided, we</span><span class="s3">\n  </span><span class="s1">// will not resolve it with an error, since this is rendered at the root of</span><span class="s3">\n  </span><span class="s1">// the app. We want the segment to error, not the entire app.</span><span class="s3">\n  </span><span class="s1">const head = cacheNode.head</span><span class="s3">\n  </span><span class="s1">if (isDeferredRsc(head)) {</span><span class="s3">\n    </span><span class="s1">head.resolve(null)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function updateCacheNodeOnPopstateRestoration(</span><span class="s3">\n  </span><span class="s1">oldCacheNode: CacheNode,</span><span class="s3">\n  </span><span class="s1">routerState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): ReadyCacheNode {</span><span class="s3">\n  </span><span class="s1">// A popstate navigation reads data from the local cache. It does not issue</span><span class="s3">\n  </span><span class="s1">// new network requests (unless the cache entries have been evicted). So, we</span><span class="s3">\n  </span><span class="s1">// update the cache to drop the prefetch data for any segment whose dynamic</span><span class="s3">\n  </span><span class="s1">// data was already received. This prevents an unnecessary flash back to PPR</span><span class="s3">\n  </span><span class="s1">// state during a back/forward navigation.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This function clones the entire cache node tree and sets the `prefetchRsc`</span><span class="s3">\n  </span><span class="s1">// field to `null` to prevent it from being rendered. We can't mutate the node</span><span class="s3">\n  </span><span class="s1">// in place because this is a concurrent data structure.</span><span class="s3">\n\n  </span><span class="s1">const routerStateChildren = routerState[1]</span><span class="s3">\n  </span><span class="s1">const oldParallelRoutes = oldCacheNode.parallelRoutes</span><span class="s3">\n  </span><span class="s1">const newParallelRoutes = new Map(oldParallelRoutes)</span><span class="s3">\n  </span><span class="s1">for (let parallelRouteKey in routerStateChildren) {</span><span class="s3">\n    </span><span class="s1">const routerStateChild: FlightRouterState =</span><span class="s3">\n      </span><span class="s1">routerStateChildren[parallelRouteKey]</span><span class="s3">\n    </span><span class="s1">const segmentChild = routerStateChild[0]</span><span class="s3">\n    </span><span class="s1">const segmentKeyChild = createRouterCacheKey(segmentChild)</span><span class="s3">\n    </span><span class="s1">const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)</span><span class="s3">\n    </span><span class="s1">if (oldSegmentMapChild !== undefined) {</span><span class="s3">\n      </span><span class="s1">const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)</span><span class="s3">\n      </span><span class="s1">if (oldCacheNodeChild !== undefined) {</span><span class="s3">\n        </span><span class="s1">const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(</span><span class="s3">\n          </span><span class="s1">oldCacheNodeChild,</span><span class="s3">\n          </span><span class="s1">routerStateChild</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">const newSegmentMapChild = new Map(oldSegmentMapChild)</span><span class="s3">\n        </span><span class="s1">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)</span><span class="s3">\n        </span><span class="s1">newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Only show prefetched data if the dynamic data is still pending.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Tehnically, what we're actually checking is whether the dynamic network</span><span class="s3">\n  </span><span class="s1">// response was received. But since it's a streaming response, this does not</span><span class="s3">\n  </span><span class="s1">// mean that all the dynamic data has fully streamed in. It just means that</span><span class="s3">\n  </span><span class="s1">// _some_ of the dynamic data was received. But as a heuristic, we assume that</span><span class="s3">\n  </span><span class="s1">// the rest dynamic data will stream in quickly, so it's still better to skip</span><span class="s3">\n  </span><span class="s1">// the prefetch state.</span><span class="s3">\n  </span><span class="s1">const rsc = oldCacheNode.rsc</span><span class="s3">\n  </span><span class="s1">const shouldUsePrefetch = isDeferredRsc(rsc) &amp;&amp; rsc.status === 'pending'</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">rsc,</span><span class="s3">\n    </span><span class="s1">head: oldCacheNode.head,</span><span class="s3">\n\n    </span><span class="s1">prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],</span><span class="s3">\n    </span><span class="s1">prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,</span><span class="s3">\n    </span><span class="s1">loading: oldCacheNode.loading,</span><span class="s3">\n\n    </span><span class="s1">// These are the cloned children we computed above</span><span class="s3">\n    </span><span class="s1">parallelRoutes: newParallelRoutes,</span><span class="s3">\n\n    </span><span class="s1">navigatedAt: oldCacheNode.navigatedAt,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const DEFERRED = Symbol()</span><span class="s3">\n\n</span><span class="s1">type PendingDeferredRsc = Promise&lt;React.ReactNode&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">status: 'pending'</span><span class="s3">\n  </span><span class="s1">resolve: (value: React.ReactNode) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (error: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">tag: Symbol</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type FulfilledDeferredRsc = Promise&lt;React.ReactNode&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">status: 'fulfilled'</span><span class="s3">\n  </span><span class="s1">value: React.ReactNode</span><span class="s3">\n  </span><span class="s1">resolve: (value: React.ReactNode) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (error: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">tag: Symbol</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RejectedDeferredRsc = Promise&lt;React.ReactNode&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">status: 'rejected'</span><span class="s3">\n  </span><span class="s1">reason: any</span><span class="s3">\n  </span><span class="s1">resolve: (value: React.ReactNode) =&gt; void</span><span class="s3">\n  </span><span class="s1">reject: (error: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">tag: Symbol</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type DeferredRsc =</span><span class="s3">\n  </span><span class="s1">| PendingDeferredRsc</span><span class="s3">\n  </span><span class="s1">| FulfilledDeferredRsc</span><span class="s3">\n  </span><span class="s1">| RejectedDeferredRsc</span><span class="s3">\n\n</span><span class="s1">// This type exists to distinguish a DeferredRsc from a Flight promise. It's a</span><span class="s3">\n</span><span class="s1">// compromise to avoid adding an extra field on every Cache Node, which would be</span><span class="s3">\n</span><span class="s1">// awkward because the pre-PPR parts of codebase would need to account for it,</span><span class="s3">\n</span><span class="s1">// too. We can remove it once type Cache Node type is more settled.</span><span class="s3">\n</span><span class="s1">function isDeferredRsc(value: any): value is DeferredRsc {</span><span class="s3">\n  </span><span class="s1">return value &amp;&amp; value.tag === DEFERRED</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createDeferredRsc(): PendingDeferredRsc {</span><span class="s3">\n  </span><span class="s1">let resolve: any</span><span class="s3">\n  </span><span class="s1">let reject: any</span><span class="s3">\n  </span><span class="s1">const pendingRsc = new Promise&lt;React.ReactNode&gt;((res, rej) =&gt; {</span><span class="s3">\n    </span><span class="s1">resolve = res</span><span class="s3">\n    </span><span class="s1">reject = rej</span><span class="s3">\n  </span><span class="s1">}) as PendingDeferredRsc</span><span class="s3">\n  </span><span class="s1">pendingRsc.status = 'pending'</span><span class="s3">\n  </span><span class="s1">pendingRsc.resolve = (value: React.ReactNode) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (pendingRsc.status === 'pending') {</span><span class="s3">\n      </span><span class="s1">const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any</span><span class="s3">\n      </span><span class="s1">fulfilledRsc.status = 'fulfilled'</span><span class="s3">\n      </span><span class="s1">fulfilledRsc.value = value</span><span class="s3">\n      </span><span class="s1">resolve(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pendingRsc.reject = (error: any) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (pendingRsc.status === 'pending') {</span><span class="s3">\n      </span><span class="s1">const rejectedRsc: RejectedDeferredRsc = pendingRsc as any</span><span class="s3">\n      </span><span class="s1">rejectedRsc.status = 'rejected'</span><span class="s3">\n      </span><span class="s1">rejectedRsc.reason = error</span><span class="s3">\n      </span><span class="s1">reject(error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pendingRsc.tag = DEFERRED</span><span class="s3">\n  </span><span class="s1">return pendingRsc</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;abortTask&quot;</span><span class="s0">,</span><span class="s1">&quot;listenForDynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;startPPRNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;updateCacheNodeOnPopstateRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;MPA_NAVIGATION_TASK&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTree&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;oldCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;oldRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;newRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchData&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchHeadPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;isSamePageNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollableSegmentsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;updateCacheNodeOnNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;didFindRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;oldRouterStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;newRouterStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchDataChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;oldParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;patchedRouterStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;taskChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;needsDynamicRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTreeChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;newRouterStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;oldRouterStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;oldSegmentMapChild&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchDataChild&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegmentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegmentPathChild&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegmentKeyChild&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;oldSegmentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;oldCacheNodeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;taskChild&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;spawnReusedTask&quot;</span><span class="s0">,</span><span class="s1">&quot;beginRenderingNewRouteTree&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNodeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;newSegmentMapChild&quot;</span><span class="s0">,</span><span class="s1">&quot;taskChildRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRequestTreeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;newCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;patchRouterStateWithNewChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;possiblyPartialPrefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;createCacheNodeOnNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;routerStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;isLeafSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeNavigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;DYNAMIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchRscPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;spawnPendingTask&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNodeChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;routerStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;existingSegmentMapChild&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPathChild&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentKeyChild&quot;</span><span class="s0">,</span><span class="s1">&quot;existingCacheNodeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;baseRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;newChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;newTask&quot;</span><span class="s0">,</span><span class="s1">&quot;createPendingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;reusedRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;responsePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;serverRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicData&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicHead&quot;</span><span class="s0">,</span><span class="s1">&quot;writeDynamicDataIntoPendingTask&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;rootTask&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;taskSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;finishTaskUsingDynamicDataPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;taskNode&quot;</span><span class="s0">,</span><span class="s1">&quot;finishPendingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;serverChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicDataChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;serverRouterStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicDataChild&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;maybePrefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;maybePrefetchLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;createDeferredRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;taskState&quot;</span><span class="s0">,</span><span class="s1">&quot;serverState&quot;</span><span class="s0">,</span><span class="s1">&quot;taskStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;serverStateChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;dataChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;taskStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;serverStateChild&quot;</span><span class="s0">,</span><span class="s1">&quot;dataChild&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentMapChild&quot;</span><span class="s0">,</span><span class="s1">&quot;taskSegmentChild&quot;</span><span class="s0">,</span><span class="s1">&quot;taskSegmentKeyChild&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNodeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;abortPendingCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;isDeferredRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;newParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldUsePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFERRED&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;rej&quot;</span><span class="s0">,</span><span class="s1">&quot;fulfilledRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;rejectedRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>