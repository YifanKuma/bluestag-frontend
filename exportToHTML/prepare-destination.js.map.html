<html>
<head>
<title>prepare-destination.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prepare-destination.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../../src/shared/lib/router/utils/prepare-destination.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery } from '../../../../server/request-meta'</span><span class="s3">\n</span><span class="s1">import type { RouteHas } from '../../../../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../../../../server/base-http'</span><span class="s3">\n\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { parseUrl } from './parse-url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">INTERCEPTION_ROUTE_MARKERS,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { getCookieParser } from '../../../../server/api-utils/get-cookie-parser'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp, safeCompile } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensure only a-zA-Z are used for param names for proper interpolating</span><span class="s3">\n </span><span class="s1">* with path-to-regexp</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getSafeParamName(paramName: string) {</span><span class="s3">\n  </span><span class="s1">let newParamName = ''</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; paramName.length; i++) {</span><span class="s3">\n    </span><span class="s1">const charCode = paramName.charCodeAt(i)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 64 &amp;&amp; charCode &lt; 91) || // A-Z</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 96 &amp;&amp; charCode &lt; 123) // a-z</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">newParamName += paramName[i]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newParamName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function escapeSegment(str: string, segmentName: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(</span><span class="s3">\n    </span><span class="s1">new RegExp(`:${escapeStringRegexp(segmentName)}`, 'g'),</span><span class="s3">\n    </span><span class="s1">`__ESC_COLON_${segmentName}`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function unescapeSegments(str: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(/__ESC_COLON_/gi, ':')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function matchHas(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">query: Params,</span><span class="s3">\n  </span><span class="s1">has: RouteHas[] = [],</span><span class="s3">\n  </span><span class="s1">missing: RouteHas[] = []</span><span class="s3">\n</span><span class="s1">): false | Params {</span><span class="s3">\n  </span><span class="s1">const params: Params = {}</span><span class="s3">\n\n  </span><span class="s1">const hasMatch = (hasItem: RouteHas) =&gt; {</span><span class="s3">\n    </span><span class="s1">let value</span><span class="s3">\n    </span><span class="s1">let key = hasItem.key</span><span class="s3">\n\n    </span><span class="s1">switch (hasItem.type) {</span><span class="s3">\n      </span><span class="s1">case 'header': {</span><span class="s3">\n        </span><span class="s1">key = key!.toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = req.headers[key] as string</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'cookie': {</span><span class="s3">\n        </span><span class="s1">if ('cookies' in req) {</span><span class="s3">\n          </span><span class="s1">value = req.cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const cookies = getCookieParser(req.headers)()</span><span class="s3">\n          </span><span class="s1">value = cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'query': {</span><span class="s3">\n        </span><span class="s1">value = query[key!]</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'host': {</span><span class="s3">\n        </span><span class="s1">const { host } = req?.headers || {}</span><span class="s3">\n        </span><span class="s1">// remove port from host if present</span><span class="s3">\n        </span><span class="s1">const hostname = host?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = hostname</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!hasItem.value &amp;&amp; value) {</span><span class="s3">\n      </span><span class="s1">params[getSafeParamName(key!)] = value</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">const matcher = new RegExp(`^${hasItem.value}$`)</span><span class="s3">\n      </span><span class="s1">const matches = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.slice(-1)[0].match(matcher)</span><span class="s3">\n        </span><span class="s1">: value.match(matcher)</span><span class="s3">\n\n      </span><span class="s1">if (matches) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(matches)) {</span><span class="s3">\n          </span><span class="s1">if (matches.groups) {</span><span class="s3">\n            </span><span class="s1">Object.keys(matches.groups).forEach((groupKey) =&gt; {</span><span class="s3">\n              </span><span class="s1">params[groupKey] = matches.groups![groupKey]</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">} else if (hasItem.type === 'host' &amp;&amp; matches[0]) {</span><span class="s3">\n            </span><span class="s1">params.host = matches[0]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const allMatch =</span><span class="s3">\n    </span><span class="s1">has.every((item) =&gt; hasMatch(item)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!missing.some((item) =&gt; hasMatch(item))</span><span class="s3">\n\n  </span><span class="s1">if (allMatch) {</span><span class="s3">\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function compileNonPath(value: string, params: Params): string {</span><span class="s3">\n  </span><span class="s1">if (!value.includes(':')) {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(params)) {</span><span class="s3">\n    </span><span class="s1">if (value.includes(`:${key}`)) {</span><span class="s3">\n      </span><span class="s1">value = value</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">*`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_ASTERISKS`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">?`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_QUESTION`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}(?!</span><span class="s3">\\\\</span><span class="s1">w)`, 'g'),</span><span class="s3">\n          </span><span class="s1">`--ESCAPED_PARAM_COLON${key}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = value</span><span class="s3">\n    </span><span class="s1">.replace(/(:|</span><span class="s3">\\</span><span class="s1">*|</span><span class="s3">\\</span><span class="s1">?|</span><span class="s3">\\</span><span class="s1">+|</span><span class="s3">\\</span><span class="s1">(|</span><span class="s3">\\</span><span class="s1">)|</span><span class="s3">\\</span><span class="s1">{|</span><span class="s3">\\</span><span class="s1">})/g, '</span><span class="s3">\\\\</span><span class="s1">$1')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_PLUS/g, '+')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_COLON/g, ':')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_QUESTION/g, '?')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')</span><span class="s3">\n\n  </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n  </span><span class="s1">// correctly</span><span class="s3">\n  </span><span class="s1">return safeCompile(`/${value}`, { validate: false })(params).slice(1)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseDestination(args: {</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Readonly&lt;Params&gt;</span><span class="s3">\n  </span><span class="s1">query: Readonly&lt;NextParsedUrlQuery&gt;</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let escaped = args.destination</span><span class="s3">\n  </span><span class="s1">for (const param of Object.keys({ ...args.params, ...args.query })) {</span><span class="s3">\n    </span><span class="s1">if (!param) continue</span><span class="s3">\n\n    </span><span class="s1">escaped = escapeSegment(escaped, param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsed = parseUrl(escaped)</span><span class="s3">\n\n  </span><span class="s1">let pathname = parsed.pathname</span><span class="s3">\n  </span><span class="s1">if (pathname) {</span><span class="s3">\n    </span><span class="s1">pathname = unescapeSegments(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let href = parsed.href</span><span class="s3">\n  </span><span class="s1">if (href) {</span><span class="s3">\n    </span><span class="s1">href = unescapeSegments(href)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">if (hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = unescapeSegments(hostname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hash = parsed.hash</span><span class="s3">\n  </span><span class="s1">if (hash) {</span><span class="s3">\n    </span><span class="s1">hash = unescapeSegments(hash)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = parsed.search</span><span class="s3">\n  </span><span class="s1">if (search) {</span><span class="s3">\n    </span><span class="s1">search = unescapeSegments(search)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...parsed,</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">hostname,</span><span class="s3">\n    </span><span class="s1">href,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function prepareDestination(args: {</span><span class="s3">\n  </span><span class="s1">appendParamsToQuery: boolean</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Params</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const parsedDestination = parseDestination(args)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">hostname: destHostname,</span><span class="s3">\n    </span><span class="s1">query: destQuery,</span><span class="s3">\n    </span><span class="s1">search: destSearch,</span><span class="s3">\n  </span><span class="s1">} = parsedDestination</span><span class="s3">\n\n  </span><span class="s1">// The following code assumes that the pathname here includes the hash if it's</span><span class="s3">\n  </span><span class="s1">// present.</span><span class="s3">\n  </span><span class="s1">let destPath = parsedDestination.pathname</span><span class="s3">\n  </span><span class="s1">if (parsedDestination.hash) {</span><span class="s3">\n    </span><span class="s1">destPath = `${destPath}${parsedDestination.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destParams: (string | number)[] = []</span><span class="s3">\n\n  </span><span class="s1">const destPathParamKeys: Key[] = []</span><span class="s3">\n  </span><span class="s1">safePathToRegexp(destPath, destPathParamKeys)</span><span class="s3">\n  </span><span class="s1">for (const key of destPathParamKeys) {</span><span class="s3">\n    </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">const destHostnameParamKeys: Key[] = []</span><span class="s3">\n    </span><span class="s1">safePathToRegexp(destHostname, destHostnameParamKeys)</span><span class="s3">\n    </span><span class="s1">for (const key of destHostnameParamKeys) {</span><span class="s3">\n      </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destPathCompiler = safeCompile(</span><span class="s3">\n    </span><span class="s1">destPath,</span><span class="s3">\n    </span><span class="s1">// we don't validate while compiling the destination since we should</span><span class="s3">\n    </span><span class="s1">// have already validated before we got to this point and validating</span><span class="s3">\n    </span><span class="s1">// breaks compiling destinations with named pattern params from the source</span><span class="s3">\n    </span><span class="s1">// e.g. /something:hello(.*) -&gt; /another/:hello is broken with validation</span><span class="s3">\n    </span><span class="s1">// since compile validation is meant for reversing and not for inserting</span><span class="s3">\n    </span><span class="s1">// params from a separate path-regex into another</span><span class="s3">\n    </span><span class="s1">{ validate: false }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let destHostnameCompiler</span><span class="s3">\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">destHostnameCompiler = safeCompile(destHostname, { validate: false })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// update any params in query values</span><span class="s3">\n  </span><span class="s1">for (const [key, strOrArray] of Object.entries(destQuery)) {</span><span class="s3">\n    </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n    </span><span class="s1">// correctly</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(strOrArray)) {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = strOrArray.map((value) =&gt;</span><span class="s3">\n        </span><span class="s1">compileNonPath(unescapeSegments(value), args.params)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (typeof strOrArray === 'string') {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add path params to query if it's not a redirect and not</span><span class="s3">\n  </span><span class="s1">// already defined in destination query or path</span><span class="s3">\n  </span><span class="s1">let paramKeys = Object.keys(args.params).filter(</span><span class="s3">\n    </span><span class="s1">(name) =&gt; name !== 'nextInternalLocale'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">args.appendParamsToQuery &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!paramKeys.some((key) =&gt; destParams.includes(key))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const key of paramKeys) {</span><span class="s3">\n      </span><span class="s1">if (!(key in destQuery)) {</span><span class="s3">\n        </span><span class="s1">destQuery[key] = args.params[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let newUrl</span><span class="s3">\n\n  </span><span class="s1">// The compiler also that the interception route marker is an unnamed param, hence '0',</span><span class="s3">\n  </span><span class="s1">// so we need to add it to the params object.</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(destPath)) {</span><span class="s3">\n    </span><span class="s1">for (const segment of destPath.split('/')) {</span><span class="s3">\n      </span><span class="s1">const marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n        </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (marker) {</span><span class="s3">\n        </span><span class="s1">if (marker === '(..)(..)') {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = '(..)'</span><span class="s3">\n          </span><span class="s1">args.params['1'] = '(..)'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = marker</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">newUrl = destPathCompiler(args.params)</span><span class="s3">\n\n    </span><span class="s1">const [pathname, hash] = newUrl.split('#', 2)</span><span class="s3">\n    </span><span class="s1">if (destHostnameCompiler) {</span><span class="s3">\n      </span><span class="s1">parsedDestination.hostname = destHostnameCompiler(args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parsedDestination.pathname = pathname</span><span class="s3">\n    </span><span class="s1">parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`</span><span class="s3">\n    </span><span class="s1">parsedDestination.search = destSearch</span><span class="s3">\n      </span><span class="s1">? compileNonPath(destSearch, args.params)</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">if (err.message.match(/Expected .*? to not repeat, but got an array/)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`To use a multi-match in the destination you must add </span><span class="s3">\\</span><span class="s1">`*</span><span class="s3">\\</span><span class="s1">` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Query merge order lowest priority to highest</span><span class="s3">\n  </span><span class="s1">// 1. initial URL query values</span><span class="s3">\n  </span><span class="s1">// 2. path segment values</span><span class="s3">\n  </span><span class="s1">// 3. destination specified query values</span><span class="s3">\n  </span><span class="s1">parsedDestination.query = {</span><span class="s3">\n    </span><span class="s1">...args.query,</span><span class="s3">\n    </span><span class="s1">...parsedDestination.query,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">newUrl,</span><span class="s3">\n    </span><span class="s1">destQuery,</span><span class="s3">\n    </span><span class="s1">parsedDestination,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;compileNonPath&quot;</span><span class="s0">,</span><span class="s1">&quot;matchHas&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;newParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;charCode&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentName&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeStringRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapeSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;missing&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasItem&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;getCookieParser&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;groupKey&quot;</span><span class="s0">,</span><span class="s1">&quot;allMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;safeCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;escaped&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;parsed&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;destQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;destSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;destPath&quot;</span><span class="s0">,</span><span class="s1">&quot;destParams&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;safePathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;strOrArray&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;appendParamsToQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;newUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;marker&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>