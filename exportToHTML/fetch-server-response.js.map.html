<html>
<head>
<title>fetch-server-response.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fetch-server-response.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/fetch-server-response.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">// TODO: Explicitly import from client.browser</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">NavigationFlightResponse,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">import type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_RSC_UNION_QUERY,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">RSC_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_DID_POSTPONE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STALE_TIME_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../app-router-headers'</span><span class="s3">\n</span><span class="s1">import { callServer } from '../../app-call-server'</span><span class="s3">\n</span><span class="s1">import { findSourceMapURL } from '../../app-find-source-map-url'</span><span class="s3">\n</span><span class="s1">import { PrefetchKind } from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">normalizeFlightData,</span><span class="s3">\n  </span><span class="s1">prepareFlightRouterStateForRequest,</span><span class="s3">\n  </span><span class="s1">type NormalizedFlightData,</span><span class="s3">\n</span><span class="s1">} from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { getAppBuildId } from '../../app-build-id'</span><span class="s3">\n</span><span class="s1">import { setCacheBustingSearchParam } from './set-cache-busting-search-param'</span><span class="s3">\n</span><span class="s1">import { urlToUrlWithoutFlightMarker } from '../../route-params'</span><span class="s3">\n\n</span><span class="s1">const createFromReadableStream =</span><span class="s3">\n  </span><span class="s1">createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']</span><span class="s3">\n\n</span><span class="s1">export interface FetchServerResponseOptions {</span><span class="s3">\n  </span><span class="s1">readonly flightRouterState: FlightRouterState</span><span class="s3">\n  </span><span class="s1">readonly nextUrl: string | null</span><span class="s3">\n  </span><span class="s1">readonly prefetchKind?: PrefetchKind</span><span class="s3">\n  </span><span class="s1">readonly isHmrRefresh?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FetchServerResponseResult = {</span><span class="s3">\n  </span><span class="s1">flightData: NormalizedFlightData[] | string</span><span class="s3">\n  </span><span class="s1">canonicalUrl: URL | undefined</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted: boolean</span><span class="s3">\n  </span><span class="s1">prerendered: boolean</span><span class="s3">\n  </span><span class="s1">postponed: boolean</span><span class="s3">\n  </span><span class="s1">staleTime: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RequestHeaders = {</span><span class="s3">\n  </span><span class="s1">[RSC_HEADER]?: '1'</span><span class="s3">\n  </span><span class="s1">[NEXT_ROUTER_STATE_TREE_HEADER]?: string</span><span class="s3">\n  </span><span class="s1">[NEXT_URL]?: string</span><span class="s3">\n  </span><span class="s1">[NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'</span><span class="s3">\n  </span><span class="s1">[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string</span><span class="s3">\n  </span><span class="s1">'x-deployment-id'?: string</span><span class="s3">\n  </span><span class="s1">[NEXT_HMR_REFRESH_HEADER]?: '1'</span><span class="s3">\n  </span><span class="s1">// A header that is only added in test mode to assert on fetch priority</span><span class="s3">\n  </span><span class="s1">'Next-Test-Fetch-Priority'?: RequestInit['priority']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function doMpaNavigation(url: string): FetchServerResponseResult {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">flightData: urlToUrlWithoutFlightMarker(</span><span class="s3">\n      </span><span class="s1">new URL(url, location.origin)</span><span class="s3">\n    </span><span class="s1">).toString(),</span><span class="s3">\n    </span><span class="s1">canonicalUrl: undefined,</span><span class="s3">\n    </span><span class="s1">couldBeIntercepted: false,</span><span class="s3">\n    </span><span class="s1">prerendered: false,</span><span class="s3">\n    </span><span class="s1">postponed: false,</span><span class="s3">\n    </span><span class="s1">staleTime: -1,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let abortController = new AbortController()</span><span class="s3">\n\n</span><span class="s1">if (typeof window !== 'undefined') {</span><span class="s3">\n  </span><span class="s1">// Abort any in-flight requests when the page is unloaded, e.g. due to</span><span class="s3">\n  </span><span class="s1">// reloading the page or performing hard navigations. This allows us to ignore</span><span class="s3">\n  </span><span class="s1">// what would otherwise be a thrown TypeError when the browser cancels the</span><span class="s3">\n  </span><span class="s1">// requests.</span><span class="s3">\n  </span><span class="s1">window.addEventListener('pagehide', () =&gt; {</span><span class="s3">\n    </span><span class="s1">abortController.abort()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Use a fresh AbortController instance on pageshow, e.g. when navigating back</span><span class="s3">\n  </span><span class="s1">// and the JavaScript execution context is restored by the browser.</span><span class="s3">\n  </span><span class="s1">window.addEventListener('pageshow', () =&gt; {</span><span class="s3">\n    </span><span class="s1">abortController = new AbortController()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Fetch the flight data for the provided url. Takes in the current router state</span><span class="s3">\n </span><span class="s1">* to decide what to render server-side.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function fetchServerResponse(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">options: FetchServerResponseOptions</span><span class="s3">\n</span><span class="s1">): Promise&lt;FetchServerResponseResult&gt; {</span><span class="s3">\n  </span><span class="s1">const { flightRouterState, nextUrl, prefetchKind } = options</span><span class="s3">\n\n  </span><span class="s1">const headers: RequestHeaders = {</span><span class="s3">\n    </span><span class="s1">// Enable flight response</span><span class="s3">\n    </span><span class="s1">[RSC_HEADER]: '1',</span><span class="s3">\n    </span><span class="s1">// Provide the current router state</span><span class="s3">\n    </span><span class="s1">[NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(</span><span class="s3">\n      </span><span class="s1">flightRouterState,</span><span class="s3">\n      </span><span class="s1">options.isHmrRefresh</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Three cases:</span><span class="s3">\n   </span><span class="s1">* - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully</span><span class="s3">\n   </span><span class="s1">* - `prefetchKind` is `full` - we want to prefetch the whole page so same as above</span><span class="s3">\n   </span><span class="s1">* - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">if (prefetchKind === PrefetchKind.AUTO) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development' &amp;&amp; options.isHmrRefresh) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_HMR_REFRESH_HEADER] = '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (nextUrl) {</span><span class="s3">\n    </span><span class="s1">headers[NEXT_URL] = nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// When creating a </span><span class="s3">\&quot;</span><span class="s1">temporary</span><span class="s3">\&quot; </span><span class="s1">prefetch (the </span><span class="s3">\&quot;</span><span class="s1">on-demand</span><span class="s3">\&quot; </span><span class="s1">prefetch that gets created on navigation, if one doesn't exist)</span><span class="s3">\n    </span><span class="s1">// we send the request with a </span><span class="s3">\&quot;</span><span class="s1">high</span><span class="s3">\&quot; </span><span class="s1">priority as it's in response to a user interaction that could be blocking a transition.</span><span class="s3">\n    </span><span class="s1">// Otherwise, all other prefetches are sent with a </span><span class="s3">\&quot;</span><span class="s1">low</span><span class="s3">\&quot; </span><span class="s1">priority.</span><span class="s3">\n    </span><span class="s1">// We use </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot; </span><span class="s1">for in all other cases to match the existing default, as this function is shared outside of prefetching.</span><span class="s3">\n    </span><span class="s1">const fetchPriority = prefetchKind</span><span class="s3">\n      </span><span class="s1">? prefetchKind === PrefetchKind.TEMPORARY</span><span class="s3">\n        </span><span class="s1">? 'high'</span><span class="s3">\n        </span><span class="s1">: 'low'</span><span class="s3">\n      </span><span class="s1">: 'auto'</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n      </span><span class="s1">if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {</span><span class="s3">\n        </span><span class="s1">// In </span><span class="s3">\&quot;</span><span class="s1">output: export</span><span class="s3">\&quot; </span><span class="s1">mode, we can't rely on headers to distinguish</span><span class="s3">\n        </span><span class="s1">// between HTML and RSC requests. Instead, we append an extra prefix</span><span class="s3">\n        </span><span class="s1">// to the request.</span><span class="s3">\n        </span><span class="s1">url = new URL(url)</span><span class="s3">\n        </span><span class="s1">if (url.pathname.endsWith('/')) {</span><span class="s3">\n          </span><span class="s1">url.pathname += 'index.txt'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">url.pathname += '.txt'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const res = await createFetch(</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">fetchPriority,</span><span class="s3">\n      </span><span class="s1">abortController.signal</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))</span><span class="s3">\n    </span><span class="s1">const canonicalUrl = res.redirected ? responseUrl : undefined</span><span class="s3">\n\n    </span><span class="s1">const contentType = res.headers.get('content-type') || ''</span><span class="s3">\n    </span><span class="s1">const interception = !!res.headers.get('vary')?.includes(NEXT_URL)</span><span class="s3">\n    </span><span class="s1">const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)</span><span class="s3">\n    </span><span class="s1">const staleTimeHeaderSeconds = res.headers.get(</span><span class="s3">\n      </span><span class="s1">NEXT_ROUTER_STALE_TIME_HEADER</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const staleTime =</span><span class="s3">\n      </span><span class="s1">staleTimeHeaderSeconds !== null</span><span class="s3">\n        </span><span class="s1">? parseInt(staleTimeHeaderSeconds, 10) * 1000</span><span class="s3">\n        </span><span class="s1">: -1</span><span class="s3">\n    </span><span class="s1">let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n      </span><span class="s1">if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {</span><span class="s3">\n        </span><span class="s1">if (!isFlightResponse) {</span><span class="s3">\n          </span><span class="s1">isFlightResponse = contentType.startsWith('text/plain')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If fetch returns something different than flight response handle it like a mpa navigation</span><span class="s3">\n    </span><span class="s1">// If the fetch was not 200, we also handle it like a mpa navigation</span><span class="s3">\n    </span><span class="s1">if (!isFlightResponse || !res.ok || !res.body) {</span><span class="s3">\n      </span><span class="s1">// in case the original URL came with a hash, preserve it before redirecting to the new URL</span><span class="s3">\n      </span><span class="s1">if (url.hash) {</span><span class="s3">\n        </span><span class="s1">responseUrl.hash = url.hash</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return doMpaNavigation(responseUrl.toString())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We may navigate to a page that requires a different Webpack runtime.</span><span class="s3">\n    </span><span class="s1">// In prod, every page will have the same Webpack runtime.</span><span class="s3">\n    </span><span class="s1">// In dev, the Webpack runtime is minimal for each page.</span><span class="s3">\n    </span><span class="s1">// We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production' &amp;&amp; !process.env.TURBOPACK) {</span><span class="s3">\n      </span><span class="s1">await (</span><span class="s3">\n        </span><span class="s1">require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')</span><span class="s3">\n      </span><span class="s1">).waitForWebpackRuntimeHotUpdate()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Handle the `fetch` readable stream that can be unwrapped by `React.use`.</span><span class="s3">\n    </span><span class="s1">const flightStream = postponed</span><span class="s3">\n      </span><span class="s1">? createUnclosingPrefetchStream(res.body)</span><span class="s3">\n      </span><span class="s1">: res.body</span><span class="s3">\n    </span><span class="s1">const response = await (createFromNextReadableStream(</span><span class="s3">\n      </span><span class="s1">flightStream</span><span class="s3">\n    </span><span class="s1">) as Promise&lt;NavigationFlightResponse&gt;)</span><span class="s3">\n\n    </span><span class="s1">if (getAppBuildId() !== response.b) {</span><span class="s3">\n      </span><span class="s1">return doMpaNavigation(res.url)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">flightData: normalizeFlightData(response.f),</span><span class="s3">\n      </span><span class="s1">canonicalUrl: canonicalUrl,</span><span class="s3">\n      </span><span class="s1">couldBeIntercepted: interception,</span><span class="s3">\n      </span><span class="s1">prerendered: response.S,</span><span class="s3">\n      </span><span class="s1">postponed,</span><span class="s3">\n      </span><span class="s1">staleTime,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (!abortController.signal.aborted) {</span><span class="s3">\n      </span><span class="s1">console.error(</span><span class="s3">\n        </span><span class="s1">`Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,</span><span class="s3">\n        </span><span class="s1">err</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If fetch fails handle it like a mpa navigation</span><span class="s3">\n    </span><span class="s1">// TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.</span><span class="s3">\n    </span><span class="s1">// See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">flightData: url.toString(),</span><span class="s3">\n      </span><span class="s1">canonicalUrl: undefined,</span><span class="s3">\n      </span><span class="s1">couldBeIntercepted: false,</span><span class="s3">\n      </span><span class="s1">prerendered: false,</span><span class="s3">\n      </span><span class="s1">postponed: false,</span><span class="s3">\n      </span><span class="s1">staleTime: -1,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// This is a subset of the standard Response type. We use a custom type for</span><span class="s3">\n</span><span class="s1">// this so we can limit which details about the response leak into the rest of</span><span class="s3">\n</span><span class="s1">// the codebase. For example, there's some custom logic for manually following</span><span class="s3">\n</span><span class="s1">// redirects, so </span><span class="s3">\&quot;</span><span class="s1">redirected</span><span class="s3">\&quot; </span><span class="s1">in this type could be a composite of multiple</span><span class="s3">\n</span><span class="s1">// browser fetch calls; however, this fact should not leak to the caller.</span><span class="s3">\n</span><span class="s1">export type RSCResponse = {</span><span class="s3">\n  </span><span class="s1">ok: boolean</span><span class="s3">\n  </span><span class="s1">redirected: boolean</span><span class="s3">\n  </span><span class="s1">headers: Headers</span><span class="s3">\n  </span><span class="s1">body: ReadableStream&lt;Uint8Array&gt; | null</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function createFetch(</span><span class="s3">\n  </span><span class="s1">url: URL,</span><span class="s3">\n  </span><span class="s1">headers: RequestHeaders,</span><span class="s3">\n  </span><span class="s1">fetchPriority: 'auto' | 'high' | 'low' | null,</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n</span><span class="s1">): Promise&lt;RSCResponse&gt; {</span><span class="s3">\n  </span><span class="s1">// TODO: In output: </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot; </span><span class="s1">mode, the headers do nothing. Omit them (and the</span><span class="s3">\n  </span><span class="s1">// cache busting search param) from the request so they're</span><span class="s3">\n  </span><span class="s1">// maximally cacheable.</span><span class="s3">\n\n  </span><span class="s1">if (process.env.__NEXT_TEST_MODE &amp;&amp; fetchPriority !== null) {</span><span class="s3">\n    </span><span class="s1">headers['Next-Test-Fetch-Priority'] = fetchPriority</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NEXT_DEPLOYMENT_ID) {</span><span class="s3">\n    </span><span class="s1">headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const fetchOptions: RequestInit = {</span><span class="s3">\n    </span><span class="s1">// Backwards compat for older browsers. `same-origin` is the default in modern browsers.</span><span class="s3">\n    </span><span class="s1">credentials: 'same-origin',</span><span class="s3">\n    </span><span class="s1">headers,</span><span class="s3">\n    </span><span class="s1">priority: fetchPriority || undefined,</span><span class="s3">\n    </span><span class="s1">signal,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// `fetchUrl` is slightly different from `url` because we add a cache-busting</span><span class="s3">\n  </span><span class="s1">// search param to it. This should not leak outside of this function, so we</span><span class="s3">\n  </span><span class="s1">// track them separately.</span><span class="s3">\n  </span><span class="s1">let fetchUrl = new URL(url)</span><span class="s3">\n  </span><span class="s1">setCacheBustingSearchParam(fetchUrl, headers)</span><span class="s3">\n  </span><span class="s1">let browserResponse = await fetch(fetchUrl, fetchOptions)</span><span class="s3">\n\n  </span><span class="s1">// If the server responds with a redirect (e.g. 307), and the redirected</span><span class="s3">\n  </span><span class="s1">// location does not contain the cache busting search param set in the</span><span class="s3">\n  </span><span class="s1">// original request, the response is likely invalid â€” when following the</span><span class="s3">\n  </span><span class="s1">// redirect, the browser forwards the request headers, but since the cache</span><span class="s3">\n  </span><span class="s1">// busting search param is missing, the server will reject the request due to</span><span class="s3">\n  </span><span class="s1">// a mismatch.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Ideally, we would be able to intercept the redirect response and perform it</span><span class="s3">\n  </span><span class="s1">// manually, instead of letting the browser automatically follow it, but this</span><span class="s3">\n  </span><span class="s1">// is not allowed by the fetch API.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// So instead, we must </span><span class="s3">\&quot;</span><span class="s1">replay</span><span class="s3">\&quot; </span><span class="s1">the redirect by fetching the new location</span><span class="s3">\n  </span><span class="s1">// again, but this time we'll append the cache busting search param to prevent</span><span class="s3">\n  </span><span class="s1">// a mismatch.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// TODO: We can optimize Next.js's built-in middleware APIs by returning a</span><span class="s3">\n  </span><span class="s1">// custom status code, to prevent the browser from automatically following it.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This does not affect Server Action-based redirects; those are encoded</span><span class="s3">\n  </span><span class="s1">// differently, as part of the Flight body. It only affects redirects that</span><span class="s3">\n  </span><span class="s1">// occur in a middleware or a third-party proxy.</span><span class="s3">\n\n  </span><span class="s1">let redirected = browserResponse.redirected</span><span class="s3">\n  </span><span class="s1">if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {</span><span class="s3">\n    </span><span class="s1">// This is to prevent a redirect loop. Same limit used by Chrome.</span><span class="s3">\n    </span><span class="s1">const MAX_REDIRECTS = 20</span><span class="s3">\n    </span><span class="s1">for (let n = 0; n &lt; MAX_REDIRECTS; n++) {</span><span class="s3">\n      </span><span class="s1">if (!browserResponse.redirected) {</span><span class="s3">\n        </span><span class="s1">// The server did not perform a redirect.</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const responseUrl = new URL(browserResponse.url, fetchUrl)</span><span class="s3">\n      </span><span class="s1">if (responseUrl.origin !== fetchUrl.origin) {</span><span class="s3">\n        </span><span class="s1">// The server redirected to an external URL. The rest of the logic below</span><span class="s3">\n        </span><span class="s1">// is not relevant, because it only applies to internal redirects.</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===</span><span class="s3">\n        </span><span class="s1">fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// The redirected URL already includes the cache busting search param.</span><span class="s3">\n        </span><span class="s1">// This was probably intentional. Regardless, there's no reason to</span><span class="s3">\n        </span><span class="s1">// issue another request to this URL because it already has the param</span><span class="s3">\n        </span><span class="s1">// value that we would have added below.</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// The RSC request was redirected. Assume the response is invalid.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// Append the cache busting search param to the redirected URL and</span><span class="s3">\n      </span><span class="s1">// fetch again.</span><span class="s3">\n      </span><span class="s1">fetchUrl = new URL(responseUrl)</span><span class="s3">\n      </span><span class="s1">setCacheBustingSearchParam(fetchUrl, headers)</span><span class="s3">\n      </span><span class="s1">browserResponse = await fetch(fetchUrl, fetchOptions)</span><span class="s3">\n      </span><span class="s1">// We just performed a manual redirect, so this is now true.</span><span class="s3">\n      </span><span class="s1">redirected = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Remove the cache busting search param from the response URL, to prevent it</span><span class="s3">\n  </span><span class="s1">// from leaking outside of this function.</span><span class="s3">\n  </span><span class="s1">const responseUrl = new URL(browserResponse.url, fetchUrl)</span><span class="s3">\n  </span><span class="s1">responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">const rscResponse: RSCResponse = {</span><span class="s3">\n    </span><span class="s1">url: responseUrl.href,</span><span class="s3">\n\n    </span><span class="s1">// This is true if any redirects occurred, either automatically by the</span><span class="s3">\n    </span><span class="s1">// browser, or manually by us. So it's different from</span><span class="s3">\n    </span><span class="s1">// `browserResponse.redirected`, which only tells us whether the browser</span><span class="s3">\n    </span><span class="s1">// followed a redirect, and only for the last response in the chain.</span><span class="s3">\n    </span><span class="s1">redirected,</span><span class="s3">\n\n    </span><span class="s1">// These can be copied from the last browser response we received. We</span><span class="s3">\n    </span><span class="s1">// intentionally only expose the subset of fields that are actually used</span><span class="s3">\n    </span><span class="s1">// elsewhere in the codebase.</span><span class="s3">\n    </span><span class="s1">ok: browserResponse.ok,</span><span class="s3">\n    </span><span class="s1">headers: browserResponse.headers,</span><span class="s3">\n    </span><span class="s1">body: browserResponse.body,</span><span class="s3">\n    </span><span class="s1">status: browserResponse.status,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return rscResponse</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createFromNextReadableStream(</span><span class="s3">\n  </span><span class="s1">flightStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;unknown&gt; {</span><span class="s3">\n  </span><span class="s1">return createFromReadableStream(flightStream, {</span><span class="s3">\n    </span><span class="s1">callServer,</span><span class="s3">\n    </span><span class="s1">findSourceMapURL,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createUnclosingPrefetchStream(</span><span class="s3">\n  </span><span class="s1">originalFlightStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">// When PPR is enabled, prefetch streams may contain references that never</span><span class="s3">\n  </span><span class="s1">// resolve, because that's how we encode dynamic data access. In the decoded</span><span class="s3">\n  </span><span class="s1">// object returned by the Flight client, these are reified into hanging</span><span class="s3">\n  </span><span class="s1">// promises that suspend during render, which is effectively what we want.</span><span class="s3">\n  </span><span class="s1">// The UI resolves when it switches to the dynamic data stream</span><span class="s3">\n  </span><span class="s1">// (via useDeferredValue(dynamic, static)).</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// However, the Flight implementation currently errors if the server closes</span><span class="s3">\n  </span><span class="s1">// the response before all the references are resolved. As a cheat to work</span><span class="s3">\n  </span><span class="s1">// around this, we wrap the original stream in a new stream that never closes,</span><span class="s3">\n  </span><span class="s1">// and therefore doesn't error.</span><span class="s3">\n  </span><span class="s1">const reader = originalFlightStream.getReader()</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">async pull(controller) {</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n        </span><span class="s1">if (!done) {</span><span class="s3">\n          </span><span class="s1">// Pass to the target stream and keep consuming the Flight response</span><span class="s3">\n          </span><span class="s1">// from the server.</span><span class="s3">\n          </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The server stream has closed. Exit, but intentionally do not close</span><span class="s3">\n        </span><span class="s1">// the target stream.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromNextReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStreamBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;doMpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;urlToUrlWithoutFlightMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;abortController&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareFlightRouterStateForRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_HMR_REFRESH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPriority&quot;</span><span class="s0">,</span><span class="s1">&quot;TEMPORARY&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CONFIG_OUTPUT&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;responseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;redirected&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;interception&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DID_POSTPONE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTimeHeaderSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STALE_TIME_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;isFlightResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;TURBOPACK&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;waitForWebpackRuntimeHotUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;flightStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createUnclosingPrefetchStream&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;getAppBuildId&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;S&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TEST_MODE&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DEPLOYMENT_ID&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;credentials&quot;</span><span class="s0">,</span><span class="s1">&quot;priority&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;setCacheBustingSearchParam&quot;</span><span class="s0">,</span><span class="s1">&quot;browserResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS&quot;</span><span class="s0">,</span><span class="s1">&quot;MAX_REDIRECTS&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RSC_UNION_QUERY&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;rscResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;callServer&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFlightStream&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;pull&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>