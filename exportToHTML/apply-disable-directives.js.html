<html>
<head>
<title>apply-disable-directives.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
apply-disable-directives.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Teddy Katz</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Typedefs</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../types&quot;).Linter.LintMessage} LintMessage */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@eslint/core&quot;).Language} Language */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@eslint/core&quot;).Position} Position */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@eslint/core&quot;).RulesConfig} RulesConfig */</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Module Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">escapeRegExp = require(</span><span class="s3">&quot;escape-string-regexp&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">{ Config } = require(</span><span class="s3">&quot;../config/config.js&quot;</span><span class="s2">);</span>

<span class="s0">/**</span>
 <span class="s0">* Compares the locations of two objects in a source file</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Position} itemA The first object</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Position} itemB The second object</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if</span>
 <span class="s0">* itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">compareLocations(itemA, itemB) {</span>
	<span class="s4">return </span><span class="s2">itemA.line - itemB.line || itemA.column - itemB.column;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Groups a set of directives into sub-arrays by their parent comment.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Iterable&lt;Directive&gt;} directives Unused directives to be removed.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Directive[][]} Directives grouped by their parent comment.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">groupByParentDirective(directives) {</span>
	<span class="s4">const </span><span class="s2">groups = </span><span class="s4">new </span><span class="s2">Map();</span>

	<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">directive of directives) {</span>
		<span class="s4">const </span><span class="s2">{</span>
			<span class="s2">unprocessedDirective: { parentDirective },</span>
		<span class="s2">} = directive;</span>

		<span class="s4">if </span><span class="s2">(groups.has(parentDirective)) {</span>
			<span class="s2">groups.get(parentDirective).push(directive);</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s2">groups.set(parentDirective, [directive]);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">[...groups.values()];</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates removal details for a set of directives within the same comment.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Directive[]} directives Unused directives to be removed.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{{node: Token, value: string}} parentDirective Data about the backing directive.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code object for the file being linted.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">createIndividualDirectivesRemoval(</span>
	<span class="s2">directives,</span>
	<span class="s2">parentDirective,</span>
	<span class="s2">sourceCode,</span>
<span class="s2">) {</span>
	<span class="s0">/* 
     * Get the list of the rules text without any surrounding whitespace. In order to preserve the original 
     * formatting, we don't want to change that whitespace. 
     * 
     *     // eslint-disable-line rule-one , rule-two , rule-three -- comment 
     *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
     */</span>
	<span class="s4">const </span><span class="s2">listText = parentDirective.value.trim();</span>

	<span class="s0">// Calculate where it starts in the source code text</span>
	<span class="s4">const </span><span class="s2">listStart = sourceCode.text.indexOf(</span>
		<span class="s2">listText,</span>
		<span class="s2">sourceCode.getRange(parentDirective.node)[</span><span class="s5">0</span><span class="s2">],</span>
	<span class="s2">);</span>

	<span class="s0">/* 
     * We can assume that `listText` contains multiple elements. 
     * Otherwise, this function wouldn't be called - if there is 
     * only one rule in the list, then the whole comment must be removed. 
     */</span>

	<span class="s4">return </span><span class="s2">directives.map(directive =&gt; {</span>
		<span class="s4">const </span><span class="s2">{ ruleId } = directive;</span>

		<span class="s4">const </span><span class="s2">regex = </span><span class="s4">new </span><span class="s2">RegExp(</span>
			<span class="s2">String.raw</span><span class="s3">`(?:^|</span><span class="s6">\s</span><span class="s3">*,</span><span class="s6">\s</span><span class="s3">*)(?&lt;quote&gt;['&quot;]?)</span><span class="s2">${escapeRegExp(ruleId)}</span><span class="s6">\k</span><span class="s3">&lt;quote&gt;(?:</span><span class="s6">\s</span><span class="s3">*,</span><span class="s6">\s</span><span class="s3">*|$)`</span><span class="s2">,</span>
			<span class="s3">&quot;u&quot;</span><span class="s2">,</span>
		<span class="s2">);</span>
		<span class="s4">const </span><span class="s2">match = regex.exec(listText);</span>
		<span class="s4">const </span><span class="s2">matchedText = match[</span><span class="s5">0</span><span class="s2">];</span>
		<span class="s4">const </span><span class="s2">matchStart = listStart + match.index;</span>
		<span class="s4">const </span><span class="s2">matchEnd = matchStart + matchedText.length;</span>

		<span class="s4">const </span><span class="s2">firstIndexOfComma = matchedText.indexOf(</span><span class="s3">&quot;,&quot;</span><span class="s2">);</span>
		<span class="s4">const </span><span class="s2">lastIndexOfComma = matchedText.lastIndexOf(</span><span class="s3">&quot;,&quot;</span><span class="s2">);</span>

		<span class="s4">let </span><span class="s2">removalStart, removalEnd;</span>

		<span class="s4">if </span><span class="s2">(firstIndexOfComma !== lastIndexOfComma) {</span>
			<span class="s0">/* 
             * Since there are two commas, this must one of the elements in the middle of the list. 
             * Matched range starts where the previous rule name ends, and ends where the next rule name starts. 
             * 
             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment 
             *                                    ^^^^^^^^^^^^^^ 
             * 
             * We want to remove only the content between the two commas, and also one of the commas. 
             * 
             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment 
             *                                     ^^^^^^^^^^^ 
             */</span>
			<span class="s2">removalStart = matchStart + firstIndexOfComma;</span>
			<span class="s2">removalEnd = matchStart + lastIndexOfComma;</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s0">/* 
             * This is either the first element or the last element. 
             * 
             * If this is the first element, matched range starts where the first rule name starts 
             * and ends where the second rule name starts. This is exactly the range we want 
             * to remove so that the second rule name will start where the first one was starting 
             * and thus preserve the original formatting. 
             * 
             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment 
             *                            ^^^^^^^^^^^ 
             * 
             * Similarly, if this is the last element, we've already matched the range we want to 
             * remove. The previous rule name will end where the last one was ending, relative 
             * to the content on the right side. 
             * 
             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment 
             *                                               ^^^^^^^^^^^^^ 
             */</span>
			<span class="s2">removalStart = matchStart;</span>
			<span class="s2">removalEnd = matchEnd;</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">description: </span><span class="s3">`'</span><span class="s2">${ruleId}</span><span class="s3">'`</span><span class="s2">,</span>
			<span class="s2">fix: {</span>
				<span class="s2">range: [removalStart, removalEnd],</span>
				<span class="s2">text: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
			<span class="s2">},</span>
			<span class="s2">unprocessedDirective: directive.unprocessedDirective,</span>
		<span class="s2">};</span>
	<span class="s2">});</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a description of deleting an entire unused disable directive.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Directive[]} directives Unused directives to be removed.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} node The backing Comment token.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code object for the file being linted.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{ description, fix, unprocessedDirective }} Details for later creation of an output problem.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">createDirectiveRemoval(directives, node, sourceCode) {</span>
	<span class="s4">const </span><span class="s2">range = sourceCode.getRange(node);</span>
	<span class="s4">const </span><span class="s2">ruleIds = directives</span>
		<span class="s2">.filter(directive =&gt; directive.ruleId)</span>
		<span class="s2">.map(directive =&gt; </span><span class="s3">`'</span><span class="s2">${directive.ruleId}</span><span class="s3">'`</span><span class="s2">);</span>

	<span class="s4">return </span><span class="s2">{</span>
		<span class="s2">description:</span>
			<span class="s2">ruleIds.length &lt;= </span><span class="s5">2</span>
				<span class="s2">? ruleIds.join(</span><span class="s3">&quot; or &quot;</span><span class="s2">)</span>
				<span class="s2">: </span><span class="s3">`</span><span class="s2">${ruleIds.slice(</span><span class="s5">0</span><span class="s2">, ruleIds.length - </span><span class="s5">1</span><span class="s2">).join(</span><span class="s3">&quot;, &quot;</span><span class="s2">)}</span><span class="s3">, or </span><span class="s2">${ruleIds.at(-</span><span class="s5">1</span><span class="s2">)}</span><span class="s3">`</span><span class="s2">,</span>
		<span class="s2">fix: {</span>
			<span class="s2">range,</span>
			<span class="s2">text: </span><span class="s3">&quot; &quot;</span><span class="s2">,</span>
		<span class="s2">},</span>
		<span class="s2">unprocessedDirective: directives[</span><span class="s5">0</span><span class="s2">].unprocessedDirective,</span>
	<span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Parses details from directives to create output Problems.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Iterable&lt;Directive&gt;} allDirectives Unused directives to be removed.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code object for the file being linted.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">processUnusedDirectives(allDirectives, sourceCode) {</span>
	<span class="s4">const </span><span class="s2">directiveGroups = groupByParentDirective(allDirectives);</span>

	<span class="s4">return </span><span class="s2">directiveGroups.flatMap(directives =&gt; {</span>
		<span class="s4">const </span><span class="s2">{ parentDirective } = directives[</span><span class="s5">0</span><span class="s2">].unprocessedDirective;</span>
		<span class="s4">const </span><span class="s2">remainingRuleIds = </span><span class="s4">new </span><span class="s2">Set(parentDirective.ruleIds);</span>

		<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">directive of directives) {</span>
			<span class="s2">remainingRuleIds.delete(directive.ruleId);</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">remainingRuleIds.size</span>
			<span class="s2">? createIndividualDirectivesRemoval(</span>
					<span class="s2">directives,</span>
					<span class="s2">parentDirective,</span>
					<span class="s2">sourceCode,</span>
				<span class="s2">)</span>
			<span class="s2">: [</span>
					<span class="s2">createDirectiveRemoval(</span>
						<span class="s2">directives,</span>
						<span class="s2">parentDirective.node,</span>
						<span class="s2">sourceCode,</span>
					<span class="s2">),</span>
				<span class="s2">];</span>
	<span class="s2">});</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Collect eslint-enable comments that are removing suppressions by eslint-disable comments.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Directive[]} directives The directives to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Set&lt;Directive&gt;} The used eslint-enable comments</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">collectUsedEnableDirectives(directives) {</span>
	<span class="s0">/**</span>
	 <span class="s0">* A Map of `eslint-enable` keyed by ruleIds that may be marked as used.</span>
	 <span class="s0">* If `eslint-enable` does not have a ruleId, the key will be `null`.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Map&lt;string|null, Directive&gt;}</span>
	 <span class="s0">*/</span>
	<span class="s4">const </span><span class="s2">enabledRules = </span><span class="s4">new </span><span class="s2">Map();</span>

	<span class="s0">/**</span>
	 <span class="s0">* A Set of `eslint-enable` marked as used.</span>
	 <span class="s0">* It is also the return value of `collectUsedEnableDirectives` function.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Set&lt;Directive&gt;}</span>
	 <span class="s0">*/</span>
	<span class="s4">const </span><span class="s2">usedEnableDirectives = </span><span class="s4">new </span><span class="s2">Set();</span>

	<span class="s0">/* 
     * Checks the directives backwards to see if the encountered `eslint-enable` is used by the previous `eslint-disable`, 
     * and if so, stores the `eslint-enable` in `usedEnableDirectives`. 
     */</span>
	<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">index = directives.length - </span><span class="s5">1</span><span class="s2">; index &gt;= </span><span class="s5">0</span><span class="s2">; index--) {</span>
		<span class="s4">const </span><span class="s2">directive = directives[index];</span>

		<span class="s4">if </span><span class="s2">(directive.type === </span><span class="s3">&quot;disable&quot;</span><span class="s2">) {</span>
			<span class="s4">if </span><span class="s2">(enabledRules.size === </span><span class="s5">0</span><span class="s2">) {</span>
				<span class="s4">continue</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s4">if </span><span class="s2">(directive.ruleId === </span><span class="s4">null</span><span class="s2">) {</span>
				<span class="s0">// If encounter `eslint-disable` without ruleId,</span>
				<span class="s0">// mark all `eslint-enable` currently held in enabledRules as used.</span>
				<span class="s0">// e.g.</span>
				<span class="s0">//    /* eslint-disable */ &lt;- current directive</span>
				<span class="s0">//    /* eslint-enable rule-id1 */ &lt;- used</span>
				<span class="s0">//    /* eslint-enable rule-id2 */ &lt;- used</span>
				<span class="s0">//    /* eslint-enable */ &lt;- used</span>
				<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">enableDirective of enabledRules.values()) {</span>
					<span class="s2">usedEnableDirectives.add(enableDirective);</span>
				<span class="s2">}</span>
				<span class="s2">enabledRules.clear();</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s4">const </span><span class="s2">enableDirective = enabledRules.get(directive.ruleId);</span>

				<span class="s4">if </span><span class="s2">(enableDirective) {</span>
					<span class="s0">// If encounter `eslint-disable` with ruleId, and there is an `eslint-enable` with the same ruleId in enabledRules,</span>
					<span class="s0">// mark `eslint-enable` with ruleId as used.</span>
					<span class="s0">// e.g.</span>
					<span class="s0">//    /* eslint-disable rule-id */ &lt;- current directive</span>
					<span class="s0">//    /* eslint-enable rule-id */ &lt;- used</span>
					<span class="s2">usedEnableDirectives.add(enableDirective);</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s4">const </span><span class="s2">enabledDirectiveWithoutRuleId =</span>
						<span class="s2">enabledRules.get(</span><span class="s4">null</span><span class="s2">);</span>

					<span class="s4">if </span><span class="s2">(enabledDirectiveWithoutRuleId) {</span>
						<span class="s0">// If encounter `eslint-disable` with ruleId, and there is no `eslint-enable` with the same ruleId in enabledRules,</span>
						<span class="s0">// mark `eslint-enable` without ruleId as used.</span>
						<span class="s0">// e.g.</span>
						<span class="s0">//    /* eslint-disable rule-id */ &lt;- current directive</span>
						<span class="s0">//    /* eslint-enable */ &lt;- used</span>
						<span class="s2">usedEnableDirectives.add(enabledDirectiveWithoutRuleId);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s4">else if </span><span class="s2">(directive.type === </span><span class="s3">&quot;enable&quot;</span><span class="s2">) {</span>
			<span class="s4">if </span><span class="s2">(directive.ruleId === </span><span class="s4">null</span><span class="s2">) {</span>
				<span class="s0">// If encounter `eslint-enable` without ruleId, the `eslint-enable` that follows it are unused.</span>
				<span class="s0">// So clear enabledRules.</span>
				<span class="s0">// e.g.</span>
				<span class="s0">//    /* eslint-enable */ &lt;- current directive</span>
				<span class="s0">//    /* eslint-enable rule-id *// &lt;- unused</span>
				<span class="s0">//    /* eslint-enable */ &lt;- unused</span>
				<span class="s2">enabledRules.clear();</span>
				<span class="s2">enabledRules.set(</span><span class="s4">null</span><span class="s2">, directive);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">enabledRules.set(directive.ruleId, directive);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
	<span class="s2">}</span>
	<span class="s4">return </span><span class="s2">usedEnableDirectives;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* This is the same as the exported function, except that it</span>
 <span class="s0">* doesn't handle disable-line and disable-next-line directives, and it always reports unused</span>
 <span class="s0">* disable directives.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} options options for applying directives. This is the same as the options</span>
 <span class="s0">* for the exported function, except that `reportUnusedDisableDirectives` is not supported</span>
 <span class="s0">* (this function always reports unused disable directives).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{problems: LintMessage[], unusedDirectives: LintMessage[]}} An object with a list</span>
 <span class="s0">* of problems (including suppressed ones) and unused eslint-disable directives</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">applyDirectives(options) {</span>
	<span class="s4">const </span><span class="s2">problems = [];</span>
	<span class="s4">const </span><span class="s2">usedDisableDirectives = </span><span class="s4">new </span><span class="s2">Set();</span>
	<span class="s4">const </span><span class="s2">{ sourceCode } = options;</span>

	<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">problem of options.problems) {</span>
		<span class="s4">let </span><span class="s2">disableDirectivesForProblem = [];</span>
		<span class="s4">let </span><span class="s2">nextDirectiveIndex = </span><span class="s5">0</span><span class="s2">;</span>

		<span class="s4">while </span><span class="s2">(</span>
			<span class="s2">nextDirectiveIndex &lt; options.directives.length &amp;&amp;</span>
			<span class="s2">compareLocations(options.directives[nextDirectiveIndex], problem) &lt;=</span>
				<span class="s5">0</span>
		<span class="s2">) {</span>
			<span class="s4">const </span><span class="s2">directive = options.directives[nextDirectiveIndex++];</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">directive.ruleId === </span><span class="s4">null </span><span class="s2">||</span>
				<span class="s2">directive.ruleId === problem.ruleId</span>
			<span class="s2">) {</span>
				<span class="s4">switch </span><span class="s2">(directive.type) {</span>
					<span class="s4">case </span><span class="s3">&quot;disable&quot;</span><span class="s2">:</span>
						<span class="s2">disableDirectivesForProblem.push(directive);</span>
						<span class="s4">break</span><span class="s2">;</span>

					<span class="s4">case </span><span class="s3">&quot;enable&quot;</span><span class="s2">:</span>
						<span class="s2">disableDirectivesForProblem = [];</span>
						<span class="s4">break</span><span class="s2">;</span>

					<span class="s0">// no default</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s4">if </span><span class="s2">(disableDirectivesForProblem.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
			<span class="s4">const </span><span class="s2">suppressions = disableDirectivesForProblem.map(directive =&gt; ({</span>
				<span class="s2">kind: </span><span class="s3">&quot;directive&quot;</span><span class="s2">,</span>
				<span class="s2">justification: directive.unprocessedDirective.justification,</span>
			<span class="s2">}));</span>

			<span class="s4">if </span><span class="s2">(problem.suppressions) {</span>
				<span class="s2">problem.suppressions =</span>
					<span class="s2">problem.suppressions.concat(suppressions);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">problem.suppressions = suppressions;</span>
				<span class="s2">usedDisableDirectives.add(disableDirectivesForProblem.at(-</span><span class="s5">1</span><span class="s2">));</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s2">problems.push(problem);</span>
	<span class="s2">}</span>

	<span class="s4">const </span><span class="s2">unusedDisableDirectivesToReport = options.directives.filter(</span>
		<span class="s2">directive =&gt;</span>
			<span class="s2">directive.type === </span><span class="s3">&quot;disable&quot; </span><span class="s2">&amp;&amp;</span>
			<span class="s2">!usedDisableDirectives.has(directive) &amp;&amp;</span>
			<span class="s2">!options.rulesToIgnore.has(directive.ruleId),</span>
	<span class="s2">);</span>

	<span class="s4">const </span><span class="s2">unusedEnableDirectivesToReport = </span><span class="s4">new </span><span class="s2">Set(</span>
		<span class="s2">options.directives.filter(</span>
			<span class="s2">directive =&gt;</span>
				<span class="s2">directive.unprocessedDirective.type === </span><span class="s3">&quot;enable&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">!options.rulesToIgnore.has(directive.ruleId),</span>
		<span class="s2">),</span>
	<span class="s2">);</span>

	<span class="s0">/* 
     * If directives has the eslint-enable directive, 
     * check whether the eslint-enable comment is used. 
     */</span>
	<span class="s4">if </span><span class="s2">(unusedEnableDirectivesToReport.size &gt; </span><span class="s5">0</span><span class="s2">) {</span>
		<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">directive of collectUsedEnableDirectives(</span>
			<span class="s2">options.directives,</span>
		<span class="s2">)) {</span>
			<span class="s2">unusedEnableDirectivesToReport.delete(directive);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s4">const </span><span class="s2">processed = processUnusedDirectives(</span>
		<span class="s2">unusedDisableDirectivesToReport,</span>
		<span class="s2">sourceCode,</span>
	<span class="s2">).concat(</span>
		<span class="s2">processUnusedDirectives(unusedEnableDirectivesToReport, sourceCode),</span>
	<span class="s2">);</span>
	<span class="s4">const </span><span class="s2">columnOffset = options.language.columnStart === </span><span class="s5">1 </span><span class="s2">? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">;</span>
	<span class="s4">const </span><span class="s2">lineOffset = options.language.lineStart === </span><span class="s5">1 </span><span class="s2">? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">;</span>

	<span class="s4">const </span><span class="s2">unusedDirectives = processed.map(</span>
		<span class="s2">({ description, fix, unprocessedDirective }) =&gt; {</span>
			<span class="s4">const </span><span class="s2">{ parentDirective, type, line, column } =</span>
				<span class="s2">unprocessedDirective;</span>

			<span class="s4">let </span><span class="s2">message;</span>

			<span class="s4">if </span><span class="s2">(type === </span><span class="s3">&quot;enable&quot;</span><span class="s2">) {</span>
				<span class="s2">message = description</span>
					<span class="s2">? </span><span class="s3">`Unused eslint-enable directive (no matching eslint-disable directives were found for </span><span class="s2">${description}</span><span class="s3">).`</span>
					<span class="s2">: </span><span class="s3">&quot;Unused eslint-enable directive (no matching eslint-disable directives were found).&quot;</span><span class="s2">;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">message = description</span>
					<span class="s2">? </span><span class="s3">`Unused eslint-disable directive (no problems were reported from </span><span class="s2">${description}</span><span class="s3">).`</span>
					<span class="s2">: </span><span class="s3">&quot;Unused eslint-disable directive (no problems were reported).&quot;</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">loc = sourceCode.getLoc(parentDirective.node);</span>

			<span class="s4">return </span><span class="s2">{</span>
				<span class="s2">ruleId: </span><span class="s4">null</span><span class="s2">,</span>
				<span class="s2">message,</span>
				<span class="s2">line:</span>
					<span class="s2">type === </span><span class="s3">&quot;disable-next-line&quot;</span>
						<span class="s2">? loc.start.line + lineOffset</span>
						<span class="s2">: line,</span>
				<span class="s2">column:</span>
					<span class="s2">type === </span><span class="s3">&quot;disable-next-line&quot;</span>
						<span class="s2">? loc.start.column + columnOffset</span>
						<span class="s2">: column,</span>
				<span class="s2">severity:</span>
					<span class="s2">options.reportUnusedDisableDirectives === </span><span class="s3">&quot;warn&quot; </span><span class="s2">? </span><span class="s5">1 </span><span class="s2">: </span><span class="s5">2</span><span class="s2">,</span>
				<span class="s2">nodeType: </span><span class="s4">null</span><span class="s2">,</span>
				<span class="s2">...(options.disableFixes ? {} : { fix }),</span>
			<span class="s2">};</span>
		<span class="s2">},</span>
	<span class="s2">);</span>

	<span class="s4">return </span><span class="s2">{ problems, unusedDirectives };</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list</span>
 <span class="s0">* of reported problems, adds the suppression information to the problems.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} options Information about directives and problems</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Language} options.language The language being linted.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} options.sourceCode The source code object for the file being linted.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{{</span>
 <span class="s0">*      type: (&quot;disable&quot;|&quot;enable&quot;|&quot;disable-line&quot;|&quot;disable-next-line&quot;),</span>
 <span class="s0">*      ruleId: (string|null),</span>
 <span class="s0">*      line: number,</span>
 <span class="s0">*      column: number,</span>
 <span class="s0">*      justification: string</span>
 <span class="s0">* }} options.directives Directive comments found in the file, with one-based columns.</span>
 <span class="s0">* Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable</span>
 <span class="s0">* comment for two different rules is represented as two directives).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{{ruleId: (string|null), line: number, column: number}[]} options.problems</span>
 <span class="s0">* A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{&quot;off&quot; | &quot;warn&quot; | &quot;error&quot;} options.reportUnusedDisableDirectives If `&quot;warn&quot;` or `&quot;error&quot;`, adds additional problems for unused directives</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RulesConfig} options.configuredRules The rules configuration.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} options.ruleFilter A predicate function to filter which rules should be executed.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} options.disableFixes If true, it doesn't make `fix` properties.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}</span>
 <span class="s0">* An object with a list of reported problems, the suppressed of which contain the suppression information.</span>
 <span class="s0">*/</span>
<span class="s2">module.exports = ({</span>
	<span class="s2">language,</span>
	<span class="s2">sourceCode,</span>
	<span class="s2">directives,</span>
	<span class="s2">disableFixes,</span>
	<span class="s2">problems,</span>
	<span class="s2">configuredRules,</span>
	<span class="s2">ruleFilter,</span>
	<span class="s2">reportUnusedDisableDirectives = </span><span class="s3">&quot;off&quot;</span><span class="s2">,</span>
<span class="s2">}) =&gt; {</span>
	<span class="s4">const </span><span class="s2">blockDirectives = directives</span>
		<span class="s2">.filter(</span>
			<span class="s2">directive =&gt;</span>
				<span class="s2">directive.type === </span><span class="s3">&quot;disable&quot; </span><span class="s2">|| directive.type === </span><span class="s3">&quot;enable&quot;</span><span class="s2">,</span>
		<span class="s2">)</span>
		<span class="s2">.map(directive =&gt;</span>
			<span class="s2">Object.assign({}, directive, { unprocessedDirective: directive }),</span>
		<span class="s2">)</span>
		<span class="s2">.sort(compareLocations);</span>

	<span class="s4">const </span><span class="s2">lineDirectives = directives</span>
		<span class="s2">.flatMap(directive =&gt; {</span>
			<span class="s4">switch </span><span class="s2">(directive.type) {</span>
				<span class="s4">case </span><span class="s3">&quot;disable&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;enable&quot;</span><span class="s2">:</span>
					<span class="s4">return </span><span class="s2">[];</span>

				<span class="s4">case </span><span class="s3">&quot;disable-line&quot;</span><span class="s2">:</span>
					<span class="s4">return </span><span class="s2">[</span>
						<span class="s2">{</span>
							<span class="s2">type: </span><span class="s3">&quot;disable&quot;</span><span class="s2">,</span>
							<span class="s2">line: directive.line,</span>
							<span class="s2">column: </span><span class="s5">1</span><span class="s2">,</span>
							<span class="s2">ruleId: directive.ruleId,</span>
							<span class="s2">unprocessedDirective: directive,</span>
						<span class="s2">},</span>
						<span class="s2">{</span>
							<span class="s2">type: </span><span class="s3">&quot;enable&quot;</span><span class="s2">,</span>
							<span class="s2">line: directive.line + </span><span class="s5">1</span><span class="s2">,</span>
							<span class="s2">column: </span><span class="s5">0</span><span class="s2">,</span>
							<span class="s2">ruleId: directive.ruleId,</span>
							<span class="s2">unprocessedDirective: directive,</span>
						<span class="s2">},</span>
					<span class="s2">];</span>

				<span class="s4">case </span><span class="s3">&quot;disable-next-line&quot;</span><span class="s2">:</span>
					<span class="s4">return </span><span class="s2">[</span>
						<span class="s2">{</span>
							<span class="s2">type: </span><span class="s3">&quot;disable&quot;</span><span class="s2">,</span>
							<span class="s2">line: directive.line + </span><span class="s5">1</span><span class="s2">,</span>
							<span class="s2">column: </span><span class="s5">1</span><span class="s2">,</span>
							<span class="s2">ruleId: directive.ruleId,</span>
							<span class="s2">unprocessedDirective: directive,</span>
						<span class="s2">},</span>
						<span class="s2">{</span>
							<span class="s2">type: </span><span class="s3">&quot;enable&quot;</span><span class="s2">,</span>
							<span class="s2">line: directive.line + </span><span class="s5">2</span><span class="s2">,</span>
							<span class="s2">column: </span><span class="s5">0</span><span class="s2">,</span>
							<span class="s2">ruleId: directive.ruleId,</span>
							<span class="s2">unprocessedDirective: directive,</span>
						<span class="s2">},</span>
					<span class="s2">];</span>

				<span class="s4">default</span><span class="s2">:</span>
					<span class="s4">throw new </span><span class="s2">TypeError(</span>
						<span class="s3">`Unrecognized directive type '</span><span class="s2">${directive.type}</span><span class="s3">'`</span><span class="s2">,</span>
					<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">})</span>
		<span class="s2">.sort(compareLocations);</span>

	<span class="s0">// This determines a list of rules that are not being run by the given ruleFilter, if present.</span>
	<span class="s4">const </span><span class="s2">rulesToIgnore =</span>
		<span class="s2">configuredRules &amp;&amp; ruleFilter</span>
			<span class="s2">? </span><span class="s4">new </span><span class="s2">Set(</span>
					<span class="s2">Object.keys(configuredRules).filter(ruleId =&gt; {</span>
						<span class="s4">const </span><span class="s2">severity = Config.getRuleNumericSeverity(</span>
							<span class="s2">configuredRules[ruleId],</span>
						<span class="s2">);</span>

						<span class="s0">// Ignore for disabled rules.</span>
						<span class="s4">if </span><span class="s2">(severity === </span><span class="s5">0</span><span class="s2">) {</span>
							<span class="s4">return false</span><span class="s2">;</span>
						<span class="s2">}</span>

						<span class="s4">return </span><span class="s2">!ruleFilter({ severity, ruleId });</span>
					<span class="s2">}),</span>
				<span class="s2">)</span>
			<span class="s2">: </span><span class="s4">new </span><span class="s2">Set();</span>

	<span class="s0">// If no ruleId is supplied that means this directive is applied to all rules, so we can't determine if it's unused if any rules are filtered out.</span>
	<span class="s4">if </span><span class="s2">(rulesToIgnore.size &gt; </span><span class="s5">0</span><span class="s2">) {</span>
		<span class="s2">rulesToIgnore.add(</span><span class="s4">null</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s4">const </span><span class="s2">blockDirectivesResult = applyDirectives({</span>
		<span class="s2">language,</span>
		<span class="s2">sourceCode,</span>
		<span class="s2">problems,</span>
		<span class="s2">directives: blockDirectives,</span>
		<span class="s2">disableFixes,</span>
		<span class="s2">reportUnusedDisableDirectives,</span>
		<span class="s2">rulesToIgnore,</span>
	<span class="s2">});</span>
	<span class="s4">const </span><span class="s2">lineDirectivesResult = applyDirectives({</span>
		<span class="s2">language,</span>
		<span class="s2">sourceCode,</span>
		<span class="s2">problems: blockDirectivesResult.problems,</span>
		<span class="s2">directives: lineDirectives,</span>
		<span class="s2">disableFixes,</span>
		<span class="s2">reportUnusedDisableDirectives,</span>
		<span class="s2">rulesToIgnore,</span>
	<span class="s2">});</span>

	<span class="s4">return </span><span class="s2">reportUnusedDisableDirectives !== </span><span class="s3">&quot;off&quot;</span>
		<span class="s2">? lineDirectivesResult.problems</span>
				<span class="s2">.concat(blockDirectivesResult.unusedDirectives)</span>
				<span class="s2">.concat(lineDirectivesResult.unusedDirectives)</span>
				<span class="s2">.sort(compareLocations)</span>
		<span class="s2">: lineDirectivesResult.problems;</span>
<span class="s2">};</span>
</pre>
</body>
</html>