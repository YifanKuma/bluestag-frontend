<html>
<head>
<title>app.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { Params } from </span><span class="s2">'../../server/request/params'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { AppPageModule } from </span><span class="s2">'../../server/route-modules/app-page/module'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { AppSegment } from </span><span class="s2">'../segment-config/app/app-segments'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { PrerenderedRoute, StaticPathsResult } from </span><span class="s2">'./types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ FallbackMode } from </span><span class="s2">'../../lib/fallback'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { IncrementalCache } from </span><span class="s2">'../../server/lib/incremental-cache'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { NextConfigComplete } from </span><span class="s2">'../../server/config-shared'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { WorkStore } from </span><span class="s2">'../../server/app-render/work-async-storage.external'</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Filters out duplicate parameters from a list of parameters.</span>
 <span class="s3">* This function uses a Map to efficiently store and retrieve unique parameter combinations.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">routeParamKeys - The keys of the parameters. These should be sorted to ensure consistent key generation.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">routeParams - The list of parameter objects to filter.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">A new array containing only the unique parameter combinations.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">filterUniqueParams(routeParamKeys: readonly string[], routeParams: readonly Params[]): Params[];</span>
<span class="s3">/**</span>
 <span class="s3">* Generates all unique sub-combinations of Route Parameters from a list of Static Parameters.</span>
 <span class="s3">* This function creates all possible prefixes of the Route Parameters, which is</span>
 <span class="s3">* useful for generating Static Shells that can serve as Fallback Shells for more specific Route Shells.</span>
 <span class="s3">*</span>
 <span class="s3">* When Root Parameters are provided, the function ensures that Static Shells only</span>
 <span class="s3">* include complete sets of Root Parameters. This prevents generating invalid Static Shells</span>
 <span class="s3">* that are missing required Root Parameters.</span>
 <span class="s3">*</span>
 <span class="s3">* Example with Root Parameters ('lang', 'region') and Route Parameters ('lang', 'region', 'slug'):</span>
 <span class="s3">*</span>
 <span class="s3">* Given the following Static Parameters:</span>
 <span class="s3">* ```</span>
 <span class="s3">* [</span>
 <span class="s3">*   { lang: 'en', region: 'US', slug: ['home'] },</span>
 <span class="s3">*   { lang: 'en', region: 'US', slug: ['about'] },</span>
 <span class="s3">*   { lang: 'fr', region: 'CA', slug: ['about'] },</span>
 <span class="s3">* ]</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* The result will be:</span>
 <span class="s3">* ```</span>
 <span class="s3">* [</span>
 <span class="s3">*   { lang: 'en', region: 'US' },  // Complete Root Parameters</span>
 <span class="s3">*   { lang: 'en', region: 'US', slug: ['home'] },</span>
 <span class="s3">*   { lang: 'en', region: 'US', slug: ['about'] },</span>
 <span class="s3">*   { lang: 'fr', region: 'CA' },  // Complete Root Parameters</span>
 <span class="s3">*   { lang: 'fr', region: 'CA', slug: ['about'] },</span>
 <span class="s3">* ]</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* Note that partial combinations like `{ lang: 'en' }` are NOT generated because</span>
 <span class="s3">* they don't include the complete set of Root Parameters.</span>
 <span class="s3">*</span>
 <span class="s3">* For routes without Root Parameters (e.g., `/[slug]`), all sub-combinations are generated</span>
 <span class="s3">* as before.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">routeParamKeys - The keys of the Route Parameters. These should be sorted</span>
 <span class="s3">*   to ensure consistent key generation for the internal Map.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">routeParams - The list of Static Parameters to filter.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">rootParamKeys - The keys of the Root Parameters. When provided, ensures Static Shells</span>
 <span class="s3">*   include all Root Parameters.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">A new array containing all unique sub-combinations of Route Parameters.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">generateAllParamCombinations(routeParamKeys: readonly string[], routeParams: readonly Params[], rootParamKeys: readonly string[]): Params[];</span>
<span class="s3">/**</span>
 <span class="s3">* Calculates the fallback mode based on the given parameters.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">dynamicParams - Whether dynamic params are enabled.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">fallbackRootParams - The root params that are part of the fallback.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">baseFallbackMode - The base fallback mode to use.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The calculated fallback mode.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">calculateFallbackMode(dynamicParams: boolean, fallbackRootParams: readonly string[], baseFallbackMode: FallbackMode | undefined): FallbackMode;</span>
<span class="s3">/**</span>
 <span class="s3">* Assigns the throwOnEmptyStaticShell property to each of the prerendered routes.</span>
 <span class="s3">* This function uses a Trie data structure to efficiently determine whether each route</span>
 <span class="s3">* should throw an error when its static shell is empty.</span>
 <span class="s3">*</span>
 <span class="s3">* A route should not throw on empty static shell if it has child routes in the Trie. For example,</span>
 <span class="s3">* if we have two routes, `/blog/first-post` and `/blog/[slug]`, the route for</span>
 <span class="s3">* `/blog/[slug]` should not throw because `/blog/first-post` is a more specific concrete route.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">prerenderedRoutes - The prerendered routes.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">routeParamKeys - The keys of the route parameters.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">assignErrorIfEmpty(prerenderedRoutes: readonly PrerenderedRoute[], routeParamKeys: readonly string[]): </span><span class="s0">void</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Processes app directory segments to build route parameters from generateStaticParams functions.</span>
 <span class="s3">* This function walks through the segments array and calls generateStaticParams for each segment that has it,</span>
 <span class="s3">* combining parent parameters with child parameters to build the complete parameter combinations.</span>
 <span class="s3">* Uses iterative processing instead of recursion for better performance.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">segments - Array of app directory segments to process</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">store - Work store for tracking fetch cache configuration</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">Promise that resolves to an array of all parameter combinations</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">generateRouteStaticParams(segments: Pick&lt;AppSegment, </span><span class="s2">'config' </span><span class="s1">| </span><span class="s2">'generateStaticParams'</span><span class="s1">&gt;[], store: Pick&lt;WorkStore, </span><span class="s2">'fetchCache'</span><span class="s1">&gt;): Promise&lt;Params[]&gt;;</span>
<span class="s3">/**</span>
 <span class="s3">* Builds the static paths for an app using `generateStaticParams`.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">params - The parameters for the build.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">The static paths.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">buildAppStaticPaths({ dir, page, distDir, cacheComponents, authInterrupts, segments, isrFlushToDisk, cacheHandler, cacheLifeProfiles, requestHeaders, cacheHandlers, maxMemoryCacheSize, fetchCacheKeyPrefix, nextConfigOutput, ComponentMod, isRoutePPREnabled, buildId, rootParamKeys, }: {</span>
    <span class="s1">dir: string;</span>
    <span class="s1">page: string;</span>
    <span class="s1">cacheComponents: boolean;</span>
    <span class="s1">authInterrupts: boolean;</span>
    <span class="s1">segments: AppSegment[];</span>
    <span class="s1">distDir: string;</span>
    <span class="s1">isrFlushToDisk?: boolean;</span>
    <span class="s1">fetchCacheKeyPrefix?: string;</span>
    <span class="s1">cacheHandler?: string;</span>
    <span class="s1">cacheHandlers?: NextConfigComplete[</span><span class="s2">'experimental'</span><span class="s1">][</span><span class="s2">'cacheHandlers'</span><span class="s1">];</span>
    <span class="s1">cacheLifeProfiles?: {</span>
        <span class="s1">[profile: string]: </span><span class="s0">import</span><span class="s1">(</span><span class="s2">'../../server/use-cache/cache-life'</span><span class="s1">).CacheLife;</span>
    <span class="s1">};</span>
    <span class="s1">maxMemoryCacheSize?: number;</span>
    <span class="s1">requestHeaders: IncrementalCache[</span><span class="s2">'requestHeaders'</span><span class="s1">];</span>
    <span class="s1">nextConfigOutput: </span><span class="s2">'standalone' </span><span class="s1">| </span><span class="s2">'export' </span><span class="s1">| undefined;</span>
    <span class="s1">ComponentMod: AppPageModule;</span>
    <span class="s1">isRoutePPREnabled: boolean;</span>
    <span class="s1">buildId: string;</span>
    <span class="s1">rootParamKeys: readonly string[];</span>
<span class="s1">}): Promise&lt;StaticPathsResult&gt;;</span>
</pre>
</body>
</html>