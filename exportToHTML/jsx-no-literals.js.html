<html>
<head>
<title>jsx-no-literals.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #264eff;}
.s6 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
jsx-no-literals.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Prevent using string literals in React component definition</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Caleb Morris</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">David Buchan-Swanson</span>
 <span class="s0">*/</span>

<span class="s3">'use strict'</span><span class="s2">;</span>

<span class="s4">const </span><span class="s2">iterFrom = require(</span><span class="s3">'es-iterator-helpers/Iterator.from'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">map = require(</span><span class="s3">'es-iterator-helpers/Iterator.prototype.map'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">some = require(</span><span class="s3">'es-iterator-helpers/Iterator.prototype.some'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">flatMap = require(</span><span class="s3">'es-iterator-helpers/Iterator.prototype.flatMap'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">fromEntries = require(</span><span class="s3">'object.fromentries'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">entries = require(</span><span class="s3">'object.entries'</span><span class="s2">);</span>

<span class="s4">const </span><span class="s2">docsUrl = require(</span><span class="s3">'../util/docsUrl'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">report = require(</span><span class="s3">'../util/report'</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">getText = require(</span><span class="s3">'../util/eslint'</span><span class="s2">).getText;</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import('eslint').Rule.RuleModule} RuleModule */</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import('../../types/rules/jsx-no-literals').Config} Config */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import('../../types/rules/jsx-no-literals').RawConfig} RawConfig */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import('../../types/rules/jsx-no-literals').ResolvedConfig} ResolvedConfig */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import('../../types/rules/jsx-no-literals').OverrideConfig} OverrideConfig */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import('../../types/rules/jsx-no-literals').ElementConfig} ElementConfig */</span>

<span class="s0">// ------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">// ------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{unknown} value</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string | unknown}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">trimIfString(value) {</span>
  <span class="s4">return typeof </span><span class="s2">value === </span><span class="s3">'string' </span><span class="s2">? value.trim() : value;</span>
<span class="s2">}</span>

<span class="s4">const </span><span class="s2">reOverridableElement = </span><span class="s5">/^[A-Z][\w.]*$/</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">reIsWhiteSpace = </span><span class="s5">/^[\s]+$/</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">jsxElementTypes = </span><span class="s4">new </span><span class="s2">Set([</span><span class="s3">'JSXElement'</span><span class="s2">, </span><span class="s3">'JSXFragment'</span><span class="s2">]);</span>
<span class="s4">const </span><span class="s2">standardJSXNodeParentTypes = </span><span class="s4">new </span><span class="s2">Set([</span><span class="s3">'JSXAttribute'</span><span class="s2">, </span><span class="s3">'JSXElement'</span><span class="s2">, </span><span class="s3">'JSXExpressionContainer'</span><span class="s2">, </span><span class="s3">'JSXFragment'</span><span class="s2">]);</span>

<span class="s4">const </span><span class="s2">messages = {</span>
  <span class="s2">invalidPropValue: </span><span class="s3">'Invalid prop value: &quot;{{text}}&quot;'</span><span class="s2">,</span>
  <span class="s2">invalidPropValueInElement: </span><span class="s3">'Invalid prop value: &quot;{{text}}&quot; in {{element}}'</span><span class="s2">,</span>
  <span class="s2">noStringsInAttributes: </span><span class="s3">'Strings not allowed in attributes: &quot;{{text}}&quot;'</span><span class="s2">,</span>
  <span class="s2">noStringsInAttributesInElement: </span><span class="s3">'Strings not allowed in attributes: &quot;{{text}}&quot; in {{element}}'</span><span class="s2">,</span>
  <span class="s2">noStringsInJSX: </span><span class="s3">'Strings not allowed in JSX files: &quot;{{text}}&quot;'</span><span class="s2">,</span>
  <span class="s2">noStringsInJSXInElement: </span><span class="s3">'Strings not allowed in JSX files: &quot;{{text}}&quot; in {{element}}'</span><span class="s2">,</span>
  <span class="s2">literalNotInJSXExpression: </span><span class="s3">'Missing JSX expression container around literal string: &quot;{{text}}&quot;'</span><span class="s2">,</span>
  <span class="s2">literalNotInJSXExpressionInElement: </span><span class="s3">'Missing JSX expression container around literal string: &quot;{{text}}&quot; in {{element}}'</span><span class="s2">,</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{Exclude&lt;RuleModule['meta']['schema'], unknown[] | false&gt;['properties']} */</span>
<span class="s4">const </span><span class="s2">commonPropertiesSchema = {</span>
  <span class="s2">noStrings: {</span>
    <span class="s2">type: </span><span class="s3">'boolean'</span><span class="s2">,</span>
  <span class="s2">},</span>
  <span class="s2">allowedStrings: {</span>
    <span class="s2">type: </span><span class="s3">'array'</span><span class="s2">,</span>
    <span class="s2">uniqueItems: </span><span class="s4">true</span><span class="s2">,</span>
    <span class="s2">items: {</span>
      <span class="s2">type: </span><span class="s3">'string'</span><span class="s2">,</span>
    <span class="s2">},</span>
  <span class="s2">},</span>
  <span class="s2">ignoreProps: {</span>
    <span class="s2">type: </span><span class="s3">'boolean'</span><span class="s2">,</span>
  <span class="s2">},</span>
  <span class="s2">noAttributeStrings: {</span>
    <span class="s2">type: </span><span class="s3">'boolean'</span><span class="s2">,</span>
  <span class="s2">},</span>
<span class="s2">};</span>

<span class="s0">// eslint-disable-next-line valid-jsdoc</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the element portion of the config</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RawConfig} config</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ElementConfig}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">normalizeElementConfig(config) {</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">type: </span><span class="s3">'element'</span><span class="s2">,</span>
    <span class="s2">noStrings: !!config.noStrings,</span>
    <span class="s2">allowedStrings: config.allowedStrings</span>
      <span class="s2">? </span><span class="s4">new </span><span class="s2">Set(map(iterFrom(config.allowedStrings), trimIfString))</span>
      <span class="s2">: </span><span class="s4">new </span><span class="s2">Set(),</span>
    <span class="s2">ignoreProps: !!config.ignoreProps,</span>
    <span class="s2">noAttributeStrings: !!config.noAttributeStrings,</span>
  <span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">// eslint-disable-next-line valid-jsdoc</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the config and applies default values to all config options</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RawConfig} config</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Config}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">normalizeConfig(config) {</span>
  <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{Config} */</span>
  <span class="s4">const </span><span class="s2">normalizedConfig = Object.assign(normalizeElementConfig(config), {</span>
    <span class="s2">elementOverrides: {},</span>
  <span class="s2">});</span>

  <span class="s4">if </span><span class="s2">(config.elementOverrides) {</span>
    <span class="s2">normalizedConfig.elementOverrides = fromEntries(</span>
      <span class="s2">flatMap(</span>
        <span class="s2">iterFrom(entries(config.elementOverrides)),</span>
        <span class="s2">(entry) =&gt; {</span>
          <span class="s4">const </span><span class="s2">elementName = entry[</span><span class="s6">0</span><span class="s2">];</span>
          <span class="s4">const </span><span class="s2">rawElementConfig = entry[</span><span class="s6">1</span><span class="s2">];</span>

          <span class="s4">if </span><span class="s2">(!reOverridableElement.test(elementName)) {</span>
            <span class="s4">return </span><span class="s2">[];</span>
          <span class="s2">}</span>

          <span class="s4">return </span><span class="s2">[[</span>
            <span class="s2">elementName,</span>
            <span class="s2">Object.assign(normalizeElementConfig(rawElementConfig), {</span>
              <span class="s2">type: </span><span class="s3">'override'</span><span class="s2">,</span>
              <span class="s2">name: elementName,</span>
              <span class="s2">allowElement: !!rawElementConfig.allowElement,</span>
              <span class="s2">applyToNestedElements: </span><span class="s4">typeof </span><span class="s2">rawElementConfig.applyToNestedElements === </span><span class="s3">'undefined' </span><span class="s2">|| !!rawElementConfig.applyToNestedElements,</span>
            <span class="s2">}),</span>
          <span class="s2">]];</span>
        <span class="s2">}</span>
      <span class="s2">)</span>
    <span class="s2">);</span>
  <span class="s2">}</span>

  <span class="s4">return </span><span class="s2">normalizedConfig;</span>
<span class="s2">}</span>

<span class="s4">const </span><span class="s2">elementOverrides = {</span>
  <span class="s2">type: </span><span class="s3">'object'</span><span class="s2">,</span>
  <span class="s2">patternProperties: {</span>
    <span class="s2">[reOverridableElement.source]: {</span>
      <span class="s2">type: </span><span class="s3">'object'</span><span class="s2">,</span>
      <span class="s2">properties: Object.assign(</span>
        <span class="s2">{ applyToNestedElements: { type: </span><span class="s3">'boolean' </span><span class="s2">} },</span>
        <span class="s2">commonPropertiesSchema</span>
      <span class="s2">),</span>

    <span class="s2">},</span>
  <span class="s2">},</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{RuleModule} */</span>
<span class="s2">module.exports = {</span>
  <span class="s2">meta: </span><span class="s0">/** </span><span class="s1">@type </span><span class="s0">{RuleModule['meta']} */ </span><span class="s2">({</span>
    <span class="s2">docs: {</span>
      <span class="s2">description: </span><span class="s3">'Disallow usage of string literals in JSX'</span><span class="s2">,</span>
      <span class="s2">category: </span><span class="s3">'Stylistic Issues'</span><span class="s2">,</span>
      <span class="s2">recommended: </span><span class="s4">false</span><span class="s2">,</span>
      <span class="s2">url: docsUrl(</span><span class="s3">'jsx-no-literals'</span><span class="s2">),</span>
    <span class="s2">},</span>

    <span class="s2">messages,</span>

    <span class="s2">schema: [{</span>
      <span class="s2">type: </span><span class="s3">'object'</span><span class="s2">,</span>
      <span class="s2">properties: Object.assign(</span>
        <span class="s2">{ elementOverrides },</span>
        <span class="s2">commonPropertiesSchema</span>
      <span class="s2">),</span>
      <span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
    <span class="s2">}],</span>
  <span class="s2">}),</span>

  <span class="s2">create(context) {</span>
    <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{RawConfig} */</span>
    <span class="s4">const </span><span class="s2">rawConfig = (context.options.length &amp;&amp; context.options[</span><span class="s6">0</span><span class="s2">]) || {};</span>
    <span class="s4">const </span><span class="s2">config = normalizeConfig(rawConfig);</span>

    <span class="s4">const </span><span class="s2">hasElementOverrides = Object.keys(config.elementOverrides).length &gt; </span><span class="s6">0</span><span class="s2">;</span>

    <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{Map&lt;string, string&gt;} */</span>
    <span class="s4">const </span><span class="s2">renamedImportMap = </span><span class="s4">new </span><span class="s2">Map();</span>

    <span class="s0">/**</span>
     <span class="s0">* Determines if the given expression is a require statement. Supports</span>
     <span class="s0">* nested MemberExpresions. ie `require('foo').nested.property`</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">isRequireStatement(node) {</span>
      <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'CallExpression'</span><span class="s2">) {</span>
        <span class="s4">if </span><span class="s2">(node.callee.type === </span><span class="s3">'Identifier'</span><span class="s2">) {</span>
          <span class="s4">return </span><span class="s2">node.callee.name === </span><span class="s3">'require'</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">'MemberExpression'</span><span class="s2">) {</span>
        <span class="s4">return </span><span class="s2">isRequireStatement(node.object);</span>
      <span class="s2">}</span>

      <span class="s4">return false</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{{ name: string, compoundName?: string }} ElementNameFragment */</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the name of the given JSX element. Supports nested</span>
     <span class="s0">* JSXMemeberExpressions. ie `&lt;Namesapce.Component.SubComponent /&gt;`</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ElementNameFragment | undefined}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">getJSXElementName(node) {</span>
      <span class="s4">if </span><span class="s2">(node.openingElement.name.type === </span><span class="s3">'JSXIdentifier'</span><span class="s2">) {</span>
        <span class="s4">const </span><span class="s2">name = node.openingElement.name.name;</span>
        <span class="s4">return </span><span class="s2">{</span>
          <span class="s2">name: renamedImportMap.get(name) || name,</span>
          <span class="s2">compoundName: undefined,</span>
        <span class="s2">};</span>
      <span class="s2">}</span>

      <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{string[]} */</span>
      <span class="s4">const </span><span class="s2">nameFragments = [];</span>

      <span class="s4">if </span><span class="s2">(node.openingElement.name.type === </span><span class="s3">'JSXMemberExpression'</span><span class="s2">) {</span>
        <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ASTNode} */</span>
        <span class="s4">let </span><span class="s2">current = node.openingElement.name;</span>
        <span class="s4">while </span><span class="s2">(current.type === </span><span class="s3">'JSXMemberExpression'</span><span class="s2">) {</span>
          <span class="s4">if </span><span class="s2">(current.property.type === </span><span class="s3">'JSXIdentifier'</span><span class="s2">) {</span>
            <span class="s2">nameFragments.unshift(current.property.name);</span>
          <span class="s2">}</span>

          <span class="s2">current = current.object;</span>
        <span class="s2">}</span>

        <span class="s4">if </span><span class="s2">(current.type === </span><span class="s3">'JSXIdentifier'</span><span class="s2">) {</span>
          <span class="s2">nameFragments.unshift(current.name);</span>

          <span class="s4">const </span><span class="s2">rootFragment = nameFragments[</span><span class="s6">0</span><span class="s2">];</span>
          <span class="s4">if </span><span class="s2">(rootFragment) {</span>
            <span class="s4">const </span><span class="s2">rootFragmentRenamed = renamedImportMap.get(rootFragment);</span>
            <span class="s4">if </span><span class="s2">(rootFragmentRenamed) {</span>
              <span class="s2">nameFragments[</span><span class="s6">0</span><span class="s2">] = rootFragmentRenamed;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>

          <span class="s4">const </span><span class="s2">nameFragment = nameFragments[nameFragments.length - </span><span class="s6">1</span><span class="s2">];</span>
          <span class="s4">if </span><span class="s2">(nameFragment) {</span>
            <span class="s4">return </span><span class="s2">{</span>
              <span class="s2">name: nameFragment,</span>
              <span class="s2">compoundName: nameFragments.join(</span><span class="s3">'.'</span><span class="s2">),</span>
            <span class="s2">};</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets all JSXElement ancestor nodes for the given node</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode[]}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">getJSXElementAncestors(node) {</span>
      <span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ASTNode[]} */</span>
      <span class="s4">const </span><span class="s2">ancestors = [];</span>

      <span class="s4">let </span><span class="s2">current = node;</span>
      <span class="s4">while </span><span class="s2">(current) {</span>
        <span class="s4">if </span><span class="s2">(current.type === </span><span class="s3">'JSXElement'</span><span class="s2">) {</span>
          <span class="s2">ancestors.push(current);</span>
        <span class="s2">}</span>

        <span class="s2">current = current.parent;</span>
      <span class="s2">}</span>

      <span class="s4">return </span><span class="s2">ancestors;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">getParentIgnoringBinaryExpressions(node) {</span>
      <span class="s4">let </span><span class="s2">current = node;</span>
      <span class="s4">while </span><span class="s2">(current.parent.type === </span><span class="s3">'BinaryExpression'</span><span class="s2">) {</span>
        <span class="s2">current = current.parent;</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">current.parent;</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{ parent: ASTNode, grandParent: ASTNode }}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">getParentAndGrandParent(node) {</span>
      <span class="s4">const </span><span class="s2">parent = getParentIgnoringBinaryExpressions(node);</span>
      <span class="s4">return </span><span class="s2">{</span>
        <span class="s2">parent,</span>
        <span class="s2">grandParent: parent.parent,</span>
      <span class="s2">};</span>
    <span class="s2">}</span>

    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">hasJSXElementParentOrGrandParent(node) {</span>
      <span class="s4">const </span><span class="s2">ancestors = getParentAndGrandParent(node);</span>
      <span class="s4">return </span><span class="s2">some(iterFrom([ancestors.parent, ancestors.grandParent]), (parent) =&gt; jsxElementTypes.has(parent.type));</span>
    <span class="s2">}</span>

    <span class="s0">// eslint-disable-next-line valid-jsdoc</span>
    <span class="s0">/**</span>
     <span class="s0">* Determines whether a given node's value and its immediate parent are</span>
     <span class="s0">* viable text nodes that can/should be reported on</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ResolvedConfig} resolvedConfig</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">isViableTextNode(node, resolvedConfig) {</span>
      <span class="s4">const </span><span class="s2">textValues = iterFrom([trimIfString(node.raw), trimIfString(node.value)]);</span>
      <span class="s4">if </span><span class="s2">(some(textValues, (value) =&gt; resolvedConfig.allowedStrings.has(value))) {</span>
        <span class="s4">return false</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">parent = getParentIgnoringBinaryExpressions(node);</span>

      <span class="s4">let </span><span class="s2">isStandardJSXNode = </span><span class="s4">false</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">node.value === </span><span class="s3">'string' </span><span class="s2">&amp;&amp; !reIsWhiteSpace.test(node.value) &amp;&amp; standardJSXNodeParentTypes.has(parent.type)) {</span>
        <span class="s4">if </span><span class="s2">(resolvedConfig.noAttributeStrings) {</span>
          <span class="s2">isStandardJSXNode = parent.type === </span><span class="s3">'JSXAttribute' </span><span class="s2">|| parent.type === </span><span class="s3">'JSXElement'</span><span class="s2">;</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
          <span class="s2">isStandardJSXNode = parent.type !== </span><span class="s3">'JSXAttribute'</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(resolvedConfig.noStrings) {</span>
        <span class="s4">return </span><span class="s2">isStandardJSXNode;</span>
      <span class="s2">}</span>

      <span class="s4">return </span><span class="s2">isStandardJSXNode &amp;&amp; parent.type !== </span><span class="s3">'JSXExpressionContainer'</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">// eslint-disable-next-line valid-jsdoc</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets an override config for a given node. For any given node, we also</span>
     <span class="s0">* need to traverse the ancestor tree to determine if an ancestor's config</span>
     <span class="s0">* will also apply to the current node.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{OverrideConfig | undefined}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">getOverrideConfig(node) {</span>
      <span class="s4">if </span><span class="s2">(!hasElementOverrides) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">const </span><span class="s2">allAncestorElements = getJSXElementAncestors(node);</span>
      <span class="s4">if </span><span class="s2">(!allAncestorElements.length) {</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">ancestorElement of allAncestorElements) {</span>
        <span class="s4">const </span><span class="s2">isClosestJSXAncestor = ancestorElement === allAncestorElements[</span><span class="s6">0</span><span class="s2">];</span>

        <span class="s4">const </span><span class="s2">ancestor = getJSXElementName(ancestorElement);</span>
        <span class="s4">if </span><span class="s2">(ancestor) {</span>
          <span class="s4">if </span><span class="s2">(ancestor.name) {</span>
            <span class="s4">const </span><span class="s2">ancestorElements = config.elementOverrides[ancestor.name];</span>
            <span class="s4">const </span><span class="s2">ancestorConfig = ancestor.compoundName</span>
              <span class="s2">? config.elementOverrides[ancestor.compoundName] || ancestorElements</span>
              <span class="s2">: ancestorElements;</span>

            <span class="s4">if </span><span class="s2">(ancestorConfig) {</span>
              <span class="s4">if </span><span class="s2">(isClosestJSXAncestor || ancestorConfig.applyToNestedElements) {</span>
                <span class="s4">return </span><span class="s2">ancestorConfig;</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s0">// eslint-disable-next-line valid-jsdoc</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ResolvedConfig} resolvedConfig</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">shouldAllowElement(resolvedConfig) {</span>
      <span class="s4">return </span><span class="s2">resolvedConfig.type === </span><span class="s3">'override' </span><span class="s2">&amp;&amp; </span><span class="s3">'allowElement' </span><span class="s4">in </span><span class="s2">resolvedConfig &amp;&amp; !!resolvedConfig.allowElement;</span>
    <span class="s2">}</span>

    <span class="s0">// eslint-disable-next-line valid-jsdoc</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} ancestorIsJSXElement</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ResolvedConfig} resolvedConfig</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string}</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">defaultMessageId(ancestorIsJSXElement, resolvedConfig) {</span>
      <span class="s4">if </span><span class="s2">(resolvedConfig.noAttributeStrings &amp;&amp; !ancestorIsJSXElement) {</span>
        <span class="s4">return </span><span class="s2">resolvedConfig.type === </span><span class="s3">'override' </span><span class="s2">? </span><span class="s3">'noStringsInAttributesInElement' </span><span class="s2">: </span><span class="s3">'noStringsInAttributes'</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">if </span><span class="s2">(resolvedConfig.noStrings) {</span>
        <span class="s4">return </span><span class="s2">resolvedConfig.type === </span><span class="s3">'override' </span><span class="s2">? </span><span class="s3">'noStringsInJSXInElement' </span><span class="s2">: </span><span class="s3">'noStringsInJSX'</span><span class="s2">;</span>
      <span class="s2">}</span>

      <span class="s4">return </span><span class="s2">resolvedConfig.type === </span><span class="s3">'override' </span><span class="s2">? </span><span class="s3">'literalNotInJSXExpressionInElement' </span><span class="s2">: </span><span class="s3">'literalNotInJSXExpression'</span><span class="s2">;</span>
    <span class="s2">}</span>

    <span class="s0">// eslint-disable-next-line valid-jsdoc</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} messageId</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ResolvedConfig} resolvedConfig</span>
     <span class="s0">*/</span>
    <span class="s4">function </span><span class="s2">reportLiteralNode(node, messageId, resolvedConfig) {</span>
      <span class="s2">report(context, messages[messageId], messageId, {</span>
        <span class="s2">node,</span>
        <span class="s2">data: {</span>
          <span class="s2">text: getText(context, node).trim(),</span>
          <span class="s2">element: resolvedConfig.type === </span><span class="s3">'override' </span><span class="s2">&amp;&amp; </span><span class="s3">'name' </span><span class="s4">in </span><span class="s2">resolvedConfig ? resolvedConfig.name : undefined,</span>
        <span class="s2">},</span>
      <span class="s2">});</span>
    <span class="s2">}</span>

    <span class="s0">// --------------------------------------------------------------------------</span>
    <span class="s0">// Public</span>
    <span class="s0">// --------------------------------------------------------------------------</span>

    <span class="s4">return </span><span class="s2">Object.assign(hasElementOverrides ? {</span>
      <span class="s0">// Get renamed import local names mapped to their imported name</span>
      <span class="s2">ImportDeclaration(node) {</span>
        <span class="s2">node.specifiers</span>
          <span class="s2">.filter((s) =&gt; s.type === </span><span class="s3">'ImportSpecifier'</span><span class="s2">)</span>
          <span class="s2">.forEach((specifier) =&gt; {</span>
            <span class="s2">renamedImportMap.set(</span>
              <span class="s2">(specifier.local || specifier.imported).name,</span>
              <span class="s2">specifier.imported.name</span>
            <span class="s2">);</span>
          <span class="s2">});</span>
      <span class="s2">},</span>

      <span class="s0">// Get renamed destructured local names mapped to their imported name</span>
      <span class="s2">VariableDeclaration(node) {</span>
        <span class="s2">node.declarations</span>
          <span class="s2">.filter((d) =&gt; (</span>
            <span class="s2">d.type === </span><span class="s3">'VariableDeclarator'</span>
            <span class="s2">&amp;&amp; isRequireStatement(d.init)</span>
            <span class="s2">&amp;&amp; d.id.type === </span><span class="s3">'ObjectPattern'</span>
          <span class="s2">))</span>
          <span class="s2">.forEach((declaration) =&gt; {</span>
            <span class="s2">declaration.id.properties</span>
              <span class="s2">.filter((property) =&gt; (</span>
                <span class="s2">property.type === </span><span class="s3">'Property'</span>
                <span class="s2">&amp;&amp; property.key.type === </span><span class="s3">'Identifier'</span>
                <span class="s2">&amp;&amp; property.value.type === </span><span class="s3">'Identifier'</span>
              <span class="s2">))</span>
              <span class="s2">.forEach((property) =&gt; {</span>
                <span class="s2">renamedImportMap.set(property.value.name, property.key.name);</span>
              <span class="s2">});</span>
          <span class="s2">});</span>
      <span class="s2">},</span>
    <span class="s2">} : </span><span class="s4">false</span><span class="s2">, {</span>
      <span class="s2">Literal(node) {</span>
        <span class="s4">const </span><span class="s2">resolvedConfig = getOverrideConfig(node) || config;</span>

        <span class="s4">const </span><span class="s2">hasJSXParentOrGrandParent = hasJSXElementParentOrGrandParent(node);</span>
        <span class="s4">if </span><span class="s2">(hasJSXParentOrGrandParent &amp;&amp; shouldAllowElement(resolvedConfig)) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s4">if </span><span class="s2">(isViableTextNode(node, resolvedConfig)) {</span>
          <span class="s4">if </span><span class="s2">(hasJSXParentOrGrandParent || !config.ignoreProps) {</span>
            <span class="s2">reportLiteralNode(node, defaultMessageId(hasJSXParentOrGrandParent, resolvedConfig), resolvedConfig);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">},</span>

      <span class="s2">JSXAttribute(node) {</span>
        <span class="s4">const </span><span class="s2">isLiteralString = node.value &amp;&amp; node.value.type === </span><span class="s3">'Literal'</span>
          <span class="s2">&amp;&amp; </span><span class="s4">typeof </span><span class="s2">node.value.value === </span><span class="s3">'string'</span><span class="s2">;</span>
        <span class="s4">const </span><span class="s2">isStringLiteral = node.value &amp;&amp; node.value.type === </span><span class="s3">'StringLiteral'</span><span class="s2">;</span>

        <span class="s4">if </span><span class="s2">(isLiteralString || isStringLiteral) {</span>
          <span class="s4">const </span><span class="s2">resolvedConfig = getOverrideConfig(node) || config;</span>

          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">resolvedConfig.noStrings</span>
            <span class="s2">&amp;&amp; !resolvedConfig.ignoreProps</span>
            <span class="s2">&amp;&amp; !resolvedConfig.allowedStrings.has(node.value.value)</span>
          <span class="s2">) {</span>
            <span class="s4">const </span><span class="s2">messageId = resolvedConfig.type === </span><span class="s3">'override' </span><span class="s2">? </span><span class="s3">'invalidPropValueInElement' </span><span class="s2">: </span><span class="s3">'invalidPropValue'</span><span class="s2">;</span>
            <span class="s2">reportLiteralNode(node, messageId, resolvedConfig);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">},</span>

      <span class="s2">JSXText(node) {</span>
        <span class="s4">const </span><span class="s2">resolvedConfig = getOverrideConfig(node) || config;</span>

        <span class="s4">if </span><span class="s2">(shouldAllowElement(resolvedConfig)) {</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s2">}</span>

        <span class="s4">if </span><span class="s2">(isViableTextNode(node, resolvedConfig)) {</span>
          <span class="s4">const </span><span class="s2">hasJSXParendOrGrantParent = hasJSXElementParentOrGrandParent(node);</span>
          <span class="s2">reportLiteralNode(node, defaultMessageId(hasJSXParendOrGrantParent, resolvedConfig), resolvedConfig);</span>
        <span class="s2">}</span>
      <span class="s2">},</span>

      <span class="s2">TemplateLiteral(node) {</span>
        <span class="s4">const </span><span class="s2">ancestors = getParentAndGrandParent(node);</span>
        <span class="s4">const </span><span class="s2">isParentJSXExpressionCont = ancestors.parent.type === </span><span class="s3">'JSXExpressionContainer'</span><span class="s2">;</span>
        <span class="s4">const </span><span class="s2">isParentJSXElement = ancestors.grandParent.type === </span><span class="s3">'JSXElement'</span><span class="s2">;</span>

        <span class="s4">if </span><span class="s2">(isParentJSXExpressionCont) {</span>
          <span class="s4">const </span><span class="s2">resolvedConfig = getOverrideConfig(node) || config;</span>

          <span class="s4">if </span><span class="s2">(</span>
            <span class="s2">resolvedConfig.noStrings</span>
            <span class="s2">&amp;&amp; (isParentJSXElement || !resolvedConfig.ignoreProps)</span>
          <span class="s2">) {</span>
            <span class="s2">reportLiteralNode(node, defaultMessageId(isParentJSXElement, resolvedConfig), resolvedConfig);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">},</span>
    <span class="s2">});</span>
  <span class="s2">},</span>
<span class="s2">};</span>
</pre>
</body>
</html>