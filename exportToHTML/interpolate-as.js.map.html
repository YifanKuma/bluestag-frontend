<html>
<head>
<title>interpolate-as.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interpolate-as.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../../src/shared/lib/router/utils/interpolate-as.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">import { getRouteMatcher } from './route-matcher'</span><span class="s3">\n</span><span class="s1">import { getRouteRegex } from './route-regex'</span><span class="s3">\n\n</span><span class="s1">export function interpolateAs(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">asPathname: string,</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let interpolatedRoute = ''</span><span class="s3">\n\n  </span><span class="s1">const dynamicRegex = getRouteRegex(route)</span><span class="s3">\n  </span><span class="s1">const dynamicGroups = dynamicRegex.groups</span><span class="s3">\n  </span><span class="s1">const dynamicMatches =</span><span class="s3">\n    </span><span class="s1">// Try to match the dynamic route against the asPath</span><span class="s3">\n    </span><span class="s1">(asPathname !== route ? getRouteMatcher(dynamicRegex)(asPathname) : '') ||</span><span class="s3">\n    </span><span class="s1">// Fall back to reading the values from the href</span><span class="s3">\n    </span><span class="s1">// TODO: should this take priority; also need to change in the router.</span><span class="s3">\n    </span><span class="s1">query</span><span class="s3">\n\n  </span><span class="s1">interpolatedRoute = route</span><span class="s3">\n  </span><span class="s1">const params = Object.keys(dynamicGroups)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!params.every((param) =&gt; {</span><span class="s3">\n      </span><span class="s1">let value = dynamicMatches[param] || ''</span><span class="s3">\n      </span><span class="s1">const { repeat, optional } = dynamicGroups[param]</span><span class="s3">\n\n      </span><span class="s1">// support single-level catch-all</span><span class="s3">\n      </span><span class="s1">// TODO: more robust handling for user-error (passing `/`)</span><span class="s3">\n      </span><span class="s1">let replaced = `[${repeat ? '...' : ''}${param}]`</span><span class="s3">\n      </span><span class="s1">if (optional) {</span><span class="s3">\n        </span><span class="s1">replaced = `${!value ? '/' : ''}[${replaced}]`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (repeat &amp;&amp; !Array.isArray(value)) value = [value]</span><span class="s3">\n\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">(optional || param in dynamicMatches) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// Interpolate group into data URL if present</span><span class="s3">\n        </span><span class="s1">(interpolatedRoute =</span><span class="s3">\n          </span><span class="s1">interpolatedRoute!.replace(</span><span class="s3">\n            </span><span class="s1">replaced,</span><span class="s3">\n            </span><span class="s1">repeat</span><span class="s3">\n              </span><span class="s1">? (value as string[])</span><span class="s3">\n                  </span><span class="s1">.map(</span><span class="s3">\n                    </span><span class="s1">// these values should be fully encoded instead of just</span><span class="s3">\n                    </span><span class="s1">// path delimiter escaped since they are being inserted</span><span class="s3">\n                    </span><span class="s1">// into the URL and we expect URL encoded segments</span><span class="s3">\n                    </span><span class="s1">// when parsing dynamic route params</span><span class="s3">\n                    </span><span class="s1">(segment) =&gt; encodeURIComponent(segment)</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">.join('/')</span><span class="s3">\n              </span><span class="s1">: encodeURIComponent(value as string)</span><span class="s3">\n          </span><span class="s1">) || '/')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">interpolatedRoute = '' // did not satisfy all requirements</span><span class="s3">\n\n    </span><span class="s1">// n.b. We ignore this error because we handle warning for this case in</span><span class="s3">\n    </span><span class="s1">// development in the `&lt;Link&gt;` component directly.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">result: interpolatedRoute,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;interpolateAs&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;asPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolatedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicGroups&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;replaced&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAKgBA;;;eAAAA;;;8BAHgB;4BACF;AAEvB,SAASA,cACdC,KAAa,EACbC,UAAkB,EAClBC,KAAqB;IAErB,IAAIC,oBAAoB;IAExB,MAAMC,eAAeC,IAAAA,yBAAa,EAACL;IACnC,MAAMM,gBAAgBF,aAAaG,MAAM;IACzC,MAAMC,iBAEJ,AADA,oDAAoD;IACnDP,CAAAA,eAAeD,QAAQS,IAAAA,6BAAe,EAACL,cAAcH,cAAc,EAAC,KACrE,gDAAgD;IAChD,sEAAsE;IACtEC;IAEFC,oBAAoBH;IACpB,MAAMU,SAASC,OAAOC,IAAI,CAACN;IAE3B,IACE,CAACI,OAAOG,KAAK,CAAC,CAACC;QACb,IAAIC,QAAQP,cAAc,CAACM,MAAM,IAAI;QACrC,MAAM,EAAEE,MAAM,EAAEC,QAAQ,EAAE,GAAGX,aAAa,CAACQ,MAAM;QAEjD,iCAAiC;QACjC,0DAA0D;QAC1D,IAAII,WAAW,AAAC,MAAGF,CAAAA,SAAS,QAAQ,EAAC,IAAIF,QAAM;QAC/C,IAAIG,UAAU;YACZC,WAAW,AAAG,CAAA,CAACH,QAAQ,MAAM,EAAC,IAAE,MAAGG,WAAS;QAC9C;QACA,IAAIF,UAAU,CAACG,MAAMC,OAAO,CAACL,QAAQA,QAAQ;YAACA;SAAM;QAEpD,OACE,AAACE,CAAAA,YAAYH,SAASN,cAAa,KACnC,6CAA6C;QAC5CL,CAAAA,oBACCA,kBAAmBkB,OAAO,CACxBH,UACAF,SACI,AAACD,MACEO,GAAG,CACF,uDAAuD;QACvD,uDAAuD;QACvD,kDAAkD;QAClD,oCAAoC;QACpC,CAACC,UAAYC,mBAAmBD,UAEjCE,IAAI,CAAC,OACRD,mBAAmBT,WACpB,GAAE;IAEb,IACA;QACAZ,oBAAoB,GAAG,mCAAmC;;IAE1D,uEAAuE;IACvE,kDAAkD;IACpD;IACA,OAAO;QACLO;QACAgB,QAAQvB;IACV;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>