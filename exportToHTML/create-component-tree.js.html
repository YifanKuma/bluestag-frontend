<html>
<head>
<title>create-component-tree.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create-component-tree.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">createComponentTree: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getRootParams: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">createComponentTree: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createComponentTree;</span>
    <span class="s1">},</span>
    <span class="s1">getRootParams: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getRootParams;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_jsxruntime = require(</span><span class="s0">&quot;react/jsx-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_react = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_clientandserverreferences = require(</span><span class="s0">&quot;../../lib/client-and-server-references&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_appdirmodule = require(</span><span class="s0">&quot;../lib/app-dir-module&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_interopdefault = require(</span><span class="s0">&quot;./interop-default&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parseloadertree = require(</span><span class="s0">&quot;./parse-loader-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createcomponentstylesandscripts = require(</span><span class="s0">&quot;./create-component-styles-and-scripts&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getlayerassets = require(</span><span class="s0">&quot;./get-layer-assets&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hasloadingcomponentintree = require(</span><span class="s0">&quot;./has-loading-component-in-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_patchfetch = require(</span><span class="s0">&quot;../lib/patch-fetch&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_default = require(</span><span class="s0">&quot;../../client/components/builtin/default&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_tracer = require(</span><span class="s0">&quot;../lib/trace/tracer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../lib/trace/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_staticgenerationbailout = require(</span><span class="s0">&quot;../../client/components/static-generation-bailout&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;./work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_boundaryconstants = require(</span><span class="s0">&quot;../../lib/framework/boundary-constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segment = require(</span><span class="s0">&quot;../../shared/lib/segment&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_segmentexplorerpath = require(</span><span class="s0">&quot;./segment-explorer-path&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createComponentTree(props) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants.NextNodeServerSpan.createComponentTree, {</span>
        <span class="s1">spanName: </span><span class="s0">'build component tree'</span>
    <span class="s1">}, ()=&gt;createComponentTreeInternal(props, </span><span class="s2">true</span><span class="s1">));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorMissingDefaultExport(pagePath, convention) {</span>
    <span class="s2">const </span><span class="s1">normalizedPagePath = pagePath === </span><span class="s0">'/' </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: pagePath;</span>
    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`The default export is not a React Component in &quot;</span><span class="s1">${normalizedPagePath}</span><span class="s0">/</span><span class="s1">${convention}</span><span class="s0">&quot;`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">&quot;E45&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">cacheNodeKey = </span><span class="s0">'c'</span><span class="s1">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createComponentTreeInternal({ loaderTree: tree, parentParams, rootLayoutIncluded, injectedCSS, injectedJS, injectedFontPreloadTags, getViewportReady, getMetadataReady, ctx, missingSlots, preloadCallbacks, authInterrupts, StreamingMetadataOutlet }, isRoot) {</span>
    <span class="s2">const </span><span class="s1">{ renderOpts: { nextConfigOutput, experimental }, workStore, componentMod: { SegmentViewNode, HTTPAccessFallbackBoundary, LayoutRouter, RenderFromTemplateContext, OutletBoundary, ClientPageRoot, ClientSegmentRoot, createServerSearchParamsForServerPage, createPrerenderSearchParamsForClientPage, createServerParamsForServerSegment, createPrerenderParamsForClientSegment, serverHooks: { DynamicServerError }, Postpone }, pagePath, getDynamicParamFromSegment, isPrefetch, query } = ctx;</span>
    <span class="s2">const </span><span class="s1">{ page, conventionPath, segment, modules, parallelRoutes } = (</span><span class="s3">0</span><span class="s1">, _parseloadertree.parseLoaderTree)(tree);</span>
    <span class="s2">const </span><span class="s1">{ layout, template, error, loading, </span><span class="s0">'not-found'</span><span class="s1">: notFound, forbidden, unauthorized } = modules;</span>
    <span class="s2">const </span><span class="s1">injectedCSSWithCurrentLayout = </span><span class="s2">new </span><span class="s1">Set(injectedCSS);</span>
    <span class="s2">const </span><span class="s1">injectedJSWithCurrentLayout = </span><span class="s2">new </span><span class="s1">Set(injectedJS);</span>
    <span class="s2">const </span><span class="s1">injectedFontPreloadTagsWithCurrentLayout = </span><span class="s2">new </span><span class="s1">Set(injectedFontPreloadTags);</span>
    <span class="s2">const </span><span class="s1">layerAssets = (</span><span class="s3">0</span><span class="s1">, _getlayerassets.getLayerAssets)({</span>
        <span class="s1">preloadCallbacks,</span>
        <span class="s1">ctx,</span>
        <span class="s1">layoutOrPagePath: conventionPath,</span>
        <span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span>
        <span class="s1">injectedJS: injectedJSWithCurrentLayout,</span>
        <span class="s1">injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">[Template, templateStyles, templateScripts] = template ? </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _createcomponentstylesandscripts.createComponentStylesAndScripts)({</span>
        <span class="s1">ctx,</span>
        <span class="s1">filePath: template[</span><span class="s3">1</span><span class="s1">],</span>
        <span class="s1">getComponent: template[</span><span class="s3">0</span><span class="s1">],</span>
        <span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span>
        <span class="s1">injectedJS: injectedJSWithCurrentLayout</span>
    <span class="s1">}) : [</span>
        <span class="s1">_react.default.Fragment</span>
    <span class="s1">];</span>
    <span class="s2">const </span><span class="s1">[ErrorComponent, errorStyles, errorScripts] = error ? </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _createcomponentstylesandscripts.createComponentStylesAndScripts)({</span>
        <span class="s1">ctx,</span>
        <span class="s1">filePath: error[</span><span class="s3">1</span><span class="s1">],</span>
        <span class="s1">getComponent: error[</span><span class="s3">0</span><span class="s1">],</span>
        <span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span>
        <span class="s1">injectedJS: injectedJSWithCurrentLayout</span>
    <span class="s1">}) : [];</span>
    <span class="s2">const </span><span class="s1">[Loading, loadingStyles, loadingScripts] = loading ? </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _createcomponentstylesandscripts.createComponentStylesAndScripts)({</span>
        <span class="s1">ctx,</span>
        <span class="s1">filePath: loading[</span><span class="s3">1</span><span class="s1">],</span>
        <span class="s1">getComponent: loading[</span><span class="s3">0</span><span class="s1">],</span>
        <span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span>
        <span class="s1">injectedJS: injectedJSWithCurrentLayout</span>
    <span class="s1">}) : [];</span>
    <span class="s2">const </span><span class="s1">isLayout = </span><span class="s2">typeof </span><span class="s1">layout !== </span><span class="s0">'undefined'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">isPage = </span><span class="s2">typeof </span><span class="s1">page !== </span><span class="s0">'undefined'</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">{ mod: layoutOrPageMod, modType } = </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants.NextNodeServerSpan.getLayoutOrPageModule, {</span>
        <span class="s1">hideSpan: !(isLayout || isPage),</span>
        <span class="s1">spanName: </span><span class="s0">'resolve segment modules'</span><span class="s1">,</span>
        <span class="s1">attributes: {</span>
            <span class="s0">'next.segment'</span><span class="s1">: segment</span>
        <span class="s1">}</span>
    <span class="s1">}, ()=&gt;(</span><span class="s3">0</span><span class="s1">, _appdirmodule.getLayoutOrPageModule)(tree));</span>
    <span class="s4">/**</span>
   <span class="s4">* Checks if the current segment is a root layout.</span>
   <span class="s4">*/ </span><span class="s2">const </span><span class="s1">rootLayoutAtThisLevel = isLayout &amp;&amp; !rootLayoutIncluded;</span>
    <span class="s4">/**</span>
   <span class="s4">* Checks if the current segment or any level above it has a root layout.</span>
   <span class="s4">*/ </span><span class="s2">const </span><span class="s1">rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;</span>
    <span class="s2">const </span><span class="s1">[NotFound, notFoundStyles] = notFound ? </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _createcomponentstylesandscripts.createComponentStylesAndScripts)({</span>
        <span class="s1">ctx,</span>
        <span class="s1">filePath: notFound[</span><span class="s3">1</span><span class="s1">],</span>
        <span class="s1">getComponent: notFound[</span><span class="s3">0</span><span class="s1">],</span>
        <span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span>
        <span class="s1">injectedJS: injectedJSWithCurrentLayout</span>
    <span class="s1">}) : [];</span>
    <span class="s2">const </span><span class="s1">[Forbidden, forbiddenStyles] = authInterrupts &amp;&amp; forbidden ? </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _createcomponentstylesandscripts.createComponentStylesAndScripts)({</span>
        <span class="s1">ctx,</span>
        <span class="s1">filePath: forbidden[</span><span class="s3">1</span><span class="s1">],</span>
        <span class="s1">getComponent: forbidden[</span><span class="s3">0</span><span class="s1">],</span>
        <span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span>
        <span class="s1">injectedJS: injectedJSWithCurrentLayout</span>
    <span class="s1">}) : [];</span>
    <span class="s2">const </span><span class="s1">[Unauthorized, unauthorizedStyles] = authInterrupts &amp;&amp; unauthorized ? </span><span class="s2">await </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _createcomponentstylesandscripts.createComponentStylesAndScripts)({</span>
        <span class="s1">ctx,</span>
        <span class="s1">filePath: unauthorized[</span><span class="s3">1</span><span class="s1">],</span>
        <span class="s1">getComponent: unauthorized[</span><span class="s3">0</span><span class="s1">],</span>
        <span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span>
        <span class="s1">injectedJS: injectedJSWithCurrentLayout</span>
    <span class="s1">}) : [];</span>
    <span class="s2">let </span><span class="s1">dynamic = layoutOrPageMod == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: layoutOrPageMod.dynamic;</span>
    <span class="s2">if </span><span class="s1">(nextConfigOutput === </span><span class="s0">'export'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!dynamic || dynamic === </span><span class="s0">'auto'</span><span class="s1">) {</span>
            <span class="s1">dynamic = </span><span class="s0">'error'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(dynamic === </span><span class="s0">'force-dynamic'</span><span class="s1">) {</span>
            <span class="s4">// force-dynamic is always incompatible with 'export'. We must interrupt the build</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_staticgenerationbailout.StaticGenBailoutError(</span><span class="s0">`Page with </span><span class="s5">\`</span><span class="s0">dynamic = &quot;force-dynamic&quot;</span><span class="s5">\` </span><span class="s0">couldn't be exported. </span><span class="s5">\`</span><span class="s0">output: &quot;export&quot;</span><span class="s5">\` </span><span class="s0">requires all pages be renderable statically because there is no runtime server to dynamically render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E527&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">dynamic === </span><span class="s0">'string'</span><span class="s1">) {</span>
        <span class="s4">// the nested most config wins so we only force-static</span>
        <span class="s4">// if it's configured above any parent that configured</span>
        <span class="s4">// otherwise</span>
        <span class="s2">if </span><span class="s1">(dynamic === </span><span class="s0">'error'</span><span class="s1">) {</span>
            <span class="s1">workStore.dynamicShouldError = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(dynamic === </span><span class="s0">'force-dynamic'</span><span class="s1">) {</span>
            <span class="s1">workStore.forceDynamic = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s4">// TODO: (PPR) remove this bailout once PPR is the default</span>
            <span class="s2">if </span><span class="s1">(workStore.isStaticGeneration &amp;&amp; !experimental.isRoutePPREnabled) {</span>
                <span class="s4">// If the postpone API isn't available, we can't postpone the render and</span>
                <span class="s4">// therefore we can't use the dynamic API.</span>
                <span class="s2">const </span><span class="s1">err = Object.defineProperty(</span><span class="s2">new </span><span class="s1">DynamicServerError(</span><span class="s0">`Page with </span><span class="s5">\`</span><span class="s0">dynamic = &quot;force-dynamic&quot;</span><span class="s5">\` </span><span class="s0">won't be rendered statically.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E585&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s1">workStore.dynamicUsageDescription = err.message;</span>
                <span class="s1">workStore.dynamicUsageStack = err.stack;</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">workStore.dynamicShouldError = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">workStore.forceStatic = dynamic === </span><span class="s0">'force-static'</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">(layoutOrPageMod == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: layoutOrPageMod.fetchCache) === </span><span class="s0">'string'</span><span class="s1">) {</span>
        <span class="s1">workStore.fetchCache = layoutOrPageMod == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: layoutOrPageMod.fetchCache;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">(layoutOrPageMod == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: layoutOrPageMod.revalidate) !== </span><span class="s0">'undefined'</span><span class="s1">) {</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _patchfetch.validateRevalidate)(layoutOrPageMod == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: layoutOrPageMod.revalidate, workStore.route);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">(layoutOrPageMod == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: layoutOrPageMod.revalidate) === </span><span class="s0">'number'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">defaultRevalidate = layoutOrPageMod.revalidate;</span>
        <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
        <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
            <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
                <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(workUnitStore.revalidate &gt; defaultRevalidate) {</span>
                        <span class="s1">workUnitStore.revalidate = defaultRevalidate;</span>
                    <span class="s1">}</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s4">// createComponentTree is not called for these stores:</span>
                <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">workUnitStore;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!workStore.forceStatic &amp;&amp; workStore.isStaticGeneration &amp;&amp; defaultRevalidate === </span><span class="s3">0 </span><span class="s1">&amp;&amp; </span><span class="s4">// If the postpone API isn't available, we can't postpone the render and</span>
        <span class="s4">// therefore we can't use the dynamic API.</span>
        <span class="s1">!experimental.isRoutePPREnabled) {</span>
            <span class="s2">const </span><span class="s1">dynamicUsageDescription = </span><span class="s0">`revalidate: 0 configured </span><span class="s1">${segment}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">workStore.dynamicUsageDescription = dynamicUsageDescription;</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">DynamicServerError(dynamicUsageDescription), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">isStaticGeneration = workStore.isStaticGeneration;</span>
    <span class="s4">// Assume the segment we're rendering contains only partial data if PPR is</span>
    <span class="s4">// enabled and this is a statically generated response. This is used by the</span>
    <span class="s4">// client Segment Cache after a prefetch to determine if it can skip the</span>
    <span class="s4">// second request to fill in the dynamic data.</span>
    <span class="s4">//</span>
    <span class="s4">// It's OK for this to be `true` when the data is actually fully static, but</span>
    <span class="s4">// it's not OK for this to be `false` when the data possibly contains holes.</span>
    <span class="s4">// Although the value here is overly pessimistic, for prefetches, it will be</span>
    <span class="s4">// replaced by a more specific value when the data is later processed into</span>
    <span class="s4">// per-segment responses (see collect-segment-data.tsx)</span>
    <span class="s4">//</span>
    <span class="s4">// For dynamic requests, this must always be `false` because dynamic responses</span>
    <span class="s4">// are never partial.</span>
    <span class="s2">const </span><span class="s1">isPossiblyPartialResponse = isStaticGeneration &amp;&amp; experimental.isRoutePPREnabled === </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">LayoutOrPage = layoutOrPageMod ? (</span><span class="s3">0</span><span class="s1">, _interopdefault.interopDefault)(layoutOrPageMod) : undefined;</span>
    <span class="s4">/**</span>
   <span class="s4">* The React Component to render.</span>
   <span class="s4">*/ </span><span class="s2">let </span><span class="s1">MaybeComponent = LayoutOrPage;</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">{ isValidElementType } = require(</span><span class="s0">'next/dist/compiled/react-is'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">MaybeComponent !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; !isValidElementType(MaybeComponent)) {</span>
            <span class="s1">errorMissingDefaultExport(pagePath, modType ?? </span><span class="s0">'page'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ErrorComponent !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; !isValidElementType(ErrorComponent)) {</span>
            <span class="s1">errorMissingDefaultExport(pagePath, </span><span class="s0">'error'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Loading !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; !isValidElementType(Loading)) {</span>
            <span class="s1">errorMissingDefaultExport(pagePath, </span><span class="s0">'loading'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">NotFound !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; !isValidElementType(NotFound)) {</span>
            <span class="s1">errorMissingDefaultExport(pagePath, </span><span class="s0">'not-found'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Forbidden !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; !isValidElementType(Forbidden)) {</span>
            <span class="s1">errorMissingDefaultExport(pagePath, </span><span class="s0">'forbidden'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Unauthorized !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; !isValidElementType(Unauthorized)) {</span>
            <span class="s1">errorMissingDefaultExport(pagePath, </span><span class="s0">'unauthorized'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// Handle dynamic segment params.</span>
    <span class="s2">const </span><span class="s1">segmentParam = getDynamicParamFromSegment(segment);</span>
    <span class="s4">// Create object holding the parent params and current params</span>
    <span class="s2">let </span><span class="s1">currentParams = parentParams;</span>
    <span class="s2">if </span><span class="s1">(segmentParam &amp;&amp; segmentParam.value !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">currentParams = {</span>
            <span class="s1">...parentParams,</span>
            <span class="s1">[segmentParam.param]: segmentParam.value</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s4">// Resolve the segment param</span>
    <span class="s2">const </span><span class="s1">actualSegment = segmentParam ? segmentParam.treeSegment : segment;</span>
    <span class="s2">const </span><span class="s1">isSegmentViewEnabled = process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; ctx.renderOpts.devtoolSegmentExplorer;</span>
    <span class="s2">const </span><span class="s1">dir = (process.env.NEXT_RUNTIME === </span><span class="s0">'edge' </span><span class="s1">? process.env.__NEXT_EDGE_PROJECT_DIR : ctx.renderOpts.dir) || </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s4">// Use the same condition to render metadataOutlet as metadata</span>
    <span class="s2">const </span><span class="s1">metadataOutlet = StreamingMetadataOutlet ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(StreamingMetadataOutlet, {}) : </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(MetadataOutlet, {</span>
        <span class="s1">ready: getMetadataReady</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">[notFoundElement, notFoundFilePath] = </span><span class="s2">await </span><span class="s1">createBoundaryConventionElement({</span>
        <span class="s1">ctx,</span>
        <span class="s1">conventionName: </span><span class="s0">'not-found'</span><span class="s1">,</span>
        <span class="s1">Component: NotFound,</span>
        <span class="s1">styles: notFoundStyles,</span>
        <span class="s1">tree</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">[forbiddenElement] = </span><span class="s2">await </span><span class="s1">createBoundaryConventionElement({</span>
        <span class="s1">ctx,</span>
        <span class="s1">conventionName: </span><span class="s0">'forbidden'</span><span class="s1">,</span>
        <span class="s1">Component: Forbidden,</span>
        <span class="s1">styles: forbiddenStyles,</span>
        <span class="s1">tree</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">[unauthorizedElement] = </span><span class="s2">await </span><span class="s1">createBoundaryConventionElement({</span>
        <span class="s1">ctx,</span>
        <span class="s1">conventionName: </span><span class="s0">'unauthorized'</span><span class="s1">,</span>
        <span class="s1">Component: Unauthorized,</span>
        <span class="s1">styles: unauthorizedStyles,</span>
        <span class="s1">tree</span>
    <span class="s1">});</span>
    <span class="s4">// TODO: Combine this `map` traversal with the loop below that turns the array</span>
    <span class="s4">// into an object.</span>
    <span class="s2">const </span><span class="s1">parallelRouteMap = </span><span class="s2">await </span><span class="s1">Promise.all(Object.keys(parallelRoutes).map(async (parallelRouteKey)=&gt;{</span>
        <span class="s2">const </span><span class="s1">isChildrenRouteKey = parallelRouteKey === </span><span class="s0">'children'</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">parallelRoute = parallelRoutes[parallelRouteKey];</span>
        <span class="s2">const </span><span class="s1">notFoundComponent = isChildrenRouteKey ? notFoundElement : undefined;</span>
        <span class="s2">const </span><span class="s1">forbiddenComponent = isChildrenRouteKey ? forbiddenElement : undefined;</span>
        <span class="s2">const </span><span class="s1">unauthorizedComponent = isChildrenRouteKey ? unauthorizedElement : undefined;</span>
        <span class="s4">// if we're prefetching and that there's a Loading component, we bail out</span>
        <span class="s4">// otherwise we keep rendering for the prefetch.</span>
        <span class="s4">// We also want to bail out if there's no Loading component in the tree.</span>
        <span class="s2">let </span><span class="s1">childCacheNodeSeedData = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">// Before PPR, the way instant navigations work in Next.js is we</span>
        <span class="s4">// prefetch everything up to the first route segment that defines a</span>
        <span class="s4">// loading.tsx boundary. (We do the same if there's no loading</span>
        <span class="s4">// boundary in the entire tree, because we don't want to prefetch too</span>
        <span class="s4">// much) The rest of the tree is deferred until the actual navigation.</span>
        <span class="s4">// It does not take into account whether the data is dynamic — even if</span>
        <span class="s4">// the tree is completely static, it will still defer everything</span>
        <span class="s4">// inside the loading boundary.</span>
        <span class="s4">//</span>
        <span class="s4">// This behavior predates PPR and is only relevant if the</span>
        <span class="s4">// PPR flag is not enabled.</span>
        <span class="s1">isPrefetch &amp;&amp; (Loading || !(</span><span class="s3">0</span><span class="s1">, _hasloadingcomponentintree.hasLoadingComponentInTree)(parallelRoute)) &amp;&amp; </span><span class="s4">// The approach with PPR is different — loading.tsx behaves like a</span>
        <span class="s4">// regular Suspense boundary and has no special behavior.</span>
        <span class="s4">//</span>
        <span class="s4">// With PPR, we prefetch as deeply as possible, and only defer when</span>
        <span class="s4">// dynamic data is accessed. If so, we only defer the nearest parent</span>
        <span class="s4">// Suspense boundary of the dynamic data access, regardless of whether</span>
        <span class="s4">// the boundary is defined by loading.tsx or a normal &lt;Suspense&gt;</span>
        <span class="s4">// component in userspace.</span>
        <span class="s4">//</span>
        <span class="s4">// NOTE: In practice this usually means we'll end up prefetching more</span>
        <span class="s4">// than we were before PPR, which may or may not be considered a</span>
        <span class="s4">// performance regression by some apps. The plan is to address this</span>
        <span class="s4">// before General Availability of PPR by introducing granular</span>
        <span class="s4">// per-segment fetching, so we can reuse as much of the tree as</span>
        <span class="s4">// possible during both prefetches and dynamic navigations. But during</span>
        <span class="s4">// the beta period, we should be clear about this trade off in our</span>
        <span class="s4">// communications.</span>
        <span class="s1">!experimental.isRoutePPREnabled) {</span>
        <span class="s4">// Don't prefetch this child. This will trigger a lazy fetch by the</span>
        <span class="s4">// client router.</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// Create the child component</span>
            <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; missingSlots) {</span>
                <span class="s2">var </span><span class="s1">_parsedTree_conventionPath;</span>
                <span class="s4">// When we detect the default fallback (which triggers a 404), we collect the missing slots</span>
                <span class="s4">// to provide more helpful debug information during development mode.</span>
                <span class="s2">const </span><span class="s1">parsedTree = (</span><span class="s3">0</span><span class="s1">, _parseloadertree.parseLoaderTree)(parallelRoute);</span>
                <span class="s2">if </span><span class="s1">((_parsedTree_conventionPath = parsedTree.conventionPath) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _parsedTree_conventionPath.endsWith(_default.PARALLEL_ROUTE_DEFAULT_PATH)) {</span>
                    <span class="s1">missingSlots.add(parallelRouteKey);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">seedData = </span><span class="s2">await </span><span class="s1">createComponentTreeInternal({</span>
                <span class="s1">loaderTree: parallelRoute,</span>
                <span class="s1">parentParams: currentParams,</span>
                <span class="s1">rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,</span>
                <span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span>
                <span class="s1">injectedJS: injectedJSWithCurrentLayout,</span>
                <span class="s1">injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,</span>
                <span class="s4">// `getMetadataReady` and `getViewportReady` are used to conditionally throw. In the case of parallel routes we will have more than one page</span>
                <span class="s4">// but we only want to throw on the first one.</span>
                <span class="s1">getMetadataReady: isChildrenRouteKey ? getMetadataReady : ()=&gt;Promise.resolve(),</span>
                <span class="s1">getViewportReady: isChildrenRouteKey ? getViewportReady : ()=&gt;Promise.resolve(),</span>
                <span class="s1">ctx,</span>
                <span class="s1">missingSlots,</span>
                <span class="s1">preloadCallbacks,</span>
                <span class="s1">authInterrupts,</span>
                <span class="s4">// `StreamingMetadataOutlet` is used to conditionally throw. In the case of parallel routes we will have more than one page</span>
                <span class="s4">// but we only want to throw on the first one.</span>
                <span class="s1">StreamingMetadataOutlet: isChildrenRouteKey ? StreamingMetadataOutlet : </span><span class="s2">null</span>
            <span class="s1">}, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">childCacheNodeSeedData = seedData;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">templateNode = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(Template, {</span>
            <span class="s1">children: </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(RenderFromTemplateContext, {})</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">templateFilePath = (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, </span><span class="s0">'template'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">errorFilePath = (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, </span><span class="s0">'error'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">loadingFilePath = (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, </span><span class="s0">'loading'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">globalErrorFilePath = isRoot ? (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, </span><span class="s0">'global-error'</span><span class="s1">) : undefined;</span>
        <span class="s2">const </span><span class="s1">wrappedErrorStyles = isSegmentViewEnabled &amp;&amp; errorFilePath ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
            <span class="s1">type: </span><span class="s0">&quot;error&quot;</span><span class="s1">,</span>
            <span class="s1">pagePath: errorFilePath,</span>
            <span class="s1">children: errorStyles</span>
        <span class="s1">}) : errorStyles;</span>
        <span class="s4">// Add a suffix to avoid conflict with the segment view node representing rendered file.</span>
        <span class="s4">// existence: not-found.tsx@boundary</span>
        <span class="s4">// rendered: not-found.tsx</span>
        <span class="s2">const </span><span class="s1">fileNameSuffix = _segmentexplorerpath.BOUNDARY_SUFFIX;</span>
        <span class="s2">const </span><span class="s1">segmentViewBoundaries = isSegmentViewEnabled ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
            <span class="s1">children: [</span>
                <span class="s1">notFoundFilePath &amp;&amp; </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
                    <span class="s1">type: </span><span class="s0">`</span><span class="s1">${_segmentexplorerpath.BOUNDARY_PREFIX}</span><span class="s0">not-found`</span><span class="s1">,</span>
                    <span class="s1">pagePath: notFoundFilePath + fileNameSuffix</span>
                <span class="s1">}),</span>
                <span class="s1">loadingFilePath &amp;&amp; </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
                    <span class="s1">type: </span><span class="s0">`</span><span class="s1">${_segmentexplorerpath.BOUNDARY_PREFIX}</span><span class="s0">loading`</span><span class="s1">,</span>
                    <span class="s1">pagePath: loadingFilePath + fileNameSuffix</span>
                <span class="s1">}),</span>
                <span class="s1">errorFilePath &amp;&amp; </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
                    <span class="s1">type: </span><span class="s0">`</span><span class="s1">${_segmentexplorerpath.BOUNDARY_PREFIX}</span><span class="s0">error`</span><span class="s1">,</span>
                    <span class="s1">pagePath: errorFilePath + fileNameSuffix</span>
                <span class="s1">}),</span>
                <span class="s1">globalErrorFilePath &amp;&amp; </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
                    <span class="s1">type: </span><span class="s0">`</span><span class="s1">${_segmentexplorerpath.BOUNDARY_PREFIX}</span><span class="s0">global-error`</span><span class="s1">,</span>
                    <span class="s1">pagePath: (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.isNextjsBuiltinFilePath)(globalErrorFilePath) ? </span><span class="s0">`</span><span class="s1">${_segmentexplorerpath.BUILTIN_PREFIX}</span><span class="s0">global-error.js</span><span class="s1">${fileNameSuffix}</span><span class="s0">` </span><span class="s1">: globalErrorFilePath</span>
                <span class="s1">})</span>
            <span class="s1">]</span>
        <span class="s1">}) : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">parallelRouteKey,</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(LayoutRouter, {</span>
                <span class="s1">parallelRouterKey: parallelRouteKey,</span>
                <span class="s4">// TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.</span>
                <span class="s1">error: ErrorComponent,</span>
                <span class="s1">errorStyles: wrappedErrorStyles,</span>
                <span class="s1">errorScripts: errorScripts,</span>
                <span class="s1">template: </span><span class="s4">// Only render SegmentViewNode when there's an actual template</span>
                <span class="s1">isSegmentViewEnabled &amp;&amp; templateFilePath ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
                    <span class="s1">type: </span><span class="s0">&quot;template&quot;</span><span class="s1">,</span>
                    <span class="s1">pagePath: templateFilePath,</span>
                    <span class="s1">children: templateNode</span>
                <span class="s1">}) : templateNode,</span>
                <span class="s1">templateStyles: templateStyles,</span>
                <span class="s1">templateScripts: templateScripts,</span>
                <span class="s1">notFound: notFoundComponent,</span>
                <span class="s1">forbidden: forbiddenComponent,</span>
                <span class="s1">unauthorized: unauthorizedComponent,</span>
                <span class="s1">...isSegmentViewEnabled &amp;&amp; {</span>
                    <span class="s1">segmentViewBoundaries</span>
                <span class="s1">}</span>
            <span class="s1">}),</span>
            <span class="s1">childCacheNodeSeedData</span>
        <span class="s1">];</span>
    <span class="s1">}));</span>
    <span class="s4">// Convert the parallel route map into an object after all promises have been resolved.</span>
    <span class="s2">let </span><span class="s1">parallelRouteProps = {};</span>
    <span class="s2">let </span><span class="s1">parallelRouteCacheNodeSeedData = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">parallelRoute of parallelRouteMap){</span>
        <span class="s2">const </span><span class="s1">[parallelRouteKey, parallelRouteProp, flightData] = parallelRoute;</span>
        <span class="s1">parallelRouteProps[parallelRouteKey] = parallelRouteProp;</span>
        <span class="s1">parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">loadingElement = Loading ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(Loading, {}, </span><span class="s0">&quot;l&quot;</span><span class="s1">) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">loadingFilePath = (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, </span><span class="s0">'loading'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(isSegmentViewEnabled &amp;&amp; loadingElement) {</span>
        <span class="s2">if </span><span class="s1">(loadingFilePath) {</span>
            <span class="s1">loadingElement = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
                <span class="s1">type: </span><span class="s0">&quot;loading&quot;</span><span class="s1">,</span>
                <span class="s1">pagePath: loadingFilePath,</span>
                <span class="s1">children: loadingElement</span>
            <span class="s1">}, cacheNodeKey + </span><span class="s0">'-loading'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">loadingData = loadingElement ? [</span>
        <span class="s1">loadingElement,</span>
        <span class="s1">loadingStyles,</span>
        <span class="s1">loadingScripts</span>
    <span class="s1">] : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">// When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component</span>
    <span class="s2">if </span><span class="s1">(!MaybeComponent) {</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">actualSegment,</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
                <span class="s1">children: [</span>
                    <span class="s1">layerAssets,</span>
                    <span class="s1">parallelRouteProps.children</span>
                <span class="s1">]</span>
            <span class="s1">}, cacheNodeKey),</span>
            <span class="s1">parallelRouteCacheNodeSeedData,</span>
            <span class="s1">loadingData,</span>
            <span class="s1">isPossiblyPartialResponse</span>
        <span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">Component = MaybeComponent;</span>
    <span class="s4">// If force-dynamic is used and the current render supports postponing, we</span>
    <span class="s4">// replace it with a node that will postpone the render. This ensures that the</span>
    <span class="s4">// postpone is invoked during the react render phase and not during the next</span>
    <span class="s4">// render phase.</span>
    <span class="s4">// @TODO this does not actually do what it seems like it would or should do. The idea is that</span>
    <span class="s4">// if we are rendering in a force-dynamic mode and we can postpone we should only make the segments</span>
    <span class="s4">// that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However</span>
    <span class="s4">// because this comes after the children traversal and the static generation store is mutated every segment</span>
    <span class="s4">// along the parent path of a force-dynamic segment will hit this condition effectively making the entire</span>
    <span class="s4">// render force-dynamic. We should refactor this function so that we can correctly track which segments</span>
    <span class="s4">// need to be dynamic</span>
    <span class="s2">if </span><span class="s1">(workStore.isStaticGeneration &amp;&amp; workStore.forceDynamic &amp;&amp; experimental.isRoutePPREnabled) {</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">actualSegment,</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
                <span class="s1">children: [</span>
                    <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(Postpone, {</span>
                        <span class="s1">reason: </span><span class="s0">'dynamic = &quot;force-dynamic&quot; was used'</span><span class="s1">,</span>
                        <span class="s1">route: workStore.route</span>
                    <span class="s1">}),</span>
                    <span class="s1">layerAssets</span>
                <span class="s1">]</span>
            <span class="s1">}, cacheNodeKey),</span>
            <span class="s1">parallelRouteCacheNodeSeedData,</span>
            <span class="s1">loadingData,</span>
            <span class="s2">true</span>
        <span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">isClientComponent = (</span><span class="s3">0</span><span class="s1">, _clientandserverreferences.isClientReference)(layoutOrPageMod);</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; </span><span class="s0">'params' </span><span class="s2">in </span><span class="s1">parallelRouteProps) {</span>
        <span class="s4">// @TODO consider making this an error and running the check in build as well</span>
        <span class="s1">console.error(</span><span class="s0">`&quot;params&quot; is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in </span><span class="s1">${segment}</span><span class="s0">`</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isPage) {</span>
        <span class="s2">const </span><span class="s1">PageComponent = Component;</span>
        <span class="s4">// Assign searchParams to props if this is a page</span>
        <span class="s2">let </span><span class="s1">pageElement;</span>
        <span class="s2">if </span><span class="s1">(isClientComponent) {</span>
            <span class="s2">if </span><span class="s1">(isStaticGeneration) {</span>
                <span class="s2">const </span><span class="s1">promiseOfParams = createPrerenderParamsForClientSegment(currentParams);</span>
                <span class="s2">const </span><span class="s1">promiseOfSearchParams = createPrerenderSearchParamsForClientPage(workStore);</span>
                <span class="s1">pageElement = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(ClientPageRoot, {</span>
                    <span class="s1">Component: PageComponent,</span>
                    <span class="s1">searchParams: query,</span>
                    <span class="s1">params: currentParams,</span>
                    <span class="s1">promises: [</span>
                        <span class="s1">promiseOfSearchParams,</span>
                        <span class="s1">promiseOfParams</span>
                    <span class="s1">]</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">pageElement = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(ClientPageRoot, {</span>
                    <span class="s1">Component: PageComponent,</span>
                    <span class="s1">searchParams: query,</span>
                    <span class="s1">params: currentParams</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// If we are passing params to a server component Page we need to track</span>
            <span class="s4">// their usage in case the current render mode tracks dynamic API usage.</span>
            <span class="s2">const </span><span class="s1">params = createServerParamsForServerSegment(currentParams, workStore);</span>
            <span class="s4">// If we are passing searchParams to a server component Page we need to</span>
            <span class="s4">// track their usage in case the current render mode tracks dynamic API</span>
            <span class="s4">// usage.</span>
            <span class="s2">let </span><span class="s1">searchParams = createServerSearchParamsForServerPage(query, workStore);</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _clientandserverreferences.isUseCacheFunction)(PageComponent)) {</span>
                <span class="s2">const </span><span class="s1">UseCachePageComponent = PageComponent;</span>
                <span class="s1">pageElement = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(UseCachePageComponent, {</span>
                    <span class="s1">params: params,</span>
                    <span class="s1">searchParams: searchParams,</span>
                    <span class="s1">$$isPageComponent: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">pageElement = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(PageComponent, {</span>
                    <span class="s1">params: params,</span>
                    <span class="s1">searchParams: searchParams</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">isDefaultSegment = segment === _segment.DEFAULT_SEGMENT_KEY;</span>
        <span class="s2">const </span><span class="s1">pageFilePath = (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, </span><span class="s0">'page'</span><span class="s1">) ?? (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, </span><span class="s0">'defaultPage'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">segmentType = isDefaultSegment ? </span><span class="s0">'default' </span><span class="s1">: </span><span class="s0">'page'</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">wrappedPageElement = isSegmentViewEnabled &amp;&amp; pageFilePath ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
            <span class="s1">type: segmentType,</span>
            <span class="s1">pagePath: pageFilePath,</span>
            <span class="s1">children: pageElement</span>
        <span class="s1">}, cacheNodeKey + </span><span class="s0">'-' </span><span class="s1">+ segmentType) : pageElement;</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">actualSegment,</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
                <span class="s1">children: [</span>
                    <span class="s1">wrappedPageElement,</span>
                    <span class="s1">layerAssets,</span>
                    <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(OutletBoundary, {</span>
                        <span class="s1">children: [</span>
                            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(MetadataOutlet, {</span>
                                <span class="s1">ready: getViewportReady</span>
                            <span class="s1">}),</span>
                            <span class="s1">metadataOutlet</span>
                        <span class="s1">]</span>
                    <span class="s1">})</span>
                <span class="s1">]</span>
            <span class="s1">}, cacheNodeKey),</span>
            <span class="s1">parallelRouteCacheNodeSeedData,</span>
            <span class="s1">loadingData,</span>
            <span class="s1">isPossiblyPartialResponse</span>
        <span class="s1">];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">SegmentComponent = Component;</span>
        <span class="s2">const </span><span class="s1">isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot = rootLayoutAtThisLevel &amp;&amp; </span><span class="s0">'children' </span><span class="s2">in </span><span class="s1">parallelRoutes &amp;&amp; Object.keys(parallelRoutes).length &gt; </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">segmentNode;</span>
        <span class="s2">if </span><span class="s1">(isClientComponent) {</span>
            <span class="s2">let </span><span class="s1">clientSegment;</span>
            <span class="s2">if </span><span class="s1">(isStaticGeneration) {</span>
                <span class="s2">const </span><span class="s1">promiseOfParams = createPrerenderParamsForClientSegment(currentParams);</span>
                <span class="s1">clientSegment = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(ClientSegmentRoot, {</span>
                    <span class="s1">Component: SegmentComponent,</span>
                    <span class="s1">slots: parallelRouteProps,</span>
                    <span class="s1">params: currentParams,</span>
                    <span class="s1">promise: promiseOfParams</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">clientSegment = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(ClientSegmentRoot, {</span>
                    <span class="s1">Component: SegmentComponent,</span>
                    <span class="s1">slots: parallelRouteProps,</span>
                    <span class="s1">params: currentParams</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {</span>
                <span class="s2">let </span><span class="s1">notfoundClientSegment;</span>
                <span class="s2">let </span><span class="s1">forbiddenClientSegment;</span>
                <span class="s2">let </span><span class="s1">unauthorizedClientSegment;</span>
                <span class="s4">// TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.</span>
                <span class="s4">// This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,</span>
                <span class="s4">// but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.</span>
                <span class="s4">// We should instead look into handling the fallback behavior differently in development mode so that it doesn't</span>
                <span class="s4">// rely on the `NotFound` behavior.</span>
                <span class="s1">notfoundClientSegment = createErrorBoundaryClientSegmentRoot({</span>
                    <span class="s1">ErrorBoundaryComponent: NotFound,</span>
                    <span class="s1">errorElement: notFoundElement,</span>
                    <span class="s1">ClientSegmentRoot,</span>
                    <span class="s1">layerAssets,</span>
                    <span class="s1">SegmentComponent,</span>
                    <span class="s1">currentParams</span>
                <span class="s1">});</span>
                <span class="s1">forbiddenClientSegment = createErrorBoundaryClientSegmentRoot({</span>
                    <span class="s1">ErrorBoundaryComponent: Forbidden,</span>
                    <span class="s1">errorElement: forbiddenElement,</span>
                    <span class="s1">ClientSegmentRoot,</span>
                    <span class="s1">layerAssets,</span>
                    <span class="s1">SegmentComponent,</span>
                    <span class="s1">currentParams</span>
                <span class="s1">});</span>
                <span class="s1">unauthorizedClientSegment = createErrorBoundaryClientSegmentRoot({</span>
                    <span class="s1">ErrorBoundaryComponent: Unauthorized,</span>
                    <span class="s1">errorElement: unauthorizedElement,</span>
                    <span class="s1">ClientSegmentRoot,</span>
                    <span class="s1">layerAssets,</span>
                    <span class="s1">SegmentComponent,</span>
                    <span class="s1">currentParams</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(notfoundClientSegment || forbiddenClientSegment || unauthorizedClientSegment) {</span>
                    <span class="s1">segmentNode = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(HTTPAccessFallbackBoundary, {</span>
                        <span class="s1">notFound: notfoundClientSegment,</span>
                        <span class="s1">forbidden: forbiddenClientSegment,</span>
                        <span class="s1">unauthorized: unauthorizedClientSegment,</span>
                        <span class="s1">children: [</span>
                            <span class="s1">layerAssets,</span>
                            <span class="s1">clientSegment</span>
                        <span class="s1">]</span>
                    <span class="s1">}, cacheNodeKey);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">segmentNode = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
                        <span class="s1">children: [</span>
                            <span class="s1">layerAssets,</span>
                            <span class="s1">clientSegment</span>
                        <span class="s1">]</span>
                    <span class="s1">}, cacheNodeKey);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">segmentNode = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
                    <span class="s1">children: [</span>
                        <span class="s1">layerAssets,</span>
                        <span class="s1">clientSegment</span>
                    <span class="s1">]</span>
                <span class="s1">}, cacheNodeKey);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">params = createServerParamsForServerSegment(currentParams, workStore);</span>
            <span class="s2">let </span><span class="s1">serverSegment;</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _clientandserverreferences.isUseCacheFunction)(SegmentComponent)) {</span>
                <span class="s2">const </span><span class="s1">UseCacheLayoutComponent = SegmentComponent;</span>
                <span class="s1">serverSegment = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(UseCacheLayoutComponent, {</span>
                    <span class="s1">...parallelRouteProps,</span>
                    <span class="s1">params: params,</span>
                    <span class="s1">$$isLayoutComponent: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">serverSegment = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentComponent, {</span>
                    <span class="s1">...parallelRouteProps,</span>
                    <span class="s1">params: params</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {</span>
                <span class="s4">// TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.</span>
                <span class="s4">// This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,</span>
                <span class="s4">// but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.</span>
                <span class="s4">// We should instead look into handling the fallback behavior differently in development mode so that it doesn't</span>
                <span class="s4">// rely on the `NotFound` behavior.</span>
                <span class="s1">segmentNode = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(HTTPAccessFallbackBoundary, {</span>
                    <span class="s1">notFound: notFoundElement ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
                        <span class="s1">children: [</span>
                            <span class="s1">layerAssets,</span>
                            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(SegmentComponent, {</span>
                                <span class="s1">params: params,</span>
                                <span class="s1">children: [</span>
                                    <span class="s1">notFoundStyles,</span>
                                    <span class="s1">notFoundElement</span>
                                <span class="s1">]</span>
                            <span class="s1">})</span>
                        <span class="s1">]</span>
                    <span class="s1">}) : undefined,</span>
                    <span class="s1">children: [</span>
                        <span class="s1">layerAssets,</span>
                        <span class="s1">serverSegment</span>
                    <span class="s1">]</span>
                <span class="s1">}, cacheNodeKey);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">segmentNode = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_react.default.Fragment, {</span>
                    <span class="s1">children: [</span>
                        <span class="s1">layerAssets,</span>
                        <span class="s1">serverSegment</span>
                    <span class="s1">]</span>
                <span class="s1">}, cacheNodeKey);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">layoutFilePath = (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, </span><span class="s0">'layout'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">wrappedSegmentNode = isSegmentViewEnabled &amp;&amp; layoutFilePath ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
            <span class="s1">type: </span><span class="s0">&quot;layout&quot;</span><span class="s1">,</span>
            <span class="s1">pagePath: layoutFilePath,</span>
            <span class="s1">children: segmentNode</span>
        <span class="s1">}, </span><span class="s0">&quot;layout&quot;</span><span class="s1">) : segmentNode;</span>
        <span class="s4">// For layouts we just render the component</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">actualSegment,</span>
            <span class="s1">wrappedSegmentNode,</span>
            <span class="s1">parallelRouteCacheNodeSeedData,</span>
            <span class="s1">loadingData,</span>
            <span class="s1">isPossiblyPartialResponse</span>
        <span class="s1">];</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">MetadataOutlet({ ready }) {</span>
    <span class="s2">const </span><span class="s1">r = ready();</span>
    <span class="s4">// We can avoid a extra microtask by unwrapping the instrumented promise directly if available.</span>
    <span class="s2">if </span><span class="s1">(r.status === </span><span class="s0">'rejected'</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">r.value;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(r.status !== </span><span class="s0">'fulfilled'</span><span class="s1">) {</span>
        <span class="s2">await </span><span class="s1">r;</span>
    <span class="s1">}</span>
    <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">MetadataOutlet.displayName = _boundaryconstants.OUTLET_BOUNDARY_NAME;</span>
<span class="s2">function </span><span class="s1">createErrorBoundaryClientSegmentRoot({ ErrorBoundaryComponent, errorElement, ClientSegmentRoot, layerAssets, SegmentComponent, currentParams }) {</span>
    <span class="s2">if </span><span class="s1">(ErrorBoundaryComponent) {</span>
        <span class="s2">const </span><span class="s1">notFoundParallelRouteProps = {</span>
            <span class="s1">children: errorElement</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
            <span class="s1">children: [</span>
                <span class="s1">layerAssets,</span>
                <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(ClientSegmentRoot, {</span>
                    <span class="s1">Component: SegmentComponent,</span>
                    <span class="s1">slots: notFoundParallelRouteProps,</span>
                    <span class="s1">params: currentParams</span>
                <span class="s1">})</span>
            <span class="s1">]</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getRootParams(loaderTree, getDynamicParamFromSegment) {</span>
    <span class="s2">return </span><span class="s1">getRootParamsImpl({}, loaderTree, getDynamicParamFromSegment);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getRootParamsImpl(parentParams, loaderTree, getDynamicParamFromSegment) {</span>
    <span class="s2">const </span><span class="s1">{ segment, modules: { layout }, parallelRoutes } = (</span><span class="s3">0</span><span class="s1">, _parseloadertree.parseLoaderTree)(loaderTree);</span>
    <span class="s2">const </span><span class="s1">segmentParam = getDynamicParamFromSegment(segment);</span>
    <span class="s2">let </span><span class="s1">currentParams = parentParams;</span>
    <span class="s2">if </span><span class="s1">(segmentParam &amp;&amp; segmentParam.value !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">currentParams = {</span>
            <span class="s1">...parentParams,</span>
            <span class="s1">[segmentParam.param]: segmentParam.value</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">isRootLayout = </span><span class="s2">typeof </span><span class="s1">layout !== </span><span class="s0">'undefined'</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(isRootLayout) {</span>
        <span class="s2">return </span><span class="s1">currentParams;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!parallelRoutes.children) {</span>
        <span class="s4">// This should really be an error but there are bugs in Turbopack that cause</span>
        <span class="s4">// the _not-found LoaderTree to not have any layouts. For rootParams sake</span>
        <span class="s4">// this is somewhat irrelevant when you are not customizing the 404 page.</span>
        <span class="s4">// If you are customizing 404</span>
        <span class="s4">// TODO update rootParams to make all params optional if `/app/not-found.tsx` is defined</span>
        <span class="s2">return </span><span class="s1">currentParams;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">getRootParamsImpl(currentParams, </span><span class="s4">// We stop looking for root params as soon as we hit the first layout</span>
        <span class="s4">// and it is not possible to use parallel route children above the root layout</span>
        <span class="s4">// so every parallelRoutes object that this function can visit will necessarily</span>
        <span class="s4">// have a single `children` prop and no others.</span>
        <span class="s1">parallelRoutes.children, getDynamicParamFromSegment);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createBoundaryConventionElement({ ctx, conventionName, Component, styles, tree }) {</span>
    <span class="s2">const </span><span class="s1">isSegmentViewEnabled = process.env.NODE_ENV === </span><span class="s0">'development' </span><span class="s1">&amp;&amp; ctx.renderOpts.devtoolSegmentExplorer;</span>
    <span class="s2">const </span><span class="s1">dir = (process.env.NEXT_RUNTIME === </span><span class="s0">'edge' </span><span class="s1">? process.env.__NEXT_EDGE_PROJECT_DIR : ctx.renderOpts.dir) || </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">{ SegmentViewNode } = ctx.componentMod;</span>
    <span class="s2">const </span><span class="s1">element = Component ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
        <span class="s1">children: [</span>
            <span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(Component, {}),</span>
            <span class="s1">styles</span>
        <span class="s1">]</span>
    <span class="s1">}) : undefined;</span>
    <span class="s2">const </span><span class="s1">pagePath = (</span><span class="s3">0</span><span class="s1">, _segmentexplorerpath.getConventionPathByType)(tree, dir, conventionName);</span>
    <span class="s2">const </span><span class="s1">wrappedElement = isSegmentViewEnabled &amp;&amp; element ? </span><span class="s4">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewNode, {</span>
        <span class="s1">type: conventionName,</span>
        <span class="s1">pagePath: pagePath,</span>
        <span class="s1">children: element</span>
    <span class="s1">}, cacheNodeKey + </span><span class="s0">'-' </span><span class="s1">+ conventionName) : element;</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">wrappedElement,</span>
        <span class="s1">pagePath</span>
    <span class="s1">];</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=create-component-tree.js.map</span></pre>
</body>
</html>