<html>
<head>
<title>lru-cache.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lru-cache.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* LRU (Least Recently Used) Cache implementation using a doubly-linked list</span>
 <span class="s0">* and hash map for O(1) operations.</span>
 <span class="s0">*</span>
 <span class="s0">* Algorithm:</span>
 <span class="s0">* - Uses a doubly-linked list to maintain access order (most recent at head)</span>
 <span class="s0">* - Hash map provides O(1) key-to-node lookup</span>
 <span class="s0">* - Sentinel head/tail nodes simplify edge case handling</span>
 <span class="s0">* - Size-based eviction supports custom size calculation functions</span>
 <span class="s0">*</span>
 <span class="s0">* Data Structure Layout:</span>
 <span class="s0">* HEAD &lt;-&gt; [most recent] &lt;-&gt; ... &lt;-&gt; [least recent] &lt;-&gt; TAIL</span>
 <span class="s0">*</span>
 <span class="s0">* Operations:</span>
 <span class="s0">* - get(): Move accessed node to head (mark as most recent)</span>
 <span class="s0">* - set(): Add new node at head, evict from tail if over capacity</span>
 <span class="s0">* - Eviction: Remove least recent node (tail.prev) when size exceeds limit</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">class </span><span class="s1">LRUCache&lt;T&gt; {</span>
    <span class="s2">private </span><span class="s1">readonly cache;</span>
    <span class="s2">private </span><span class="s1">readonly head;</span>
    <span class="s2">private </span><span class="s1">readonly tail;</span>
    <span class="s2">private </span><span class="s1">totalSize;</span>
    <span class="s2">private </span><span class="s1">readonly maxSize;</span>
    <span class="s2">private </span><span class="s1">readonly calculateSize;</span>
    <span class="s1">constructor(maxSize: number, calculateSize?: (value: T) =&gt; number);</span>
    <span class="s0">/**</span>
     <span class="s0">* Adds a node immediately after the head (marks as most recently used).</span>
     <span class="s0">* Used when inserting new items or when an item is accessed.</span>
     <span class="s0">* PRECONDITION: node must be disconnected (prev/next should be null)</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">addToHead;</span>
    <span class="s0">/**</span>
     <span class="s0">* Removes a node from its current position in the doubly-linked list.</span>
     <span class="s0">* Updates the prev/next pointers of adjacent nodes to maintain list integrity.</span>
     <span class="s0">* PRECONDITION: node must be connected (prev/next are non-null)</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">removeNode;</span>
    <span class="s0">/**</span>
     <span class="s0">* Moves an existing node to the head position (marks as most recently used).</span>
     <span class="s0">* This is the core LRU operation - accessed items become most recent.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">moveToHead;</span>
    <span class="s0">/**</span>
     <span class="s0">* Removes and returns the least recently used node (the one before tail).</span>
     <span class="s0">* This is called during eviction when the cache exceeds capacity.</span>
     <span class="s0">* PRECONDITION: cache is not empty (ensured by caller)</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">removeTail;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets a key-value pair in the cache.</span>
     <span class="s0">* If the key exists, updates the value and moves to head.</span>
     <span class="s0">* If new, adds at head and evicts from tail if necessary.</span>
     <span class="s0">*</span>
     <span class="s0">* Time Complexity:</span>
     <span class="s0">* - O(1) for uniform item sizes</span>
     <span class="s0">* - O(k) where k is the number of items evicted (can be O(N) for variable sizes)</span>
     <span class="s0">*/</span>
    <span class="s1">set(key: string, value: T): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Checks if a key exists in the cache.</span>
     <span class="s0">* This is a pure query operation - does NOT update LRU order.</span>
     <span class="s0">*</span>
     <span class="s0">* Time Complexity: O(1)</span>
     <span class="s0">*/</span>
    <span class="s1">has(key: string): boolean;</span>
    <span class="s0">/**</span>
     <span class="s0">* Retrieves a value by key and marks it as most recently used.</span>
     <span class="s0">* Moving to head maintains the LRU property for future evictions.</span>
     <span class="s0">*</span>
     <span class="s0">* Time Complexity: O(1)</span>
     <span class="s0">*/</span>
    <span class="s1">get(key: string): T | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns an iterator over the cache entries. The order is outputted in the</span>
     <span class="s0">* order of most recently used to least recently used.</span>
     <span class="s0">*/</span>
    <span class="s1">[Symbol.iterator](): IterableIterator&lt;[string, T]&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Removes a specific key from the cache.</span>
     <span class="s0">* Updates both the hash map and doubly-linked list.</span>
     <span class="s0">*</span>
     <span class="s0">* Time Complexity: O(1)</span>
     <span class="s0">*/</span>
    <span class="s1">remove(key: string): </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the number of items in the cache.</span>
     <span class="s0">*/</span>
    <span class="s1">get size(): number;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the current total size of all cached items.</span>
     <span class="s0">* This uses the custom size calculation if provided.</span>
     <span class="s0">*/</span>
    <span class="s1">get currentSize(): number;</span>
<span class="s1">}</span>
</pre>
</body>
</html>