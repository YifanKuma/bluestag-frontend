<html>
<head>
<title>metadata.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #264eff;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
.s7 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
metadata.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">compare from </span><span class="s2">'./tools/semver-compare.js'</span>
<span class="s0">import </span><span class="s1">isObject from </span><span class="s2">'./helpers/isObject.js'</span>

<span class="s3">// Added &quot;possibleLengths&quot; and renamed</span>
<span class="s3">// &quot;country_phone_code_to_countries&quot; to &quot;country_calling_codes&quot;.</span>
<span class="s0">const </span><span class="s1">V2 = </span><span class="s2">'1.0.18'</span>

<span class="s3">// Added &quot;idd_prefix&quot; and &quot;default_idd_prefix&quot;.</span>
<span class="s0">const </span><span class="s1">V3 = </span><span class="s2">'1.2.0'</span>

<span class="s3">// Moved `001` country code to &quot;nonGeographic&quot; section of metadata.</span>
<span class="s0">const </span><span class="s1">V4 = </span><span class="s2">'1.7.35'</span>

<span class="s0">const </span><span class="s1">DEFAULT_EXT_PREFIX = </span><span class="s2">' ext. '</span>

<span class="s0">const </span><span class="s1">CALLING_CODE_REG_EXP = </span><span class="s4">/^\d+$/</span>

<span class="s3">/**</span>
 <span class="s3">* See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md</span>
 <span class="s3">*/</span>
<span class="s0">export default class </span><span class="s1">Metadata {</span>
	<span class="s1">constructor(metadata) {</span>
		<span class="s1">validateMetadata(metadata)</span>
		<span class="s0">this</span><span class="s1">.metadata = metadata</span>
		<span class="s1">setVersion.call(</span><span class="s0">this</span><span class="s1">, metadata)</span>
	<span class="s1">}</span>

	<span class="s1">getCountries() {</span>
		<span class="s0">return </span><span class="s1">Object.keys(</span><span class="s0">this</span><span class="s1">.metadata.countries).filter(_ =&gt; _ !== </span><span class="s2">'001'</span><span class="s1">)</span>
	<span class="s1">}</span>

	<span class="s1">getCountryMetadata(countryCode) {</span>
		<span class="s0">return this</span><span class="s1">.metadata.countries[countryCode]</span>
	<span class="s1">}</span>

	<span class="s1">nonGeographic() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.v1 || </span><span class="s0">this</span><span class="s1">.v2 || </span><span class="s0">this</span><span class="s1">.v3) </span><span class="s0">return</span>
		<span class="s3">// `nonGeographical` was a typo.</span>
		<span class="s3">// It's present in metadata generated from `1.7.35` to `1.7.37`.</span>
		<span class="s3">// The test case could be found by searching for &quot;nonGeographical&quot;.</span>
		<span class="s0">return this</span><span class="s1">.metadata.nonGeographic || </span><span class="s0">this</span><span class="s1">.metadata.nonGeographical</span>
	<span class="s1">}</span>

	<span class="s1">hasCountry(country) {</span>
		<span class="s0">return this</span><span class="s1">.getCountryMetadata(country) !== undefined</span>
	<span class="s1">}</span>

	<span class="s1">hasCallingCode(callingCode) {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.getCountryCodesForCallingCode(callingCode)) {</span>
			<span class="s0">return true</span>
		<span class="s1">}</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.nonGeographic()) {</span>
			<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.nonGeographic()[callingCode]) {</span>
				<span class="s0">return true</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s3">// A hacky workaround for old custom metadata (generated before V4).</span>
			<span class="s0">const </span><span class="s1">countryCodes = </span><span class="s0">this</span><span class="s1">.countryCallingCodes()[callingCode]</span>
			<span class="s0">if </span><span class="s1">(countryCodes &amp;&amp; countryCodes.length === </span><span class="s5">1 </span><span class="s1">&amp;&amp; countryCodes[</span><span class="s5">0</span><span class="s1">] === </span><span class="s2">'001'</span><span class="s1">) {</span>
				<span class="s0">return true</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">isNonGeographicCallingCode(callingCode) {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.nonGeographic()) {</span>
			<span class="s0">return this</span><span class="s1">.nonGeographic()[callingCode] ? </span><span class="s0">true </span><span class="s1">: </span><span class="s0">false</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s0">return this</span><span class="s1">.getCountryCodesForCallingCode(callingCode) ? </span><span class="s0">false </span><span class="s1">: </span><span class="s0">true</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">country(countryCode) {</span>
		<span class="s0">return this</span><span class="s1">.selectNumberingPlan(countryCode)</span>
	<span class="s1">}</span>

	<span class="s1">selectNumberingPlan(countryCode, callingCode) {</span>
		<span class="s3">// Supports just passing `callingCode` as the first argument.</span>
		<span class="s0">if </span><span class="s1">(countryCode &amp;&amp; CALLING_CODE_REG_EXP.test(countryCode)) {</span>
			<span class="s1">callingCode = countryCode</span>
			<span class="s1">countryCode = </span><span class="s0">null</span>
		<span class="s1">}</span>
		<span class="s0">if </span><span class="s1">(countryCode &amp;&amp; countryCode !== </span><span class="s2">'001'</span><span class="s1">) {</span>
			<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.hasCountry(countryCode)) {</span>
				<span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Unknown country: </span><span class="s1">${countryCode}</span><span class="s2">`</span><span class="s1">)</span>
			<span class="s1">}</span>
			<span class="s0">this</span><span class="s1">.numberingPlan = </span><span class="s0">new </span><span class="s1">NumberingPlan(</span><span class="s0">this</span><span class="s1">.getCountryMetadata(countryCode), </span><span class="s0">this</span><span class="s1">)</span>
		<span class="s1">} </span><span class="s0">else if </span><span class="s1">(callingCode) {</span>
			<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.hasCallingCode(callingCode)) {</span>
				<span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Unknown calling code: </span><span class="s1">${callingCode}</span><span class="s2">`</span><span class="s1">)</span>
			<span class="s1">}</span>
			<span class="s0">this</span><span class="s1">.numberingPlan = </span><span class="s0">new </span><span class="s1">NumberingPlan(</span><span class="s0">this</span><span class="s1">.getNumberingPlanMetadata(callingCode), </span><span class="s0">this</span><span class="s1">)</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s0">this</span><span class="s1">.numberingPlan = undefined</span>
		<span class="s1">}</span>
		<span class="s0">return this</span>
	<span class="s1">}</span>

	<span class="s1">getCountryCodesForCallingCode(callingCode) {</span>
		<span class="s0">const </span><span class="s1">countryCodes = </span><span class="s0">this</span><span class="s1">.countryCallingCodes()[callingCode]</span>
		<span class="s0">if </span><span class="s1">(countryCodes) {</span>
			<span class="s3">// Metadata before V4 included &quot;non-geographic entity&quot; calling codes</span>
			<span class="s3">// inside `country_calling_codes` (for example, `&quot;881&quot;:[&quot;001&quot;]`).</span>
			<span class="s3">// Now the semantics of `country_calling_codes` has changed:</span>
			<span class="s3">// it's specifically for &quot;countries&quot; now.</span>
			<span class="s3">// Older versions of custom metadata will simply skip parsing</span>
			<span class="s3">// &quot;non-geographic entity&quot; phone numbers with new versions</span>
			<span class="s3">// of this library: it's not considered a bug,</span>
			<span class="s3">// because such numbers are extremely rare,</span>
			<span class="s3">// and developers extremely rarely use custom metadata.</span>
			<span class="s0">if </span><span class="s1">(countryCodes.length === </span><span class="s5">1 </span><span class="s1">&amp;&amp; countryCodes[</span><span class="s5">0</span><span class="s1">].length === </span><span class="s5">3</span><span class="s1">) {</span>
				<span class="s0">return</span>
			<span class="s1">}</span>
			<span class="s0">return </span><span class="s1">countryCodes</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">getCountryCodeForCallingCode(callingCode) {</span>
		<span class="s0">const </span><span class="s1">countryCodes = </span><span class="s0">this</span><span class="s1">.getCountryCodesForCallingCode(callingCode)</span>
		<span class="s0">if </span><span class="s1">(countryCodes) {</span>
			<span class="s0">return </span><span class="s1">countryCodes[</span><span class="s5">0</span><span class="s1">]</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">getNumberingPlanMetadata(callingCode) {</span>
		<span class="s0">const </span><span class="s1">countryCode = </span><span class="s0">this</span><span class="s1">.getCountryCodeForCallingCode(callingCode)</span>
		<span class="s0">if </span><span class="s1">(countryCode) {</span>
			<span class="s0">return this</span><span class="s1">.getCountryMetadata(countryCode)</span>
		<span class="s1">}</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.nonGeographic()) {</span>
			<span class="s0">const </span><span class="s1">metadata = </span><span class="s0">this</span><span class="s1">.nonGeographic()[callingCode]</span>
			<span class="s0">if </span><span class="s1">(metadata) {</span>
				<span class="s0">return </span><span class="s1">metadata</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s3">// A hacky workaround for old custom metadata (generated before V4).</span>
			<span class="s3">// In that metadata, there was no concept of &quot;non-geographic&quot; metadata</span>
			<span class="s3">// so metadata for `001` country code was stored along with other countries.</span>
			<span class="s3">// The test case can be found by searching for:</span>
			<span class="s3">// &quot;should work around `nonGeographic` metadata not existing&quot;.</span>
			<span class="s0">const </span><span class="s1">countryCodes = </span><span class="s0">this</span><span class="s1">.countryCallingCodes()[callingCode]</span>
			<span class="s0">if </span><span class="s1">(countryCodes &amp;&amp; countryCodes.length === </span><span class="s5">1 </span><span class="s1">&amp;&amp; countryCodes[</span><span class="s5">0</span><span class="s1">] === </span><span class="s2">'001'</span><span class="s1">) {</span>
				<span class="s0">return this</span><span class="s1">.metadata.countries[</span><span class="s2">'001'</span><span class="s1">]</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">countryCallingCode() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.callingCode()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">IDDPrefix() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.IDDPrefix()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">defaultIDDPrefix() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.defaultIDDPrefix()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">nationalNumberPattern() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.nationalNumberPattern()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">possibleLengths() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.possibleLengths()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">formats() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.formats()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">nationalPrefixForParsing() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.nationalPrefixForParsing()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">nationalPrefixTransformRule() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.nationalPrefixTransformRule()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">leadingDigits() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.leadingDigits()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">hasTypes() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.hasTypes()</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">type(type) {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.type(type)</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">ext() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan.ext()</span>
	<span class="s1">}</span>

	<span class="s1">countryCallingCodes() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.v1) </span><span class="s0">return this</span><span class="s1">.metadata.country_phone_code_to_countries</span>
		<span class="s0">return this</span><span class="s1">.metadata.country_calling_codes</span>
	<span class="s1">}</span>

	<span class="s3">// Deprecated.</span>
	<span class="s1">chooseCountryByCountryCallingCode(callingCode) {</span>
		<span class="s0">return this</span><span class="s1">.selectNumberingPlan(callingCode)</span>
	<span class="s1">}</span>

	<span class="s1">hasSelectedNumberingPlan() {</span>
		<span class="s0">return this</span><span class="s1">.numberingPlan !== undefined</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">class </span><span class="s1">NumberingPlan {</span>
	<span class="s1">constructor(metadata, globalMetadataObject) {</span>
		<span class="s0">this</span><span class="s1">.globalMetadataObject = globalMetadataObject</span>
		<span class="s0">this</span><span class="s1">.metadata = metadata</span>
		<span class="s1">setVersion.call(</span><span class="s0">this</span><span class="s1">, globalMetadataObject.metadata)</span>
	<span class="s1">}</span>

	<span class="s1">callingCode() {</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s5">0</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s3">// Formatting information for regions which share</span>
	<span class="s3">// a country calling code is contained by only one region</span>
	<span class="s3">// for performance reasons. For example, for NANPA region</span>
	<span class="s3">// (&quot;North American Numbering Plan Administration&quot;,</span>
	<span class="s3">//  which includes USA, Canada, Cayman Islands, Bahamas, etc)</span>
	<span class="s3">// it will be contained in the metadata for `US`.</span>
	<span class="s1">getDefaultCountryMetadataForRegion() {</span>
		<span class="s0">return this</span><span class="s1">.globalMetadataObject.getNumberingPlanMetadata(</span><span class="s0">this</span><span class="s1">.callingCode())</span>
	<span class="s1">}</span>

	<span class="s3">// Is always present.</span>
	<span class="s1">IDDPrefix() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.v1 || </span><span class="s0">this</span><span class="s1">.v2) </span><span class="s0">return</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s5">1</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s3">// Is only present when a country supports multiple IDD prefixes.</span>
	<span class="s1">defaultIDDPrefix() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.v1 || </span><span class="s0">this</span><span class="s1">.v2) </span><span class="s0">return</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s5">12</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">nationalNumberPattern() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.v1 || </span><span class="s0">this</span><span class="s1">.v2) </span><span class="s0">return this</span><span class="s1">.metadata[</span><span class="s5">1</span><span class="s1">]</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s5">2</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s3">// &quot;possible length&quot; data is always present in Google's metadata.</span>
	<span class="s1">possibleLengths() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.v1) </span><span class="s0">return</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">2 </span><span class="s1">: </span><span class="s5">3</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">_getFormats(metadata) {</span>
		<span class="s0">return </span><span class="s1">metadata[</span><span class="s0">this</span><span class="s1">.v1 ? </span><span class="s5">2 </span><span class="s1">: </span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">3 </span><span class="s1">: </span><span class="s5">4</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s3">// For countries of the same region (e.g. NANPA)</span>
	<span class="s3">// formats are all stored in the &quot;main&quot; country for that region.</span>
	<span class="s3">// E.g. &quot;RU&quot; and &quot;KZ&quot;, &quot;US&quot; and &quot;CA&quot;.</span>
	<span class="s1">formats() {</span>
		<span class="s0">const </span><span class="s1">formats = </span><span class="s0">this</span><span class="s1">._getFormats(</span><span class="s0">this</span><span class="s1">.metadata) || </span><span class="s0">this</span><span class="s1">._getFormats(</span><span class="s0">this</span><span class="s1">.getDefaultCountryMetadataForRegion()) || []</span>
		<span class="s0">return </span><span class="s1">formats.map(_ =&gt; </span><span class="s0">new </span><span class="s1">Format(_, </span><span class="s0">this</span><span class="s1">))</span>
	<span class="s1">}</span>

	<span class="s1">nationalPrefix() {</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s0">this</span><span class="s1">.v1 ? </span><span class="s5">3 </span><span class="s1">: </span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">4 </span><span class="s1">: </span><span class="s5">5</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">_getNationalPrefixFormattingRule(metadata) {</span>
		<span class="s0">return </span><span class="s1">metadata[</span><span class="s0">this</span><span class="s1">.v1 ? </span><span class="s5">4 </span><span class="s1">: </span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">5 </span><span class="s1">: </span><span class="s5">6</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s3">// For countries of the same region (e.g. NANPA)</span>
	<span class="s3">// national prefix formatting rule is stored in the &quot;main&quot; country for that region.</span>
	<span class="s3">// E.g. &quot;RU&quot; and &quot;KZ&quot;, &quot;US&quot; and &quot;CA&quot;.</span>
	<span class="s1">nationalPrefixFormattingRule() {</span>
		<span class="s0">return this</span><span class="s1">._getNationalPrefixFormattingRule(</span><span class="s0">this</span><span class="s1">.metadata) || </span><span class="s0">this</span><span class="s1">._getNationalPrefixFormattingRule(</span><span class="s0">this</span><span class="s1">.getDefaultCountryMetadataForRegion())</span>
	<span class="s1">}</span>

	<span class="s1">_nationalPrefixForParsing() {</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s0">this</span><span class="s1">.v1 ? </span><span class="s5">5 </span><span class="s1">: </span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">6 </span><span class="s1">: </span><span class="s5">7</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">nationalPrefixForParsing() {</span>
		<span class="s3">// If `national_prefix_for_parsing` is not set explicitly,</span>
		<span class="s3">// then infer it from `national_prefix` (if any)</span>
		<span class="s0">return this</span><span class="s1">._nationalPrefixForParsing() || </span><span class="s0">this</span><span class="s1">.nationalPrefix()</span>
	<span class="s1">}</span>

	<span class="s1">nationalPrefixTransformRule() {</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s0">this</span><span class="s1">.v1 ? </span><span class="s5">6 </span><span class="s1">: </span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">7 </span><span class="s1">: </span><span class="s5">8</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">_getNationalPrefixIsOptionalWhenFormatting() {</span>
		<span class="s0">return </span><span class="s1">!!</span><span class="s0">this</span><span class="s1">.metadata[</span><span class="s0">this</span><span class="s1">.v1 ? </span><span class="s5">7 </span><span class="s1">: </span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">8 </span><span class="s1">: </span><span class="s5">9</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s3">// For countries of the same region (e.g. NANPA)</span>
	<span class="s3">// &quot;national prefix is optional when formatting&quot; flag is</span>
	<span class="s3">// stored in the &quot;main&quot; country for that region.</span>
	<span class="s3">// E.g. &quot;RU&quot; and &quot;KZ&quot;, &quot;US&quot; and &quot;CA&quot;.</span>
	<span class="s1">nationalPrefixIsOptionalWhenFormattingInNationalFormat() {</span>
		<span class="s0">return this</span><span class="s1">._getNationalPrefixIsOptionalWhenFormatting(</span><span class="s0">this</span><span class="s1">.metadata) ||</span>
			<span class="s0">this</span><span class="s1">._getNationalPrefixIsOptionalWhenFormatting(</span><span class="s0">this</span><span class="s1">.getDefaultCountryMetadataForRegion())</span>
	<span class="s1">}</span>

	<span class="s1">leadingDigits() {</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s0">this</span><span class="s1">.v1 ? </span><span class="s5">8 </span><span class="s1">: </span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">9 </span><span class="s1">: </span><span class="s5">10</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">types() {</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s0">this</span><span class="s1">.v1 ? </span><span class="s5">9 </span><span class="s1">: </span><span class="s0">this</span><span class="s1">.v2 ? </span><span class="s5">10 </span><span class="s1">: </span><span class="s5">11</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">hasTypes() {</span>
		<span class="s3">// Versions 1.2.0 - 1.2.4: can be `[]`.</span>
		<span class="s3">/* istanbul ignore next */</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.types() &amp;&amp; </span><span class="s0">this</span><span class="s1">.types().length === </span><span class="s5">0</span><span class="s1">) {</span>
			<span class="s0">return false</span>
		<span class="s1">}</span>
		<span class="s3">// Versions &lt;= 1.2.4: can be `undefined`.</span>
		<span class="s3">// Version &gt;= 1.2.5: can be `0`.</span>
		<span class="s0">return </span><span class="s1">!!</span><span class="s0">this</span><span class="s1">.types()</span>
	<span class="s1">}</span>

	<span class="s1">type(type) {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hasTypes() &amp;&amp; getType(</span><span class="s0">this</span><span class="s1">.types(), type)) {</span>
			<span class="s0">return new </span><span class="s1">Type(getType(</span><span class="s0">this</span><span class="s1">.types(), type), </span><span class="s0">this</span><span class="s1">)</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">ext() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.v1 || </span><span class="s0">this</span><span class="s1">.v2) </span><span class="s0">return </span><span class="s1">DEFAULT_EXT_PREFIX</span>
		<span class="s0">return this</span><span class="s1">.metadata[</span><span class="s5">13</span><span class="s1">] || DEFAULT_EXT_PREFIX</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">class </span><span class="s1">Format {</span>
	<span class="s1">constructor(format, metadata) {</span>
		<span class="s0">this</span><span class="s1">._format = format</span>
		<span class="s0">this</span><span class="s1">.metadata = metadata</span>
	<span class="s1">}</span>

	<span class="s1">pattern() {</span>
		<span class="s0">return this</span><span class="s1">._format[</span><span class="s5">0</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">format() {</span>
		<span class="s0">return this</span><span class="s1">._format[</span><span class="s5">1</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">leadingDigitsPatterns() {</span>
		<span class="s0">return this</span><span class="s1">._format[</span><span class="s5">2</span><span class="s1">] || []</span>
	<span class="s1">}</span>

	<span class="s1">nationalPrefixFormattingRule() {</span>
		<span class="s0">return this</span><span class="s1">._format[</span><span class="s5">3</span><span class="s1">] || </span><span class="s0">this</span><span class="s1">.metadata.nationalPrefixFormattingRule()</span>
	<span class="s1">}</span>

	<span class="s1">nationalPrefixIsOptionalWhenFormattingInNationalFormat() {</span>
		<span class="s0">return </span><span class="s1">!!</span><span class="s0">this</span><span class="s1">._format[</span><span class="s5">4</span><span class="s1">] || </span><span class="s0">this</span><span class="s1">.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat()</span>
	<span class="s1">}</span>

	<span class="s1">nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {</span>
		<span class="s3">// National prefix is omitted if there's no national prefix formatting rule</span>
		<span class="s3">// set for this country, or when the national prefix formatting rule</span>
		<span class="s3">// contains no national prefix itself, or when this rule is set but</span>
		<span class="s3">// national prefix is optional for this phone number format</span>
		<span class="s3">// (and it is not enforced explicitly)</span>
		<span class="s0">return this</span><span class="s1">.usesNationalPrefix() &amp;&amp; !</span><span class="s0">this</span><span class="s1">.nationalPrefixIsOptionalWhenFormattingInNationalFormat()</span>
	<span class="s1">}</span>

	<span class="s3">// Checks whether national prefix formatting rule contains national prefix.</span>
	<span class="s1">usesNationalPrefix() {</span>
		<span class="s0">return this</span><span class="s1">.nationalPrefixFormattingRule() &amp;&amp;</span>
			<span class="s3">// Check that national prefix formatting rule is not a &quot;dummy&quot; one.</span>
			<span class="s1">!FIRST_GROUP_ONLY_PREFIX_PATTERN.test(</span><span class="s0">this</span><span class="s1">.nationalPrefixFormattingRule())</span>
			<span class="s3">// In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`</span>
			<span class="s3">// when `national_prefix_formatting_rule` is not present.</span>
			<span class="s3">// So, `true` or `false` are returned explicitly here, so that</span>
			<span class="s3">// `0` number isn't returned.</span>
			<span class="s1">? </span><span class="s0">true</span>
			<span class="s1">: </span><span class="s0">false</span>
	<span class="s1">}</span>

	<span class="s1">internationalFormat() {</span>
		<span class="s0">return this</span><span class="s1">._format[</span><span class="s5">5</span><span class="s1">] || </span><span class="s0">this</span><span class="s1">.format()</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* A pattern that is used to determine if the national prefix formatting rule</span>
 <span class="s3">* has the first group only, i.e., does not start with the national prefix.</span>
 <span class="s3">* Note that the pattern explicitly allows for unbalanced parentheses.</span>
 <span class="s3">*/</span>
<span class="s0">const </span><span class="s1">FIRST_GROUP_ONLY_PREFIX_PATTERN = </span><span class="s4">/^\(?\$1\)?$/</span>

<span class="s0">class </span><span class="s1">Type {</span>
	<span class="s1">constructor(type, metadata) {</span>
		<span class="s0">this</span><span class="s1">.type = type</span>
		<span class="s0">this</span><span class="s1">.metadata = metadata</span>
	<span class="s1">}</span>

	<span class="s1">pattern() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.metadata.v1) </span><span class="s0">return this</span><span class="s1">.type</span>
		<span class="s0">return this</span><span class="s1">.type[</span><span class="s5">0</span><span class="s1">]</span>
	<span class="s1">}</span>

	<span class="s1">possibleLengths() {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.metadata.v1) </span><span class="s0">return</span>
		<span class="s0">return this</span><span class="s1">.type[</span><span class="s5">1</span><span class="s1">] || </span><span class="s0">this</span><span class="s1">.metadata.possibleLengths()</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getType(types, type) {</span>
	<span class="s0">switch </span><span class="s1">(type) {</span>
		<span class="s0">case </span><span class="s2">'FIXED_LINE'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">0</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'MOBILE'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">1</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'TOLL_FREE'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">2</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'PREMIUM_RATE'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">3</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'PERSONAL_NUMBER'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">4</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'VOICEMAIL'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">5</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'UAN'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">6</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'PAGER'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">7</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'VOIP'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">8</span><span class="s1">]</span>
		<span class="s0">case </span><span class="s2">'SHARED_COST'</span><span class="s1">:</span>
			<span class="s0">return </span><span class="s1">types[</span><span class="s5">9</span><span class="s1">]</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">export function </span><span class="s1">validateMetadata(metadata) {</span>
	<span class="s0">if </span><span class="s1">(!metadata) {</span>
		<span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'[libphonenumber-js] `metadata` argument not passed. Check your arguments.'</span><span class="s1">)</span>
	<span class="s1">}</span>

	<span class="s3">// `country_phone_code_to_countries` was renamed to `country_calling_codes` in `1.0.18`.</span>
	<span class="s3">// For that reason, it's not used in this detection algorithm.</span>
	<span class="s3">// Instead, it detects by `countries: {}` property existence.</span>
	<span class="s0">if </span><span class="s1">(!isObject(metadata) || !isObject(metadata.countries)) {</span>
		<span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`[libphonenumber-js] </span><span class="s6">\`</span><span class="s2">metadata</span><span class="s6">\` </span><span class="s2">argument was passed but it's not a valid metadata. Must be an object having </span><span class="s6">\`</span><span class="s2">.countries</span><span class="s6">\` </span><span class="s2">child object property. Got </span><span class="s1">${isObject(metadata) ? </span><span class="s2">'an object of shape: { ' </span><span class="s1">+ Object.keys(metadata).join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">' }' </span><span class="s1">: </span><span class="s2">'a ' </span><span class="s1">+ typeOf(metadata) + </span><span class="s2">': ' </span><span class="s1">+ metadata}</span><span class="s2">.`</span><span class="s1">)</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">// Babel transforms `typeof` into some &quot;branches&quot;</span>
<span class="s3">// so istanbul will show this as &quot;branch not covered&quot;.</span>
<span class="s3">/* istanbul ignore next */</span>
<span class="s0">const </span><span class="s1">typeOf = _ =&gt; </span><span class="s0">typeof </span><span class="s1">_</span>

<span class="s3">/**</span>
 <span class="s3">* Returns extension prefix for a country.</span>
 <span class="s3">* </span><span class="s7">@param  </span><span class="s3">{string} country</span>
 <span class="s3">* </span><span class="s7">@param  </span><span class="s3">{object} metadata</span>
 <span class="s3">* </span><span class="s7">@return </span><span class="s3">{string?}</span>
 <span class="s3">* </span><span class="s7">@example</span>
 <span class="s3">* // Returns &quot; ext. &quot;</span>
 <span class="s3">* getExtPrefix(&quot;US&quot;)</span>
 <span class="s3">*/</span>
<span class="s0">export function </span><span class="s1">getExtPrefix(country, metadata) {</span>
	<span class="s1">metadata = </span><span class="s0">new </span><span class="s1">Metadata(metadata)</span>
	<span class="s0">if </span><span class="s1">(metadata.hasCountry(country)) {</span>
		<span class="s0">return </span><span class="s1">metadata.selectNumberingPlan(country).ext()</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">DEFAULT_EXT_PREFIX</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Returns &quot;country calling code&quot; for a country.</span>
 <span class="s3">* Throws an error if the country doesn't exist or isn't supported by this library.</span>
 <span class="s3">* </span><span class="s7">@param  </span><span class="s3">{string} country</span>
 <span class="s3">* </span><span class="s7">@param  </span><span class="s3">{object} metadata</span>
 <span class="s3">* </span><span class="s7">@return </span><span class="s3">{string}</span>
 <span class="s3">* </span><span class="s7">@example</span>
 <span class="s3">* // Returns &quot;44&quot;</span>
 <span class="s3">* getCountryCallingCode(&quot;GB&quot;)</span>
 <span class="s3">*/</span>
<span class="s0">export function </span><span class="s1">getCountryCallingCode(country, metadata) {</span>
	<span class="s1">metadata = </span><span class="s0">new </span><span class="s1">Metadata(metadata)</span>
	<span class="s0">if </span><span class="s1">(metadata.hasCountry(country)) {</span>
		<span class="s0">return </span><span class="s1">metadata.selectNumberingPlan(country).countryCallingCode()</span>
	<span class="s1">}</span>
	<span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Unknown country: </span><span class="s1">${country}</span><span class="s2">`</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">export function </span><span class="s1">isSupportedCountry(country, metadata) {</span>
	<span class="s3">// metadata = new Metadata(metadata)</span>
	<span class="s3">// return metadata.hasCountry(country)</span>
	<span class="s0">return </span><span class="s1">metadata.countries.hasOwnProperty(country)</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">setVersion(metadata) {</span>
	<span class="s0">const </span><span class="s1">{ version } = metadata</span>
	<span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">version === </span><span class="s2">'number'</span><span class="s1">) {</span>
		<span class="s0">this</span><span class="s1">.v1 = version === </span><span class="s5">1</span>
		<span class="s0">this</span><span class="s1">.v2 = version === </span><span class="s5">2</span>
		<span class="s0">this</span><span class="s1">.v3 = version === </span><span class="s5">3</span>
		<span class="s0">this</span><span class="s1">.v4 = version === </span><span class="s5">4</span>
	<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
		<span class="s0">if </span><span class="s1">(!version) {</span>
			<span class="s0">this</span><span class="s1">.v1 = </span><span class="s0">true</span>
		<span class="s1">} </span><span class="s0">else if </span><span class="s1">(compare(version, V3) === -</span><span class="s5">1</span><span class="s1">) {</span>
			<span class="s0">this</span><span class="s1">.v2 = </span><span class="s0">true</span>
		<span class="s1">} </span><span class="s0">else if </span><span class="s1">(compare(version, V4) === -</span><span class="s5">1</span><span class="s1">) {</span>
			<span class="s0">this</span><span class="s1">.v3 = </span><span class="s0">true</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s0">this</span><span class="s1">.v4 = </span><span class="s0">true</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">// const ISO_COUNTRY_CODE = /^[A-Z]{2}$/</span>
<span class="s3">// function isCountryCode(countryCode) {</span>
<span class="s3">//  return ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)</span>
<span class="s3">// }</span></pre>
</body>
</html>