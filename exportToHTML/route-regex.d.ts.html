<html>
<head>
<title>route-regex.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
route-regex.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">export interface </span><span class="s1">Group {</span>
    <span class="s1">pos: number;</span>
    <span class="s1">repeat: boolean;</span>
    <span class="s1">optional: boolean;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">RouteRegex {</span>
    <span class="s1">groups: {</span>
        <span class="s1">[groupName: string]: Group;</span>
    <span class="s1">};</span>
    <span class="s1">re: RegExp;</span>
<span class="s1">}</span>
<span class="s1">type GetNamedRouteRegexOptions = {</span>
    <span class="s2">/**</span>
     <span class="s2">* Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX</span>
     <span class="s2">* or NEXT_QUERY_PARAM_PREFIX. This is only relevant when creating the</span>
     <span class="s2">* routes-manifest during the build.</span>
     <span class="s2">*/</span>
    <span class="s1">prefixRouteKeys: boolean;</span>
    <span class="s2">/**</span>
     <span class="s2">* Whether to include the suffix in the route regex. This means that when you</span>
     <span class="s2">* have something like `/[...slug].json` the `.json` part will be included</span>
     <span class="s2">* in the regex, yielding `/(.*).json` as the regex.</span>
     <span class="s2">*/</span>
    <span class="s1">includeSuffix?: boolean;</span>
    <span class="s2">/**</span>
     <span class="s2">* Whether to include the prefix in the route regex. This means that when you</span>
     <span class="s2">* have something like `/[...slug].json` the `/` part will be included</span>
     <span class="s2">* in the regex, yielding `^/(.*).json$` as the regex.</span>
     <span class="s2">*</span>
     <span class="s2">* Note that interception markers will already be included without the need</span>
     <span class="s2">*/</span>
    <span class="s1">includePrefix?: boolean;</span>
    <span class="s2">/**</span>
     <span class="s2">* Whether to exclude the optional trailing slash from the route regex.</span>
     <span class="s2">*/</span>
    <span class="s1">excludeOptionalTrailingSlash?: boolean;</span>
    <span class="s2">/**</span>
     <span class="s2">* Whether to backtrack duplicate keys. This is only relevant when creating</span>
     <span class="s2">* the routes-manifest during the build.</span>
     <span class="s2">*/</span>
    <span class="s1">backreferenceDuplicateKeys?: boolean;</span>
<span class="s1">};</span>
<span class="s1">type GetRouteRegexOptions = {</span>
    <span class="s2">/**</span>
     <span class="s2">* Whether to include extra parts in the route regex. This means that when you</span>
     <span class="s2">* have something like `/[...slug].json` the `.json` part will be included</span>
     <span class="s2">* in the regex, yielding `/(.*).json` as the regex.</span>
     <span class="s2">*/</span>
    <span class="s1">includeSuffix?: boolean;</span>
    <span class="s2">/**</span>
     <span class="s2">* Whether to include the prefix in the route regex. This means that when you</span>
     <span class="s2">* have something like `/[...slug].json` the `/` part will be included</span>
     <span class="s2">* in the regex, yielding `^/(.*).json$` as the regex.</span>
     <span class="s2">*</span>
     <span class="s2">* Note that interception markers will already be included without the need</span>
     <span class="s2">* of adding this option.</span>
     <span class="s2">*/</span>
    <span class="s1">includePrefix?: boolean;</span>
    <span class="s2">/**</span>
     <span class="s2">* Whether to exclude the optional trailing slash from the route regex.</span>
     <span class="s2">*/</span>
    <span class="s1">excludeOptionalTrailingSlash?: boolean;</span>
<span class="s1">};</span>
<span class="s2">/**</span>
 <span class="s2">* From a normalized route this function generates a regular expression and</span>
 <span class="s2">* a corresponding groups object intended to be used to store matching groups</span>
 <span class="s2">* from the regular expression.</span>
 <span class="s2">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getRouteRegex(normalizedRoute: string, { includeSuffix, includePrefix, excludeOptionalTrailingSlash, }?: GetRouteRegexOptions): RouteRegex;</span>
<span class="s2">/**</span>
 <span class="s2">* This function extends `getRouteRegex` generating also a named regexp where</span>
 <span class="s2">* each group is named along with a routeKeys object that indexes the assigned</span>
 <span class="s2">* named group with its corresponding key. When the routeKeys need to be</span>
 <span class="s2">* prefixed to uniquely identify internally the &quot;prefixRouteKey&quot; arg should</span>
 <span class="s2">* be &quot;true&quot; currently this is only the case when creating the routes-manifest</span>
 <span class="s2">* during the build</span>
 <span class="s2">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getNamedRouteRegex(normalizedRoute: string, options: GetNamedRouteRegexOptions): {</span>
    <span class="s1">namedRegex: string;</span>
    <span class="s1">routeKeys: {</span>
        <span class="s1">[named: string]: string;</span>
    <span class="s1">};</span>
    <span class="s1">groups: {</span>
        <span class="s1">[groupName: string]: Group;</span>
    <span class="s1">};</span>
    <span class="s1">re: RegExp;</span>
<span class="s1">};</span>
<span class="s2">/**</span>
 <span class="s2">* Generates a named regexp.</span>
 <span class="s2">* This is intended to be using for build time only.</span>
 <span class="s2">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getNamedMiddlewareRegex(normalizedRoute: string, options: {</span>
    <span class="s1">catchAll?: boolean;</span>
<span class="s1">}): {</span>
    <span class="s1">namedRegex: string;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">{};</span>
</pre>
</body>
</html>