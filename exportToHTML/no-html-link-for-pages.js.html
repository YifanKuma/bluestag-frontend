<html>
<head>
<title>no-html-link-for-pages.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-html-link-for-pages.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">_definerule = require(</span><span class="s0">&quot;../utils/define-rule&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_path = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_fs = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_getrootdirs = require(</span><span class="s0">&quot;../utils/get-root-dirs&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_url = require(</span><span class="s0">&quot;../utils/url&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_array_like_to_array(arr, len) {</span>
    <span class="s2">if </span><span class="s1">(len == </span><span class="s2">null </span><span class="s1">|| len &gt; arr.length) len = arr.length;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, arr2 = </span><span class="s2">new </span><span class="s1">Array(len); i &lt; len; i++)arr2[i] = arr[i];</span>
    <span class="s2">return </span><span class="s1">arr2;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_array_with_holes(arr) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(arr)) </span><span class="s2">return </span><span class="s1">arr;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_array_without_holes(arr) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(arr)) </span><span class="s2">return </span><span class="s1">_array_like_to_array(arr);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_iterable_to_array(iter) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Symbol !== </span><span class="s0">&quot;undefined&quot; </span><span class="s1">&amp;&amp; iter[Symbol.iterator] != </span><span class="s2">null </span><span class="s1">|| iter[</span><span class="s0">&quot;@@iterator&quot;</span><span class="s1">] != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">Array.from(iter);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_iterable_to_array_limit(arr, i) {</span>
    <span class="s2">var </span><span class="s1">_i = arr == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">typeof </span><span class="s1">Symbol !== </span><span class="s0">&quot;undefined&quot; </span><span class="s1">&amp;&amp; arr[Symbol.iterator] || arr[</span><span class="s0">&quot;@@iterator&quot;</span><span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(_i == </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">_arr = [];</span>
    <span class="s2">var </span><span class="s1">_n = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">_d = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">_s, _e;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">for</span><span class="s1">(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = </span><span class="s2">true</span><span class="s1">){</span>
            <span class="s1">_arr.push(_s.value);</span>
            <span class="s2">if </span><span class="s1">(i &amp;&amp; _arr.length === i) </span><span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s1">_d = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">_e = err;</span>
    <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!_n &amp;&amp; _i[</span><span class="s0">&quot;return&quot;</span><span class="s1">] != </span><span class="s2">null</span><span class="s1">) _i[</span><span class="s0">&quot;return&quot;</span><span class="s1">]();</span>
        <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(_d) </span><span class="s2">throw </span><span class="s1">_e;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_arr;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_non_iterable_rest() {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Invalid attempt to destructure non-iterable instance.</span><span class="s5">\\</span><span class="s0">nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_non_iterable_spread() {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Invalid attempt to spread non-iterable instance.</span><span class="s5">\\</span><span class="s0">nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_sliced_to_array(arr, i) {</span>
    <span class="s2">return </span><span class="s1">_array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_to_consumable_array(arr) {</span>
    <span class="s2">return </span><span class="s1">_array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_unsupported_iterable_to_array(o, minLen) {</span>
    <span class="s2">if </span><span class="s1">(!o) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">o === </span><span class="s0">&quot;string&quot;</span><span class="s1">) </span><span class="s2">return </span><span class="s1">_array_like_to_array(o, minLen);</span>
    <span class="s2">var </span><span class="s1">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(n === </span><span class="s0">&quot;Object&quot; </span><span class="s1">&amp;&amp; o.constructor) n = o.constructor.name;</span>
    <span class="s2">if </span><span class="s1">(n === </span><span class="s0">&quot;Map&quot; </span><span class="s1">|| n === </span><span class="s0">&quot;Set&quot;</span><span class="s1">) </span><span class="s2">return </span><span class="s1">Array.from(n);</span>
    <span class="s2">if </span><span class="s1">(n === </span><span class="s0">&quot;Arguments&quot; </span><span class="s1">|| </span><span class="s6">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span><span class="s1">.test(n)) </span><span class="s2">return </span><span class="s1">_array_like_to_array(o, minLen);</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">pagesDirWarning = (</span><span class="s4">0</span><span class="s1">, _url.execOnce)(</span><span class="s2">function</span><span class="s1">(pagesDirs) {</span>
    <span class="s1">console.warn(</span><span class="s0">&quot;Pages directory cannot be found at &quot;</span><span class="s1">.concat(pagesDirs.join(</span><span class="s0">' or '</span><span class="s1">), </span><span class="s0">&quot;. &quot;</span><span class="s1">) + </span><span class="s0">'If using a custom path, please configure with the `no-html-link-for-pages` rule in your eslint config file.'</span><span class="s1">);</span>
<span class="s1">});</span>
<span class="s3">// Cache for fs.existsSync lookup.</span>
<span class="s3">// Prevent multiple blocking IO requests that have already been calculated.</span>
<span class="s2">var </span><span class="s1">fsExistsSyncCache = {};</span>
<span class="s2">var </span><span class="s1">memoize = </span><span class="s2">function</span><span class="s1">(fn) {</span>
    <span class="s2">var </span><span class="s1">cache = {};</span>
    <span class="s2">return function</span><span class="s1">() {</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">_len = arguments.length, args = </span><span class="s2">new </span><span class="s1">Array(_len), _key = </span><span class="s4">0</span><span class="s1">; _key &lt; _len; _key++){</span>
            <span class="s1">args[_key] = arguments[_key];</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">key = JSON.stringify(args);</span>
        <span class="s2">if </span><span class="s1">(cache[key] === undefined) {</span>
            <span class="s1">cache[key] = fn.apply(</span><span class="s2">void </span><span class="s4">0</span><span class="s1">, _to_consumable_array(args));</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">cache[key];</span>
    <span class="s1">};</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">cachedGetUrlFromPagesDirectories = memoize(_url.getUrlFromPagesDirectories);</span>
<span class="s2">var </span><span class="s1">cachedGetUrlFromAppDirectory = memoize(_url.getUrlFromAppDirectory);</span>
<span class="s2">var </span><span class="s1">url = </span><span class="s0">'https://nextjs.org/docs/messages/no-html-link-for-pages'</span><span class="s1">;</span>
<span class="s1">module.exports = (</span><span class="s4">0</span><span class="s1">, _definerule.defineRule)({</span>
    <span class="s1">meta: {</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Prevent usage of `&lt;a&gt;` elements to navigate to internal Next.js pages.'</span><span class="s1">,</span>
            <span class="s1">category: </span><span class="s0">'HTML'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">url: url</span>
        <span class="s1">},</span>
        <span class="s1">type: </span><span class="s0">'problem'</span><span class="s1">,</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">oneOf: [</span>
                    <span class="s1">{</span>
                        <span class="s1">type: </span><span class="s0">'string'</span>
                    <span class="s1">},</span>
                    <span class="s1">{</span>
                        <span class="s1">type: </span><span class="s0">'array'</span><span class="s1">,</span>
                        <span class="s1">uniqueItems: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">items: {</span>
                            <span class="s1">type: </span><span class="s0">'string'</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">]</span>
            <span class="s1">}</span>
        <span class="s1">]</span>
    <span class="s1">},</span>
    <span class="s3">/**</span>
   <span class="s3">* Creates an ESLint rule listener.</span>
   <span class="s3">*/ </span><span class="s1">create: </span><span class="s2">function </span><span class="s1">create(context) {</span>
        <span class="s2">var </span><span class="s1">ruleOptions = context.options;</span>
        <span class="s2">var </span><span class="s1">_ruleOptions = _sliced_to_array(ruleOptions, </span><span class="s4">1</span><span class="s1">), customPagesDirectory = _ruleOptions[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s2">var </span><span class="s1">rootDirs = (</span><span class="s4">0</span><span class="s1">, _getrootdirs.getRootDirs)(context);</span>
        <span class="s2">var </span><span class="s1">pagesDirs = (customPagesDirectory ? [</span>
            <span class="s1">customPagesDirectory</span>
        <span class="s1">] : rootDirs.map(</span><span class="s2">function</span><span class="s1">(dir) {</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">_path.join(dir, </span><span class="s0">'pages'</span><span class="s1">),</span>
                <span class="s1">_path.join(dir, </span><span class="s0">'src'</span><span class="s1">, </span><span class="s0">'pages'</span><span class="s1">)</span>
            <span class="s1">];</span>
        <span class="s1">})).flat();</span>
        <span class="s2">var </span><span class="s1">foundPagesDirs = pagesDirs.filter(</span><span class="s2">function</span><span class="s1">(dir) {</span>
            <span class="s2">if </span><span class="s1">(fsExistsSyncCache[dir] === undefined) {</span>
                <span class="s1">fsExistsSyncCache[dir] = _fs.existsSync(dir);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">fsExistsSyncCache[dir];</span>
        <span class="s1">});</span>
        <span class="s2">var </span><span class="s1">appDirs = rootDirs.map(</span><span class="s2">function</span><span class="s1">(dir) {</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">_path.join(dir, </span><span class="s0">'app'</span><span class="s1">),</span>
                <span class="s1">_path.join(dir, </span><span class="s0">'src'</span><span class="s1">, </span><span class="s0">'app'</span><span class="s1">)</span>
            <span class="s1">];</span>
        <span class="s1">}).flat();</span>
        <span class="s2">var </span><span class="s1">foundAppDirs = appDirs.filter(</span><span class="s2">function</span><span class="s1">(dir) {</span>
            <span class="s2">if </span><span class="s1">(fsExistsSyncCache[dir] === undefined) {</span>
                <span class="s1">fsExistsSyncCache[dir] = _fs.existsSync(dir);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">fsExistsSyncCache[dir];</span>
        <span class="s1">});</span>
        <span class="s3">// warn if there are no pages and app directories</span>
        <span class="s2">if </span><span class="s1">(foundPagesDirs.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; foundAppDirs.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">pagesDirWarning(pagesDirs);</span>
            <span class="s2">return </span><span class="s1">{};</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">pageUrls = cachedGetUrlFromPagesDirectories(</span><span class="s0">'/'</span><span class="s1">, foundPagesDirs);</span>
        <span class="s2">var </span><span class="s1">appDirUrls = cachedGetUrlFromAppDirectory(</span><span class="s0">'/'</span><span class="s1">, foundAppDirs);</span>
        <span class="s2">var </span><span class="s1">allUrlRegex = _to_consumable_array(pageUrls).concat(_to_consumable_array(appDirUrls));</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">JSXOpeningElement: </span><span class="s2">function </span><span class="s1">JSXOpeningElement(node) {</span>
                <span class="s2">if </span><span class="s1">(node.name.name !== </span><span class="s0">'a'</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.attributes.length === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">var </span><span class="s1">target = node.attributes.find(</span><span class="s2">function</span><span class="s1">(attr) {</span>
                    <span class="s2">return </span><span class="s1">attr.type === </span><span class="s0">'JSXAttribute' </span><span class="s1">&amp;&amp; attr.name.name === </span><span class="s0">'target'</span><span class="s1">;</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(target &amp;&amp; target.value.value === </span><span class="s0">'_blank'</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">var </span><span class="s1">href = node.attributes.find(</span><span class="s2">function</span><span class="s1">(attr) {</span>
                    <span class="s2">return </span><span class="s1">attr.type === </span><span class="s0">'JSXAttribute' </span><span class="s1">&amp;&amp; attr.name.name === </span><span class="s0">'href'</span><span class="s1">;</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(!href || href.value &amp;&amp; href.value.type !== </span><span class="s0">'Literal'</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">var </span><span class="s1">hasDownloadAttr = node.attributes.find(</span><span class="s2">function</span><span class="s1">(attr) {</span>
                    <span class="s2">return </span><span class="s1">attr.type === </span><span class="s0">'JSXAttribute' </span><span class="s1">&amp;&amp; attr.name.name === </span><span class="s0">'download'</span><span class="s1">;</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(hasDownloadAttr) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">var </span><span class="s1">hrefPath = (</span><span class="s4">0</span><span class="s1">, _url.normalizeURL)(href.value.value);</span>
                <span class="s3">// Outgoing links are ignored</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s6">/^(https?:\/\/|\/\/)/</span><span class="s1">.test(hrefPath)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">allUrlRegex.forEach(</span><span class="s2">function</span><span class="s1">(foundUrl) {</span>
                    <span class="s2">if </span><span class="s1">(foundUrl.test((</span><span class="s4">0</span><span class="s1">, _url.normalizeURL)(hrefPath))) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: node,</span>
                            <span class="s1">message: </span><span class="s0">&quot;Do not use an `&lt;a&gt;` element to navigate to `&quot;</span><span class="s1">.concat(hrefPath, </span><span class="s0">&quot;`. Use `&lt;Link /&gt;` from `next/link` instead. See: &quot;</span><span class="s1">).concat(url)</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">});</span>
</pre>
</body>
</html>