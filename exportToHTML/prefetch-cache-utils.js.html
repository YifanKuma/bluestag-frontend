<html>
<head>
<title>prefetch-cache-utils.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prefetch-cache-utils.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">DYNAMIC_STALETIME_MS: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">STATIC_STALETIME_MS: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createSeededPrefetchCacheEntry: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getOrCreatePrefetchCacheEntry: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">prunePrefetchCache: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">DYNAMIC_STALETIME_MS: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">DYNAMIC_STALETIME_MS;</span>
    <span class="s1">},</span>
    <span class="s1">STATIC_STALETIME_MS: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">STATIC_STALETIME_MS;</span>
    <span class="s1">},</span>
    <span class="s1">createSeededPrefetchCacheEntry: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createSeededPrefetchCacheEntry;</span>
    <span class="s1">},</span>
    <span class="s1">getOrCreatePrefetchCacheEntry: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getOrCreatePrefetchCacheEntry;</span>
    <span class="s1">},</span>
    <span class="s1">prunePrefetchCache: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">prunePrefetchCache;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_fetchserverresponse = require(</span><span class="s0">&quot;./fetch-server-response&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerreducertypes = require(</span><span class="s0">&quot;./router-reducer-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_prefetchreducer = require(</span><span class="s0">&quot;./reducers/prefetch-reducer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">INTERCEPTION_CACHE_KEY_MARKER = </span><span class="s0">'%'</span><span class="s1">;</span>
<span class="s4">/**</span>
 <span class="s4">* Creates a cache key for the router prefetch cache</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">url - The URL being navigated to</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.</span>
 <span class="s4">* </span><span class="s5">@return </span><span class="s4">The generated prefetch cache key.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {</span>
    <span class="s4">// Initially we only use the pathname as the cache key. We don't want to include</span>
    <span class="s4">// search params so that multiple URLs with the same search parameter can re-use</span>
    <span class="s4">// loading states.</span>
    <span class="s2">let </span><span class="s1">pathnameFromUrl = url.pathname;</span>
    <span class="s4">// RSC responses can differ based on search params, specifically in the case where we aren't</span>
    <span class="s4">// returning a partial response (ie with `PrefetchKind.AUTO`).</span>
    <span class="s4">// In the auto case, since loading.js &amp; layout.js won't have access to search params,</span>
    <span class="s4">// we can safely re-use that cache entry. But for full prefetches, we should not</span>
    <span class="s4">// re-use the cache entry as the response may differ.</span>
    <span class="s2">if </span><span class="s1">(includeSearchParams) {</span>
        <span class="s4">// if we have a full prefetch, we can include the search param in the key,</span>
        <span class="s4">// as we'll be getting back a full response. The server might have read the search</span>
        <span class="s4">// params when generating the full response.</span>
        <span class="s1">pathnameFromUrl += url.search;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(prefix) {</span>
        <span class="s2">return </span><span class="s0">&quot;&quot; </span><span class="s1">+ prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">pathnameFromUrl;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPrefetchCacheKey(url, kind, nextUrl) {</span>
    <span class="s2">return </span><span class="s1">createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s2">void </span><span class="s3">0</span><span class="s1">) kind = _routerreducertypes.PrefetchKind.TEMPORARY;</span>
    <span class="s4">// We first check if there's a more specific interception route prefetch entry</span>
    <span class="s4">// This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)</span>
    <span class="s4">// to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">maybeNextUrl of [</span>
        <span class="s1">nextUrl,</span>
        <span class="s2">null</span>
    <span class="s1">]){</span>
        <span class="s2">const </span><span class="s1">cacheKeyWithParams = createPrefetchCacheKeyImpl(url, </span><span class="s2">true</span><span class="s1">, maybeNextUrl);</span>
        <span class="s2">const </span><span class="s1">cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, </span><span class="s2">false</span><span class="s1">, maybeNextUrl);</span>
        <span class="s4">// First, we check if we have a cache entry that exactly matches the URL</span>
        <span class="s2">const </span><span class="s1">cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;</span>
        <span class="s2">const </span><span class="s1">existingEntry = prefetchCache.get(cacheKeyToUse);</span>
        <span class="s2">if </span><span class="s1">(existingEntry &amp;&amp; allowAliasing) {</span>
            <span class="s4">// We know we're returning an aliased entry when the pathname matches but the search params don't,</span>
            <span class="s2">const </span><span class="s1">isAliased = existingEntry.url.pathname === url.pathname &amp;&amp; existingEntry.url.search !== url.search;</span>
            <span class="s2">if </span><span class="s1">(isAliased) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">...existingEntry,</span>
                    <span class="s1">aliased: </span><span class="s2">true</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">existingEntry;</span>
        <span class="s1">}</span>
        <span class="s4">// If the request contains search params, and we're not doing a full prefetch, we can return the</span>
        <span class="s4">// param-less entry if it exists.</span>
        <span class="s4">// This is technically covered by the check at the bottom of this function, which iterates over cache entries,</span>
        <span class="s4">// but lets us arrive there quicker in the param-full case.</span>
        <span class="s2">const </span><span class="s1">entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'development' </span><span class="s1">&amp;&amp; allowAliasing &amp;&amp; url.search &amp;&amp; kind !== _routerreducertypes.PrefetchKind.FULL &amp;&amp; entryWithoutParams &amp;&amp; </span><span class="s4">// We shouldn't return the aliased entry if it was relocated to a new cache key.</span>
        <span class="s4">// Since it's rewritten, it could respond with a completely different loading state.</span>
        <span class="s1">!entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">...entryWithoutParams,</span>
                <span class="s1">aliased: </span><span class="s2">true</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// If we've gotten to this point, we didn't find a specific cache entry that matched</span>
    <span class="s4">// the request URL.</span>
    <span class="s4">// We attempt a partial match by checking if there's a cache entry with the same pathname.</span>
    <span class="s4">// Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it &quot;aliased&quot;.</span>
    <span class="s4">// This will signal to the router that it should only apply the loading state on the prefetched data.</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'development' </span><span class="s1">&amp;&amp; kind !== _routerreducertypes.PrefetchKind.FULL &amp;&amp; allowAliasing) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">cacheEntry of prefetchCache.values()){</span>
            <span class="s2">if </span><span class="s1">(cacheEntry.url.pathname === url.pathname &amp;&amp; </span><span class="s4">// We shouldn't return the aliased entry if it was relocated to a new cache key.</span>
            <span class="s4">// Since it's rewritten, it could respond with a completely different loading state.</span>
            <span class="s1">!cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">...cacheEntry,</span>
                    <span class="s1">aliased: </span><span class="s2">true</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getOrCreatePrefetchCacheEntry(param) {</span>
    <span class="s2">let </span><span class="s1">{ url, nextUrl, tree, prefetchCache, kind, allowAliasing = </span><span class="s2">true </span><span class="s1">} = param;</span>
    <span class="s2">const </span><span class="s1">existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);</span>
    <span class="s2">if </span><span class="s1">(existingCacheEntry) {</span>
        <span class="s4">// Grab the latest status of the cache entry and update it</span>
        <span class="s1">existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);</span>
        <span class="s4">// when `kind` is provided, an explicit prefetch was requested.</span>
        <span class="s4">// if the requested prefetch is &quot;full&quot; and the current cache entry wasn't, we want to re-prefetch with the new intent</span>
        <span class="s2">const </span><span class="s1">switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL &amp;&amp; kind === _routerreducertypes.PrefetchKind.FULL;</span>
        <span class="s2">if </span><span class="s1">(switchedToFullPrefetch) {</span>
            <span class="s4">// If we switched to a full prefetch, validate that the existing cache entry contained partial data.</span>
            <span class="s4">// It's possible that the cache entry was seeded with full data but has a cache type of &quot;auto&quot; (ie when cache entries</span>
            <span class="s4">// are seeded but without a prefetch intent)</span>
            <span class="s1">existingCacheEntry.data.then((prefetchResponse)=&gt;{</span>
                <span class="s2">const </span><span class="s1">isFullPrefetch = Array.isArray(prefetchResponse.flightData) &amp;&amp; prefetchResponse.flightData.some((flightData)=&gt;{</span>
                    <span class="s4">// If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.</span>
                    <span class="s2">return </span><span class="s1">flightData.isRootRender &amp;&amp; flightData.seedData !== </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(!isFullPrefetch) {</span>
                    <span class="s2">return </span><span class="s1">createLazyPrefetchEntry({</span>
                        <span class="s1">tree,</span>
                        <span class="s1">url,</span>
                        <span class="s1">nextUrl,</span>
                        <span class="s1">prefetchCache,</span>
                        <span class="s4">// If we didn't get an explicit prefetch kind, we want to set a temporary kind</span>
                        <span class="s4">// rather than assuming the same intent as the previous entry, to be consistent with how we</span>
                        <span class="s4">// lazily create prefetch entries when intent is left unspecified.</span>
                        <span class="s1">kind: kind != </span><span class="s2">null </span><span class="s1">? kind : _routerreducertypes.PrefetchKind.TEMPORARY</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">// If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,</span>
        <span class="s4">// where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.</span>
        <span class="s2">if </span><span class="s1">(kind &amp;&amp; existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {</span>
            <span class="s1">existingCacheEntry.kind = kind;</span>
        <span class="s1">}</span>
        <span class="s4">// We've determined that the existing entry we found is still valid, so we return it.</span>
        <span class="s2">return </span><span class="s1">existingCacheEntry;</span>
    <span class="s1">}</span>
    <span class="s4">// If we didn't return an entry, create a new one.</span>
    <span class="s2">return </span><span class="s1">createLazyPrefetchEntry({</span>
        <span class="s1">tree,</span>
        <span class="s1">url,</span>
        <span class="s1">nextUrl,</span>
        <span class="s1">prefetchCache,</span>
        <span class="s1">kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s4">/* 
 * Used to take an existing cache entry and prefix it with the nextUrl, if it exists. 
 * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception). 
 */ </span><span class="s2">function </span><span class="s1">prefixExistingPrefetchCacheEntry(param) {</span>
    <span class="s2">let </span><span class="s1">{ url, nextUrl, prefetchCache, existingCacheKey } = param;</span>
    <span class="s2">const </span><span class="s1">existingCacheEntry = prefetchCache.get(existingCacheKey);</span>
    <span class="s2">if </span><span class="s1">(!existingCacheEntry) {</span>
        <span class="s4">// no-op -- there wasn't an entry to move</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);</span>
    <span class="s1">prefetchCache.set(newCacheKey, {</span>
        <span class="s1">...existingCacheEntry,</span>
        <span class="s1">key: newCacheKey</span>
    <span class="s1">});</span>
    <span class="s1">prefetchCache.delete(existingCacheKey);</span>
    <span class="s2">return </span><span class="s1">newCacheKey;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createSeededPrefetchCacheEntry(param) {</span>
    <span class="s2">let </span><span class="s1">{ nextUrl, tree, prefetchCache, url, data, kind } = param;</span>
    <span class="s4">// The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the</span>
    <span class="s4">// prefetch cache so that we can skip an extra prefetch request later, since we already have the data.</span>
    <span class="s4">// if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key</span>
    <span class="s2">const </span><span class="s1">prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);</span>
    <span class="s2">const </span><span class="s1">prefetchEntry = {</span>
        <span class="s1">treeAtTimeOfPrefetch: tree,</span>
        <span class="s1">data: Promise.resolve(data),</span>
        <span class="s1">kind,</span>
        <span class="s1">prefetchTime: Date.now(),</span>
        <span class="s1">lastUsedTime: Date.now(),</span>
        <span class="s1">staleTime: data.staleTime,</span>
        <span class="s1">key: prefetchCacheKey,</span>
        <span class="s1">status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,</span>
        <span class="s1">url</span>
    <span class="s1">};</span>
    <span class="s1">prefetchCache.set(prefetchCacheKey, prefetchEntry);</span>
    <span class="s2">return </span><span class="s1">prefetchEntry;</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">createLazyPrefetchEntry(param) {</span>
    <span class="s2">let </span><span class="s1">{ url, kind, tree, nextUrl, prefetchCache } = param;</span>
    <span class="s2">const </span><span class="s1">prefetchCacheKey = createPrefetchCacheKey(url, kind);</span>
    <span class="s4">// initiates the fetch request for the prefetch and attaches a listener</span>
    <span class="s4">// to the promise to update the prefetch cache entry when the promise resolves (if necessary)</span>
    <span class="s2">const </span><span class="s1">data = _prefetchreducer.prefetchQueue.enqueue(()=&gt;(</span><span class="s3">0</span><span class="s1">, _fetchserverresponse.fetchServerResponse)(url, {</span>
            <span class="s1">flightRouterState: tree,</span>
            <span class="s1">nextUrl,</span>
            <span class="s1">prefetchKind: kind</span>
        <span class="s1">}).then((prefetchResponse)=&gt;{</span>
            <span class="s4">// TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations</span>
            <span class="s4">// to avoid drift between this cache key prefixing logic</span>
            <span class="s4">// (which is currently directly influenced by the server response)</span>
            <span class="s2">let </span><span class="s1">newCacheKey;</span>
            <span class="s2">if </span><span class="s1">(prefetchResponse.couldBeIntercepted) {</span>
                <span class="s4">// Determine if we need to prefix the cache key with the nextUrl</span>
                <span class="s1">newCacheKey = prefixExistingPrefetchCacheEntry({</span>
                    <span class="s1">url,</span>
                    <span class="s1">existingCacheKey: prefetchCacheKey,</span>
                    <span class="s1">nextUrl,</span>
                    <span class="s1">prefetchCache</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.</span>
            <span class="s4">// This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`</span>
            <span class="s4">// staleTime.</span>
            <span class="s2">if </span><span class="s1">(prefetchResponse.prerendered) {</span>
                <span class="s2">const </span><span class="s1">existingCacheEntry = prefetchCache.get(</span><span class="s4">// if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key</span>
                <span class="s1">newCacheKey != </span><span class="s2">null </span><span class="s1">? newCacheKey : prefetchCacheKey);</span>
                <span class="s2">if </span><span class="s1">(existingCacheEntry) {</span>
                    <span class="s1">existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;</span>
                    <span class="s2">if </span><span class="s1">(prefetchResponse.staleTime !== -</span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s4">// This is the stale time that was collected by the server during</span>
                        <span class="s4">// static generation. Use this in place of the default stale time.</span>
                        <span class="s1">existingCacheEntry.staleTime = prefetchResponse.staleTime;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">prefetchResponse;</span>
        <span class="s1">}));</span>
    <span class="s2">const </span><span class="s1">prefetchEntry = {</span>
        <span class="s1">treeAtTimeOfPrefetch: tree,</span>
        <span class="s1">data,</span>
        <span class="s1">kind,</span>
        <span class="s1">prefetchTime: Date.now(),</span>
        <span class="s1">lastUsedTime: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">staleTime: -</span><span class="s3">1</span><span class="s1">,</span>
        <span class="s1">key: prefetchCacheKey,</span>
        <span class="s1">status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,</span>
        <span class="s1">url</span>
    <span class="s1">};</span>
    <span class="s1">prefetchCache.set(prefetchCacheKey, prefetchEntry);</span>
    <span class="s2">return </span><span class="s1">prefetchEntry;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">prunePrefetchCache(prefetchCache) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[href, prefetchCacheEntry] of prefetchCache){</span>
        <span class="s2">if </span><span class="s1">(getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {</span>
            <span class="s1">prefetchCache.delete(href);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">DYNAMIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * </span><span class="s3">1000</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">STATIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * </span><span class="s3">1000</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">getPrefetchEntryCacheStatus(param) {</span>
    <span class="s2">let </span><span class="s1">{ kind, prefetchTime, lastUsedTime } = param;</span>
    <span class="s4">// We will re-use the cache entry data for up to the `dynamic` staletime window.</span>
    <span class="s2">if </span><span class="s1">(Date.now() &lt; (lastUsedTime != </span><span class="s2">null </span><span class="s1">? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {</span>
        <span class="s2">return </span><span class="s1">lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;</span>
    <span class="s1">}</span>
    <span class="s4">// For &quot;auto&quot; prefetching, we'll re-use only the loading boundary for up to `static` staletime window.</span>
    <span class="s4">// A stale entry will only re-use the `loading` boundary, not the full data.</span>
    <span class="s4">// This will trigger a &quot;lazy fetch&quot; for the full data.</span>
    <span class="s2">if </span><span class="s1">(kind === _routerreducertypes.PrefetchKind.AUTO) {</span>
        <span class="s2">if </span><span class="s1">(Date.now() &lt; prefetchTime + STATIC_STALETIME_MS) {</span>
            <span class="s2">return </span><span class="s1">_routerreducertypes.PrefetchCacheEntryStatus.stale;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// for &quot;full&quot; prefetching, we'll re-use the cache entry data for up to `static` staletime window.</span>
    <span class="s2">if </span><span class="s1">(kind === _routerreducertypes.PrefetchKind.FULL) {</span>
        <span class="s2">if </span><span class="s1">(Date.now() &lt; prefetchTime + STATIC_STALETIME_MS) {</span>
            <span class="s2">return </span><span class="s1">_routerreducertypes.PrefetchCacheEntryStatus.reusable;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_routerreducertypes.PrefetchCacheEntryStatus.expired;</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=prefetch-cache-utils.js.map</span></pre>
</body>
</html>