<html>
<head>
<title>no-unnecessary-condition.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-unnecessary-condition.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || (</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">ownKeys = </span><span class="s2">function</span><span class="s1">(o) {</span>
        <span class="s1">ownKeys = Object.getOwnPropertyNames || </span><span class="s2">function </span><span class="s1">(o) {</span>
            <span class="s2">var </span><span class="s1">ar = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">o) </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;</span>
            <span class="s2">return </span><span class="s1">ar;</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">ownKeys(o);</span>
    <span class="s1">};</span>
    <span class="s2">return function </span><span class="s1">(mod) {</span>
        <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
        <span class="s2">var </span><span class="s1">result = {};</span>
        <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k = ownKeys(mod), i = </span><span class="s3">0</span><span class="s1">; i &lt; k.length; i++) </span><span class="s2">if </span><span class="s1">(k[i] !== </span><span class="s0">&quot;default&quot;</span><span class="s1">) __createBinding(result, mod, k[i]);</span>
        <span class="s1">__setModuleDefault(result, mod);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>
<span class="s1">})();</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">tsutils = __importStar(require(</span><span class="s0">&quot;ts-api-utils&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">assertionFunctionUtils_1 = require(</span><span class="s0">&quot;../util/assertionFunctionUtils&quot;</span><span class="s1">);</span>
<span class="s4">// #region</span>
<span class="s2">const </span><span class="s1">nullishFlag = ts.TypeFlags.Undefined | ts.TypeFlags.Null;</span>
<span class="s2">function </span><span class="s1">isNullishType(type) {</span>
    <span class="s2">return </span><span class="s1">tsutils.isTypeFlagSet(type, nullishFlag);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isAlwaysNullish(type) {</span>
    <span class="s2">return </span><span class="s1">tsutils.unionConstituents(type).every(isNullishType);</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Note that this differs from {</span><span class="s5">@link </span><span class="s4">isNullableType} in that it doesn't consider</span>
 <span class="s4">* `any` or `unknown` to be nullable.</span>
 <span class="s4">*/</span>
<span class="s2">function </span><span class="s1">isPossiblyNullish(type) {</span>
    <span class="s2">return </span><span class="s1">tsutils.unionConstituents(type).some(isNullishType);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toStaticValue(type) {</span>
    <span class="s4">// type.isLiteral() only covers numbers/bigints and strings, hence the rest of the branches.</span>
    <span class="s2">if </span><span class="s1">(tsutils.isBooleanLiteralType(type)) {</span>
        <span class="s2">return </span><span class="s1">{ value: tsutils.isTrueLiteralType(type) };</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type.flags === ts.TypeFlags.Undefined) {</span>
        <span class="s2">return </span><span class="s1">{ value: undefined };</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type.flags === ts.TypeFlags.Null) {</span>
        <span class="s2">return </span><span class="s1">{ value: </span><span class="s2">null </span><span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type.isLiteral()) {</span>
        <span class="s2">return </span><span class="s1">{ value: (</span><span class="s3">0</span><span class="s1">, util_1.getValueOfLiteralType)(type) };</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">BOOL_OPERATORS = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s0">'&lt;'</span><span class="s1">,</span>
    <span class="s0">'&gt;'</span><span class="s1">,</span>
    <span class="s0">'&lt;='</span><span class="s1">,</span>
    <span class="s0">'&gt;='</span><span class="s1">,</span>
    <span class="s0">'=='</span><span class="s1">,</span>
    <span class="s0">'==='</span><span class="s1">,</span>
    <span class="s0">'!='</span><span class="s1">,</span>
    <span class="s0">'!=='</span><span class="s1">,</span>
<span class="s1">]);</span>
<span class="s2">function </span><span class="s1">isBoolOperator(operator) {</span>
    <span class="s2">return </span><span class="s1">BOOL_OPERATORS.has(operator);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">booleanComparison(left, operator, right) {</span>
    <span class="s2">switch </span><span class="s1">(operator) {</span>
        <span class="s2">case </span><span class="s0">'!='</span><span class="s1">:</span>
            <span class="s4">// eslint-disable-next-line eqeqeq -- intentionally comparing with loose equality</span>
            <span class="s2">return </span><span class="s1">left != right;</span>
        <span class="s2">case </span><span class="s0">'!=='</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">left !== right;</span>
        <span class="s2">case </span><span class="s0">'&lt;'</span><span class="s1">:</span>
            <span class="s4">// @ts-expect-error: we don't care if the comparison seems unintentional.</span>
            <span class="s2">return </span><span class="s1">left &lt; right;</span>
        <span class="s2">case </span><span class="s0">'&lt;='</span><span class="s1">:</span>
            <span class="s4">// @ts-expect-error: we don't care if the comparison seems unintentional.</span>
            <span class="s2">return </span><span class="s1">left &lt;= right;</span>
        <span class="s2">case </span><span class="s0">'=='</span><span class="s1">:</span>
            <span class="s4">// eslint-disable-next-line eqeqeq -- intentionally comparing with loose equality</span>
            <span class="s2">return </span><span class="s1">left == right;</span>
        <span class="s2">case </span><span class="s0">'==='</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">left === right;</span>
        <span class="s2">case </span><span class="s0">'&gt;'</span><span class="s1">:</span>
            <span class="s4">// @ts-expect-error: we don't care if the comparison seems unintentional.</span>
            <span class="s2">return </span><span class="s1">left &gt; right;</span>
        <span class="s2">case </span><span class="s0">'&gt;='</span><span class="s1">:</span>
            <span class="s4">// @ts-expect-error: we don't care if the comparison seems unintentional.</span>
            <span class="s2">return </span><span class="s1">left &gt;= right;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">constantLoopConditionsAllowedLiterals = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s2">true</span><span class="s1">,</span>
    <span class="s2">false</span><span class="s1">,</span>
    <span class="s3">1</span><span class="s1">,</span>
    <span class="s3">0</span><span class="s1">,</span>
<span class="s1">]);</span>
<span class="s1">exports.default = (</span><span class="s3">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'no-unnecessary-condition'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Disallow conditionals where the type is always truthy or always falsy'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s0">'strict'</span><span class="s1">,</span>
            <span class="s1">requiresTypeChecking: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">hasSuggestions: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">alwaysFalsy: </span><span class="s0">'Unnecessary conditional, value is always falsy.'</span><span class="s1">,</span>
            <span class="s1">alwaysFalsyFunc: </span><span class="s0">'This callback should return a conditional, but return is always falsy.'</span><span class="s1">,</span>
            <span class="s1">alwaysNullish: </span><span class="s0">'Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.'</span><span class="s1">,</span>
            <span class="s1">alwaysTruthy: </span><span class="s0">'Unnecessary conditional, value is always truthy.'</span><span class="s1">,</span>
            <span class="s1">alwaysTruthyFunc: </span><span class="s0">'This callback should return a conditional, but return is always truthy.'</span><span class="s1">,</span>
            <span class="s1">comparisonBetweenLiteralTypes: </span><span class="s0">'Unnecessary conditional, comparison is always {{trueOrFalse}}, since `{{left}} {{operator}} {{right}}` is {{trueOrFalse}}.'</span><span class="s1">,</span>
            <span class="s1">never: </span><span class="s0">'Unnecessary conditional, value is `never`.'</span><span class="s1">,</span>
            <span class="s1">neverNullish: </span><span class="s0">'Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.'</span><span class="s1">,</span>
            <span class="s1">neverOptionalChain: </span><span class="s0">'Unnecessary optional chain on a non-nullish value.'</span><span class="s1">,</span>
            <span class="s1">noOverlapBooleanExpression: </span><span class="s0">'Unnecessary conditional, the types have no overlap.'</span><span class="s1">,</span>
            <span class="s1">noStrictNullCheck: </span><span class="s0">'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.'</span><span class="s1">,</span>
            <span class="s1">suggestRemoveOptionalChain: </span><span class="s0">'Remove unnecessary optional chain'</span><span class="s1">,</span>
            <span class="s1">typeGuardAlreadyIsType: </span><span class="s0">'Unnecessary conditional, expression already has the type being checked by the {{typeGuardOrAssertionFunction}}.'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">allowConstantLoopConditions: {</span>
                        <span class="s1">description: </span><span class="s0">'Whether to ignore constant loop conditions, such as `while (true)`.'</span><span class="s1">,</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">{</span>
                                <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                                <span class="s2">enum</span><span class="s1">: [</span><span class="s0">'always'</span><span class="s1">, </span><span class="s0">'never'</span><span class="s1">, </span><span class="s0">'only-allowed-literals'</span><span class="s1">],</span>
                            <span class="s1">},</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to not error when running with a tsconfig that has strictNullChecks turned.'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">checkTypePredicates: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to check the asserted argument of a type predicate function for unnecessary conditions'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">allowConstantLoopConditions: </span><span class="s0">'never'</span><span class="s1">,</span>
            <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">checkTypePredicates: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [{ allowConstantLoopConditions, allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing, checkTypePredicates, },]) {</span>
        <span class="s2">const </span><span class="s1">services = (</span><span class="s3">0</span><span class="s1">, util_1.getParserServices)(context);</span>
        <span class="s2">const </span><span class="s1">checker = services.program.getTypeChecker();</span>
        <span class="s2">const </span><span class="s1">compilerOptions = services.program.getCompilerOptions();</span>
        <span class="s2">const </span><span class="s1">isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, </span><span class="s0">'strictNullChecks'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">isNoUncheckedIndexedAccess = tsutils.isCompilerOptionEnabled(compilerOptions, </span><span class="s0">'noUncheckedIndexedAccess'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">allowConstantLoopConditionsOption = normalizeAllowConstantLoopConditions(</span>
        <span class="s4">// https://github.com/typescript-eslint/typescript-eslint/issues/5439</span>
        <span class="s4">// eslint-disable-next-line @typescript-eslint/no-non-null-assertion</span>
        <span class="s1">allowConstantLoopConditions);</span>
        <span class="s2">if </span><span class="s1">(!isStrictNullChecks &amp;&amp;</span>
            <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">context.report({</span>
                <span class="s1">loc: {</span>
                    <span class="s1">start: { column: </span><span class="s3">0</span><span class="s1">, line: </span><span class="s3">0 </span><span class="s1">},</span>
                    <span class="s1">end: { column: </span><span class="s3">0</span><span class="s1">, line: </span><span class="s3">0 </span><span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">messageId: </span><span class="s0">'noStrictNullCheck'</span><span class="s1">,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">nodeIsArrayType(node) {</span>
            <span class="s2">const </span><span class="s1">nodeType = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node);</span>
            <span class="s2">return </span><span class="s1">tsutils</span>
                <span class="s1">.unionConstituents(nodeType)</span>
                <span class="s1">.some(part =&gt; checker.isArrayType(part));</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">nodeIsTupleType(node) {</span>
            <span class="s2">const </span><span class="s1">nodeType = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node);</span>
            <span class="s2">return </span><span class="s1">tsutils</span>
                <span class="s1">.unionConstituents(nodeType)</span>
                <span class="s1">.some(part =&gt; checker.isTupleType(part));</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isArrayIndexExpression(node) {</span>
            <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// Is an index signature</span>
            <span class="s1">node.type === utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;</span>
                <span class="s1">node.computed &amp;&amp;</span>
                <span class="s4">// ...into an array type</span>
                <span class="s1">(nodeIsArrayType(node.object) ||</span>
                    <span class="s4">// ... or a tuple type</span>
                    <span class="s1">(nodeIsTupleType(node.object) &amp;&amp;</span>
                        <span class="s4">// Exception: literal index into a tuple - will have a sound type</span>
                        <span class="s1">node.property.type !== utils_1.AST_NODE_TYPES.Literal)));</span>
        <span class="s1">}</span>
        <span class="s4">// Conditional is always necessary if it involves:</span>
        <span class="s4">//    `any` or `unknown` or a naked type variable</span>
        <span class="s2">function </span><span class="s1">isConditionalAlwaysNecessary(type) {</span>
            <span class="s2">return </span><span class="s1">tsutils</span>
                <span class="s1">.unionConstituents(type)</span>
                <span class="s1">.some(part =&gt; (</span><span class="s3">0</span><span class="s1">, util_1.isTypeAnyType)(part) ||</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isTypeUnknownType)(part) ||</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeVariable));</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isNullableMemberExpression(node) {</span>
            <span class="s2">const </span><span class="s1">objectType = services.getTypeAtLocation(node.object);</span>
            <span class="s2">if </span><span class="s1">(node.computed) {</span>
                <span class="s2">const </span><span class="s1">propertyType = services.getTypeAtLocation(node.property);</span>
                <span class="s2">return </span><span class="s1">isNullablePropertyType(objectType, propertyType);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">property = node.property;</span>
            <span class="s4">// Get the actual property name, to account for private properties (this.#prop).</span>
            <span class="s2">const </span><span class="s1">propertyName = context.sourceCode.getText(property);</span>
            <span class="s2">const </span><span class="s1">propertyType = objectType</span>
                <span class="s1">.getProperties()</span>
                <span class="s1">.find(prop =&gt; prop.name === propertyName);</span>
            <span class="s2">if </span><span class="s1">(propertyType &amp;&amp;</span>
                <span class="s1">tsutils.isSymbolFlagSet(propertyType, ts.SymbolFlags.Optional)) {</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks if a conditional node is necessary:</span>
         <span class="s4">* if the type of the node is always true or always false, it's not necessary.</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">checkNode(expression, isUnaryNotArgument = </span><span class="s2">false</span><span class="s1">, node = expression) {</span>
            <span class="s4">// Check if the node is Unary Negation expression and handle it</span>
            <span class="s2">if </span><span class="s1">(expression.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;</span>
                <span class="s1">expression.operator === </span><span class="s0">'!'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">checkNode(expression.argument, !isUnaryNotArgument, node);</span>
            <span class="s1">}</span>
            <span class="s4">// Since typescript array index signature types don't represent the</span>
            <span class="s4">//  possibility of out-of-bounds access, if we're indexing into an array</span>
            <span class="s4">//  just skip the check, to avoid false positives</span>
            <span class="s2">if </span><span class="s1">(!isNoUncheckedIndexedAccess &amp;&amp; isArrayIndexExpression(expression)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// When checking logical expressions, only check the right side</span>
            <span class="s4">//  as the left side has been checked by checkLogicalExpressionForUnnecessaryConditionals</span>
            <span class="s4">//</span>
            <span class="s4">// Unless the node is nullish coalescing, as it's common to use patterns like `nullBool ?? true` to to strict</span>
            <span class="s4">//  boolean checks if we inspect the right here, it'll usually be a constant condition on purpose.</span>
            <span class="s4">// In this case it's better to inspect the type of the expression as a whole.</span>
            <span class="s2">if </span><span class="s1">(expression.type === utils_1.AST_NODE_TYPES.LogicalExpression &amp;&amp;</span>
                <span class="s1">expression.operator !== </span><span class="s0">'??'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">checkNode(expression.right);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">type = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, expression);</span>
            <span class="s2">if </span><span class="s1">(isConditionalAlwaysNecessary(type)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">messageId = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {</span>
                <span class="s1">messageId = </span><span class="s0">'never'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, util_1.isPossiblyTruthy)(type)) {</span>
                <span class="s1">messageId = !isUnaryNotArgument ? </span><span class="s0">'alwaysFalsy' </span><span class="s1">: </span><span class="s0">'alwaysTruthy'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, util_1.isPossiblyFalsy)(type)) {</span>
                <span class="s1">messageId = !isUnaryNotArgument ? </span><span class="s0">'alwaysTruthy' </span><span class="s1">: </span><span class="s0">'alwaysFalsy'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(messageId) {</span>
                <span class="s1">context.report({ node, messageId });</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkNodeForNullish(node) {</span>
            <span class="s2">const </span><span class="s1">type = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node);</span>
            <span class="s4">// Conditional is always necessary if it involves `any`, `unknown` or a naked type parameter</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any |</span>
                <span class="s1">ts.TypeFlags.Unknown |</span>
                <span class="s1">ts.TypeFlags.TypeParameter |</span>
                <span class="s1">ts.TypeFlags.TypeVariable)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">messageId = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {</span>
                <span class="s1">messageId = </span><span class="s0">'never'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!isPossiblyNullish(type) &amp;&amp;</span>
                <span class="s1">!(node.type === utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;</span>
                    <span class="s1">isNullableMemberExpression(node))) {</span>
                <span class="s4">// Since typescript array index signature types don't represent the</span>
                <span class="s4">//  possibility of out-of-bounds access, if we're indexing into an array</span>
                <span class="s4">//  just skip the check, to avoid false positives</span>
                <span class="s2">if </span><span class="s1">(isNoUncheckedIndexedAccess ||</span>
                    <span class="s1">(!isArrayIndexExpression(node) &amp;&amp;</span>
                        <span class="s1">!(node.type === utils_1.AST_NODE_TYPES.ChainExpression &amp;&amp;</span>
                            <span class="s1">node.expression.type !== utils_1.AST_NODE_TYPES.TSNonNullExpression &amp;&amp;</span>
                            <span class="s1">optionChainContainsOptionArrayIndex(node.expression)))) {</span>
                    <span class="s1">messageId = </span><span class="s0">'neverNullish'</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isAlwaysNullish(type)) {</span>
                <span class="s1">messageId = </span><span class="s0">'alwaysNullish'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(messageId) {</span>
                <span class="s1">context.report({ node, messageId });</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks that a binary expression is necessarily conditional, reports otherwise.</span>
         <span class="s4">* If both sides of the binary expression are literal values, it's not a necessary condition.</span>
         <span class="s4">*</span>
         <span class="s4">* NOTE: It's also unnecessary if the types that don't overlap at all</span>
         <span class="s4">*    but that case is handled by the Typescript compiler itself.</span>
         <span class="s4">*    Known exceptions:</span>
         <span class="s4">*      - https://github.com/microsoft/TypeScript/issues/32627</span>
         <span class="s4">*      - https://github.com/microsoft/TypeScript/issues/37160 (handled)</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">checkIfBoolExpressionIsNecessaryConditional(node, left, right, operator) {</span>
            <span class="s2">const </span><span class="s1">leftType = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, left);</span>
            <span class="s2">const </span><span class="s1">rightType = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, right);</span>
            <span class="s2">const </span><span class="s1">leftStaticValue = toStaticValue(leftType);</span>
            <span class="s2">const </span><span class="s1">rightStaticValue = toStaticValue(rightType);</span>
            <span class="s2">if </span><span class="s1">(leftStaticValue != </span><span class="s2">null </span><span class="s1">&amp;&amp; rightStaticValue != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">conditionIsTrue = booleanComparison(leftStaticValue.value, operator, rightStaticValue.value);</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: </span><span class="s0">'comparisonBetweenLiteralTypes'</span><span class="s1">,</span>
                    <span class="s1">data: {</span>
                        <span class="s1">left: checker.typeToString(leftType),</span>
                        <span class="s1">operator,</span>
                        <span class="s1">right: checker.typeToString(rightType),</span>
                        <span class="s1">trueOrFalse: conditionIsTrue ? </span><span class="s0">'true' </span><span class="s1">: </span><span class="s0">'false'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Workaround for https://github.com/microsoft/TypeScript/issues/37160</span>
            <span class="s2">if </span><span class="s1">(isStrictNullChecks) {</span>
                <span class="s2">const </span><span class="s1">UNDEFINED = ts.TypeFlags.Undefined;</span>
                <span class="s2">const </span><span class="s1">NULL = ts.TypeFlags.Null;</span>
                <span class="s2">const </span><span class="s1">VOID = ts.TypeFlags.Void;</span>
                <span class="s2">const </span><span class="s1">isComparable = (type, flag) =&gt; {</span>
                    <span class="s4">// Allow comparison to `any`, `unknown` or a naked type parameter.</span>
                    <span class="s1">flag |=</span>
                        <span class="s1">ts.TypeFlags.Any |</span>
                            <span class="s1">ts.TypeFlags.Unknown |</span>
                            <span class="s1">ts.TypeFlags.TypeParameter |</span>
                            <span class="s1">ts.TypeFlags.TypeVariable;</span>
                    <span class="s4">// Allow loose comparison to nullish values.</span>
                    <span class="s2">if </span><span class="s1">(operator === </span><span class="s0">'==' </span><span class="s1">|| operator === </span><span class="s0">'!='</span><span class="s1">) {</span>
                        <span class="s1">flag |= NULL | UNDEFINED | VOID;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isTypeFlagSet)(type, flag);</span>
                <span class="s1">};</span>
                <span class="s2">if </span><span class="s1">((leftType.flags === UNDEFINED &amp;&amp;</span>
                    <span class="s1">!isComparable(rightType, UNDEFINED | VOID)) ||</span>
                    <span class="s1">(rightType.flags === UNDEFINED &amp;&amp;</span>
                        <span class="s1">!isComparable(leftType, UNDEFINED | VOID)) ||</span>
                    <span class="s1">(leftType.flags === NULL &amp;&amp; !isComparable(rightType, NULL)) ||</span>
                    <span class="s1">(rightType.flags === NULL &amp;&amp; !isComparable(leftType, NULL))) {</span>
                    <span class="s1">context.report({ node, messageId: </span><span class="s0">'noOverlapBooleanExpression' </span><span class="s1">});</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks that a logical expression contains a boolean, reports otherwise.</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">checkLogicalExpressionForUnnecessaryConditionals(node) {</span>
            <span class="s2">if </span><span class="s1">(node.operator === </span><span class="s0">'??'</span><span class="s1">) {</span>
                <span class="s1">checkNodeForNullish(node.left);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Only checks the left side, since the right side might not be &quot;conditional&quot; at all.</span>
            <span class="s4">// The right side will be checked if the LogicalExpression is used in a conditional context</span>
            <span class="s1">checkNode(node.left);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkIfWhileLoopIsNecessaryConditional(node) {</span>
            <span class="s2">if </span><span class="s1">(allowConstantLoopConditionsOption === </span><span class="s0">'only-allowed-literals' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">node.test.type === utils_1.AST_NODE_TYPES.Literal &amp;&amp;</span>
                <span class="s1">constantLoopConditionsAllowedLiterals.has(node.test.value)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkIfLoopIsNecessaryConditional(node);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Checks that a testable expression of a loop is necessarily conditional, reports otherwise.</span>
         <span class="s4">*/</span>
        <span class="s2">function </span><span class="s1">checkIfLoopIsNecessaryConditional(node) {</span>
            <span class="s2">if </span><span class="s1">(node.test == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s4">// e.g. `for(;;)`</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(allowConstantLoopConditionsOption === </span><span class="s0">'always' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">tsutils.isTrueLiteralType((</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node.test))) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkNode(node.test);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkCallExpression(node) {</span>
            <span class="s2">if </span><span class="s1">(checkTypePredicates) {</span>
                <span class="s2">const </span><span class="s1">truthinessAssertedArgument = (</span><span class="s3">0</span><span class="s1">, assertionFunctionUtils_1.findTruthinessAssertedArgument)(services, node);</span>
                <span class="s2">if </span><span class="s1">(truthinessAssertedArgument != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">checkNode(truthinessAssertedArgument);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">typeGuardAssertedArgument = (</span><span class="s3">0</span><span class="s1">, assertionFunctionUtils_1.findTypeGuardAssertedArgument)(services, node);</span>
                <span class="s2">if </span><span class="s1">(typeGuardAssertedArgument != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s2">const </span><span class="s1">typeOfArgument = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, typeGuardAssertedArgument.argument);</span>
                    <span class="s2">if </span><span class="s1">(typeOfArgument === typeGuardAssertedArgument.type) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: typeGuardAssertedArgument.argument,</span>
                            <span class="s1">messageId: </span><span class="s0">'typeGuardAlreadyIsType'</span><span class="s1">,</span>
                            <span class="s1">data: {</span>
                                <span class="s1">typeGuardOrAssertionFunction: typeGuardAssertedArgument.asserts</span>
                                    <span class="s1">? </span><span class="s0">'assertion function'</span>
                                    <span class="s1">: </span><span class="s0">'type guard'</span><span class="s1">,</span>
                            <span class="s1">},</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// If this is something like arr.filter(x =&gt; /*condition*/), check `condition`</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isArrayMethodCallWithPredicate)(context, services, node) &amp;&amp;</span>
                <span class="s1">node.arguments.length) {</span>
                <span class="s2">const </span><span class="s1">callback = node.arguments[</span><span class="s3">0</span><span class="s1">];</span>
                <span class="s4">// Inline defined functions</span>
                <span class="s2">if </span><span class="s1">(callback.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||</span>
                    <span class="s1">callback.type === utils_1.AST_NODE_TYPES.FunctionExpression) {</span>
                    <span class="s4">// Two special cases, where we can directly check the node that's returned:</span>
                    <span class="s4">// () =&gt; something</span>
                    <span class="s2">if </span><span class="s1">(callback.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {</span>
                        <span class="s2">return </span><span class="s1">checkNode(callback.body);</span>
                    <span class="s1">}</span>
                    <span class="s4">// () =&gt; { return something; }</span>
                    <span class="s2">const </span><span class="s1">callbackBody = callback.body.body;</span>
                    <span class="s2">if </span><span class="s1">(callbackBody.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">callbackBody[</span><span class="s3">0</span><span class="s1">].type === utils_1.AST_NODE_TYPES.ReturnStatement &amp;&amp;</span>
                        <span class="s1">callbackBody[</span><span class="s3">0</span><span class="s1">].argument) {</span>
                        <span class="s2">return </span><span class="s1">checkNode(callbackBody[</span><span class="s3">0</span><span class="s1">].argument);</span>
                    <span class="s1">}</span>
                    <span class="s4">// Potential enhancement: could use code-path analysis to check</span>
                    <span class="s4">//   any function with a single return statement</span>
                    <span class="s4">// (Value to complexity ratio is dubious however)</span>
                <span class="s1">}</span>
                <span class="s4">// Otherwise just do type analysis on the function as a whole.</span>
                <span class="s2">const </span><span class="s1">returnTypes = tsutils</span>
                    <span class="s1">.getCallSignaturesOfType((</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, callback))</span>
                    <span class="s1">.map(sig =&gt; sig.getReturnType());</span>
                <span class="s2">if </span><span class="s1">(returnTypes.length === </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s4">// Not a callable function, e.g. `any`</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">hasFalsyReturnTypes = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">let </span><span class="s1">hasTruthyReturnTypes = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">type of returnTypes) {</span>
                    <span class="s2">const </span><span class="s1">{ constraintType } = (</span><span class="s3">0</span><span class="s1">, util_1.getConstraintInfo)(checker, type);</span>
                    <span class="s4">// Predicate is always necessary if it involves `any` or `unknown`</span>
                    <span class="s2">if </span><span class="s1">(!constraintType ||</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isTypeAnyType)(constraintType) ||</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isTypeUnknownType)(constraintType)) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isPossiblyFalsy)(constraintType)) {</span>
                        <span class="s1">hasFalsyReturnTypes = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, util_1.isPossiblyTruthy)(constraintType)) {</span>
                        <span class="s1">hasTruthyReturnTypes = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s4">// bail early if both a possibly-truthy and a possibly-falsy have been detected</span>
                    <span class="s2">if </span><span class="s1">(hasFalsyReturnTypes &amp;&amp; hasTruthyReturnTypes) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!hasFalsyReturnTypes) {</span>
                    <span class="s2">return </span><span class="s1">context.report({</span>
                        <span class="s1">node: callback,</span>
                        <span class="s1">messageId: </span><span class="s0">'alwaysTruthyFunc'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!hasTruthyReturnTypes) {</span>
                    <span class="s2">return </span><span class="s1">context.report({</span>
                        <span class="s1">node: callback,</span>
                        <span class="s1">messageId: </span><span class="s0">'alwaysFalsyFunc'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// Recursively searches an optional chain for an array index expression</span>
        <span class="s4">//  Has to search the entire chain, because an array index will &quot;infect&quot; the rest of the types</span>
        <span class="s4">//  Example:</span>
        <span class="s4">//  ```</span>
        <span class="s4">//  [{x: {y: &quot;z&quot;} }][n] // type is {x: {y: &quot;z&quot;}}</span>
        <span class="s4">//    ?.x // type is {y: &quot;z&quot;}</span>
        <span class="s4">//    ?.y // This access is considered &quot;unnecessary&quot; according to the types</span>
        <span class="s4">//  ```</span>
        <span class="s2">function </span><span class="s1">optionChainContainsOptionArrayIndex(node) {</span>
            <span class="s2">const </span><span class="s1">lhsNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;</span>
            <span class="s2">if </span><span class="s1">(node.optional &amp;&amp; isArrayIndexExpression(lhsNode)) {</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(lhsNode.type === utils_1.AST_NODE_TYPES.MemberExpression ||</span>
                <span class="s1">lhsNode.type === utils_1.AST_NODE_TYPES.CallExpression) {</span>
                <span class="s2">return </span><span class="s1">optionChainContainsOptionArrayIndex(lhsNode);</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isNullablePropertyType(objType, propertyType) {</span>
            <span class="s2">if </span><span class="s1">(propertyType.isUnion()) {</span>
                <span class="s2">return </span><span class="s1">propertyType.types.some(type =&gt; isNullablePropertyType(objType, type));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(propertyType.isNumberLiteral() || propertyType.isStringLiteral()) {</span>
                <span class="s2">const </span><span class="s1">propType = (</span><span class="s3">0</span><span class="s1">, util_1.getTypeOfPropertyOfName)(checker, objType, propertyType.value.toString());</span>
                <span class="s2">if </span><span class="s1">(propType) {</span>
                    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isNullableType)(propType);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">typeName = (</span><span class="s3">0</span><span class="s1">, util_1.getTypeName)(checker, propertyType);</span>
            <span class="s2">return </span><span class="s1">checker</span>
                <span class="s1">.getIndexInfosOfType(objType)</span>
                <span class="s1">.some(info =&gt; (</span><span class="s3">0</span><span class="s1">, util_1.getTypeName)(checker, info.keyType) === typeName);</span>
        <span class="s1">}</span>
        <span class="s4">// Checks whether a member expression is nullable or not regardless of it's previous node.</span>
        <span class="s4">//  Example:</span>
        <span class="s4">//  ```</span>
        <span class="s4">//  // 'bar' is nullable if 'foo' is null.</span>
        <span class="s4">//  // but this function checks regardless of 'foo' type, so returns 'true'.</span>
        <span class="s4">//  declare const foo: { bar : { baz: string } } | null</span>
        <span class="s4">//  foo?.bar;</span>
        <span class="s4">//  ```</span>
        <span class="s2">function </span><span class="s1">isMemberExpressionNullableOriginFromObject(node) {</span>
            <span class="s2">const </span><span class="s1">prevType = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node.object);</span>
            <span class="s2">const </span><span class="s1">property = node.property;</span>
            <span class="s2">if </span><span class="s1">(prevType.isUnion() &amp;&amp; (</span><span class="s3">0</span><span class="s1">, util_1.isIdentifier)(property)) {</span>
                <span class="s2">const </span><span class="s1">isOwnNullable = prevType.types.some(type =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(node.computed) {</span>
                        <span class="s2">const </span><span class="s1">propertyType = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node.property);</span>
                        <span class="s2">return </span><span class="s1">isNullablePropertyType(type, propertyType);</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">propType = (</span><span class="s3">0</span><span class="s1">, util_1.getTypeOfPropertyOfName)(checker, type, property.name);</span>
                    <span class="s2">if </span><span class="s1">(propType) {</span>
                        <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, util_1.isNullableType)(propType);</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">indexInfo = checker.getIndexInfosOfType(type);</span>
                    <span class="s2">return </span><span class="s1">indexInfo.some(info =&gt; {</span>
                        <span class="s2">const </span><span class="s1">isStringTypeName = (</span><span class="s3">0</span><span class="s1">, util_1.getTypeName)(checker, info.keyType) === </span><span class="s0">'string'</span><span class="s1">;</span>
                        <span class="s2">return </span><span class="s1">(isStringTypeName &amp;&amp;</span>
                            <span class="s1">(isNoUncheckedIndexedAccess || (</span><span class="s3">0</span><span class="s1">, util_1.isNullableType)(info.type)));</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">!isOwnNullable &amp;&amp; (</span><span class="s3">0</span><span class="s1">, util_1.isNullableType)(prevType);</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isCallExpressionNullableOriginFromCallee(node) {</span>
            <span class="s2">const </span><span class="s1">prevType = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node.callee);</span>
            <span class="s2">if </span><span class="s1">(prevType.isUnion()) {</span>
                <span class="s2">const </span><span class="s1">isOwnNullable = prevType.types.some(type =&gt; {</span>
                    <span class="s2">const </span><span class="s1">signatures = type.getCallSignatures();</span>
                    <span class="s2">return </span><span class="s1">signatures.some(sig =&gt; (</span><span class="s3">0</span><span class="s1">, util_1.isNullableType)(sig.getReturnType()));</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">!isOwnNullable &amp;&amp; (</span><span class="s3">0</span><span class="s1">, util_1.isNullableType)(prevType);</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isOptionableExpression(node) {</span>
            <span class="s2">const </span><span class="s1">type = (</span><span class="s3">0</span><span class="s1">, util_1.getConstrainedTypeAtLocation)(services, node);</span>
            <span class="s2">const </span><span class="s1">isOwnNullable = node.type === utils_1.AST_NODE_TYPES.MemberExpression</span>
                <span class="s1">? !isMemberExpressionNullableOriginFromObject(node)</span>
                <span class="s1">: node.type === utils_1.AST_NODE_TYPES.CallExpression</span>
                    <span class="s1">? !isCallExpressionNullableOriginFromCallee(node)</span>
                    <span class="s1">: </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">return </span><span class="s1">(isConditionalAlwaysNecessary(type) ||</span>
                <span class="s1">(isOwnNullable &amp;&amp; (</span><span class="s3">0</span><span class="s1">, util_1.isNullableType)(type)));</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkOptionalChain(node, beforeOperator, fix) {</span>
            <span class="s4">// We only care if this step in the chain is optional. If just descend</span>
            <span class="s4">// from an optional chain, then that's fine.</span>
            <span class="s2">if </span><span class="s1">(!node.optional) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Since typescript array index signature types don't represent the</span>
            <span class="s4">//  possibility of out-of-bounds access, if we're indexing into an array</span>
            <span class="s4">//  just skip the check, to avoid false positives</span>
            <span class="s2">if </span><span class="s1">(!isNoUncheckedIndexedAccess &amp;&amp;</span>
                <span class="s1">optionChainContainsOptionArrayIndex(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">nodeToCheck = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;</span>
            <span class="s2">if </span><span class="s1">(isOptionableExpression(nodeToCheck)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">questionDotOperator = (</span><span class="s3">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenAfter(beforeOperator, token =&gt; token.type === utils_1.AST_TOKEN_TYPES.Punctuator &amp;&amp; token.value === </span><span class="s0">'?.'</span><span class="s1">), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'operator'</span><span class="s1">, node.type));</span>
            <span class="s1">context.report({</span>
                <span class="s1">loc: questionDotOperator.loc,</span>
                <span class="s1">node,</span>
                <span class="s1">messageId: </span><span class="s0">'neverOptionalChain'</span><span class="s1">,</span>
                <span class="s1">suggest: [</span>
                    <span class="s1">{</span>
                        <span class="s1">messageId: </span><span class="s0">'suggestRemoveOptionalChain'</span><span class="s1">,</span>
                        <span class="s1">fix(fixer) {</span>
                            <span class="s2">return </span><span class="s1">fixer.replaceText(questionDotOperator, fix);</span>
                        <span class="s1">},</span>
                    <span class="s1">},</span>
                <span class="s1">],</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkOptionalMemberExpression(node) {</span>
            <span class="s1">checkOptionalChain(node, node.object, node.computed ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkOptionalCallExpression(node) {</span>
            <span class="s1">checkOptionalChain(node, node.callee, </span><span class="s0">''</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkAssignmentExpression(node) {</span>
            <span class="s4">// Similar to checkLogicalExpressionForUnnecessaryConditionals, since</span>
            <span class="s4">// a ||= b is equivalent to a || (a = b)</span>
            <span class="s2">if </span><span class="s1">([</span><span class="s0">'&amp;&amp;='</span><span class="s1">, </span><span class="s0">'||='</span><span class="s1">].includes(node.operator)) {</span>
                <span class="s1">checkNode(node.left);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(node.operator === </span><span class="s0">'??='</span><span class="s1">) {</span>
                <span class="s1">checkNodeForNullish(node.left);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">AssignmentExpression: checkAssignmentExpression,</span>
            <span class="s1">BinaryExpression(node) {</span>
                <span class="s2">const </span><span class="s1">{ operator } = node;</span>
                <span class="s2">if </span><span class="s1">(isBoolOperator(operator)) {</span>
                    <span class="s1">checkIfBoolExpressionIsNecessaryConditional(node, node.left, node.right, operator);</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s1">CallExpression: checkCallExpression,</span>
            <span class="s0">'CallExpression[optional = true]'</span><span class="s1">: checkOptionalCallExpression,</span>
            <span class="s1">ConditionalExpression: (node) =&gt; checkNode(node.test),</span>
            <span class="s1">DoWhileStatement: checkIfLoopIsNecessaryConditional,</span>
            <span class="s1">ForStatement: checkIfLoopIsNecessaryConditional,</span>
            <span class="s1">IfStatement: (node) =&gt; checkNode(node.test),</span>
            <span class="s1">LogicalExpression: checkLogicalExpressionForUnnecessaryConditionals,</span>
            <span class="s0">'MemberExpression[optional = true]'</span><span class="s1">: checkOptionalMemberExpression,</span>
            <span class="s1">SwitchCase({ parent, test }) {</span>
                <span class="s4">// only check `case ...:`, not `default:`</span>
                <span class="s2">if </span><span class="s1">(test) {</span>
                    <span class="s1">checkIfBoolExpressionIsNecessaryConditional(test, parent.discriminant, test, </span><span class="s0">'==='</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s1">WhileStatement: checkIfWhileLoopIsNecessaryConditional,</span>
        <span class="s1">};</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">normalizeAllowConstantLoopConditions(allowConstantLoopConditions) {</span>
    <span class="s2">if </span><span class="s1">(allowConstantLoopConditions === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s0">'always'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(allowConstantLoopConditions === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s0">'never'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">allowConstantLoopConditions;</span>
<span class="s1">}</span>
</pre>
</body>
</html>