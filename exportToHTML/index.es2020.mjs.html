<html>
<head>
<title>index.es2020.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.es2020.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">fs from </span><span class="s2">'node:fs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">module from </span><span class="s2">'node:module'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">path from </span><span class="s2">'node:path'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">isNodeCoreModule from </span><span class="s2">'@nolyfill/is-core-module'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">debug from </span><span class="s2">'debug'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ getTsconfig, createPathsMatcher } from </span><span class="s2">'get-tsconfig'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ isBunModule } from </span><span class="s2">'is-bun-module'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ stableHash } from </span><span class="s2">'stable-hash'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ globSync, isDynamicPattern } from </span><span class="s2">'tinyglobby'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ ResolverFactory } from </span><span class="s2">'unrs-resolver'</span><span class="s1">;</span>

<span class="s0">const </span><span class="s1">IMPORTER_NAME = </span><span class="s2">&quot;eslint-import-resolver-typescript&quot;</span><span class="s1">;</span>
<span class="s0">const </span><span class="s1">log = debug(IMPORTER_NAME);</span>
<span class="s0">const </span><span class="s1">defaultConditionNames = [</span>
  <span class="s2">&quot;types&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;import&quot;</span><span class="s1">,</span>
  <span class="s3">// APF: https://angular.io/guide/angular-package-format</span>
  <span class="s2">&quot;esm2020&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;es2020&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;es2015&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;require&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;node&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;node-addons&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;browser&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;default&quot;</span>
<span class="s1">];</span>
<span class="s0">const </span><span class="s1">defaultExtensions = [</span>
  <span class="s2">&quot;.ts&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;.tsx&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;.d.ts&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;.js&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;.jsx&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;.json&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;.node&quot;</span>
<span class="s1">];</span>
<span class="s0">const </span><span class="s1">defaultExtensionAlias = {</span>
  <span class="s2">&quot;.js&quot;</span><span class="s1">: [</span>
    <span class="s2">&quot;.ts&quot;</span><span class="s1">,</span>
    <span class="s3">// `.tsx` can also be compiled as `.js`</span>
    <span class="s2">&quot;.tsx&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;.d.ts&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;.js&quot;</span>
  <span class="s1">],</span>
  <span class="s2">&quot;.jsx&quot;</span><span class="s1">: [</span><span class="s2">&quot;.tsx&quot;</span><span class="s1">, </span><span class="s2">&quot;.d.ts&quot;</span><span class="s1">, </span><span class="s2">&quot;.jsx&quot;</span><span class="s1">],</span>
  <span class="s2">&quot;.cjs&quot;</span><span class="s1">: [</span><span class="s2">&quot;.cts&quot;</span><span class="s1">, </span><span class="s2">&quot;.d.cts&quot;</span><span class="s1">, </span><span class="s2">&quot;.cjs&quot;</span><span class="s1">],</span>
  <span class="s2">&quot;.mjs&quot;</span><span class="s1">: [</span><span class="s2">&quot;.mts&quot;</span><span class="s1">, </span><span class="s2">&quot;.d.mts&quot;</span><span class="s1">, </span><span class="s2">&quot;.mjs&quot;</span><span class="s1">]</span>
<span class="s1">};</span>
<span class="s0">const </span><span class="s1">defaultMainFields = [</span>
  <span class="s2">&quot;types&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;typings&quot;</span><span class="s1">,</span>
  <span class="s3">// APF: https://angular.io/guide/angular-package-format</span>
  <span class="s2">&quot;fesm2020&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;fesm2015&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;esm2020&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;es2020&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;module&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;jsnext:main&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;main&quot;</span>
<span class="s1">];</span>
<span class="s0">const </span><span class="s1">interfaceVersion = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s0">const </span><span class="s1">JS_EXT_PATTERN = </span><span class="s5">/\.(?:[cm]js|jsx?)$/</span><span class="s1">;</span>
<span class="s0">const </span><span class="s1">RELATIVE_PATH_PATTERN = </span><span class="s5">/^\.{1,2}(?:\/.*)?$/</span><span class="s1">;</span>
<span class="s0">let </span><span class="s1">previousOptionsHash;</span>
<span class="s0">let </span><span class="s1">optionsHash;</span>
<span class="s0">let </span><span class="s1">cachedOptions;</span>
<span class="s0">let </span><span class="s1">cachedCwd;</span>
<span class="s0">let </span><span class="s1">mappersCachedOptions;</span>
<span class="s0">let </span><span class="s1">mappers = [];</span>
<span class="s0">let </span><span class="s1">resolverCachedOptions;</span>
<span class="s0">let </span><span class="s1">cachedResolver;</span>
<span class="s0">function </span><span class="s1">resolve(source, file, options, resolver) {</span>
  <span class="s0">if </span><span class="s1">(!cachedOptions || previousOptionsHash !== (optionsHash = stableHash(options))) {</span>
    <span class="s1">previousOptionsHash = optionsHash;</span>
    <span class="s1">cachedOptions = {</span>
      <span class="s1">...options,</span>
      <span class="s1">conditionNames: options?.conditionNames ?? defaultConditionNames,</span>
      <span class="s1">extensions: options?.extensions ?? defaultExtensions,</span>
      <span class="s1">extensionAlias: options?.extensionAlias ?? defaultExtensionAlias,</span>
      <span class="s1">mainFields: options?.mainFields ?? defaultMainFields</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(!resolver) {</span>
    <span class="s0">if </span><span class="s1">(!cachedResolver || resolverCachedOptions !== cachedOptions) {</span>
      <span class="s1">cachedResolver = </span><span class="s0">new </span><span class="s1">ResolverFactory(cachedOptions);</span>
      <span class="s1">resolverCachedOptions = cachedOptions;</span>
    <span class="s1">}</span>
    <span class="s1">resolver = cachedResolver;</span>
  <span class="s1">}</span>
  <span class="s1">log(</span><span class="s2">&quot;looking for&quot;</span><span class="s1">, source, </span><span class="s2">&quot;in&quot;</span><span class="s1">, file);</span>
  <span class="s1">source = removeQuerystring(source);</span>
  <span class="s0">if </span><span class="s1">(isNodeCoreModule(source) || isBunModule(source)) {</span>
    <span class="s1">log(</span><span class="s2">&quot;matched core:&quot;</span><span class="s1">, source);</span>
    <span class="s0">return </span><span class="s1">{</span>
      <span class="s1">found: </span><span class="s0">true</span><span class="s1">,</span>
      <span class="s1">path: </span><span class="s0">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(process.versions.pnp &amp;&amp; source === </span><span class="s2">&quot;pnpapi&quot;</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">{</span>
      <span class="s1">found: </span><span class="s0">true</span><span class="s1">,</span>
      <span class="s1">path: module.findPnpApi(file).resolveToUnqualified(source, file, {</span>
        <span class="s1">considerBuiltins: </span><span class="s0">false</span>
      <span class="s1">})</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">initMappers(cachedOptions);</span>
  <span class="s0">let </span><span class="s1">mappedPaths = getMappedPaths(source, file, cachedOptions.extensions, </span><span class="s0">true</span><span class="s1">);</span>
  <span class="s0">if </span><span class="s1">(mappedPaths.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">log(</span><span class="s2">&quot;matched ts path:&quot;</span><span class="s1">, ...mappedPaths);</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s1">mappedPaths = [source];</span>
  <span class="s1">}</span>
  <span class="s0">let </span><span class="s1">foundNodePath;</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">mappedPath of mappedPaths) {</span>
    <span class="s0">try </span><span class="s1">{</span>
      <span class="s0">const </span><span class="s1">resolved = resolver.sync(</span>
        <span class="s1">path.dirname(path.resolve(file)),</span>
        <span class="s1">mappedPath</span>
      <span class="s1">);</span>
      <span class="s0">if </span><span class="s1">(resolved.path) {</span>
        <span class="s1">foundNodePath = resolved.path;</span>
        <span class="s0">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">catch </span><span class="s1">{</span>
      <span class="s1">log(</span><span class="s2">&quot;failed to resolve with&quot;</span><span class="s1">, mappedPath);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">((JS_EXT_PATTERN.test(foundNodePath) || cachedOptions.alwaysTryTypes &amp;&amp; !foundNodePath) &amp;&amp; !</span><span class="s5">/^@types[/\\]/</span><span class="s1">.test(source) &amp;&amp; !path.isAbsolute(source) &amp;&amp; !source.startsWith(</span><span class="s2">&quot;.&quot;</span><span class="s1">)) {</span>
    <span class="s0">const </span><span class="s1">definitelyTyped = resolve(</span>
      <span class="s2">&quot;@types&quot; </span><span class="s1">+ path.sep + mangleScopedPackage(source),</span>
      <span class="s1">file,</span>
      <span class="s1">options</span>
    <span class="s1">);</span>
    <span class="s0">if </span><span class="s1">(definitelyTyped.found) {</span>
      <span class="s0">return </span><span class="s1">definitelyTyped;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(foundNodePath) {</span>
    <span class="s1">log(</span><span class="s2">&quot;matched node path:&quot;</span><span class="s1">, foundNodePath);</span>
    <span class="s0">return </span><span class="s1">{</span>
      <span class="s1">found: </span><span class="s0">true</span><span class="s1">,</span>
      <span class="s1">path: foundNodePath</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">log(</span><span class="s2">&quot;didn't find &quot;</span><span class="s1">, source);</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">found: </span><span class="s0">false</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createTypeScriptImportResolver(options) {</span>
  <span class="s0">const </span><span class="s1">resolver = </span><span class="s0">new </span><span class="s1">ResolverFactory({</span>
    <span class="s1">...options,</span>
    <span class="s1">conditionNames: options?.conditionNames ?? defaultConditionNames,</span>
    <span class="s1">extensions: options?.extensions ?? defaultExtensions,</span>
    <span class="s1">extensionAlias: options?.extensionAlias ?? defaultExtensionAlias,</span>
    <span class="s1">mainFields: options?.mainFields ?? defaultMainFields</span>
  <span class="s1">});</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">interfaceVersion: </span><span class="s4">3</span><span class="s1">,</span>
    <span class="s1">name: IMPORTER_NAME,</span>
    <span class="s1">resolve(source, file) {</span>
      <span class="s0">return </span><span class="s1">resolve(source, file, options, resolver);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">removeQuerystring(id) {</span>
  <span class="s0">const </span><span class="s1">querystringIndex = id.lastIndexOf(</span><span class="s2">&quot;?&quot;</span><span class="s1">);</span>
  <span class="s0">if </span><span class="s1">(querystringIndex !== -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">id.slice(</span><span class="s4">0</span><span class="s1">, querystringIndex);</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">id;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">isFile = (path2) =&gt; {</span>
  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">return </span><span class="s1">!!(path2 &amp;&amp; fs.statSync(path2, { throwIfNoEntry: </span><span class="s0">false </span><span class="s1">})?.isFile());</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">{</span>
    <span class="s0">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s0">const </span><span class="s1">isModule = (modulePath) =&gt; !!modulePath &amp;&amp; isFile(path.resolve(modulePath, </span><span class="s2">&quot;package.json&quot;</span><span class="s1">));</span>
<span class="s0">function </span><span class="s1">getMappedPaths(source, file, extensions = defaultExtensions, retry) {</span>
  <span class="s0">const </span><span class="s1">originalExtensions = extensions;</span>
  <span class="s1">extensions = [</span><span class="s2">&quot;&quot;</span><span class="s1">, ...extensions];</span>
  <span class="s0">let </span><span class="s1">paths = [];</span>
  <span class="s0">if </span><span class="s1">(RELATIVE_PATH_PATTERN.test(source)) {</span>
    <span class="s0">const </span><span class="s1">resolved = path.resolve(path.dirname(file), source);</span>
    <span class="s0">if </span><span class="s1">(isFile(resolved)) {</span>
      <span class="s1">paths = [resolved];</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s0">let </span><span class="s1">mapperFns = mappers.filter(({ files }) =&gt; files.has(file)).map(({ mapperFn }) =&gt; mapperFn);</span>
    <span class="s0">if </span><span class="s1">(mapperFns.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">mapperFns = mappers.map((mapper) =&gt; ({</span>
        <span class="s1">mapperFn: mapper.mapperFn,</span>
        <span class="s1">counter: equalChars(path.dirname(file), path.dirname(mapper.path))</span>
      <span class="s1">})).sort(</span>
        <span class="s1">(a, b) =&gt; (</span>
          <span class="s3">// Sort in descending order where the nearest one has the longest counter</span>
          <span class="s1">b.counter - a.counter</span>
        <span class="s1">)</span>
      <span class="s1">).map(({ mapperFn }) =&gt; mapperFn);</span>
    <span class="s1">}</span>
    <span class="s1">paths = mapperFns.map(</span>
      <span class="s1">(mapperFn) =&gt; mapperFn(source).map((item) =&gt; [</span>
        <span class="s1">...extensions.map((ext) =&gt; </span><span class="s2">`</span><span class="s1">${item}${ext}</span><span class="s2">`</span><span class="s1">),</span>
        <span class="s1">...originalExtensions.map((ext) =&gt; </span><span class="s2">`</span><span class="s1">${item}</span><span class="s2">/index</span><span class="s1">${ext}</span><span class="s2">`</span><span class="s1">)</span>
      <span class="s1">])</span>
    <span class="s1">).flat(</span>
      <span class="s3">/* The depth is always 2 */</span>
      <span class="s4">2</span>
    <span class="s1">).map(toNativePathSeparator).filter((mappedPath) =&gt; {</span>
      <span class="s0">try </span><span class="s1">{</span>
        <span class="s0">const </span><span class="s1">stat = fs.statSync(mappedPath, { throwIfNoEntry: </span><span class="s0">false </span><span class="s1">});</span>
        <span class="s0">if </span><span class="s1">(stat === </span><span class="s0">void </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s0">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(stat.isFile()) {</span>
          <span class="s0">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(stat.isDirectory()) {</span>
          <span class="s0">return </span><span class="s1">isModule(mappedPath);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">catch </span><span class="s1">{</span>
        <span class="s0">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s0">return false</span><span class="s1">;</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(retry &amp;&amp; paths.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">const </span><span class="s1">isJs = JS_EXT_PATTERN.test(source);</span>
    <span class="s0">if </span><span class="s1">(isJs) {</span>
      <span class="s0">const </span><span class="s1">jsExt = path.extname(source);</span>
      <span class="s0">const </span><span class="s1">tsExt = jsExt.replace(</span><span class="s2">&quot;js&quot;</span><span class="s1">, </span><span class="s2">&quot;ts&quot;</span><span class="s1">);</span>
      <span class="s0">const </span><span class="s1">basename = source.replace(JS_EXT_PATTERN, </span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
      <span class="s0">let </span><span class="s1">resolved = getMappedPaths(basename + tsExt, file);</span>
      <span class="s0">if </span><span class="s1">(resolved.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; jsExt === </span><span class="s2">&quot;.js&quot;</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">tsxExt = jsExt.replace(</span><span class="s2">&quot;js&quot;</span><span class="s1">, </span><span class="s2">&quot;tsx&quot;</span><span class="s1">);</span>
        <span class="s1">resolved = getMappedPaths(basename + tsxExt, file);</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(resolved.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">resolved = getMappedPaths(</span>
          <span class="s1">basename + </span><span class="s2">&quot;.d&quot; </span><span class="s1">+ (tsExt === </span><span class="s2">&quot;.tsx&quot; </span><span class="s1">? </span><span class="s2">&quot;.ts&quot; </span><span class="s1">: tsExt),</span>
          <span class="s1">file</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(resolved.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">resolved;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">ext of extensions) {</span>
      <span class="s0">const </span><span class="s1">mappedPaths = isJs ? [] : getMappedPaths(source + ext, file);</span>
      <span class="s0">const </span><span class="s1">resolved = mappedPaths.length &gt; </span><span class="s4">0 </span><span class="s1">? mappedPaths : getMappedPaths(source + </span><span class="s2">`/index</span><span class="s1">${ext}</span><span class="s2">`</span><span class="s1">, file);</span>
      <span class="s0">if </span><span class="s1">(resolved.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">resolved;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">paths;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">initMappers(options) {</span>
  <span class="s0">if </span><span class="s1">(mappers.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; mappersCachedOptions === options &amp;&amp; cachedCwd === process.cwd()) {</span>
    <span class="s0">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">cachedCwd = process.cwd();</span>
  <span class="s0">const </span><span class="s1">configPaths = (</span><span class="s0">typeof </span><span class="s1">options.project === </span><span class="s2">&quot;string&quot; </span><span class="s1">? [options.project] : (</span>
    <span class="s3">// eslint-disable-next-line sonarjs/no-nested-conditional</span>
    <span class="s1">Array.isArray(options.project) ? options.project : [cachedCwd]</span>
  <span class="s1">)).map((config) =&gt; replacePathSeparator(config, path.sep, path.posix.sep));</span>
  <span class="s0">const </span><span class="s1">defaultInclude = [</span><span class="s2">&quot;**/*&quot;</span><span class="s1">];</span>
  <span class="s0">const </span><span class="s1">defaultIgnore = [</span><span class="s2">&quot;**/node_modules/**&quot;</span><span class="s1">];</span>
  <span class="s0">const </span><span class="s1">projectPaths = [</span>
    <span class="s1">...</span><span class="s3">/* @__PURE__ */ </span><span class="s0">new </span><span class="s1">Set([</span>
      <span class="s1">...configPaths.filter((p) =&gt; !isDynamicPattern(p)).map((p) =&gt; path.resolve(process.cwd(), p)),</span>
      <span class="s1">...globSync(</span>
        <span class="s1">configPaths.filter((path2) =&gt; isDynamicPattern(path2)),</span>
        <span class="s1">{</span>
          <span class="s1">absolute: </span><span class="s0">true</span><span class="s1">,</span>
          <span class="s1">dot: </span><span class="s0">true</span><span class="s1">,</span>
          <span class="s1">expandDirectories: </span><span class="s0">false</span><span class="s1">,</span>
          <span class="s1">ignore: defaultIgnore</span>
        <span class="s1">}</span>
      <span class="s1">)</span>
    <span class="s1">])</span>
  <span class="s1">];</span>
  <span class="s1">mappers = projectPaths.map((projectPath) =&gt; {</span>
    <span class="s0">let </span><span class="s1">tsconfigResult;</span>
    <span class="s0">if </span><span class="s1">(isFile(projectPath)) {</span>
      <span class="s0">const </span><span class="s1">{ dir, base } = path.parse(projectPath);</span>
      <span class="s1">tsconfigResult = getTsconfig(dir, base);</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">tsconfigResult = getTsconfig(projectPath);</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!tsconfigResult) {</span>
      <span class="s0">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">mapperFn = createPathsMatcher(tsconfigResult);</span>
    <span class="s0">if </span><span class="s1">(!mapperFn) {</span>
      <span class="s0">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">files = tsconfigResult.config.files == </span><span class="s0">null </span><span class="s1">&amp;&amp; tsconfigResult.config.include == </span><span class="s0">null </span><span class="s1">? (</span>
      <span class="s3">// Include everything if no files or include options</span>
      <span class="s1">globSync(defaultInclude, {</span>
        <span class="s1">absolute: </span><span class="s0">true</span><span class="s1">,</span>
        <span class="s1">cwd: path.dirname(tsconfigResult.path),</span>
        <span class="s1">dot: </span><span class="s0">true</span><span class="s1">,</span>
        <span class="s1">ignore: [</span>
          <span class="s1">...tsconfigResult.config.exclude ?? [],</span>
          <span class="s1">...defaultIgnore</span>
        <span class="s1">]</span>
      <span class="s1">})</span>
    <span class="s1">) : [</span>
      <span class="s3">// https://www.typescriptlang.org/tsconfig/#files</span>
      <span class="s1">...tsconfigResult.config.files != </span><span class="s0">null </span><span class="s1">&amp;&amp; tsconfigResult.config.files.length &gt; </span><span class="s4">0 </span><span class="s1">? tsconfigResult.config.files.map(</span>
        <span class="s1">(file) =&gt; path.normalize(</span>
          <span class="s1">path.resolve(path.dirname(tsconfigResult.path), file)</span>
        <span class="s1">)</span>
      <span class="s1">) : [],</span>
      <span class="s3">// https://www.typescriptlang.org/tsconfig/#include</span>
      <span class="s1">...tsconfigResult.config.include != </span><span class="s0">null </span><span class="s1">&amp;&amp; tsconfigResult.config.include.length &gt; </span><span class="s4">0 </span><span class="s1">? globSync(tsconfigResult.config.include, {</span>
        <span class="s1">absolute: </span><span class="s0">true</span><span class="s1">,</span>
        <span class="s1">cwd: path.dirname(tsconfigResult.path),</span>
        <span class="s1">dot: </span><span class="s0">true</span><span class="s1">,</span>
        <span class="s1">ignore: [</span>
          <span class="s1">...tsconfigResult.config.exclude ?? [],</span>
          <span class="s1">...defaultIgnore</span>
        <span class="s1">]</span>
      <span class="s1">}) : []</span>
    <span class="s1">];</span>
    <span class="s0">return </span><span class="s1">{</span>
      <span class="s1">path: toNativePathSeparator(tsconfigResult.path),</span>
      <span class="s1">files: </span><span class="s0">new </span><span class="s1">Set(files.map(toNativePathSeparator)),</span>
      <span class="s1">mapperFn</span>
    <span class="s1">};</span>
  <span class="s1">}).filter(Boolean);</span>
  <span class="s1">mappersCachedOptions = options;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">mangleScopedPackage(moduleName) {</span>
  <span class="s0">if </span><span class="s1">(moduleName.startsWith(</span><span class="s2">&quot;@&quot;</span><span class="s1">)) {</span>
    <span class="s0">const </span><span class="s1">replaceSlash = moduleName.replace(path.sep, </span><span class="s2">&quot;__&quot;</span><span class="s1">);</span>
    <span class="s0">if </span><span class="s1">(replaceSlash !== moduleName) {</span>
      <span class="s0">return </span><span class="s1">replaceSlash.slice(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">moduleName;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">replacePathSeparator(p, from, to) {</span>
  <span class="s0">return </span><span class="s1">from === to ? p : p.replaceAll(from, to);</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">toNativePathSeparator(p) {</span>
  <span class="s0">return </span><span class="s1">replacePathSeparator(</span>
    <span class="s1">p,</span>
    <span class="s1">path[process.platform === </span><span class="s2">&quot;win32&quot; </span><span class="s1">? </span><span class="s2">&quot;posix&quot; </span><span class="s1">: </span><span class="s2">&quot;win32&quot;</span><span class="s1">].sep,</span>
    <span class="s1">path[process.platform === </span><span class="s2">&quot;win32&quot; </span><span class="s1">? </span><span class="s2">&quot;win32&quot; </span><span class="s1">: </span><span class="s2">&quot;posix&quot;</span><span class="s1">].sep</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">equalChars(a, b) {</span>
  <span class="s0">if </span><span class="s1">(a.length === </span><span class="s4">0 </span><span class="s1">|| b.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s0">const </span><span class="s1">length = Math.min(a.length, b.length);</span>
  <span class="s0">while </span><span class="s1">(i &lt; length &amp;&amp; a.charAt(i) === b.charAt(i)) {</span>
    <span class="s1">i += </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">i;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ createTypeScriptImportResolver, defaultConditionNames, defaultExtensionAlias, defaultExtensions, defaultMainFields, interfaceVersion, resolve };</span>
</pre>
</body>
</html>