<html>
<head>
<title>track-dynamic-import.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
track-dynamic-import.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/app-render/module-loading/track-dynamic-import.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { InvariantError } from '../../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import { isThenable } from '../../../shared/lib/is-thenable'</span><span class="s3">\n</span><span class="s1">import { trackPendingImport } from './track-module-loading.external'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* in CacheComponents, `import(...)` will be transformed into `trackDynamicImport(import(...))`.</span><span class="s3">\n </span><span class="s1">* A dynamic import is essentially a cached async function, except it's cached by the module system.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The promises are tracked globally regardless of if the `import()` happens inside a render or outside of it.</span><span class="s3">\n </span><span class="s1">* When rendering, we can make the `cacheSignal` wait for all pending promises via `trackPendingModules`.</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">export function trackDynamicImport&lt;TExports extends Record&lt;string, any&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">modulePromise: Promise&lt;TExports&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;TExports&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      \&quot;</span><span class="s1">Dynamic imports should not be instrumented in the edge runtime, because `cacheComponents` doesn't support it</span><span class="s3">\&quot;\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!isThenable(modulePromise)) {</span><span class="s3">\n    </span><span class="s1">// We're expecting `import()` to always return a promise. If it's not, something's very wrong.</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">'`trackDynamicImport` should always receive a promise. Something went wrong in the dynamic imports transform.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Even if we're inside a prerender and have `workUnitStore.cacheSignal`, we always track the promise globally.</span><span class="s3">\n  </span><span class="s1">// (i.e. via the global `moduleLoadingSignal` that `trackPendingImport` uses internally).</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// We do this because the `import()` promise might be cached in userspace:</span><span class="s3">\n  </span><span class="s1">// (which is quite common for e.g. lazy initialization in libraries)</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   let promise;</span><span class="s3">\n  </span><span class="s1">//   function doDynamicImportOnce() {</span><span class="s3">\n  </span><span class="s1">//     if (!promise) {</span><span class="s3">\n  </span><span class="s1">//       promise = import(</span><span class="s3">\&quot;</span><span class="s1">...</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">//       // transformed into:</span><span class="s3">\n  </span><span class="s1">//       // promise = trackDynamicImport(import(</span><span class="s3">\&quot;</span><span class="s1">...</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">//     }</span><span class="s3">\n  </span><span class="s1">//     return promise;</span><span class="s3">\n  </span><span class="s1">//   }</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// If multiple prerenders (e.g. multiple pages) depend on `doDynamicImportOnce`,</span><span class="s3">\n  </span><span class="s1">// we have to wait for the import *in all of them*.</span><span class="s3">\n  </span><span class="s1">// If we only tracked it using `workUnitStore.cacheSignal.trackRead()`,</span><span class="s3">\n  </span><span class="s1">// then only the first prerender to call `doDynamicImportOnce` would wait --</span><span class="s3">\n  </span><span class="s1">// Subsequent prerenders would re-use the existing `promise`,</span><span class="s3">\n  </span><span class="s1">// and `trackDynamicImport` wouldn't be called again in their scope,</span><span class="s3">\n  </span><span class="s1">// so their respective CacheSignals wouldn't wait for the promise.</span><span class="s3">\n  </span><span class="s1">trackPendingImport(modulePromise)</span><span class="s3">\n\n  </span><span class="s1">return modulePromise</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;trackDynamicImport&quot;</span><span class="s0">,</span><span class="s1">&quot;modulePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;isThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;trackPendingImport&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAWgBA;;;eAAAA;;;gCAXe;4BACJ;4CACQ;AAS5B,SAASA,mBACdC,aAAgC;IAEhC,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;QACvC,MAAM,qBAEL,CAFK,IAAIC,8BAAc,CACtB,iHADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,IAAI,CAACC,IAAAA,sBAAU,EAACL,gBAAgB;QAC9B,8FAA8F;QAC9F,MAAM,qBAEL,CAFK,IAAII,8BAAc,CACtB,iHADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,+GAA+G;IAC/G,yFAAyF;IACzF,EAAE;IACF,0EAA0E;IAC1E,oEAAoE;IACpE,EAAE;IACF,iBAAiB;IACjB,qCAAqC;IACrC,sBAAsB;IACtB,iCAAiC;IACjC,6BAA6B;IAC7B,wDAAwD;IACxD,QAAQ;IACR,sBAAsB;IACtB,MAAM;IACN,EAAE;IACF,gFAAgF;IAChF,mDAAmD;IACnD,uEAAuE;IACvE,4EAA4E;IAC5E,6DAA6D;IAC7D,oEAAoE;IACpE,kEAAkE;IAClEE,IAAAA,8CAAkB,EAACN;IAEnB,OAAOA;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>